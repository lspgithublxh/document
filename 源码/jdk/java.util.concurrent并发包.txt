//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备；化被动为主动去做)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
//大的想法，具体行动。
//出现了if-else就是因为有不同的考虑。
//阅读文档达到直接可以看出思路编写程序的清晰逻辑的地步。
//一个大函数功能直接看懂而描述。
//从网上找答案变为从源码中找答案。
//功能组织体系，而不是动作实现体系。是目标，是事情，而不是精细到实现方案的动作。
//数据源-数据结果模式：而不是全部动作过程。
//能够主动猜某个方法的功能和猜测它的实现。
//情况-通用处理。
//情况-精细结构。
//数据结构-与处理。
//某个时刻某个地方：所有可能用户做的事情。
//就像是军队打仗一样：AbstractApplicationContext上下文就是总部主帅，负责整个流程，但实现个别子流程；ServletWebServerApplicationContext就是地区主帅，负责使用总部流程且根据区域情况具体化部分流程实现，同时负责分给不同的人去实现更细的子流程(用人/用器：如事件广播器、bean工厂、生命周期处理器; 向它们发号命令：调用/叫他们做什么)，层层下去到事务的精细结构。(负责事务的精细级别 就看出 和一线的和当前的距离)
	>对一个事物类：他是有属性
	>对一个组织类：他是有人；属性当作人。人可能是为他办事的，也可能是监听他的监听器。
	>对一个系统类：他是有组件/器具；属性当作器具
//为什么层次多：因为连续地向上进行了抽象，每层都分类了/拆分了不同的功能，每层连续往下拆分。
//业务模型最好的体现：就是对ideal/eclipse开发工具的功能组织和描述。
//源码-算法-业务-架构：看书看源码做东西。
//自大而错误的原因：缺少验证和反馈。只是创造是不够的。

>抽象队列同步器 AbstractQueuedSynchronizer ：数据模型 和 设计的算法 从而提供的服务/功能；为什么是通用的？	
	>场景-场景中要做的事情-事情的精细结构(事情做法的精细-全面-宏观-微观度量: 每个度量及其值域)-事情中的对象和对对象进行的所有可行动作/公共操作(以形成一个通用的事情框架/模板，或者一个最佳的每个度量的取值)：若干线程并发获取资源，谁第一个获取到，谁第二个获取到...？还是每次上一个释放资源后都是重新竞争？，总共可以获取到多少？--资源量总共多少？
	>问题方案：包含当前不好的实现。
		>概念模型: 对象和对它的公共操作及其操作者
			>对象：资源、线程
			>行为：
				>若干线程为下一个获取资源而等待/尝试获取资源：
				>某个已经获得资源的线程完成它的任务后释放资源：
			>业务模型(活动规则)：游戏初始化、游戏演变、游戏结束(游戏目标达成)的过程。包含游戏规则，参与方。(全局掌控，接口生成<每个操作-对象为一个方法>)
				>初始化资源：
				>各个线程并发地获取资源：
				>成功获取到资源的线程开始做一些事：原本业务逻辑
				>未获取到资源的线程开始做另一些事：无序等待/排队等待/尝试获取资源
				>占用资源的线程完成任务释放资源：释放后可能触发某个资源空闲信号/通知各个等待线程/唤醒各个等待线程
				>等待中的线程开始竞争获取资源：排队则一个个依次获取资源。
		>逻辑的代码实现：业务模型的代码模型。
			>自定义度量：
				>同步状态：int:state
				>尾节点：Node:tail
				>等待状态：int:waitStatus >0表示取消Cancel
				>下一个队列：Node:nextWaiter 在SHARD模式下 值 为 new Node()
			>自定义API: 	
				>尝试获取资源：获取到返回，没获取到加入队列等待：@acquireSharedInterruptibly(int)
					>线程中断：直接抛出中断异常
					否则尝试获取资源：@tryAcquireShared() -- 子类实现 
					#结果>=0则表示成功获取到资源：直接返回
					#结果<0则表示没有获取到资源：加入队列开始等待：@doAcquireSharedInterruptibly(int)
						>加入等待队列：@addWaiter(Node.SHARED)
							>当前线程 封装到 新建new Node(): node
							>尾节点属性tail如果不是null: CAS方式更新为上一步新建的node
								>更新成功：那么自然的，node和tail之间建立了双向引用，且node是新的尾元素。直接返回 
							>如果是null: 那么开始继续尝试从队尾加入队列：因为可能因为竞争而失败，所以失败了继续竞争，直到成功@enq(Node)
								-显然，这是一个CLH锁的实现：
								>如果tail为null:那么还没有head: 则CAS方式设置一个new Node()空值元素给head: 成功则tail=head顺带设置。失败则有head了，那么循环添加到队尾的逻辑。
								>否则：CAS方式更新队尾为node: 成功则双向引用，失败自然循环再次尝试，直至成功而退出。
								-成功加入队尾，则才返回。
							>返回这个队尾元素。
						>开始尝试获取资源：当然是循环中：
							>如果前驱节点是head: 
								>那么显然轮到自己来获取资源了，因此尝试获取一下：@tryAcquireShared(int)
								>如果结果>=0 那么成功了：这个结果当作 propagate
									>设置head并且传播-即唤醒下一个Node的线程:@setHeadAndPropagate()
										>将自己这个Node赋值为head, 且将自己Node的thread=null,prev=null设置，即清空。@setHead(node)
										>如果 propagate > 0 或者 node.waitStatus < 0 即没有取消： 取Node的下一个节点 s：
											>如果s == null 或者 s.是共享资源状态isShared(): 即nextWaiter=Node.SHARED这个条件符合：则 @doReleaseShared() 唤醒head的继任者。
												-开启循环：
												>如果head 不是 tail: 
													>如果h的waitStatus==Node.SIGNAL表明需要继任者需要触发：
														>尝试将h的waitStatus CAS更新为0: @compareAndSetWaitStatus()
														#如果更新失败则返回循环开始处continue:
														#如果成功：则开始唤醒继任者@unparkSuccessor(h)
															>如果这个入参node的 waitStatus < 0也要CAS更新为0:@compareAndSetWaitStatus() 表示清空
															>寻找node.next下一个节点：如果它==null或者 waitStatus表明已经取消：则从tail开始往回找直到node, 只要节点 waitStatus <= 0 则都赋值给s, 显然这个s 就是 node之后下一个 waitStatus <= 0 的节点。
															>如果找到的s 不是null: 那么就找到了下一个节点：则开始唤醒它的线程：@LockSupport.unpark(s.thread)
													>否则如果是0 那么CAS更新为 -3 @compareAndSetWaitStatus(h, 0, Node.PROPAGATE)
														>更新失败则：继续循环。
														>否则下一步： 
												>如果head 没有改变：那么退出break循环；否则要继续循环检查。
									>设置p.next=null 实际是为了解除联系，即会修改head, 这个head会被修改。
									>直接返回 
							>否则：需要等待被唤醒：
								>检查是否需要等待：@shouldParkAfterFailedAcquire()
									>如果前一个节点的 waitStatus == Node.SIGNAL 则需要等待，直接返回true 
									>否则都要返回false不需要等待：但在此之前：需要：如果ws > 0那么说明已经取消：则需要将这些取消的节点都移除：重新整理这个等待队列。否则ws == 0 或者 -2 -3 那么：统一CAS更新为 SIGNAL :compareAndSetWaitStatus(pred, ws, Node.SIGNAL)
								>如果上一步成立即需要等待：则启动停车方法:并且在唤醒后返回中断状态：@parkAndCheckInterrupt()	
									>LockSupport.park(this)
									>返回Thread.interrupted()
								>如果上述两个条件都满足：抛出中断异常。如果第二条不满足：那么继续循环---直到自己的前驱是head(一般唤醒之后一定就是),而再次尝试获取资源--等上述逻辑。
						>如果等待中发生了中断：则需要取消获取：@cancelAcquire(node) 
							>动作1： node.thread=null
							>动作2：node.pre指向上一个非取消的node
							>动作3：node.waitStatus=Node.CANCELLED设置 
							>如果node是尾元素：则 找到的上一个非取消node:prev CAS方式设置为尾元素
								>如果设置成功：那么 prev的next通过CAS设置为null
							#否则：如果 prev 不是head 且 waitStatus == SIGNAL 那么则把prev的next CAS更新为 node.next。。另一个条件下也这么做：ws<=0 且 cas更新为 SIGNAL	成功 且 prev.thread不是null。
								#否则：表示node前面已经没有有效的node , 则需要唤醒下一个节点：@unparkSuccessor(node)
							>最后设置node.next = node 当做垃圾。help Gc
				>接口2：带等待时间的尝试获取资源-时间截止则不再尝试：@tryAcquireSharedNanos(int arg, long nanosTimeout)
					>类似，也是先尝试取资源：@tryAcquireShared()子类实现：
					>如果没有取得：则开始 入队等待取：@doAcquireSharedNanos(arg, nanosTimeout)
						>也是入队：@addWaiter(Node.SHARED)
						>也是循环中：看上一个元素是否是head, 是则进行 @setHeadAndPropagate()等操作，类似上。
							>否则看等待时间有没有过：过了则返回false:没有得到资源。
							>否则还是看是否需要等待：如果需要 且 剩余时间 > 1000ns 那么就尝试阻塞到截止时间：@LockSupport.parkNanos(this, nanosTimeout)
						>自然的：如果时间到了 或者 中断异常：则需要取消 自己这个节点等：@cancelAcquire(node)
				>接口3：释放资源：@releaseShared(int)
					>尝试释放资源：@tryReleaseShared(int) 子类实现： 
					>尝试成功：则开始真正释放：@doReleaseShared() 返回true成功 。主要工作就是唤醒 head的 继任者节点的线程。代码几乎重复。
						-循环中：
						>如果head != tail : 那么看head.waitStatus 如果是 SHARED 那么：尝试CAS更新为0, 没成功则continue, 成功了则唤醒继任者@unparkSuccessor(h)
							>否则如果是0 那么 CAS更新为-3： 失败则continue
						>如果h == head: 头没有改变：那么break;
					#否则返回false
				--以上总结为2大方法：1.尝试获取资源(交给子类)：成功则加入队尾并阻塞；唤醒后如果前驱是head则唤醒后继并退出；否则继续阻塞。  2.尝试释放资源(交给子类)：成功则唤醒head的继任者。失败则直接返回。显然释放资源是触发队列执行的开关。	
>CountDownLatch: 门闩(men shuan)
	>业务模型：主线程等待子线程完成的场景。
		>若干个线程并发获取资源，限定队列n个: 也是任务量
		>超过n个的新的线程尝试获取资源则直接失败返回-不加入队列，直接忽略；
		>主线程调用非获取资源的功能为等待子线程完成的方法：则看标记值-如果为0则返回，否则阻塞，直到被唤醒。
		>每个线程完成任务后做标记(状态值):当标记任务量为0(一般为任务完成时调用标记方法修改标记)：同时进行：唤醒主线程
	>因为也要同步并发的线程：所以内部实现一个 同步器：Sync 
		>可以用state表示资源数:属性来表示。
		>同步器需要实现尝试获取资源的方法：@tryAcquireShared()
			>从上AQS实现知：尝试成功 则 入尾等待。所以是 主线程等待方法 调用的。因此内容为查看 资源剩余量是否为0，为0不等待否则等待。
		>同步器也要实现释放资源的方法：@tryReleaseShared(int) 自然的要实现：state自减，当state == 0 要唤醒主线程。
			-循环中： 因为CAS更新state可能失败，所以需要自旋
			>如果状态值== 0 ? 说明已经释放完了，直接不必要再释放，返回，且返回false 
			>否则状态值-1得到一个数，CAS方式更新state: 如果更新成功：则返回 nextc == 0 新状态是否是0了，是0 那么就资源完全释放完了--那么执行唤醒head的继任者，否则没有--什么也不做。
				>如果CAS更新冲突了：那么重新自旋来更新。
		
>Semaphore: 信号量。按照我自己独立的设计：那么可以分为两种。一种阻塞型，一种非阻塞型。
	>业务模型1：
		>概念：
			>令牌允许量：
			>线程：
		>行为： 
			>并发线程获取令牌：允许量减1
			>并发线程释放令牌：允许量加1
		>活动规则：初始化-演化-达到目标-结束
			>初始化令牌数：n 
			--非阻塞型：
			>并发线程获取令牌： 还有令牌且获取到则返回成功，没有令牌了返回失败；有但获取失败则重新获取<公平队列/非公平继续竞争>
			>线程释放令牌：释放成功返回，否则继续释放。
			--阻塞型：
			>并发线程获取令牌：还有令牌且获取到则返回成功--返回之前：释放令牌，没有令牌了则加入队列后等待被唤醒；唤醒后再次尝试获取令牌...。有但获取失败则重新获取。
			>并发线程释放令牌：如上被调用。没有专门接口。
	>业务模型2：
	>业务模型2的代码API实现：
		>资源量：state 表示。
		>基本API：
			>获取资源的接口：@acquireSharedInterruptibly()->@tryAcquireShared(int) 
				-采用NonfairSync：
					>转发@nonfairTryAcquireShared(int)
					-循环内：
						>用当前资源数-int得出 remaining：结果如果<0那么直接返回，否则还有剩余：CAS更新剩余资源数为 remaining, 如果成功那么返回remainig--也会成功；如果失败，那么继续循环。---逻辑和我的业务模型1的逻辑一致。
				-采用FairSync：公平锁
					>则是非每次竞争的，而是排队的：即如果head的next的Node.thread不是当前线程，那么轮不到自己，从而直接返回-1,获取资源失败，则后面会继续等待或者入队等待(前驱非head)。如果前驱就是head,自然的就是自己，则获取资源-1, CAS更新成功则返回剩余量，更新失败则循环。
			>非中断方式获取资源的接口：@acquireUninterruptibly()-->@acquireShared()-->@tryAcquireShared()之后：@doAcquireShared(int)		
				>这个接口的不同在于：@parkAndCheckInterrupt()即便当前线程被中断了：也不抛出中断异常；但是在轮到自己--自己的前驱是head时，则自中断：@selfInterrupt()---Thread.currentThread().interrupt() 实际上当前线程并不会中断，仅仅是 Thread.interrupted()值为true了。
			>尝试获取：立即返回那种：@tryAcquire()
				>仅仅直接看@nonfairTryAcquireShared()-1 的值 
			>释放资源的接口：@releaseShared(int)->@tryReleaseShared(int) 公平同步和非公平同步共有
				>和想象的一样：也是取 state+int来CAS更新，成功则true, 如果这个值就>最大整数，使得值溢出了，抛错误。没有更新成功则循环。
			-其他接口：过于简单，略。

>ReentrantReadWriteLock：读写锁 
	>业务模型1：
		>概念：
			>状态：值:共享数量(次数)_独占数量(次数)
			>第一个读者：即第一个设置共享数量的线程
			>第一个读者hold数量：即第一个读者 共享次数 
			>非第一个读者hold数量：即各个读者自己存的存在线程本地变量里的：共享次数：rh.count， 获取次数。
		>行为： 
		>规则：初始化、演化、达到目标-结束 
			>
	>业务模型的代码实现：
		>读锁ReadLock:
			>锁方法：@lock()-->@sync.acquireShared(1):依然是到尝试获取锁,<0则加入队尾阻塞 (仅仅为不抛出中断异常那种)。因此看@tryAcquireShared(int)
				>如果独占数量：state的低16位的值不是0 且 独占线程 AbstractOwnableSynchronizer.exclusiveOwnerThread 不是 当前线程， 直接返回-1：即会入队尾等待。
				>查出共享数量：state的高16位的值r。
				>如果读者 不应该阻塞@readerShouldBlock() 且 r<最大int 且 CAS更新state为高16位的数+1(实际就是共享数量+1)
					- 非公平同步 实现：NonfairSync
						>直接转发：@apparentlyFirstQueuedIsExclusive() 显然第一个排队的是独占？
							>直接看AQS里：head的下一个Node如果不是Shared模式且thread不是null: 则返回true(应该阻塞), 否则返回false
					- 公平同步 FairSync 的实现：都是@hasQueuedPredecessors() 即看 当前线程是否是head的下一个node的thread
				>如果上一步更新成功：
					>如果r是0：即之前的共享数量是0：则设置firstReader = current 第一个读者为当前线程， 同时初始化 firstReaderHoldCount=1
					#否则如果 firstReader == current：当前线程就是第一个读者： 那么 直接firstReaderHoldCount++， 即第一个增加1---往往是同一个线程再次获取资源引起。
					#否则：第一个读者不是当前线程
						>如果 cachedHoldCounter 为null 或者.tid不是当前线程的tid: 那么从 readHolds 这个线程本地变量 里get()出来 ThreadLocalHoldCounter 赋值给它
						#否则不是null但是 .count==0 那么：readHolds.set(rh)设置进去。
						>统一的：rh.count++ //可以当做重入次数。
					>返回：1 那么不会入队尾。即 获取成功 
					--总结读成功条件：1.没有独占数量或者独占线程是当前线程，读者不应该阻塞 且CAS更新状态共享数量成功
				#否则不满足或者没有更新成功(同样没有独占数量或者独占线程是当前线程，且：或者读者应该阻塞 或者 CAS更新状态共享数量失败)：@fullTryAcquireShared(current)
					-循环中： 
					>如果独占数量 > 0： 如果当前线程不是 独占线程：返回 -1 
					#否则独占数量 =0 或者当前线程是独占线程: 
						#如果读者可以阻塞：@readerShouldBlock()
							>进一步如果 当前线程 为第一个读者： 那么按照 不要重入 获取读锁的规则：
								>直接什么也不做
							>否则不是第一个读者：如果第一次： cachedHoldCounter的tid不是当前线程：那么 取 线程本地变量里的：readHolds.get()， 如果.count=0 即重入次数为0：移除这个局部变量readHolds.remove()
								>否则不是第一次,rh不是null: 如果rh.count还是0: 返回-1  (即读者需要阻塞时 如果既不是第一个读者 且重入次数还是0直接 获取失败)
					>如果 共享数量 == 最大int: 则抛出异常new Error()
					>CAS更新state中共享数量+1： 如果更新成功： 
						>如果老的共享数量=0： 那么  firstReader == current 且 firstReaderHoldCount = 1 
						>否则如果第一个读者是当前线程：firstReaderHoldCount++即可 
						>否则：不是第一个读者：老的数量>0: 则：
							>看 cachedHoldCounter：如果 是null 或者.tid 不是当前线程的tid:则从 readHolds.get()获取，；否则如果 .count = 0则设置到 readHolds里。
							>最后统一：rh.count++ 即重入个数自增1；设置cachedHoldCounter=rh 
						>直接返回 1 
					--总结读成功条件2:2.没有独占数量或者独占线程是当前线程，如果读者应该阻塞 那么要么是第一读者 要么重入次数>0,此时再 CAS更新状态共享数量，成功才返回，失败则继续循环；同样如果是上一步CAS更新失败而进入这个循环，那么继续循环。
					--总结为应用层次上：A线程加了写锁(为独占线程)，则A可以加读锁，而线程B再加读锁则会进入等待；如果A加读锁后再次加读锁，那么重入次数+1，状态的共享数量也+1;如果此时A释放了写锁，B获得了写锁-为独占线程，那么A再次获取读锁会阻塞；而B再去获取读锁，则不是第一读者，如果读者应该阻塞，因为B是第一次入所以重入次数为0，因此会阻塞。这里AB就都阻塞了。A取写A取读，A释写，B取写，A取读(阻塞),B取读-EXCLUSIVE-count==0则阻塞
			>锁方法2：要抛出异常@lockInterruptibly()->@acquireSharedInterruptibly(1)
			>尝试获取锁：@tryLock()
				>转发：@sync.tryReadLock()
					-循环里：
						> 如果独占数量不是0 且 独占线程 不是 当前线程：返回 false  //被别的线程独占了。一旦别的线程独占，那么想获取共享也无法进行。
						> 如果共享数量为最大整数：抛出异常。
						>CAS更新 state 的共享数量+1： 如果成功了：则又分共享数量=0，当前读者 是当前线程，其他情形  进行处理：firstReader/firstReaderHoldCount/cachedHoldCounter同上。
							>最后返回true 
			>限时尝试获取锁：@tryLock(long timeout, TimeUnit unit)
				>转发：@sync.tryAcquireSharedNanos()
			>解锁：@unlock()
				>转发：@sync.releaseShared(1) - 还是看@tryReleaseShared(int)的实现：
					>如果当前线程就是第一个读者：那么专门处理：如果hold数仅仅为1：firstReaderHoldCount==1 那么直接 firstReader=null即可：否则要先firstReaderHoldCount-- 因为还重入了其他次。
					>否则不是第一个读者：那么直接从线程上下文里取赋值给 如果 cachedHoldCounter是null(首次)：那么看rh如果count==0 即hold次数/重入次数为1：那么readHolds.remove()移除即可。count<=0则抛出异常。最后是count--
					-开始循环：
					>CAS更新state 为共享数量-1：如果成功：返回 共享数量-1的这个值 == 0 的判断值，即如果已经没有共享数量，则返回true: 释放成功；从而后面会开始触发下一个节点的线程唤醒。	即也说明了：@lock()是公平锁。			
			>新条件：@newCondition() 不支持：抛异常。	
		>写锁：WriteLock: 有自己的同步器 Sync 
			>锁方法@lock():
				>转发：@sync.acquire(int arg) 独占模式的操作内容不同(主要是对state的看作不同，利用不同)。但仍然是要排队。
					>如果@tryAcquire(arg)失败：
						>如果状态!=0： 如果 独占数量是0 || 当前线程不是独占线程：返回false ---因为 共享数量则一定不是0--此时也不能获取到写锁(共享模式不能写-入队等待;独占模式独占线程非当前线程也不能写-入队等待)。
							>否则说明是当前线程独占了，如果独占数量+要增加的独占值 大于了最大int: 抛出错误 
							>否则：直接set State= 旧值+要增加的值 --- 显然增加的是独占数量。
							>返回true 
						>如果写者应该阻塞：@writerShouldBlock() 或者 即写者不该阻塞时 CAS更新 状态值为老值+新增(修改的也是独占数量) 失败： 返回 false  
							- NonfairSync 的实现： 直接false 即写者不应该阻塞。
							- FairSync 的实现：都是@hasQueuedPredecessors() 即看 当前线程是否是head的下一个node的thread
						>则此时：要么上一步更新成功，独占数量增1了：设置独占线程为当前线程：@setExclusiveOwnerThread(th) 返回：true 
						-总结：共有两种情况成功：1.状态表明有独占数量 且 独占线程 为当前线程；2.写者不应该阻塞 且CAS更新状态独占数量+int成功；顺便设置独占线程为当前线程。
					>进一步：@addWaiter(Node.EXCLUSIVE)添加到等待队列
					>进一步：@acquireQueued(Node, int) 上述Node为入参.功能即为排队获取。
						-进入循环：
						>如果node的前驱是head 且 尝试获取资源@tryAcquire(arg)成功了： 那么设置head=node, 其.thread=.prev=null; 自然的，前驱的next=null(双向剪除head/node联系), 返回线程是否中断过
						>否则：如果@shouldParkAfterFailedAcquire() 且 parkAndCheckInterrupt()停车之后：线程中断状态为true: 则 设置中断状态变量为true
						-退出循环：如果抛了异常：那么会@cancelAcquire()
					>如果上述为true: 则当前线程中断过，需要执行自中断：@selfInterrupt()	-- 其实仅仅设置了中断状态。
					--总结：应用上：A线程获取了写锁，可以继续获取写锁;此时如果非公平下则B获取写锁直接CAS更新-成功了则成功获取到了写锁；如果公平同步下则B如果是head.next.thread那么才开始CAS更新	否则阻塞
			>带中断锁方法：@lockInterruptibly()
				>转发：@sync.acquireInterruptibly(1)
					>如果@tryAcquire(arg)失败时则@doAcquireInterruptibly(int)可抛中断异常的等待； 因此看前者的实现
			>尝试获取写锁：@tryLock()  实为得写锁后再次获取可以成功
				>转发：@sync.tryWriteLock()
					>看状态：如果不是0：但独占数量是0则共享数量>0：那么获取失败，否则独占数量>0但当前线程不是独占线程：返回失败。独占数量超过最大int也抛错误。
					-此时：状态=0 ， 或者 当前线程是独占线程 且 还有独占数量余地：则CAS更新state独占数量+1, 失败则返回false, 成功则更新独占线程为当前线程；返回true 
			>带时限的尝试获取锁：@tryLock(long timeout, TimeUnit unit)
				>转发：@tryAcquire(arg) 成功则返回成功，否则带时限继续尝试：@doAcquireNanos(arg, nanosTimeout)结果直接返回。
			>释放锁：@unlock()
				>转发：@sync.release(1) 
					>还是看；@tryRelease(int releases) 的实现： 因为成功后才会唤醒继任者。
						>如果当前线程不是独占线程：抛异常：new IllegalMonitorStateException()
						>否则就是：状态值-int 即独占数量-1 的结果next,如果已经是0了，那么：需要释放独占线程：setExclusiveOwnerThread(null); 直接新状态值next设置：@setState(next)返回剩余数量是否==0, 为0则释放完毕。
			>新条件：@newCondition()
				>转发：@sync.newCondition() 
					>直接新建返回：@new ConditionObject() --- 也是AQS里的内部类。
		
		>条件对象ConditionObject：
			>业务模型1： 
				>概念：
					>第一个等待节点：Node:firstWaiter
					>最后一个等待节点：Node:lastWaiter
				>行为： 
					>全部释放写锁的state: 	fullyRelease 
					>
				>规则： 
					>创建新的条件对象：
					>入单向waiter队-全部释放写锁的状态值-进入循环-->在同步队列中则停车：(CAS先读后写)释放失败抛出异常。节点状态更新为 CANCELLED取消。 
					>
					>
			>业务模型的API实现：		
				>非中断等待：@awaitUninterruptibly()
					>当前线程封装到Node加入队尾：@addConditionWaiter() 类型为：Node.CONDITION
						>如果队尾的状态不是CONDITION, 那么需要整理：@unlinkCancelledWaiters() 从头开始：把非CONDITION的Node都移除出去。
						-注意不是双向关系：只有Node.nextWaiter=Node 单向队列关系。
					>@fullyRelease(Node)注入的是新节点 
						>取state:@release(state) -- 显然想一次全部释放：强于@unlock()，而由其中的@tryRelease(int)实现内容看：这样必然会state==0从而设置独占线程为null--因此其他线程可以加写锁。
						>释放失败：抛出异常：@throw new IllegalMonitorStateException() 且 finally:node.waitStatus=Node.CANCELLED取消。
						>释放成功：返回释放的数量。
					>循环：条件：不在同步队列中：查看是否在同步Node:@isOnSyncQueue(Node) 如果Node.waitStatus==Node.CONDITION 则false 不同步<显然直接await就会是>。前驱==null也不在同步中，next!=null则有后继，在同步中。否则next是null但prev不是null: 进一步判断：@findNodeFromTail(Node) ---从尾往前找：找到了Node则true,没找到则false
						>直接停车：@LockSupport.park(this)
						>记录线程中断状态：@Thread.interrupted()
					>退出循环：	重新排队获取：@acquireQueued() 排队获取 ，如果成功：需要自中断：失败了如果之前线程中断过：也要自中断。
				>等待：@await()
					>当前线程已中断：抛中断异常。
					>入队和释放全部状态值：@addConditionWaiter()-@fullyRelease()
					>不在同步队列中则要循环：@isOnSyncQueue(node):循环内容：先停车，再查看节点中断模式：@checkInterruptWhileWaiting(Node) :如果当前线程状态为已经中断：@transferAfterCancelledWait(Node)查看： 是抛中断异常模式 还是 重新中断模式。。只要线程已经中断：都break
						>如果Node.waitStatus状态是Node.CONDITION，CAS更新为0
							>成功则入队：@enq(node)显然是入 写锁的队列 ，返回true 
							>如果不在同步队列：@isOnSyncQueue(node) 简单的线程让步：Thread.yield()---让出一些时间片，然后再次醒来参与竞争；。即便因为在同步队列：而退出了，也只返回false 
					>循环退出后：
						>排队式获取@acquireQueued(node, savedState) ：如果成功 获取到 了， 且 中断模式不是 抛中断异常：设置： interruptMode = REINTERRUPT		
						>如果node.nextWaiter 不是null: 即条件等待节点增加了，则要整理一下：@unlinkCancelledWaiters()
						>中断模式表明不是无中断：则@reportInterruptAfterWait(im)处理---该抛则抛中断异常，该重新中断 则自中断。
				>限时等待：@awaitNanos(long nanosTimeout) 和上述方法差别在：不在同步队列中要循环：这个循环里：如果到达时限了：@transferAfterCancelledWait(node)，停车时间为输入值：@LockSupport.parkNanos(this, nanosTimeout)--条件是输入时间>=1ms
					>最后返回剩余时间。
				>绝对时间等待：@awaitUntil(Date deadline) 内容类似。
				>带时间单位的限时等待：@await(long time, TimeUnit unit)略。
				>信号触发：@signal() -- 从firstWaiter开始刚好唤醒一个为止(一个执行唤醒动作一次)
					>如果当前线程不是独占线程：抛异常：new IllegalMonitorStateException()
					>如果firstWaiter不是null: 真正的发信号：@doSignal(first)--从first开始成功唤醒一个为止。
						>先赋值：firstWaiter = first.nextWaiter 入参节点的下一个waiter节点赋值给firstWaiter第一个waiter
						>设置当前节点的nextWaiter为null：first.nextWaiter = null 如果老的 nextWaiter 是 null 那么：lastWaiter也设置=null 
						>开始传递：将一个节点入队到 写锁队列 等：@transferForSignal(Node)
							>先CAS设置节点 等待状态从CONDIITON到0：@compareAndSetWaitStatus(node, Node.CONDITION, 0)
							>如果失败了：则返回 false 
							#否则成功了：则节点 等待状态为 0, 开始入队：@enq(node) 因为写锁创建的Sync, 所以是入写锁的队尾：此方法返回值是上一个队尾Node, (入队的目的：则prev属性一定不是null，那么await()方法就一定可以退出循环)
								>如果上一个 尾Node的等待状态为 CANCELLED取消, 则要唤醒入参Node.thread。否则没有取消 但如果 CAS更新这个Node的等待状态为Node.SIGNAL 失败了：也要唤醒入参Node.thread---或许是因为靠上一个不行而要自己来唤醒。
							>返回true -- 表示 入参Node.thread已经唤醒或者将被上一个Node唤醒。
						>如果上一步表明没有被唤醒：且first = firstWaiter 时 ，即入参first的下一个节点不是null, 即开始尝试唤醒入参first的下一个waiter	
						- 唤醒动作总结为：对一个Node:更新状态-入队-唤醒。
						- 显然：唤醒之后：对应的那个线程执行到await()方法里就会退出while循环，开始下一步：排队获取资源@acquireQueued(xxx)--队也是 写锁的队， 因为已经入队，所以只要轮到自己那么就可以触发尝试获取-全部独占数量了。 
						- 注意一个特点：@fullyRelease(int)是为了全部减少到0，而执行@acquireQueued()则是为了全部加上-加回来(中间过程中可以改变state的值，因为最后只是累加上之前扣除的而已)。
				>信号触发2：@signalAll() 全部都进行唤醒操作一次 
					>如果当前线程不是独占线程：抛异常：new IllegalMonitorStateException()
					>如果firstWaiter不是null: @doSignalAll(first) 全部都执行一次唤醒
						>首尾waiter都清空：lastWaiter = firstWaiter = null
						>一个个的唤醒：并且解除nextWaiter关系：唤醒同上@transferForSignal(first)。。自然会使用循环。
					--总结 写锁的 ConditionObject的好处是：await()方法会先释放所有的独占数量和释放独占线程，以及释放共享数量，(那么其他线程就可以获取读锁或者获取写锁了)，释放成功则停车等待；singal触发唤醒后退出循环等待而 排队获取 补上之前的state释放量,且设置当前线程为独占线程(@tryAcquire(int)中)
					-- 读写锁：以方法调用的方式：包裹代码块进行同步。
					-- 为什么不能直接 ConditionObject.await()， 因为 @fullyRelease(Node)会有个 当前线程是否是独占线程的判断。同理@signal()也是。--只能在写锁@lock()成功之后而@unlock()之前后使用。
					-- WriteLock-ConditionObject 这一套同步 相对于 synchronized-Object这一套：好处在 前者同步是公平的，且内部可以多个ConditionObject来await(), 而后者非公平且只能用一个Object.wait()。。以下：AB同读写锁对象。
						>第二，A读之后，B可以读,A也可以再读,A可以再写，B不可以再写
						>第三，A写之后，A可以再读，B不可以再读;A可以再写，B不可以再写;A可以创建 条件对象X进行await()-释放独占和共享且而循环停车，之后B可以再读再写，B写之后B可以使用A创建的条件对象X进行sigal()-操作一个节点即A即让A入队后唤醒A，A则退出循环而入队等待获取(非共享)，当B 释放写锁unlock()完成或者await()之时(释放都会执行：unpark head的继任者)A才可以获取成功而继续独占。	
						
>ReentrantLock可重入锁：	
	>业务模型：
	>业务模型的API实现： 
		>锁方法：@lock()
			- 非公平同步：
			>CAS更新状态从0到1：成功则设置 独占线程为当前线程；失败：则@acquire(1) --即 EXCLUSIVE 写锁的方式等待：尝试-失败则入队等待-唤醒后再次尝试-...。
				>看尝试方法@tryAcquire(int acquires)
					>非公平 锁实现：@nonfairTryAcquire(acquires)
						>如果state=0则：CAS更新为 acquires,成功则 独占线程设置，返回true;失败返回false
						>否则state>0则： 如果当前线程为独占线程：则 state+acquires 过界则抛出错误，否则直接设置@setState(int) 返回true 
			- 公平同步：
			>会考虑在状态为0时是否有前驱：有前驱则 @tryAcquire()尝试就失败；状态不是0时则看当前线程是否是独占线程-不是则失败。
			- 总结：公平同步和非公平同步：关键在尝试获取时：是否考虑有前驱。
		>可中断锁方法：@lockInterruptibly()类似。尝试后 仅仅等待中可以抛出中断异常。
		>尝试锁：@tryLock()
			>转发@nonfairTryAcquire(1) 即做一次尝试。只做尝试不做等待。
		>限时获取：@tryLock(int, TimeUnit) 尝试后 限时等待。
		>解锁：@unlock()
			>转发：@sync.release(1)
				>先尝试释放：@tryRelease(arg)
					>也是独占线程为当前线程才可以：否则抛异常。
					>状态值扣减后为0：则设置独占线程为空，再直接setState(),否则直接setState()
				>成功则：唤醒head的继任者。
				>失败返回false 
		>条件:@newCondition() 
			>转发：@sync.newCondition() 即创建对象： new ConditionObject()   后面的操作就类似了：直接只在AQS中。
			
>ThreadPoolExecutor线程池：
	>业务模型：
		>概念：
			>线程： 
				>线程池中线程的状态：ctl
			>线程池：核心线程数、最大线程数
			>非核心线程无任务时的活跃时间：非核心线程无任务时的最大idle时间。
			>任务队列：
			>线程工厂：
			>拒绝执行处理器：
			-
			>线程+状态+首个任务等的封装类：worker
		>行为：(包含原子行为，有必要一起表述的)
			>向线程池一个任务：并立即执行 
			>线程池将任务调度给线程：并返回结果获取钩子(没有计算结果阻塞，有则返回)，或者无返回。
			>调用线程工厂创建线程：
			>调用拒绝执行handler处理新的任务：
			>线程的管理：线程的增删
		>活动规则： 
			>初始化：利用线程工厂创建corePoolSize个线程-每个线程要连带其他信息和行为所以封装到专门内部类里，放到专门的地方，比如一个数组，长期活跃。
			>提交的任务先给核心线程：如果在执行任务则给非核心线程，如果没有则同理创建非核心线程封装在内部类容器里并将其放在专门地方。如果不能创建新的或者使用旧的非核心线程了，加入任务队列。任务队列满了，拒绝执行handler来处理。
	>业务模型的API定义：
		>执行任务方法：@execute(Runnable command)
			-预备：定义了一个整数int: ctl 高3位是运行状态，低29位是workerCount工人数。可以直接二进制&计算出给定int代表的运行状态和 workerCount
			>如果 workerCount<corePoolSize: 开始增加worker:@addWorker(Runnable, true) 添加成功，直接返回。否则没有添加成功：或者没有启动worker成功。再次取ctl的值来更新一下局部变量。
				>进入无限循环：
					>首先看是否需要处理这个task: 如果运行状态 runState 是 shutdown/stop/tidying/terminated, 并且 (要么不是shutdown，要么输入task不是null, 要么任务队列是空), 即后三种状态直接不处理，shutdown时task不是空不处理-任务队列空也不处理，返回false
					-其他情况要处理：状态为run时、shutdown时且任务队列非空且入参task为空
					>进入无限循环： 
						>首先判断是否要执行：看 workerCount 如果 >= 29个1即最大容量，返回false不处理; 即便 < 最大容量，如果第二个入参true:则比较 workerCount >= corePoolSize 则也不处理；如果 第二个入参false: 则比较 workerCount >= maximumPoolSize 成立则也不处理。
						>如果需要处理：那么CAS更新ctl workerCount +1 ：@compareAndIncrementWorkerCount() 如果更新成功：退出双层循环：即break retry标记。否则更新失败：则重新获取 runState 看是否和上一步计算的一样：不一样则要重新开始两层循环：continue retry;一样则内层循环即可。
				-此时则：已经成功更新了workerCount+1: 开始 worker 的新建和封装线程。
				>先用入参task 初始化 创建 worker: new Worker(firstTask) -继承了 AQS，实现了Runnable
					>状态state设置为：-1 --运行中。实际上是AQS里的state
					>设置firstTask:为了效率而有第一个任务属性。
					>用线程工厂创建线程：@getThreadFactory().newThread(this): thread:线程属性：执行任务的线程。
				>取 worker 的线程：如果线程不是null: 开始实际工作  
					>使用可重入锁ReentrantLock:ThreadPoolExecutor.mainLock:进行同步：
						>查看运行状态：ThreadPoolExecutor.ctl中，如果是run， 或者 shutdown且入参task==null:  继续操作：
							>如果线程 仍然 活跃：抛出异常：new IllegalThreadStateException()因为表明它在运行任务。
							>worker加入工作队列：ThreadPoolExecutor.workers, 
							>记录workers数量：表示 出现过的最大workers数量：largestPoolSize
					>退出同步：
						>如果添加worker成功：那么就要启动 worker里的线程：t.start();workerStarted=true	
						>如果worker添加失败而没有启动：那么@addWorkerFailed(w)回调处理。
							>再次 mainLock 同步： workers.remove(w)， 然后自旋减少ctl 1直到成功:@decrementWorkerCount(),  再尝试终止：@tryTerminate():
								>无限循环中：(自旋)
									>是否要处理：如果run/tidying/terminated则不处理，直接返回。shutdown且非空 则也返回。
									-则此时状态：stop 或者 shutdown且队列为空
									>如果 worker 数量 > 0:  那么需要：中断 idle的 worker:@interruptIdleWorkers(true) --只中断一个(且idle特点没有体现)。然后直接返回(毕竟是尝试中断，所以只中断1个)。
										>用 mainLock 同步：遍历 workers的 thread: 如果线程不是中断状态 那么 @worker.tryLock() 用worker来尝试锁：
											>如果锁成功了：则线程中断：@t.interrupt() 最后一定 w.unlock()释放。
											-看@tryLock()的内容：
												>直接转发@tryAcquire(1)--<尝试的内容一般都是cas更state, 失败直接返回不入队停车>
													>尝试CAS更新AQS的state从0到1：@compareAndSetState(0, 1) 如果成功了：设置独占线程为当前线程，并返回true,否则返回false;
											>如果没有锁成功：而入参 为true:即确实 只中断1个，那么 直接break退出循环。否则继续遍历。
									>此时则worker数量是0，使用 mainLock 进行同步： 
										>先尝试ctl cas方式更新 为 tidying, 且0workercount: 如果成功： 
											>@调用终止方法：@terminated() - 空方法：线程池继承类可以继承而实现。
											>finally:一定做的：ctl强制set为：TERMINATED-0, 然后 条件对象 ConditionObject:termination.signalAll() 触发此条件对象的所有的等待线程(Node状态更新、入队、unpark)。	
									-总结: 终止条件：stop / shutdown且队列为空， 且workerCount=0 ,  如果>0则中断第一个worker。 终止动作：ctl更新为终止状态，条件对象信号触发。		
					>返回：即是否启动worker成功
				--总结：增加worker：任务封装到worker, 后其实worker加到了workers, 最后启动了worker.start()
			-此时则：要么添加失败，要么就是 worker数量超过了 corePoolSize, 此时都当做 新任务没有执行来看待
			>如果 ctl状态表明 runState是 running, 那么 先将 task放到 BlockingQueue:workQueue任务队列:如果成功了，要再次检查是否ctl 是否在run, 
				>如果再次检查出不是run：那么 就要：移除task:@remove(command) 。且@remove()成功之后：@reject(command)：即使用拒绝执行handler来处理：@handler.rejectedExecution(command, this)
					>先对队列里移除：workQueue.remove(task)
					>尝试中断：@tryTerminate()
				-则此时 要么在run, 要么不在run但移除失败：查看workercount, 如果是0：则空调：@addWorker(null, false) - 即任务不加入
			>否则：此时 不是run, 或者 是run但是添加队列失败：则开始增加worker：@addWorker(command, false) 如果还是失败，则要执行拒绝执行Handler的方法：@reject(command)	
				
		>查看Worker的run()方法：直接转发到@runWorker(this)
			>取出worker的firstTask, 并立即给这个属性情况：worker.firstTask=null
			>执行解锁：实际上是为了其他线程方便"检查独占线程":@worker.unlock(): 核心方法：@tryRelease():内容自然是对state的处理：这里是setState(0), 设置独占线程为null:返回true
			>开始循环中：循环条件为：先看 上一步取出的 firstTask 如果不是null那么进入循环，否则是null但是 @getTask()即从队列里取出Task不是null 那么也可以进入循环：
				>先看@getTask():
					>直接进入无限循环：
						>取ctl运行状态：如果 stop/tidying/terminated， 或者 shutdown 时 任务队列是空的：那么是不执行的：直接@decrementWorkerCount() 返回null
						>退出条件2：如果 workerCount > maximumPoolSize ： 那么不用看 workQueue是否为空：都直接 CAS更新 wc-1， 如果成功了：返回null, 否则 继续循环。 
						>从 workQueue里取任务：如果 wc > corePoolSize, 那么就 限时获取：@workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)， 没有超过那么就一直等待取：workQueue.take()  。。这个动作是最优或者比较优的。同时这个取任务是有中断异常捕获的，如果因为如@shutdownNow()方法的执行而中断了此线程，那么捕获异常而直接退出了，但是如果是@shutdown()那么只是捕获异常而还会继续尝试取任务。
						>如果取出的不是null:那么直接返回。否则设置 timeOut=true, 使得下一轮循环时：只要 wc > corePoolSize:那么都会直接 cas更新 wc-1 然后返回null，如上2步。	
						--总结三大导致worker退出的条件：
						--总结：当wc>corePoolSize则限时获取，如果超时而没有获取到，则下一次看wc>corePoolSize时就直接wc-1而返回null--那么就会导致@runWorker()方法退出循环，从而整个worker都结束了。
						--总结2： 当wc > maximumPoolSize 也会直接wc-1且返回null 而导致worker退出。
						--总结3：线程池状态ctl是 stop/tidying/terminated;  也会退出。线程池状态是 shutdown, 且 workQueue 为空 也会 退出。(即如果是 shutdown 但是 workQueue还有任务则不会退出-继续取任务)
				-循环里的内容：
					>使用Worker开始同步：w.lock()
					>判断worker的线程是否需要中断：(runState为：stop/tidying/terminated 或者 (当前线程已经中断 且 再次看 runState 也是s/t/ter)) 且  worker的线程未中断 ：那么worker的线程要中断：wt.interrupt()
					-则此时：要么wt线程已经中断，或者没有中断 但是 runState 为 run/shutdown:
					>执行前的钩子函数：@beforeExecute(wt, task)
					>调用执行：@task.run()
					>捕获相应的异常和Error处理，Throwable也捕获，最后执行 钩子函数：@afterExecute(task, thrown)
					>最后清扫环境：task=null , worker的completedTasks++，来表明完成的任务数，w.unlock()来去除同步。
					-则继续取任务。
				>退出循环：则不能再获取任务来执行，则是非正常的，开始一系列的事情：@processWorkerExit(w, completedAbruptly)
					>如果是突然中断：则@decrementWorkerCount() 调整 来 补偿。
					>使用 mainLock 进行同步：将 w.completedTasks 值 累加到 ThreadPoolExecutor.completedTaskCount上
					>清扫：移除worker:workers.remove(w)
					>尝试终止：@tryTerminate()
					>继续看ctl的运行状态：如果是 run/shutdown, 那么：
						>如果不是突然完成：如果worker数 >= corePoolSize, 那么 直接返回 
						-此时 是： 突然完成， 或者 wc < corePoolSize: 都需要：@addWorker(null, false)， 第一个入参为firstTask形参，显然不是第一次了，所以null, 则自然会从任务队列里取， false则自然不是 和 corePoolSize比较了。所以就是纯粹的加一个worker 并启动起来。
				-此时则完成了：@runWorker()
		>关闭线程池方法：@shutdown()
			>使用 mainLock 同步锁：lock开启
				>检查是否有权限：@checkShutdownAccess()
					>获取SecurityManager后：调用：@security.checkPermission(new RuntimePermission("modifyThread"))
					>再次使用 mainLock 同步开启：遍历 workers 的每个：
						>用安全管理器查看线程是否有连接权限：@security.checkAccess(w.thread)
					>解开同步unlock()一次
				>尝试更新 ctl 为 shutdown:@advanceRunState(SHUTDOWN)
					>无限循环中：
						>如果状态已经为： shutdown/stop/tidying/terminated 那么直接break;否则 run 则看 CAS更新 ctl为 shutdown_当前worker数 , 如果成功了，则退出，否则继续循环。
				>中断闲逛线程：@interruptIdleWorkers() 直接转发给：@interruptIdleWorkers(false) 则会全部 worker 都检查 试图 interrupt 一次。 
				>钩子函数：@onShutdown()  -空实现。 
				>finally：解开同步
				>最后尝试状态更新为 关闭：@tryTerminate()
				--总结：一是更新ctl为shutdown,二是workers的线程全都中断(则如果队列空了就退出)，三是尝试更新ctl为terminated
				--总结2：中断：只有对在等待阻塞的线程执行中断才有效，没有阻塞的线程执行中断是不会让它抛出中断异常的。
		>立即关闭线程池方法：@shutdownNow()		类似
			>先使用 mainLock 进行同步： 
				>检查是否有权限：@checkShutdownAccess()
				>尝试更新 ctl 为 stop:@advanceRunState(STOP)
					>无限循环中：
						>如果状态 为： stop/tidying/terminated 那么直接break;否则 run/shutdown 则看 CAS更新 ctl为 stop_当前worker数 , 如果成功了，则退出，否则继续循环。
				>中断线程：@interruptWorkers()
				>吸干任务队列的所有任务：@drainQueue()	-- 内部靠：@BlockingQueue.drainTo(taskList) 来实现提取任务队列里的任务--如果之后还有空余，那么还会直接queue转数组后q移除而添加到 taskList。
				>尝试更新为终止：@tryTerminate()
				>返回任务列表：taskList
				--总结：会导致正在阻塞的闲逛worker先中断后直接退出。(所以如果正好还没有取限时取任务时被中断，那么还是会继续等设定的idle时间；如果@showdown()同步并发的@add()任务-即便只有1个那么也可能导致有worker没有退出--并且一直阻塞在那里)---所以shutdown()时候必须确保返回之前都没有add()的执行；而@shutdownNow()则也可能会有线程或者，所以要确保关闭之后:1.没有add,2.任务队列里取出剩下的未执行任务3.没有正在执行的worker--全部都在阻塞等待任务队列处，那么就可以最安全的退出了。
				--总结：注意worker不分core/maxi类型。
		>限时等待终止：@awaitTermination()
			>使用 mainLock	同步： 
				>进入无限循环中：
					>如果状态是 TERMINATED, 直接返回true 
					>否则不是，看限时时间<0则也返回false 
					>最后调用 ConditionObject 条件对象进行 释放独占和状态量而-循环等待-入队等待：@termination.awaitNanos(nanos)
			>退出同步	
		>结束：@finalize()
			>带安全框架地执行@shutdown()
			