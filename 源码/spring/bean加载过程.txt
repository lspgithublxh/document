//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备；化被动为主动去做)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
//大的想法，具体行动。
//出现了if-else就是因为有不同的考虑。
//阅读文档达到直接可以看出思路编写程序的清晰逻辑的地步。
//一个大函数功能直接看懂而描述。
//从网上找答案变为从源码中找答案。

>加载bean: 
 >AbstractApplicationContext.getBean(String name)开始的：
	@考虑到(什么情况)(预防)：beanFactory的活跃状态、关闭状态影响是否获取bean, 如不活跃则不获取。决定(做一件什么事)：判断beanFactory活跃，否则抛出错误。世界观：容器有active,closed状态
		#当容器不活跃(标记：active=false)甚至关闭(closed=true)时抛出异常。
	@由于：本质上bean加载是beanFactory的功能，决定：获取上下文里的beanFactory让它去获取这个bean: getBean(name)
		#当采用AbstractBeanFactory实现时：
			@由于：为了各种各样的入参情形适配，决定：转发给一个统一的参数调用接口：doGetBean(name, null, null, false)
				>由于：name取值各种格式，需要转化为权威的：
					@由于：可能存在前缀&，需要全部去除；同时额外的事情：缓存下来，无需每次都这样去除。//要做多件事情 ，而不是仅仅就解析而已。如缓存。
					@由于：这个name可能是alias即别称，需要转换为权威的。决定：通过aliasMap来找到别称对应的权威名称。SimpleAliasRegistry中存在这个aliasMap
				>2由于： 决定：获取name的单例：getSingleton(beanName)
					@由于：经常存在获取单例的不同入参的需求，决定：统一调用一个统一的单例获取接口：DefaultSingletonBeanRegistry.getSingleton(...)，其中一个参数：是否允许提前引用allowEarlyReference。。。整体试图从各个工具那里获取bean的顺序--三次尝试：单例对象map-->提前单例对象map(正在创建过程中--应该是存在循环引用)--->单例工厂里先获取对象工厂(正在创建过程中)。。。三次尝试都不行，那么可能是个工厂bean--&开头。
						#当单例map:singletonObjects包含时：取它。
						#没有则当“正在创建的bean集合”set:singletonsCurrentlyInCreation包含name时：进入同步
							#当提前单例map:earlySingletonObjects包含时：取它 
							#没有则当“允许提前引用”时：从单例工厂map:singletonFactories里取它的对象工厂
							#当存在时：从工厂里获取.getObject(), 并保存在提前单例map里--以便并发获取时下一个线程直接从这里获取，并从单例工厂里移出name, 从而不会再调用.getObject()---保证了工厂创建只执行一次。
				#3由于：第二步返回的instance可能满足：instance != null && args == null, 决定：专门处理
					>允许打印日志：如果在创建中：singletonsCurrentlyInCreation中，打印日志。
					#当name是&开头说明是FactoryBean：如果instance不是FactoryBean类型则要抛出错误。NullBean类型直接返回。否则继续。
					#此时name可能：&开头的FactoryBean类型实例，不是&开头的任意类型。对于第一种，决定：直接返回。对于第二种：如果instance不是FactoryBean类型也直接返回。
					#此时name可能：不是&开头的FactoryBean类型。后面的目的则为：要从factory里获取object，并且条件下执行处理器方法。
						#由于： 效率考虑，工厂bean也进行缓存。决定：先从工厂bean缓存map:FactoryBeanRegistrySupport.factoryBeanObjectCache中取，有则直接返回它。
						#此时如果缓存没有：决定：尝试通过instance这个FactoryBean获取。考虑到：bean工厂获取时如果这个bean是非合成类型，则有非合成bean需要postProcess事情，此时情况：instance强转Factory
							@由于：判断bean是否合成类型是从它的RootBeanDefinition信息中判断，而RootBeanDefinition存在的条件是：DefaultListableBeanFactory.beanDefinitionMap包含name; 决定：看这个包含条件是否满足
							@当条件满足：即包含这个name的定义--beanDefinitionMap中含有。获取bean的RootBeanDefinition信息mbd
								#当已融合的RootBeanDefinition map:mergedBeanDefinitions中包含时：取它，直接返回。
								#没有则:先进行融合。融合的条件：BeanDefinition先找到。
									@获取BeanDefinition：从map:DefaultListableBeanFactory.beanDefinitionMap里，没有则报错。
									@然后获取合并后的RootBeanDefinition(事情/任务)：考虑：到这种获取融合bean常见，决定：转发给一个统一入参的接口：AbstractBeanFactory.getMergedBeanDefinition()。
										#考虑到性能：决定：使用同步块，先从已融合的beanDefinition map:AbstractBeanFactory.mergedBeanDefinitions里取，有则直接返回。
										#如果此时该融合map里没有：则需要新建bean definition 和root bean definition并融合。具体步骤分为：
											#当bean没有parent时：可以简单的复制属性处理。
												#当它是RootBeanDefinition类型：则直接复制各个属性到一个新的子类型ClassDerivedBeanDefinition/ConfigurationClassBeanDefinition实例中。
												#否则：直接属性赋值传递到新建一个RootBeanDefinition实例里。
											#当有parent时：考虑到子类属性更多，决定：需要先转换，再合并到一个RootBeanDefinition实例里。
												#由于：bean的parent的权威名可能和bean的权威名一样，需要区分处理，决定区分处理：先获取parent的权威名
													#当二者权威名不相同：考虑到获取bean的应该有多种渠道，而设计了至少两种来获取parent的bean definition。
														#当beanDefinitionMap里不包含且parentBeanFactory是ConfigurableBeanFactory类型：认为bean的各级parent中最终肯定有一级的parent的beanFactory已经被包含了----如果到根也没有包括且还是ConfigurableBeanFactory类型就会报错了, 所以只需要递归地找parent的权威name进行寻找bean definition。
														#否则的情况就是：beanDefinitionMap包含或者parentBeanFactory不再是ConfigurableBeanFactory类型：那么直接从本地获取---是一个统一的接口。? getMergedLocalBeanDefinition(String beanName)
															@由于：可能其他线程会先调用而产生而放到mergedBeanDefinitions，所以依然先从mergedBeanDefinitions里查看是否有：有则直接返回。
															@否则没有：则转发给一个统一的获取融合bean definition的方法，其入参是先获取这个parent name的BeanDefinition。AbstractBeanFactory.getMergedBeanDefinition(String beanName, BeanDefinition bd);
																@由于：获取融合bean definition非常普遍，所以再次递归地传递给了统一的获取mergeBean的接口：AbstractBeanFactory.getMergedBeanDefinition(String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)
													#否则对于权威名相同的情况：同名，则考虑从parentBeanFactory里获取。
														#当它的parentBeanFactory是ConfigurableBeanFactory类型，则调用它的通用的接口：getMergedBeanDefinition(String beanName)来获取			
														#否则：抛出异常。并被直接捕获，再向上抛出异常。	
													>现在的情况则是已经获取到了parent的BeanDefinition：需要做的事情就是属性传递到一个新的RootBeanDefinition实例mbd，这个实例overrideFrom 它的child的BeanDefinition 实例引用。		
													>考虑到属性传递接口通用：如果mpd有scope值，那么这里需要强制传递mbd的scope范围是：RootBeanDefinition.SCOPE_SINGLETON		
													>最后的事情：将mpd放到融合bean definition map:AbstractBeanFactory.mergedBeanDefinitions.put(name, mpd)		
							>由于：信息已经足够：决定：判断bd是否为合成类型--通过mbd中的字段判断。
							@由于：工厂bean有了，合成类型也有了，FactoryBean类型的name也有了，决定从工厂bean中获取实例。FactoryBeanRegistrySupport.getObjectFromFactoryBean()
								#当工厂bean管理的bean是单例模式 且 单例池singletonObjects里包含了name: 认为是单例模式，
									#由于：多线程下可能多次调用创建：而进入同步块，再次尝试从FactoryBeanRegistrySupport.factoryBeanObjectCache里获取，取到则直接返回。
									#没有则进行实质的通过factorybean来获取：对于这件事情，考虑到：从factorybean里获取可能需要权限，因此可能需要放到权限框架里，还有一些收尾工作。doGetObjectFromFactoryBean()
										#当设置了权限框架：则委托给权限框架来执行：AccessController.doPrivileged(()->{}...)。
										#否则没有设置：直接factoryBean.getObject()
										#此时的情况是已经通过调用方法来获取Object: 考虑到它可能为null而需要的后续处理，决定：继续分两步：
											#当不为null：直接返回。 
											#如果为空: 进一步判断如果工厂bean的beanName在创建过程中:singletonsCurrentlyInCreation,认为是有问题的，抛出异常。如果不为null,那么返回NullBean()实例。 
									#此时的情况：考虑到可能在getObject()执行过程中就已经将object放置到了factoryBeanObjectCache里：所以再次尝试从factoryBeanObjectCache里获取：取到则直接返回。没有需要进一步判断。 
										#此时factoryBeanObjectCache里没有：
											#如果是合成的类型，那么直接先不做什么。
											#否则非合成的需要后续处理:
												#如果name在“当前正在创建”的单例池中：即name包含在set:singletonsCurrentlyInCreation，则不能后续处理，所以直接返回object
												#否则已经创建完成：开始bean的processer处理器的三段通知/观测回调。考虑到：工厂创建的bean也需要一般化的初始化后的处理器处理(BeanPostProcessors)，前后也有一些通知操作。决定： 
													@前置处理：如果name的bean包含--即singletonsCurrentlyInCreation包含(添加失败)，且需要创建中检查--即set:inCreationCheckExclusions不包含 , 则抛出异常，不被捕获。否则什么也不做，直接返回。
													@处理器处理：AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean(Object object, String beanName)
														@由于：bean创建后初始化之后都需要处理器处理，决定：复用统一的处理器处理接口，转发给它。AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
															>获取全部的beanPostProcessors，遍历每一个：利用上个beanPostProcessor编织的结果来获取本次进一步编织后的结果，执行每一个的postProcessAfterInitialization(result, beanName)方法
																#如果这个结果为null, 则直接返回上次编织后的结果。
																#否则不为空：继续下一轮编织。直到编织完全，返回。这个object覆盖老的object
													@后置处理：如果name的bean不包含--即singletonsCurrentlyInCreation不包含(移除失败),且需要创建中检查--即set:inCreationCheckExclusions不包含，则抛出异常。不被捕获。 
											>如果单例池singletonObjects里包含name: 将工厂调用getObject()返回的object 放到 工厂名-生产的对象 这个map:factoryBeanObjectCache里：(name, object)
										>最后返回object
								#否则此时情况：工厂bean不是单例 或者 单例池不包含；那么此时不需要同步块，也不需要前置后置处理，决定： 直接进行实质的通过factorybean来获取object, 然后执行处理器处理即可。
									>实质的factorybean获取object:doGetObjectFromFactoryBean
									#当为非合成的则需要处理器处理：调用处理器：postProcessObjectFromFactoryBean
									>返回object
							>返回object 
				#否则args为null或者instance为null: 
					@当“正在创建中的bean集合”的线程局部变量prototypesCurrentlyInCreation里包含时：直接抛出异常。
					#此时则name没有在创建：此时考虑可能可以通过parentBeanFactory来获取bean,决定：获取parentBeanFactory
					#如果此时parentBeanFactory不为null且还没有bean definition:即beanDefinitionMap里没有, 则决定通过parentBeanFactory来获取bean,具体过程如下：
						@由于：可能出现递归的调用“通过factory来获取bean”方法，所以决定：获取name的原始name---就是权威名/&权威名(如果是工厂bean)
							#当parentBeanFactory是AbstractBeanFactory类型时：则递归调用:AbstractBeanFactory.doGetBean()
							#否则不是这种类型，进一步如果args != null:则此时instance为null, 决定：使用args入参从bean工厂里获取实例：parentBeanFactory.getBean(原始name, args)	
							#否则args==null, 进一步requiredType	如果!= null: 调用rt入参来获取parentBeanFactory.getBean(nameToLookup, requiredType)							
							#否则就只能直接根据name获取：parentBeanFactory.getBean(nameToLookup)								
					>否则此时：parentBeanFactory==null 或者已经有name的BeanDefinition了；考虑可能出现重复创建，所以先标记已经在创建：同步方式加到alreadyCreated:set中---且删除mergedBeanDefinitions里的同name key。显然只会加一次，移除一次。
					>考虑后面会通过各种参数和条件而用不同路径创建bean, 决定：先通用的方法获取本地融合bean:getMergedLocalBeanDefinition(name) mbd
						#如果mbd是抽象的：那么抛出错误。
					>进一步考虑：bean可能有依赖，依赖自然要先创建，所以决定：先从mbd获取所有的依赖名数组，并先将这些依赖逐个创建和注册。							
						#当依赖不为null: 考虑到循环依赖，且接口常用，所以转发委托给专门的依赖检测接口：					
							@循环依赖检测接口的检测：如果存在，则抛出异常。通过 权威名-依赖此name的set 这个map:DefaultSingletonBeanRegistry.dependentBeanMap来帮助判断：取出值集合dependentBeans。					
								#当dependentBeans为null:则自然不会有循环依赖。返回false
								#否则dependentBeans包含被依赖的name:则说明依赖此name的bean集合中有的还被此bean依赖，则说明存在循环依赖，返回true.
								#否则检测dependentBeans的每个元素的依赖主 集合：即递归地往上找，是否在依赖主的依赖主 集合里依赖了该bean。				
							@注册依赖bean: 一个是放到 name<-依赖name的set map:dependentBeanMap里--上面也会使用来帮助判断循环依赖，一个是放到name->被依赖的name的set map:dependenciesForBeanMap里---来在销毁依赖前，先把依赖的销毁。		
							@开始真正的要做的事-:创建依赖bean: 由于这是一个常见的方法，且有多个入参接口，且显然也应该和最开始获取bean的接口一样，所以直接调用：AbstractBeanFactory.getBean(name)。。和最开始调用的方法一样。			
					#当mbd是单例时：开始实质性的获取单例,而不是像之前的仅仅从缓存里。通过单例工厂方式。
						@考虑到：可能多线程创建，所以需要同步块，需要缓存---先判读是否单例池中存在,如果存在直接返回
							#否则不存在：考虑到当前可能在运行销毁单例：所以从正在销毁单例池singletonsCurrentlyInDestruction中查看，有则抛出错误。
							#此时的情况：则name没有创建在单例池也没有被销毁：开始常见的前面已经叙述的三段通知：
								>前置处理：同前述
								>单例工厂获取单例：singletonFactory.getObject()
									>单例工厂为lamda注入：做的事情为：创建--->编织/异常则销毁
										@创建：并且初始化、各种post-processors处理。createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
											@解析获取bean的Class对象：直接从mdb获取，或者：或许需要放到权限框架地：通过beanExpressionResolver.evaluate()入参为bean name/ 定义中的Scope来获取 评估结果：expressionParser.parseExpression()来获取表达式对象，使用该对象的Expression.getValue(EvaluationContext context)得到评估结果---可能和name一样或者是个Class类型对象。$$$$
												#解析结果是Class类型：则直接返回了。
												#否则：交给统一的ClassUtils.forName()方法来获取。AbstractBeanDefinition.resolveBeanClass()
											#此时如果解析的Class对象不为空且 当mbd有类名无类Class ：那么将mdb重新封装到一个新的RootBeanDefinition实例，并且Class对象设置到setBeanClass()属性里。	
											>当存在覆盖方法时需要专门处理：AbstractBeanDefinition.methodOverrides保存了覆盖方法。遍历每个方法，进行相同的统一处理：
												@当此时beanClass还没有设置：直接抛出错误
													#有设置则通过一个巧妙的方法找到同名方法个数：在本Class, 全部父类、全部接口，递归向上的寻找。
													#当这个个数小于0：那么没有覆盖--则抛出错误。
													#否则如果==0: 该覆盖方法是否重载属性设置为false: MethodOverride.setOverloaded(false)
											@后面将进行实例初始化，此时进行一次BeanPostProcessors责任链 处理：看实例初始化之前是否有代理产生。也属于通知的应用。AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)	
												#当“实例初始化前处理器已经准备好”属性已经生效：beforeInstantiationResolved==true
													#进一步当mbd表面非合成类型且工厂包含处理器InstantiationAwareBeanPostProcessor：hasInstantiationAwareBeanPostProcessors==true
														#进一步检测目标类而获取tagetType Class对象: 目的时尽量使的不创建bean,
															#当目标类targetType不为null: 如果工厂方法名为null,则直接进行上述的解析获取bean的Class对象：如果工厂方法名不为空，则以更加苛刻的目标类检查过程，来从mbd的factoryBeanName建立它的类Class单例(也可以mbd中本身类同上解析创建), 甚至如果时cglib类还要返回它的父类，此间种种条件下都可能返回null:AbstractAutowireCapableBeanFactory.getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch)
															#当上述之后返回的targetType Class仍然不为null:则确认是完成了解析目标类：设置mbd.resolvedTargetType=targetType
														#当检测出的targetType不为null: 开始初始化前的处理器通知applyBeanPostProcessorsBeforeInstantiation
															@由于处理器通知是常见的，所以统一接口：此时关注实例化前通知方法，所以以一个具体方法来走处理器责任链。
																#遍历所有BeanPostProcessors: 对所有的InstantiationAwareBeanPostProcessor类型的处理器：
																	@调用对应方法来尝试获取代理：但是不会层层编织--只会编织一次--InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation(targetType, beanName)
																		#如果结果不为null:则返回这个结果。最后否则返回null。
														#当上述处理器通知返回的结果不为null时：需要进行后置处理器处理---前面有使用过。applyBeanPostProcessorsAfterInitialization	
															@同样，后置处理器处理也是统一的接口：应用通知，只需要直接获取所有的处理器，直接调用后置方法BeanPostProcessor.postProcessAfterInitialization(result, beanName)层层编织。
																#编织的结果为null: 则直接返回上次编织的结果。
																#否则不为Null: 继续当作下次编织的对象。
											#当上一步返回的编织结果不为null:则直接返回这个编织结果。
											@否则没有编织：开始真正的实质的创建AbstractAutowireCapableBeanFactory.doCreateBean()。工作为：创建、处理器、两步初始化、各种key缓存、注册
												>事情1：创建BeanWrapper包装类
													>mbd是单例模式，则先看缓存池里是否有bw: 工厂bean name到beanWrapper的映射缓存池factoryBeanInstanceCache中：没有则开始真正的创建createBeanInstance()
														#@：先解析beanClass, 如果mbd里有则直接返回，AbstractBeanFactory.resolveBeanClass()
															#没有则或带安全框架进行真正的解析beanClass: AbstractBeanFactory.doResolveBeanClass()。过程分为几步：先必然要获取加载器
																>获取beanClassLoader: AbstractBeanFactory.beanClassLoader属性，
																#如果mbd的bean类名就是null: 那么直接调用mbd的AbstractBeanDefinition.resolveBeanClass(cl)返回null , 该方法非常简单：就是用ClassUtils.forName(className, classLoader)来加载类字节码Class<?>对象---显然需要类名和类加载器：：最基本的加载一个Class的条件数据。
																	>这个加载过程：用了缓存;考虑了名称的--基本数据类型、考虑了数组类型、考虑列表类型,做了不同的处理，统一返回带类型的数组类型Array.newInstance(ec,0).getClass()；
																		#如果cl也为null: 那么开始考虑使用的其他类加载器来加载，尝试的cl顺序为：当前线程上下文加载器Thread.currentThread().getContextClassLoader() > 本工具ClassUtils类的类加载器ClassUtils.class.getClassLoader() > 系统加载器/根加载器/bootstrap 类加载器/sun.misc.Launcher类的加载器
																		>最后使用：java的Class.forName(name, false, clToUse)来加载类字节码
																#否则不为null: 先评估beanDefinition， 
																	@转发给专门的评估类：AbstractBeanFactory.beanExpressionResolver.evaluate(beanName, BeanExpressionContext)
																		>对Expression和StandardEvaluationContext使用了缓存模式：说明个数不多。expr.getValue(context)的评估结果：评估工作简单：LiteralExpression直接返回.literalValue,而SpelExpression则多一些工作。
																	#如果上述评估结果和className一样：说明className是正常名，则可以直接mdb.resolveBeanClass(cl)加载类字节码对象。
																	#否则是一个表达式名或者Class对象：需要专门解析：如果是Class对象，直接返回。 
																		#否则是表达式名：其实也是一个类名cn, 此时优先使用前面获取到的cl来加载.loadClass(cn)--比较客户化, 没有才使用比较官方的ClassUtils.forName(className, dynamicLoader)来加载，然后返回。
														#此时：已经解析 获取到Class对象，还要判断：Bean Class是否public和可以access, 不行的话抛出异常。
														-准备创建实例：按照一个顺序从各种渠道工具来创建实例：instanceSupplier > factoryMethod > 手动
														#如果实例提供器不为null: 用这个工具创建，三步走
															>设置线程局部变量-当前正在创建的Bean: AbstractAutowireCapableBeanFactory.currentlyCreatedBean为给定的beanName
															>调用实例提供器的get()方法 
															>恢复设置线程局部变量-当前正在创建的Bean：为设置之前的beanName
															#创建的实例为null: 则设置为new NullBean()实例 
															>将实例直接封装为BeanWrapperImpl实例：bw
															@对这个bw初始化：AbstractBeanFactory.initBeanWrapper() 核心事务概述：注册属性编辑器
																>设置bw的转换服务：conversionService
																@注册客户的编辑器：bw实现了PropertyEditorRegistry接口，其中有注册方法，来注册一些PropertyEditorRegistrar实例，来辅助bean的属性值的注入。AbstractBeanFactory.registerCustomEditors()
																	@注册方法：ResourceEditorRegistrar.registerCustomEditors()
																		@实际注册方法：ResourceEditorRegistrar.doRegisterEditor()
																			#判断registry类型而分别存放：PropertyEditorRegistrySupport类型则存放到：map:PropertyEditorRegistrySupport.overriddenDefaultEditors
																			#否则注册到：可能是map:PropertyEditorRegistrySupport.customEditors属性里。DataBinder也是。
																			-上述map:都是key为资源类型如：File.class/URL.class/InputStream.class/Resource.class/Reader.class等，value则为对应的编辑器：FileEditor/ReaderEditor等
															>返回这个bw
														#@如果mbd的工厂BeanName不为null: 调用工厂方法进行创建：instantiateUsingFactoryMethod()
															@统一转发给ConstructorResolver.instantiateUsingFactoryMethod()实现：先给ConstructorResolver实例注入工厂引用本身AbstractAutowireCapableBeanFactory
																>直接new BeanWrapperImpl()实例：bw
																@调用工厂的初始化方法初始化bw: AbstractBeanFactory.initBeanWrapper() 同上方法。
																#如果工厂beanName和beanName一样：则不正确，抛出异常。
																#否则不一样：开始获取bean: 获取方式即递归最开始的方法：this.beanFactory.getBean(factoryBeanName)。AbstractBeanFactory.getBean(String name)
																>开始创建前，要做存在性判断：入股mbd是单例模式，且单例池中已经存在该bean: singletonObjects.containsKey(beanName) 则抛出异常
																#到此则说明单例池没有，该bean还没有创建：对构造参数explicitArgs开始判断
																	#如果为null: 则从mbd中获取：构造方法获取：mbd.resolvedConstructorOrFactoryMethod； 和方法参数获取：mbd.resolvedConstructorArguments /没有则预备参数：mbd.preparedConstructorArguments; 
																		#如果使用了预备参数：则需要进一步解析处理：解析获取参数：ConstructorResolver.resolvePreparedArguments()
																			-需要解析每个方法参数：类型和值，需要进行引用解析，因为可能是未解析类型，甚至需要重新beanFactory.getBean(name)、加入依赖表beanFactory.registerDependentBean(refName, beanName)
																			>准备工作：构造一个值解析器BeanDefinitionValueResolver实例valueResolver
																			#如果某个方法参数值类型为：BeanMetadataElement
																				@使用值解析器解析值：(BeanDefinitionValueResolver)valueResolver.resolveValueIfNecessary("constructor argument", argValue)
																					-根据值类型的不同 而调用不同的解析方法，也返回不同的类型：直接返回bean或者直接返回beanName
																					#如果值是运行时引用RuntimeBeanReference类型：
																						@调用值解析器的解析引用方法：BeanDefinitionValueResolver.resolveReference()
																							>先评估这个值的BeanName名：BeanName
																							#看这个值是否是父类的工厂方法创建：是则用父类工厂getBean(refName)
																							#否则用本beanFactory来getBean(): 之后保存依赖关系对：beanFactory.registerDependentBean(refName,beanName)即保存到了dependentBeanMap和dependenciesForBeanMap里。
																					#如果值是运行时名称引用RuntimeBeanNameReference类型：
																						>先评估这个refName,评估结果转换为name, 如果它不在beanFactory中，抛出错误
																						#在，则返回这个评估结果。
																					#如果值是bean定义持有类型BeanDefinitionHolder：bh
																						@转发调用解析内部bean：valueResolver.resolveInnerBean()
																							@调用统一的方法合并为mbd:RootBeanDefinition类型：beanFactory.getMergedBeanDefinition() 该方法之前已经讲解过。
																							-因为bh的beanName就是innerBeanName
																							#当mbd是单例模式：这个innerBeanName需要调整。
																								@调整方法调用：BeanDefinitionValueResolver.adaptInnerBeanName()功能在于对innerBeanName后面添加#1, 即认为这个name可能被使用过，则数字累加：alias中使用map:aliasMap, 单例池singletonObjects使用map:, 定义map:beanDefinitionMap使用，或者是工厂Bean?FactoryBean--解析一下看是否能解析成功， 或者依赖map里有：dependentBeanMap。
																							-此时则得到了真正的内部beanName:actualInnerBeanName
																							@开始注册到“一个bean包含的所有bean的map”中：DefaultSingletonBeanRegistry.registerContainedBean() containedBeanMap			
																								#如果注册成功：那么继续注册依赖：@注册到依赖map:dependentBeanMap/dependenciesForBeanMap。方法同之前。beanFactory.registerDependentBean()
																							>将mdb所有的依赖bean创建和注册：mbd.getDependsOn()对每个依赖的bean, 注册依赖关系beanFactory.registerDependentBean(), 第二，获取依赖bean: beanFactory.getBean(String name)					
																							@此时才开始真正创建bean: 调用bean工厂创建:this.beanFactory.createBean(actualInnerBeanName, mbd, null) 这就是递归了。
																							-此时创建完毕，但是bean的类型可能还是工厂bean类型：
																							#如果创建的结果bean是工厂bean类型：FactoryBean	那么需要通过工厂bean的方式创建它：beanFactory.getObjectFromFactoryBean()前面使用过此方法。
																							#如果结果bean是NullBean类型：返回null
																							#否则直接返回innerBean。#				
																					#如果值是bean定义类型BeanDefinition：
																						>先获取innerBeanName: (inner bean)#4fesx 其中#后面的就是值的hashcode的十六进制字符串。
																						@转发调用解析内部bean：valueResolver.resolveInnerBean()
																					#如果是ManagedArray: 则元素类型需要考虑
																						>加载元素类型：array.resolvedElementType使用：ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader())
																						@专门解析每个元素类型：BeanDefinitionValueResolver.resolveManagedArray()
																							>遍历每个元素：递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																							#解析完成则返回。
																					#如果是ManagedList：
																						@专门解析resolveManagedList(): 
																							>遍历每个元素：递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																								#解析完成则返回。
																					#如果是ManagedSet：
																						@专门解析resolveManagedSet(): 
																							>遍历每个元素：递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																								#解析完成则返回。	
																					#如果是ManagedMap：
																						@专门解析resolveManagedMap(): 
																							>遍历每个key-value：两个都递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																								#解析完成则返回。	
																					#如果是ManagedProperties类型：
																						>转换为Properties类型：所有的键值都要评估。
																						#只要有一个评估结果为null都抛出异常。
																					#如果是TypedStringValue类型：
																						>先评估：得出评估结果
																						>再解析这个值的目标类：BeanDefinitionValueResolver.resolveTargetType() 目标类就是要求类
																							#属性有目标类：即targetType属性是Class实例类型，直接返回。
																							#否则需要借助beanClassLoader来解析：
																								@调用接口：TypedStringValue.resolveTargetType()来解析
																									#看属性targetType是是什么类型：string, class, 都可以获取为string, 然后反射加载对应的Class: ClassUtils.forName(typeName, classLoader)
																									#为null则返回null, 否则就是加载的结果。
																						#如果此时的解析后的目标类Class不为null: 需要转换为要求的类型。即上述解析的类型。将值转换为这个类型。
																							@统一调用：this.typeConverter.convertIfNecessary()
																								@统一封装调用：TypeConverterSupport.doConvert()
																									@再次委托调用：TypeConverterDelegate.convertIfNecessary()
																										@再次转到统一参数接口：TypeConverterDelegate.convertIfNecessary()
																											>先根据要求类型获取属性编辑器：propertyEditorRegistry.findCustomEditor()
																												@转发调用统一的从用户定制的编辑器里获取属性编辑器：PropertyEditorRegistrySupport.getCustomEditor()
																													>获取顺序：map:customEditors  > map:customEditorCache
																													#如果获取的结果仍然为null: 那么猜测可能要求类是 customEditors里的key的子类，这样的话，也可以；就用这个超类的属性编辑器；同时缓存起来customEditorCache，key=requiredType, value=editor
																											>再从属性注册器仓库获取转换服务：propertyEditorRegistry.getConversionService()
																											#如果没有编辑器但是有转换服务：那么考虑使用转换服务来转换：
																												@统一调用GenericConversionService.convert() 结果直接返回作为convertIfNecessary()返回值。
																													@根据源类型和目标类型 统一获取转换器：GenericConverter.getConverter()
																														>先缓存里获取：converterCache
																														#没有则调用发现服务来获取：
																															@统一发现转换器服务：converters.find(sourceType, targetType)来获取：
																																>两个类的由近及远的类继承体系：通过这个两两组合对ConvertiblePair 作为key参数，调用map:converters来获取出ConvertersForPair，
																																@根据每个组合Pair获取注册的converter:getRegisteredConverter()
																																	@统一调用ConvertersForPair.getConverter(): ConvertersForPair有list:converters属性，
																																		@遍历每个converter进行匹配：ConditionalGenericConverter.matches() 
																																			@如果匹配成功：立即返回该converter
																																	
																																	#如果此时没有匹配成功：则继续从globalConverters属性里获取GenericConverter来一个个的匹配：
																																		#如果匹配成功则返回。否则返回null
																																#如果此时converter不为null:那么返回。否则没有一个组合满足，直接返回null。
																															#如果此时没有发现converter:	那么 调用默认转换器获取方法获取@getDefaultConverter()
																																#只看源类是否可以赋值给目标类(isAssignableTo)：可以则返回new NoOpConverter("NO_OP")实例。 
																															#此时converter不是null：存到map:converterCache属性里 并返回它,否则存一个new NoOpConverter("NO_MATCH")实例--并返回null。	
																													#获取的转换器不为Null: 那么统一使用@ConversionUtils.invokeConverter()来转换为目标值。
																														>转换器就直接转换：converter.convert(source, sourceType, targetType)，得到一个转换结果。
																														#对结果handler一下处理：@GenericConversionService.handleResult() 
																															#如果结果为null, @assertNotPrimitiveTargetType():由于null不能赋值给基本类型，所以判断targetType是否是基本类型primitive type, 是则抛出异常：ConversionFailedException 。。其他情况下都直接返回result;
																													#没有发现转换器的处理：handleConverterNotFound() ，有的话则会抛出。
																														#此时对转换之前的值进行判断：source为null,那么还是null-基本类型是否抛出错误判断：@assertNotPrimitiveTargetType()
																														-当源类型可以赋值给目标类型且source是目标类型(基本类型也可以)的实例(instanceof , isInstance(obj))，那么直接返回source就可以。条件是：sourceType 是null。其他情况都抛出未发现异常：ConverterNotFoundException
																											#如果转换后的值不是requireType要求类型：			
																												#如果要求类型是集合类型且转换后的值是字符串类型：从赋值角度检查Collection.class.isAssignableFrom()		
																													@将逗号分隔的字符串转换为字符串数组：@StringUtils.commaDelimitedListToStringArray(str)
																														@统一转发给：@delimitedListToStringArray()
																															@再转发给统一参数入口的接口：@delimitedListToStringArray()
																																>内容描述：从逗号分隔indexOf找到位置，不断substring出来放到一个集合里，最后集合转换为数组：collection.toArray(new String[0])---自己之前也曾使用过。	
																												-此时可能已经获取到了转换后的字符串数组，需要其他方式进一步转换“字符串数组”
																												#如果编辑器为null, 那么就获取默认的：@findDefaultEditor(requiredType)
																													>从属性编辑器仓库获取：@TypeConverterDelegate.propertyEditorRegistry.getDefaultEditor(rt)	
																														#查看默认编辑器激活开关：是否启用。开启才用。
																														>先尝试从map:overriddenDefaultEditors属性获取，有则返回。
																														#没有则看defaultEditors属性，如果为null: 则创建它@createDefaultEditors()
																															>除了注册常规的编辑器如：CharsetEditor/FileEditor/PathEditor/URLEditor/UUIDEditor/, configValueEditorsActive
																															>也注册集合编辑器如：new CustomCollectionEditor(Set.class)/new CustomMapEditor(SortedMap.class)
																															>也注册基本类型及其数组、包装类编辑器：new CustomNumberEditor(Double.class, false)/new CustomNumberEditor(Double.class, true))
																															>在configValueEditorsActive激活时注册：	new StringArrayPropertyEditor() 给short[]/int[]/long[]/String[]类型。
																														>从默认编辑器里取：map:defaultEditors, 直接get返回。
																													#如果此时依然没有发现编辑器：通过转换服务获取BeanUtils.findEditorByConvention()：
																														#不处理数组、不知道的targetType:直接返回null 
																														-尝试使用“加载编辑器类”的方式，而假设编辑器类类名等同于targetType的name+"Editor"
																														>所以先获取加载器：顺序：targetType.getClassLoader() > ClassLoader.getSystemClassLoader()
																														>构造编辑器名字：editorName=targetType.name + "Editor"
																														#开始加载cl.loadClass(editorName)，如果加载成功：检查Class对象是否可以赋值给PropertyEditor
																															#如果不可以：放入垃圾堆-不知道的编辑器类型map:unknownEditorTypes.add(targetType)，返回null 
																															#如果可以：需要对Class对象初始化：@BeanUtils.instantiateClass(ec) 里面会捕获可能发生的各种BeanInstantiationException异常。结果直接返回findEditorByConvention()
																																#使用构造器方法初始化：统一调用@instantiateClass(Constructor<T> ctor, Object... args)
																																	>设置构造方法可访问：ReflectionUtils.makeAccessible(ctor)， 几个判断。
																																	#如果构造方法类是特殊类：KotlinDetector.isKotlinType() 那么委托进行初始化：@KotlinDelegate.instantiateClass(ctor, args)
																																		-基本内容就是：使用KFunction实例ReflectJvmMapping.getKotlinFunction(ctor)的.callBy(argParameters)方法进行初始化。
																																	#否则简单的直接反射的构造方法调用：@ctor.newInstance(args)	
																																		-里面最终调用ConstructorAccessor.newInstance() 里面又BootstrapConstructorAccessorImpl.newInstance() 里面又：UnsafeFieldAccessorImpl.unsafe.allocateInstance(this.constructor.getDeclaringClass())
																													#返回编辑器。					
																												-此时编辑器获取完毕，开始利用来进行实质的转换值为目标类型：doConvertValue()						
																													#如果值不是字符串：调用编辑器setValue()又取出getValue()，如果两个值不相等，那么取出的值作为最新的值，下一步使用。同时该编辑器不再使用。						
																													-此时如果要求的类型不是数组，但是此时的转换值是字符串数组，则调用方法将字符串数组转换为逗号分隔的字符串：@StringUtils.arrayToCommaDelimitedString()					
																													-此时如果转换值是字符串：
																														#如果编辑器不为null: 统一转换设置@doConvertTextValue()
																															>直接设置转换前的值editor.setValue(oldValue)，设置当前转换值editor.setAsText(newTextValue)，返回值editor.getValue() 
																															#直接返回doConvertValue()
																														#否则如果要求类型就是字符串：那么直接返回当前转换值
																													-返回doConvertValue()		
																											-此时如果要求要求类型不是null: 还需要应用一些标准的类型转换规则。						
																												#此时的转换值不为null时：如果要求类型是Object那么直接返回转换值。			
																													#否则如果要求类型是数组：如果转换值是String且要求类型的元素类型可以赋值给Enum枚举类型，那么将字符串转换为字符串数组：@StringUtils.commaDelimitedListToStringArray()						
																														-此时统一再次进行转换值的转换：@convertToTypedArray()					
																															#如果转换值是集合Collection类型：构建一个该元素类型的数组Array.newInstance(componentType, coll.size())，并将集合元素值处理后设置set进去Arrary.set(r,i,v)				
																																-元素值的处理：先属性名转换，后按需转换：
																																@将属性名转换：@buildIndexedPropertyName() , 在属性名后面加[i] 这样的数组元素标记
																																@按需转换：走统一的按需转换方法：@TypeConverterDelegate.convertIfNecessary()
																																>直接返回
																															#否则如果转换值是数组Array类型：
																																#判断属性编辑器仓库里是否有组成元素的编辑器：调用@propertyEditorRegistry.hasCustomEditorForElement()
																																	>遍历“路径属性编辑器”map: PropertyEditorRegistrySupport.customEditorsForPath	
																																		#如果某个编辑器entry的key匹配到了属性名：@PropertyAccessorUtils.matchesProperty() 并且entry.value即CustomEditorHolder类型的属性编辑器存在--元素类型可以赋值给要求类型：那么返回true	
																																	-如果上述遍历都没有找到，那么就从“一般的定制编辑器”map:PropertyEditorRegistrySupport.customEditors里找：包含则返回true,否则其他情况都是false		
																																#如果没有包含:那么直接返回输入值，不再转换处理。			
																																#否则包含：那么直接按照之前的处理方法：构建一个该元素类型的数组Array.newInstance(componentType, Array.getLength(input))	并将集合元素值处理后设置set进去Arrary.set(r,i,v)	
																															#否则其他任意类型：
																																>统一直接上述的构建数组后，逐个元素处理后设置。
																													#否则如果转换值值是集合Collection类型：
																														>调用统一的方法转换集合元素类型为目标类型：@convertToTypedCollection() 并设置standardConversion=true标记为标准转换。
																															#如果要求类型不是各种基本的集合类型：@CollectionFactory.isApproximableCollectionType(requiredType)				
																																#进一步如果要求类也不可以创建实例：canCreateCopy(requiredType) ---可创建条件：Modifier.isAbstract()非抽象和接口，是public且有构造方法。。那么返回集合不做处理。			
																															#否则此时检查 如果值可以赋值给要求类型，且属性编辑器仓库没有null&这个属性名的编辑器@propertyEditorRegistry.hasCustomEditorForElement()：那么不做处理，直接返回。
																															#否则检测可迭代？不可以则返回。
																															#否则可以迭代，且如果前面检测出的是基本集合类型，那么获取最近似的集合类型：@CollectionFactory.createApproximateCollection()
																																>逐个基本集合类型判断：看值是否是它的实例instanceof ，是则返回这个。List/SortedSet			
																															#否则不是基本集合类型的集合类型：那么先设置反射允许再反射构造。@ReflectionUtils.accessibleConstructor(rt).newInstance()				
																															-此时已经构造出复制的集合：下面开始往里面添加内容。
																															>遍历原始集合：获取每个元素，进行上述的buildIndexedPropertyName+convertIfNecessary获取结果，添加到集合里。
																															#如果转换后的元素全部都和转换前的集合元素相等==，且待转换值就是要求类的值，那么直接返回入参里的原始转换值。
																																#否则才返回这个新的各个元素转换后的集合。
																													#否则如果是此时的转换值是Map类型：		
																														>调用统一的转换方法：@TypeConverterDelegate.convertToTypedMap()	
																															#如果要求类可以赋值给Map直接返回。不转换。
																															-判断是否存在近似的基本Map类型：CollectionFactory.isApproximableMapType()，基本map就是常见的HashMap等。
																															#同上在无近似且要求类不可复制时：直接返回。不转换。 
																															#同上在值可以赋值给要求类 且  属性编辑器仓库没有null&这个属性名的编辑器：直接返回，不转换。 
																															#同上查看是否可迭代：不可，直接返回。 
																															#如果有近似Map：那么创建近似Map:@CollectionFactory.createApproximateMap() 
																															#没有近似Map则直接反射创建：ReflectionUtils.accessibleConstructor(requiredType).newInstance()
																															-此时已经构造出新的Map,但没有元素，下面开始加元素。
																															>遍历原始Map: 同样方式按需转化key:buildKeyedPropertyName+convertIfNecessary, value则直接转换convertIfNecessary()
																															#同理，再如果每次转换前后值都没变且老值可以赋值给requireType那么返回老值，否则返回这个新的集合。
																													-此时可能转换已经进行了一部分。		
																													#如果值是数组array且长度为1，那么：将元素取出来赋给转换值。	标记standardConversion=true	
																													#如果要求类型是字符串，而转换值是基本类型或者其包装类：tostring()返回。	
																													#否则如果转换值是字符串 且 转换值不是要求的类型：
																														#如果要求类不是接口 且不是枚举：那么获取要去类的单str参数构造方法，然后用这个构造方法和转换值 来构造实例：@BeanUtils.instantiateClass(ct,args) 前面已经描述。
																														-细碎的判断：如果转换值字符串为空串且要求类是枚举，那么直接返回null
																														@尝试转换值为枚举：attemptToConvertStringToEnum()
																															#如果要求类是枚举类Enum：那么尝试将字符串认为是 枚举类型.fieldName ,而恢复它的枚举类Class,和属性Field; 方法就是分割为2半，类则用ClassUtils.forName()加载，再反射Field.get(null)获取属性的值作为新的转换值。
																															#作为一个退路：兜底，如果新的转换值和原来的值一样，那么用要求类直接反射获取Field(原来值作为参数),再Field获取转换值。	
																														-再次标记设置standardConversion = true	
																													#否则如果转换值是Number类型且要求类可以赋值给Number: 那么统一方法转换为目标类类型：@NumberUtils.convertNumberToTargetClass()		
																														>对目标类可能的各种包装类类型：都需要专门处理：由于转换值具体可能是BigInteger/BigDecimal类型， 再检查值域，未通过可能会抛出异常。
																														-再次标记standardConversion = true 
																												#否则：转换值为null.需要小的处理：目标类是Optional类型时，赋值为Optional.empty()	
																												-此时转换值可能已经被处理过。还需要一些处理。
																												#如果此时转换值还属于不能赋值给要求类：
																													#先看转换服务是否可用：就是看有没有转换器@GenericConversionService.canConvert()，前面有讲述getConverter();如果有那么直接用这个转换服务转换@GenericConversionService.convert()，并将转换结果直接返回。
																													#否则不可用：开始构造抛错信息，直接抛出错误new IllegalArgumentException(msg.toString())
																														
																											>返回转换值	。返回TypeConverterDelegate.convertIfNecessary()按需转换。
																						#如果解析后的目标类是null: 那么直接返回上一步返回的评估结果。								
																					#如果是NullBean类型：返回null 
																					#其他情况都统一返回评估结果：入参就是值，@evaluate(value)
																						#值是字符串：直接真正评估：@doEvaluate(v)
																							@统一转发给统一的评估bean定义接口：beanFactory.evaluateBeanDefinitionString()
																								@转发给专门的评估类：AbstractBeanFactory.beanExpressionResolver.evaluate(beanName, BeanExpressionContext)
																						#如果值是字符串数组,则遍历每个元素，每个元素都进行转换真正的转换并设置：@doEvaluate(v)		
																						#其他类型直接返回。
																			#如果参数值类型为AutowiredArgumentMarker：调用统一的自动绑定参数解析方法@ConstructorResolver.resolveAutowiredArgument()
																				#如果方法参数可以赋值给InjectionPoint类型：则从线程局部变量currentInjectionPoint里取出InjectionPoint对象，没有则抛错，有则返回。 
																				>开始统一的解析依赖：把方法参数传递进来。@DefaultListableBeanFactory.resolveDependency()
																					#初始化方法参数名发现器：parameterNameDiscoverer   @DependencyDescriptor.initParameterNameDiscovery()
																					#如果依赖类型是Optional：统一调用依赖创建@createOptionalDependency()
																						#构造一个NestedDependencyDescriptor对象---覆盖某些方法。
																						@统一调用解析依赖接口@doResolveDependency()
																							>先设置注入点线程局部变量：@ConstructorResolver.setCurrentInjectionPoint()	,内容就是设置到ConstructorResolver.currentInjectionPoint属性里。		
																							>解析shortcut捷径:@ShortcutDependencyDescriptor.resolveShortcut(BeanFactory beanFactory) ，本质上就是调用beanFactory.getBean()获取。
																							#如果shortcut不为null: 那么可以返回它。
																							-否则此时需要专门处理。
																							>获取自动绑定候选解析器autowireCandidateResolver来 获取注解值@QualifierAnnotationAutowireCandidateResolver.getSuggestedValue(DependencyDescriptor descriptor)
																								@统一调用从注解中获取值方法：@QualifierAnnotationAutowireCandidateResolver.findValue(Annotation[]) 
																									>先将注解放到AnnotatedElement对象，AnnotatedElementUtils.forAnnotations()很巧妙，直接放到类定义的返回值上。
																									>再获取注解属性：@AnnotatedElementUtils.getMergedAnnotationAttributes()	
																										@先统一调用根据类型或者名称搜索查找注解方法@searchWithGetSemantics() ,注入一个实例MergedAnnotationAttributesProcessor切面处理器, 和目标注解类型valueAnnotationType---后面会放到一个集合里。
																											@统一转发给统一参数接口@searchWithGetSemantics()
																												>获取声明的注解，利用了缓存declaredAnnotationsCache,也利用了之前的元素AnnotatedElement @AnnotationUtils.getDeclaredAnnotations()
																												>再次统一转发给专门的接口：@searchWithGetSemanticsInAnnotations()再里面遍历注解，来获取正确的匹配注解。
																													>遍历上一步获取的声明注解：对每个注解
																														#如果注解类型不在java注解包下：
																															#如果目标注解类型集合包含它：
																																>先用处理器处理：@processor.process()
																																	@统一调用注解属性解析方法：@AnnotationUtils.retrieveAnnotationAttributes()
																																		>获取注解的定义类字节码Class: .annotationType()：封装到一个new AnnotationAttributes()实例中
																																		>通过注解的定义类Class对象获取它所有的属性：@AnnotationUtils.getAttributeMethods() 使用了缓存机制attributeMethodsCache
																																			>只需要用这个Class对象.getDeclaredMethods() 就获取到了：需要过滤一下--确认是注解方法：返回类型不等于void.class 且getParameterCount()为0， 当然方法要setAccessible
																																		>对每个注解方法：反射，获取invoke(annotation)获取注解值，getDefaultValue()获取默认的注解值。
																																		#如果设置值和默认值相等：设置值重新赋值为：new DefaultValueHolder(dfv)
																																		>统一放到AnnotationAttributes实例中：key:注解方法名、调整值@adaptValue()
																																			#如果类值作为字符串：
																																				#如果设置值就是Class类型，直接返回设置值的name()
																																				#否则如果是Class[]类型，则遍历，每个元素也获取name(),从而返回字符串数组。
																																			#如果设置值是注解类型Annotation：
																																				#如果允许嵌套注解：统一调用解析方法@getAnnotationAttributes() 内容和searchWithGetSemantics()类似：
																																					>先解析注解属性：@retrieveAnnotationAttributes()
																																					>再注解属性获取之后的处理器处理：@postProcessAnnotationAttributes()
																																				#否则不允许嵌套：那么只进行同步：@synthesizeAnnotation() 结果直接返回。
																																					>设置值是SynthesizedAnnotation类型或者设置值仅仅是不同的java类型：@hasPlainJavaAnnotationsOnly那么直接返回这个设置值，不做处理。
																																					>查看是否可以同步：@isSynthesizable() 基本注解类型不能同步。
																																						>获取注解类Class对象：采用缓存机制：map:synthesizableCache
																																						>获取注解Class对象的所有属性方法：即注解属性。遍历：
																																							>对每个方法：查看它的别称@getAttributeAliasNames():其实就是看有没有AliasFor注解-及其内容，如果有并且验证通过而没有报错：@AliasDescriptor.validate()  $
																																							#如果有别称：那么就认为可以同步，直接退出循环，缓存一下，而返回。
																																							>否则再看这个方法的返回类型ReturnType():
																																								#如果可以赋值给Annotation[]：把返回类型的数组元素类型取出来，递归看是否可以同步@isSynthesizable();如果可以，那么可以同步，退出循环，缓存一下，返回。
																																								#否则如果可以赋值给Annotation：那么对这个返回类型也进行递归看是否可以同步@isSynthesizable();如果可以，认为可以同步，退出循环，缓存一下，返回。
																																					#如果不可以同步：那么直接返回，不做处理。		
																																					>否则可以同步：构造默认注解属性提取器new DefaultAnnotationAttributeExtractor()	注入一个新构造的同步注解InvocationHandler:new SynthesizedAnnotationInvocationHandler()
																																					>定义代理类的实现接口：SynthesizedAnnotation和本注解类
																																					>使用java动态代理生成这两个接口的代理类：Proxy.newProxyInstance()返回这个动态代理类。
																																			#如果设置值是注解数组类型Annotation[]：
																																				#同理如果允许嵌套：设置值转换为注解数组，遍历每一个，并获取每个注解的注解属性封装到一个AnnotationAttributes对象，最终得到它的数组而直接返回。									
																																					>这个封装过程为：调用统一方法@getAnnotationAttributes()	,同上方法。
																																				#否则不允许嵌套：调用统一的处理方法@synthesizeAnnotationArray()	结果直接返回。	
																																					#如果是普通java注解：直接返回注解数组。
																																					#否则构造一个注解数组：Array.newInstance(),元素类型就是 入参注解数组的元素类型	
																																					>开始遍历这个入参注解数组：对每一个注解，调用上述@synthesizeAnnotation()同步方法获取结果，设置到新建数组中。		
																																			>返回传入值。				
																																		>返回这个AnnotationAttributes实例即可。					
																																>如果上一步处理结果不为null:
																																	#如果需要聚合结果：则将处理结果放到聚合list里：processor.aggregatedResults					
																																	#否则直接就返回这个处理结果result了。作为@searchWithGetSemanticsInAnnotations()的返回。
																															>否则不包含，如果当前这个注解 和容器注解类型相同：
																																@决定获取批量的注解@getRawAnnotationsFromContainer()			
																																	>先获取容器的注解：@AnnotationUtils.getValue()							
																																		@统一转发给标准入参接口：获取注解的value属性的值AnnotationUtils.getValue(annotation, attrName);返回的值认为是一个注解数组A[],不为null则返回到getRawAnnotationsFromContainer()，否则返回一个空数组。
																																>然后遍历获取到的注解数组，对每个注解用处理器处理：@processor.process()	
																																	#如果处理结果不为null,那么放到聚合list列表里：list: processor.aggregatedResults				
																													>再次遍历上次获取到的声明注解：对每个注解，做一些递归性质的处理。
																														#如果注解类型不在java注解包/spring语言包下：直接递归标准的入参最多的最后一层的@searchWithGetSemantics()，得到搜索结果。
																															#如果这个搜索结果不为null: 
																																@进行处理器的后置处理@MergedAnnotationAttributesProcessor.postProcess()。
																																	>获取注解同步结果：@AnnotationUtils.synthesizeAnnotation()
																																	>遍历参数注解的所有方法：使用了缓存机制获取所有的方法。	对每个方法： 
																																		>获取本身的名字和覆盖的名字----覆盖的名字的作用：过滤器容器的作用：一旦某个属性覆盖了，那么其他属性如果还覆盖，那么不做处理直接退出。
																																		>如果覆盖属性不为null:
																																			>获取这个方法的别称属性集合：@AliasDescriptor.getAttributeAliasNames() $$
																																				>如果不为null:遍历这个别称属性集合：第一次获取的所有别称+方法的覆盖名称，作为一个参数，它们在AnnotationAttribute中的值应该是一样的，所以需要调用来覆盖：@overrideAttributes()
																																					>设置相同值之前，需要获取这个相同值：@getAdaptedValue()
																																						>获取注解的这个属性的值：@AnnotationUtils.getValue()
																																						>值需要调整一下：@AnnotationUtils.adaptValue() 然后将值直接返回。
																																					>然后才开始对属性多个键设置同一个转换值：AnnotationAttributes.put()
																																		>否则为null,进一步如果属性名不是value,且属性map:AnnotationAttributes不包含这个属性名：
																																			>直接使用覆盖方法：@overrideAttribute()---仅仅覆盖这一个属性的值。
																																#如果允许聚合且metaDepth==0(入参确实是0)：那么增加这个递归结果到processor.aggregatedResults																										
																																#否则：直接返回这个递归结果。返回到@searchWithGetSemanticsInAnnotations()																										
																													>到此都没有返回，则返回null.																														
																												>此时已经获取了注解的语义结果: 如果结果不为null那么就直接返回了。返回到searchWithGetSemantics()																															
																												#否则此时注解的语义结果为null:	最后一次机会处理。																														
																													#如果AnnotatedElement是Class类型：获取ele的父类，																														
																														#如果父类不是Object，不是null:	那么从ele的所有注解getAnnotations()里排除声明注解getDeclaredAnnotations()而获取的继承的注解集合：																												
																														>对这个继承注解集合：也进行语义上的搜索处理@searchWithGetSemanticsInAnnotations()得到一个处理结果。																													
																															#如果这个结果不为null:直接返回这个结果。																												
																												>到此还没有获取到语义结果而返回，那么直接返回null。																															
																										>此时已经获取到了注解属性map:AnnotationAttributes对象：开始处理器的后置处理：@AnnotationUtils.postProcessAnnotationAttributes()																																		
																											#没有属性，直接返回null 
																											#有属性，获取注解的Class对象：	
																											#如果属性还没有验证：需要做一些验证工作。																																	
																												>获取注解类的"方法-别名list“的这样的map:@getAttributeAliasMap()																																
																												>开始遍历这个map: 同时建立一个set,来过滤掉已经处理过的同一类的属性名---中间可能加进来别称属性。																																
																													>从入参属性里获取属性值，如果不为null且不是DefaultValueHolder类型，那么认为是当前值：valuePresent=true																															
																													>遍历别称list：同理set记录处理过的别称，后面不再处理。																															
																														>从入参属性里获取别称的值，同理确定是否有别称值：如果不为null且不是DefaultValueHolder类型																												
																														#如果属性值或者别称值至少有一个有：	需要验证																													
																															#两个都有：	且不相等@!ObjectUtils.nullSafeEquals(),那么抛出异常new AnnotationConfigurationException()																												
																															#否则如果仅仅别称值有：则把别称值适配一下@adaptValue()再设置到入参属性里.																													
																															#否则如果仅仅属性值有: 则把属性值适配一下@adaptValue()再设置到入参属性里.																													
																												>此时遍历完成:设置验证标记为true: attributes.validated = true																															
																											>验证完成，需要对默认值做处理：																																	
																												>遍历入参属性的所有kv: 对于上一步已经验证过的---加入set的，不再处理，对于其他的：																																
																													#如果属性值是DefaultValueHolder类型，那么获取这个类型的defaultValue属性值，适配一下@adaptValue()设置到入参属性里。																															
																											>返回。																																	
																									>此时已经进行了获取注解属性的过程，如果获取的注解属性AnnotationAttributes不为null:	则提取value值：@extractValue()														
																										>直接取"value"键的值：结果为null要抛出异常new IllegalStateException(),否则返回这个结果。	
																								>此时已经获取值完成：如果结果不为null:获取描述符的方法参数MethodParameter				
																									>如果不为null:需要再次寻找它的方法注解@getMethodAnnotations()的值：@findValue()	来替换上一步find的value
																								>此时返回值value作为最终的建议值。		
																							#如果获取的注解值不为null: 那么稍微处理就可以返回了。			
																								#获取的注解值是string类型：则必须要经过一系列的内嵌值解析器的过滤处理：@AbstractBeanFactory.resolveEmbeddedValue()		
																									#对所有的值解析器：只要有一个解析结果为null就没通过，直接返回。过滤过程调用：@PlaceholderResolvingStringValueResolver.resolveStringValue()	
																										@统一调用格式替换：@PropertyPlaceholderHelper.replacePlaceholders() 替换占位符为实际值。占位符有前缀和后缀、还可能嵌套。
																											@统一转发给带占位符的解析出值的方法：@parseStringValue() 处理算法：
																												>确定占位符前缀开始位置:indexOf()，再确定占位符结束位置：@findPlaceholderEndIndex()
																													#对结束位置的寻找：从前缀的下一个位置开始：匹配占位符后缀字符串@StringUtils.substringMatch()
																														#如果匹配到了：那么可以直接返回当前这个位置。
																														#否则如果匹配到了前缀：那么说明有了嵌套，则必须经过两个后缀才可以退出，所以有一个嵌套个数标记withinNestedPlaceholder。并从这个前缀的后一个字符开始，下一轮匹配。
																														#否则其他情况：仅仅直接index++,向后移动一个字符即可。
																													>那么最后就找到了输入的前缀的后缀的开始index位置。否则返回-1
																												#如果得到的后缀位置不是-1: 那么前缀和后缀之间的字符串就是 占位符。
																													>截取这个中间的占位符：考虑到嵌套占位符的存在，需要递归解析：所以调用解析@parseStringValue(),由于只允许最多2次嵌套，所以得到的解析结果认为就是最终的 无嵌套的占位符(变量名)。
																													>开始调用占位符解析器解析：@PropertyPlaceholderConfigurerResolver.resolvePlaceholder(String placeholderName)
																														@统一转发给解析PropertyPlaceholderConfigurer.this.resolvePlaceholder(): 入参之一为“系统解析模式”/系统属性模式快速失败
																															>此模式下调用：@resolveSystemProperty()
																																>值从系统属性里取：System.getProperty(key)，为null时如果可以还从 System.getenv(key)里获取结果里返回。
																													#如果此时获取的属性值是null,且值分割符不为null: 那么需要将值按分割符分割处理，分割符之前的一半是真正的属性名，分隔符之后的是默认值。
																														>调用解析器解析真实值：@resolvePlaceholder() 和上述一样，获取了一个系统属性值，如果这个属性值为null,那么就设置属性值为默认值。
																													>此时如果属性值不是null了：再次递归式的解析这个属性值@parseStringValue() 得到一个新的属性值。这个属性值，才用来替换 占位符开始和结束之间的内容。
																														>那么下一步的替换和解析就是从替换之后的那个位置的下一个字符开始。	
																													#否则如果可以忽视未解析的占位符：那么直接从占位符的下一个字符开始，继续解析。
																													#否则其他情况：抛出异常。
																												#否则可以直接退出了。			
																										#占位符替换成功之后：需要trim则要trim()一下，如果是空串则返回null,否则还是原样返回。						
																									#如果解析结果为null:就认为没通过，而直接返回null到resolveEmbeddedValue()								
																								>此时考虑bean定义合并：先看当前工厂/父类工厂是否包含bean：	
																									>查询是否包含：@containsBean()											
																										>转换为标准名										
																										>如果单例池或者bean定义map:beanDefinitionMap中包含：那么直接返回：包含条件：不是$开头，或者是factoryBean:(!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(name)) $$
																											@是否是工厂bean: isFactoryBean() 结果直接返回。
																												>转换为标准名 
																												>从单例池中获取：(不从提前单例池中获取)
																												#如果存在：则如果是FactoryBean实例则是工厂bean，否则就不是，直接返回。
																												>此时不存在：可能没创建：
																													#如果bean定义map:beanDefinitionMap不包含, 且父类工厂不是ConfigurableBeanFactory实例：那么调用父类工厂递归判断：getParentBeanFactory().isFactoryBean() 结果直接返回。
																												>最后的判断：先获取融合本地bean定义：@getMergedLocalBeanDefinition()前面已将；结果作为入参继续判断：@isFactoryBean(name, bd)	
																													>猜测bean的类型：@predictBeanType()
																														>bd的目标类有则返回：否则直接解析bean类：@resolveBeanClass()---所谓的带权限解析。结果Class对象直接返回。
																													#如果结果Class可以赋值给FactoryBean：那么就是工厂类，否则不是。
																										>获取父bean工厂：检查父工厂中是否包含：@containsBean()	作为直接结果返回。		
																									>如果包含：获取合并定义@getMergedBeanDefinition()；不包含则结果为null										
																									>开始评估bean定义：@evaluateBeanDefinitionString()	评估的值，覆盖之前的值。											
																									>开始使用转换器转换：也是按需转换：先获取类转换器@getTypeConverter()												
																										>先获取用户定制的类转换器：@getCustomTypeConverter() 												
																											>直接返回AbstractBeanFactory.typeConverter													
																										#如果不为null:则直接返回这个转换器。
																										#否则构造一个转换器：注入转换服务，并且注册：new SimpleTypeConverter()	 注册为：@registerCustomEditors()
																										>然后才返回这个构造的类转换器。																	
																									>开始按需转换：如果描述符中Field属性不为null:则先用Field属性值进行值的转换：@converter.convertIfNecessary()	转换后的值直接返回@doResolveDependency()																
																							>此时则建议值为null: 则可能是多个bean,那么解析获取之后 也可以返回了：解析多bean的方法为：@resolveMultipleBeans()																				
																								#根据依赖描述的不同类型而分别处理：如果是StreamDependencyDescriptor类型：																				
																									>获取和自动绑定匹配的符合要求类型的候选bean集合：@findAutowireCandidates()																				
																										@直接调用统一的方法获取候选的names数组：BeanFactoryUtils.beanNamesForTypeIncludingAncestors()																				
																											@先获取该类的所有beanNames:@DefaultListableBeanFactory.getBeanNamesForType()																		
																												#如果配置冻结、要求类为null、不允许提前初始化：	调用统一的实质类解析方法@doGetBeanNamesForType()																	
																													>遍历所有的bean定义：DefaultListableBeanFactory.beanDefinitionNames	, 对每个beanName																		
																														#如果不是别称：																			
																															>获取融合定义：@getMergedLocalBeanDefinition(bn)	
																															#如果不是抽象类型、且(允许提前初始化|有beanClass|非延迟初始化|允许提前类加载)且	不要求提交对类初始化@requiresEagerInitForType()----是工厂bean且单例池中没有：那么就“要求提前对类初始化”		
																																>获取是否是工厂bean: @isFactoryBean()			
																																#判断是否匹配：非工厂bean|允许提前初始化|...且类匹配@isTypeMatch(beanName, type)--其实是看遍历的当前beanName是否和目标类Type相匹配：
																																	>名称转换为权威名：@transformedBeanName()
																																	>单例池中非提前池中获取实例：@getSingleton()
																																	#如果获取到的实例不为null不是NullBean的实例：
																																		#如果是FactoryBean类型: 
																																			#如果name不是&开头：那么实例直接强转为FactoryBean类型，进一步用带权限框架的方式获取这个bean的类型：@getTypeForFactoryBean()(@FactoryBean.getObjectType())
																																				#在获得这个bean类型之后：如果不是null, 那么就开始用@ResolvableType.isAssignableFrom()进行比较
																																					>即看获得的这个Type是否可以赋值给开始初始化时给的那个类：如果可以返回可以匹配，否则返回不能匹配。
																																			#否则不是&开头：那么判断这个单例是否是入参ResolvableType实例的实例：@ResolvableType.isInstance()即可以赋值给这个ResolvableType类。可以则返回true,否则false:返回到isTypeMatch()
																																		#否则如果不是&开头：
																																			#直接判断实例是否可以赋值给ResolvableType：	@ResolvableType.isInstance()， 是那么就直接返回了。
																																			#否则不是ResolvableType的实例：进一步判断是否有一般参数@ResolvableType.hasGenerics() 和map:beanDefinitionMap包含@containsBeanDefinition()
																																				@先获取是否一般参数：@getGenerics()的长度>0就是true
																																					>基于ResolvableType.generics属性：属性不为null直接返回。
																																					#如果该属性为null: 需要构造。
																																						#如果type属性是Class: 
																																							>获取这个type属性的getTypeParameters()参数数组
																																							>构造一个ResolvableType[]数组
																																							>开始遍历获取到的参数数组：对每个参数类型：
																																								>转换后设置到ResolvableType[]相应的位置：转换方法为@ResolvableType.forType()
																																									@统一转发给@ResolvableType.forType() ：对给定类型返回ResolvableType类型。
																																										//其他情况下会SerializableTypeWrapper.forTypeProvider()调用访问，但此时不会。
																																										>如果给定类型是Class:则直接new ResolvableType()返回。
																																										-否则考虑使用ConcurrentReferenceHashMap<ResolvableType, ResolvableType>来进行缓存：
																																										>先清空：ConcurrentReferenceHashMap.purgeUnreferencedEntries()
																																										>再构造：new ResolvableType()
																																										>再缓存：cache.put()
																																						#否则如果type是ParameterizedType类型：
																																							>获取这个type的真实type数组：@getActualTypeArguments()
																																							>遍历这个数组：对每个type:进行统一的解析获取解析type:ResolvableType 转换方法@ResolvableType.forType()
																																						#否则其他任何类型：都统一处理：获取解析类@ResolvableType.resolveType()之后 获取一般解析类型getGenerics()结果需要设置到舒兴国generics里。
																																							@对于resolveType()处理： 
																																								#如果type属性是ParameterizedType类型：
																																									>获取它的type簇后转发到forType() 结果也直接返回@resolveType()
																																								#否则如果type是WildcardType类型：
																																									>则获取泛型变量type的上边界：@WildcardType.getUpperBounds() 然后获取第一个类型：@resolveBounds()
																																									#如果这个类型为null: 再次尝试：此时获取泛型变量的下边界：@WildcardType.getLowerBounds() 同样进行过滤。
																																									>最后统一调用@forType():入参就是此时的转换类型.返回 
																																								#否则如果type是TypeVariable类型：
																																									#如果变量解析器不是null:则调用变量解析器来解析这个类型变量为解析类型：@variableResolver.resolveVariable()
																																										>遍历TypeVariablesVariableResolver.variables属性：对每个TypeVariable对象，unwap之后和入参的TypeVariable同样unwrap之后进行比较，如果相等，那么就返回对应索引位置的ResolvableType.TypeVariablesVariableResolver.generics[i]解析类。
																																											@SerializableTypeWrapper.unwrap() 解开方法：是一个迭代的过程。
																																									>如果此时得到的解析类型不是null:则直接返回。
																																									#否则到此时，需要进行统一的转发给@forType()处理	：入参包含：获取变量的边界(上下)
																																								#否则其他类型直接返回None: new ResolvableType(EmptyType.INSTANCE, null, null, 0)		
																																							@对于@getGenerics()处理： 
																																								>要么递归：要么是返回一个空对象：new ResolvableType[0]
																																						>最后就是设置给generics属性	
																																					>此时就可以直接返回generics属性了。
																																				@再看定义map是否包含：直接。
																																				>如果上述两个都是true:
																																					>获取融合bean定义mbd：getMergedLocalBeanDefinition()
																																					#如果mbd.targetType不是null且不是 “用户类”：这个用户类的获取需要专门方法@ClassUtils.getUserClass(),因为这个实例可能是cglib的代理类---而不是用户定义的类：
																																						-@转发给ClassUtils.getUserClass(): 判定是否是cglib代理类：看className是否包含"$$"分隔符，包含则是代理类，需要返回它的父类；
																																						#如果bean不是解析类的实例：返回false 
																																						#如果目标类型可以赋值给解析类：返回true 
																																					>此时先后从mbd.targetType/factoryMethodReturnType获取解析类：来判定是否可以赋值给入参解析类：如果可以返回true,否则false
																																		>此时就直接返回false了。
																																	#否则如果包含单例，但是不包含定义：那么不正常，返回false 
																																	-此时已经明确没有实例：开始一般的处理，还进行各种尝试。
																																	#如果父工厂bean不是null调用他来匹配：parentBeanFactory.isTypeMatch() 入参为复原的带&的beanName。。结果直接返回。 
																																	>再次获取融合bean: 尝试从装饰bean定义来获取到匹配是否的信息
																																	#获取装饰定义holder: 如果不是null且name不是&开头： 
																																		>获取融合bean: 
																																		>猜测装饰hodler的class类型：@predictBeanType()
																																			#如果这个猜测类型不是null且 类型不能赋值给FactoryBean：那么直接只看入参解析类型是否可以接受这个猜测类型ResolvableType.isAssignableFrom() 并且结果直接返回。
																																	#开始获取权威名的预测类型：@predictBeanType() 为null则返回false 
																																	#否则不是null,那么判断是否可以赋值给FactoryBean类型：
																																		#进一步不是&开头，获取的实例为null:
																																			>获取工厂bean创建的bean的类型：@getTypeForFactoryBean()
																																			#如果这个类型为null:则不匹配返回。
																																	#否则如果权威名&开头： 
																																		>猜测beanName的类型：类型不存在或者不可以赋值给FactoryBean：那么也返回false
																																	>最后尝试顺序：targetType/factoryMethodReturnType属性当做解析类，
																																		#如果不是null:那么看是否可以赋值给入参解析类，是否值直接返回。
																																	>最后就是一般的赋值可否的检查：入参解析类.isAssignableFrom(预测类型)，结果直接返回。
																																
																																#如果不匹配且是工厂bean类型：需要重新判断是否匹配。				
																																	>先beanName恢复：加前缀&		
																																	>赋值是否匹配：也是以类匹配为主：@isTypeMatch(beanName, type)		
																																#此时如果匹配了：则结果里加上这个beanName----作为候选的names之一。			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			
																																			




																			

																					
											>返回实质创建结果。
															
															
															
															
															
															
															
												
												
												
												
												
												
												
												
												
								>后置处理：同前述 
								>加入单例池：singletonObjects加入，单例工厂singletonFactories中移除name, 提前单例池earlySingletonObjects中移除，带注册顺序的注册单例池：registeredSingletons添加。
							>返回单例。
					#否则如果mbd是原型模式时：
					#否则其他所有情况：
				>如果创建的bean的类型就是参数中requireType，需要做一些后续处理：		
													
													
													
 >AbstractBeanFactory.getBean(String name, Class<T> requiredType)开始的：
 
 
 
 
 
 
 
 
 
 
 
 
世界观： 
 >容器：具有活跃、关闭状态。
 >bean注册器中的单例: 
  >singletonObjects: map: beanName --> bean instance引用
  >singletonsCurrentlyInCreation: set: 正在创建中的单例
  >earlySingletonObjects: map:  beanName --> bean instance引用， 提前单例引用map
  >singletonFactories： 单例工厂：有getObject()方法，
  
  
>待研究课题：
	>springmvc切面代理：方法拦截：@RestControllerAdvice--异常捕获，@Log日志记录 , @DataScope方法权限验证(如直接查库，或者加where部分限制--角色限制也加到sql里)@RequiresPermissions方法权限验证(如文件访问权限)
									@DataSource数据源切换--加到服务Service级别。
	>spring-jdbc手动数据源切换关键：AbstractRoutingDataSource继承并实现的类实例，会在每次都调用determineCurrentLookupKey()方法返回一个注册的数据源名---来从配置的数据源即左边那类型的实例(路由型数据源)的一个属性map:targetDataSources里找到数据源对象，然后才开始具体的发送sql等等，那么就可以在该方法里读取一个数据源名线程局部变量--那么外面就可以动态存放到这个局部变量里---如做一个注解切面做在一个服务bean上，每次执行方法的时候在执行切面的时候从注解中获取数据源而设置到该线程局部变量里，然后之后才执行正式的代码。

>重要结论：
	>可以给任意的每个bean都增加切面：那么可以对@Entity也进行切面，切面配置为：加了某个注解的类的所有方法，或者加了某个注解的所有方法 都被切。然后获取类和获取方法。
	>可以运行时修改类上注解的某个属性的值：同理，方法上也可以。
	>可以查看定时任务自己的线程池：org.quartz.simpl.SimpleThreadPool
		>定时任务框架Quatz核心概念-世界观：主方法-cron表达式调度一个任务：Scheduler.scheduleJob(JobDetail, CronTrigger)，(其中JobDetail由Job类创建) 此外，可以删除和暂停job: deleteJob(JobKey)和pauseJob(JobKey) ，另外，可以立即激活triggerJob(JobKey jobKey, JobDataMap data)
			>根据上述世界观-四个调度方法(排-删-停-起)：完全可以构造出一个任务调度系统
	>公共的方法：其实合并了逻辑：合并了多个业务在这里的逻辑，导致看不出分别的逻辑，是逻辑的合成和兼容。
	>不要仅仅罗列动作：而不看功能和目的。