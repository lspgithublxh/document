//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备；化被动为主动去做)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
//大的想法，具体行动。
//出现了if-else就是因为有不同的考虑。
//阅读文档达到直接可以看出思路编写程序的清晰逻辑的地步。
//一个大函数功能直接看懂而描述。
//从网上找答案变为从源码中找答案。

>加载bean: 
 >AbstractApplicationContext.getBean(String name)开始的：
	@考虑到(什么情况)(预防)：beanFactory的活跃状态、关闭状态影响是否获取bean, 如不活跃则不获取。决定(做一件什么事)：判断beanFactory活跃，否则抛出错误。世界观：容器有active,closed状态
		#当容器不活跃(标记：active=false)甚至关闭(closed=true)时抛出异常。
	@由于：本质上bean加载是beanFactory的功能，决定：获取上下文里的beanFactory让它去获取这个bean: getBean(name)
		#当采用AbstractBeanFactory实现时：
			@由于：为了各种各样的入参情形适配，决定：转发给一个统一的参数调用接口：doGetBean(name, null, null, false)
				>由于：name取值各种格式，需要转化为权威的：
					@由于：可能存在前缀&，需要全部去除；同时额外的事情：缓存下来，无需每次都这样去除。//要做多件事情 ，而不是仅仅就解析而已。如缓存。
					@由于：这个name可能是alias即别称，需要转换为权威的。决定：通过aliasMap来找到别称对应的权威名称。SimpleAliasRegistry中存在这个aliasMap
				>2由于： 决定：获取name的单例：getSingleton(beanName)
					@由于：经常存在获取单例的不同入参的需求，决定：统一调用一个统一的单例获取接口：DefaultSingletonBeanRegistry.getSingleton(...)，其中一个参数：是否允许提前引用allowEarlyReference。。。整体试图从各个工具那里获取bean的顺序--三次尝试：单例对象map-->提前单例对象map(正在创建过程中--应该是存在循环引用)--->单例工厂里先获取对象工厂(正在创建过程中)。。。三次尝试都不行，那么可能是个工厂bean--&开头。
						#当单例map:singletonObjects包含时：取它。
						#没有则当“正在创建的bean集合”set:singletonsCurrentlyInCreation包含name时：进入同步
							#当提前单例map:earlySingletonObjects包含时：取它 
							#没有则当“允许提前引用”时：从单例工厂map:singletonFactories里取它的对象工厂
							#当存在时：从工厂里获取.getObject(), 并保存在提前单例map里--以便并发获取时下一个线程直接从这里获取，并从单例工厂里移出name, 从而不会再调用.getObject()---保证了工厂创建只执行一次。
				#3由于：第二步返回的instance可能满足：instance != null && args == null, 决定：专门处理
					>允许打印日志：如果在创建中：singletonsCurrentlyInCreation中，打印日志。
					#当name是&开头说明是FactoryBean：如果instance不是FactoryBean类型则要抛出错误。NullBean类型直接返回。否则继续。
					#此时name可能：&开头的FactoryBean类型实例，不是&开头的任意类型。对于第一种，决定：直接返回。对于第二种：如果instance不是FactoryBean类型也直接返回。
					#此时name可能：不是&开头的FactoryBean类型。后面的目的则为：要从factory里获取object，并且条件下执行处理器方法。
						#由于： 效率考虑，工厂bean也进行缓存。决定：先从工厂bean缓存map:FactoryBeanRegistrySupport.factoryBeanObjectCache中取，有则直接返回它。
						#此时如果缓存没有：决定：尝试通过instance这个FactoryBean获取。考虑到：bean工厂获取时如果这个bean是非合成类型，则有非合成bean需要postProcess事情，此时情况：instance强转Factory
							@由于：判断bean是否合成类型是从它的RootBeanDefinition信息中判断，而RootBeanDefinition存在的条件是：DefaultListableBeanFactory.beanDefinitionMap包含name; 决定：看这个包含条件是否满足
							@当条件满足：即包含这个name的定义--beanDefinitionMap中含有。获取bean的RootBeanDefinition信息mbd
								#当已融合的RootBeanDefinition map:mergedBeanDefinitions中包含时：取它，直接返回。
								#没有则:先进行融合。融合的条件：BeanDefinition先找到。
									@获取BeanDefinition：从map:DefaultListableBeanFactory.beanDefinitionMap里，没有则报错。
									@然后获取合并后的RootBeanDefinition(事情/任务)：考虑：到这种获取融合bean常见，决定：转发给一个统一入参的接口：AbstractBeanFactory.getMergedBeanDefinition()。
										#考虑到性能：决定：使用同步块，先从已融合的beanDefinition map:AbstractBeanFactory.mergedBeanDefinitions里取，有则直接返回。
										#如果此时该融合map里没有：则需要新建bean definition 和root bean definition并融合。具体步骤分为：
											#当bean没有parent时：可以简单的复制属性处理。
												#当它是RootBeanDefinition类型：则直接复制各个属性到一个新的子类型ClassDerivedBeanDefinition/ConfigurationClassBeanDefinition实例中。
												#否则：直接属性赋值传递到新建一个RootBeanDefinition实例里。
											#当有parent时：考虑到子类属性更多，决定：需要先转换，再合并到一个RootBeanDefinition实例里。
												#由于：bean的parent的权威名可能和bean的权威名一样，需要区分处理，决定区分处理：先获取parent的权威名
													#当二者权威名不相同：考虑到获取bean的应该有多种渠道，而设计了至少两种来获取parent的bean definition。
														#当beanDefinitionMap里不包含且parentBeanFactory是ConfigurableBeanFactory类型：认为bean的各级parent中最终肯定有一级的parent的beanFactory已经被包含了----如果到根也没有包括且还是ConfigurableBeanFactory类型就会报错了, 所以只需要递归地找parent的权威name进行寻找bean definition。
														#否则的情况就是：beanDefinitionMap包含或者parentBeanFactory不再是ConfigurableBeanFactory类型：那么直接从本地获取---是一个统一的接口。? getMergedLocalBeanDefinition(String beanName)
															@由于：可能其他线程会先调用而产生而放到mergedBeanDefinitions，所以依然先从mergedBeanDefinitions里查看是否有：有则直接返回。
															@否则没有：则转发给一个统一的获取融合bean definition的方法，其入参是先获取这个parent name的BeanDefinition。AbstractBeanFactory.getMergedBeanDefinition(String beanName, BeanDefinition bd);
																@由于：获取融合bean definition非常普遍，所以再次递归地传递给了统一的获取mergeBean的接口：AbstractBeanFactory.getMergedBeanDefinition(String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)
													#否则对于权威名相同的情况：同名，则考虑从parentBeanFactory里获取。
														#当它的parentBeanFactory是ConfigurableBeanFactory类型，则调用它的通用的接口：getMergedBeanDefinition(String beanName)来获取			
														#否则：抛出异常。并被直接捕获，再向上抛出异常。	
													>现在的情况则是已经获取到了parent的BeanDefinition：需要做的事情就是属性传递到一个新的RootBeanDefinition实例mbd，这个实例overrideFrom 它的child的BeanDefinition 实例引用。		
													>考虑到属性传递接口通用：如果mpd有scope值，那么这里需要强制传递mbd的scope范围是：RootBeanDefinition.SCOPE_SINGLETON		
													>最后的事情：将mpd放到融合bean definition map:AbstractBeanFactory.mergedBeanDefinitions.put(name, mpd)		
							>由于：信息已经足够：决定：判断bd是否为合成类型--通过mbd中的字段判断。
							@由于：工厂bean有了，合成类型也有了，FactoryBean类型的name也有了，决定从工厂bean中获取实例。FactoryBeanRegistrySupport.getObjectFromFactoryBean()
								#当工厂bean管理的bean是单例模式 且 单例池singletonObjects里包含了name: 认为是单例模式，
									#由于：多线程下可能多次调用创建：而进入同步块，再次尝试从FactoryBeanRegistrySupport.factoryBeanObjectCache里获取，取到则直接返回。
									#没有则进行实质的通过factorybean来获取：对于这件事情，考虑到：从factorybean里获取可能需要权限，因此可能需要放到权限框架里，还有一些收尾工作。doGetObjectFromFactoryBean()
										#当设置了权限框架：则委托给权限框架来执行：AccessController.doPrivileged(()->{}...)。
										#否则没有设置：直接factoryBean.getObject()
										#此时的情况是已经通过调用方法来获取Object: 考虑到它可能为null而需要的后续处理，决定：继续分两步：
											#当不为null：直接返回。 
											#如果为空: 进一步判断如果工厂bean的beanName在创建过程中:singletonsCurrentlyInCreation,认为是有问题的，抛出异常。如果不为null,那么返回NullBean()实例。 
									#此时的情况：考虑到可能在getObject()执行过程中就已经将object放置到了factoryBeanObjectCache里：所以再次尝试从factoryBeanObjectCache里获取：取到则直接返回。没有需要进一步判断。 
										#此时factoryBeanObjectCache里没有：
											#如果是合成的类型，那么直接先不做什么。
											#否则非合成的需要后续处理:
												#如果name在“当前正在创建”的单例池中：即name包含在set:singletonsCurrentlyInCreation，则不能后续处理，所以直接返回object
												#否则已经创建完成：开始bean的processer处理器的三段通知/观测回调。考虑到：工厂创建的bean也需要一般化的初始化后的处理器处理(BeanPostProcessors)，前后也有一些通知操作。决定： 
													@前置处理：如果name的bean包含--即singletonsCurrentlyInCreation包含(添加失败)，且需要创建中检查--即set:inCreationCheckExclusions不包含 , 则抛出异常，不被捕获。否则什么也不做，直接返回。
													@处理器处理：AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean(Object object, String beanName)
														@由于：bean创建后初始化之后都需要处理器处理，决定：复用统一的处理器处理接口，转发给它。AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
															>获取全部的beanPostProcessors，遍历每一个：利用上个beanPostProcessor编织的结果来获取本次进一步编织后的结果，执行每一个的postProcessAfterInitialization(result, beanName)方法
																#如果这个结果为null, 则直接返回上次编织后的结果。
																#否则不为空：继续下一轮编织。直到编织完全，返回。这个object覆盖老的object
													@后置处理：如果name的bean不包含--即singletonsCurrentlyInCreation不包含(移除失败),且需要创建中检查--即set:inCreationCheckExclusions不包含，则抛出异常。不被捕获。 
											>如果单例池singletonObjects里包含name: 将工厂调用getObject()返回的object 放到 工厂名-生产的对象 这个map:factoryBeanObjectCache里：(name, object)
										>最后返回object
								#否则此时情况：工厂bean不是单例 或者 单例池不包含；那么此时不需要同步块，也不需要前置后置处理，决定： 直接进行实质的通过factorybean来获取object, 然后执行处理器处理即可。
									>实质的factorybean获取object:doGetObjectFromFactoryBean
									#当为非合成的则需要处理器处理：调用处理器：postProcessObjectFromFactoryBean
									>返回object
							>返回object 
				#否则args为null或者instance为null: 
					@当“正在创建中的bean集合”的线程局部变量prototypesCurrentlyInCreation里包含时：直接抛出异常。
					#此时则name没有在创建：此时考虑可能可以通过parentBeanFactory来获取bean,决定：获取parentBeanFactory
					#如果此时parentBeanFactory不为null且还没有bean definition:即beanDefinitionMap里没有, 则决定通过parentBeanFactory来获取bean,具体过程如下：
						@由于：可能出现递归的调用“通过factory来获取bean”方法，所以决定：获取name的原始name---就是权威名/&权威名(如果是工厂bean)
							#当parentBeanFactory是AbstractBeanFactory类型时：则递归调用:AbstractBeanFactory.doGetBean()
							#否则不是这种类型，进一步如果args != null:则此时instance为null, 决定：使用args入参从bean工厂里获取实例：parentBeanFactory.getBean(原始name, args)	
							#否则args==null, 进一步requiredType	如果!= null: 调用rt入参来获取parentBeanFactory.getBean(nameToLookup, requiredType)							
							#否则就只能直接根据name获取：parentBeanFactory.getBean(nameToLookup)								
					>否则此时：parentBeanFactory==null 或者已经有name的BeanDefinition了；考虑可能出现重复创建，所以先标记已经在创建：同步方式加到alreadyCreated:set中---且删除mergedBeanDefinitions里的同name key。显然只会加一次，移除一次。
					>考虑后面会通过各种参数和条件而用不同路径创建bean, 决定：先通用的方法获取本地融合bean:getMergedLocalBeanDefinition(name) mbd
						#如果mbd是抽象的：那么抛出错误。
					>进一步考虑：bean可能有依赖，依赖自然要先创建，所以决定：先从mbd获取所有的依赖名数组，并先将这些依赖逐个创建和注册。							
						#当依赖不为null: 考虑到循环依赖，且接口常用，所以转发委托给专门的依赖检测接口：					
							@循环依赖检测接口的检测：如果存在，则抛出异常。通过 权威名-依赖此name的set 这个map:DefaultSingletonBeanRegistry.dependentBeanMap来帮助判断：取出值集合dependentBeans。					
								#当dependentBeans为null:则自然不会有循环依赖。返回false
								#否则dependentBeans包含被依赖的name:则说明依赖此name的bean集合中有的还被此bean依赖，则说明存在循环依赖，返回true.
								#否则检测dependentBeans的每个元素的依赖主 集合：即递归地往上找，是否在依赖主的依赖主 集合里依赖了该bean。				
							@注册依赖bean: 一个是放到 name<-依赖name的set map:dependentBeanMap里--上面也会使用来帮助判断循环依赖，一个是放到name->被依赖的name的set map:dependenciesForBeanMap里---来在销毁依赖前，先把依赖的销毁。		
							@开始真正的要做的事-:创建依赖bean: 由于这是一个常见的方法，且有多个入参接口，且显然也应该和最开始获取bean的接口一样，所以直接调用：AbstractBeanFactory.getBean(name)。。和最开始调用的方法一样。			
					#当mbd是单例时：开始实质性的获取单例,而不是像之前的仅仅从缓存里。通过单例工厂方式。
						@考虑到：可能多线程创建，所以需要同步块，需要缓存---先判读是否单例池中存在,如果存在直接返回
							#否则不存在：考虑到当前可能在运行销毁单例：所以从正在销毁单例池singletonsCurrentlyInDestruction中查看，有则抛出错误。
							#此时的情况：则name没有创建在单例池也没有被销毁：开始常见的前面已经叙述的三段通知：
								>前置处理：同前述
								>单例工厂获取单例：singletonFactory.getObject()
									>单例工厂为lamda注入：做的事情为：创建--->编织/异常则销毁
										@创建：并且初始化、各种post-processors处理。createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
											@解析获取bean的Class对象：直接从mdb获取，或者：或许需要放到权限框架地：通过beanExpressionResolver.evaluate()入参为bean name/ 定义中的Scope来获取 评估结果：expressionParser.parseExpression()来获取表达式对象，使用该对象的Expression.getValue(EvaluationContext context)得到评估结果---可能和name一样或者是个Class类型对象。$$$$
												#解析结果是Class类型：则直接返回了。
												#否则：交给统一的ClassUtils.forName()方法来获取。AbstractBeanDefinition.resolveBeanClass()
											#此时如果解析的Class对象不为空且 当mbd有类名无类Class ：那么将mdb重新封装到一个新的RootBeanDefinition实例，并且Class对象设置到setBeanClass()属性里。	
											>当存在覆盖方法时需要专门处理：AbstractBeanDefinition.methodOverrides保存了覆盖方法。遍历每个方法，进行相同的统一处理：
												@当此时beanClass还没有设置：直接抛出错误
													#有设置则通过一个巧妙的方法找到同名方法个数：在本Class, 全部父类、全部接口，递归向上的寻找。
													#当这个个数小于0：那么没有覆盖--则抛出错误。
													#否则如果==0: 该覆盖方法是否重载属性设置为false: MethodOverride.setOverloaded(false)
											@后面将进行实例初始化，此时进行一次BeanPostProcessors责任链 处理：看实例初始化之前是否有代理产生。也属于通知的应用。AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd)	
												#当“实例初始化前处理器已经准备好”属性已经生效：beforeInstantiationResolved==true
													#进一步当mbd表面非合成类型且工厂包含处理器InstantiationAwareBeanPostProcessor：hasInstantiationAwareBeanPostProcessors==true
														#进一步检测目标类而获取tagetType Class对象: 目的时尽量使的不创建bean,
															#当目标类targetType不为null: 如果工厂方法名为null,则直接进行上述的解析获取bean的Class对象：如果工厂方法名不为空，则以更加苛刻的目标类检查过程，来从mbd的factoryBeanName建立它的类Class单例(也可以mbd中本身类同上解析创建), 甚至如果时cglib类还要返回它的父类，此间种种条件下都可能返回null:AbstractAutowireCapableBeanFactory.getTypeForFactoryMethod(String beanName, RootBeanDefinition mbd, Class<?>... typesToMatch)
															#当上述之后返回的targetType Class仍然不为null:则确认是完成了解析目标类：设置mbd.resolvedTargetType=targetType
														#当检测出的targetType不为null: 开始初始化前的处理器通知applyBeanPostProcessorsBeforeInstantiation
															@由于处理器通知是常见的，所以统一接口：此时关注实例化前通知方法，所以以一个具体方法来走处理器责任链。
																#遍历所有BeanPostProcessors: 对所有的InstantiationAwareBeanPostProcessor类型的处理器：
																	@调用对应方法来尝试获取代理：但是不会层层编织--只会编织一次--InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation(targetType, beanName)
																		#如果结果不为null:则返回这个结果。最后否则返回null。
														#当上述处理器通知返回的结果不为null时：需要进行后置处理器处理---前面有使用过。applyBeanPostProcessorsAfterInitialization	
															@同样，后置处理器处理也是统一的接口：应用通知，只需要直接获取所有的处理器，直接调用后置方法BeanPostProcessor.postProcessAfterInitialization(result, beanName)层层编织。
																#编织的结果为null: 则直接返回上次编织的结果。
																#否则不为Null: 继续当作下次编织的对象。
											#当上一步返回的编织结果不为null:则直接返回这个编织结果。
											@否则没有编织：开始真正的实质的创建AbstractAutowireCapableBeanFactory.doCreateBean()。工作为：创建、处理器、两步初始化、各种key缓存、注册
												>事情1：创建BeanWrapper包装类
													>mbd是单例模式，则先看缓存池里是否有bw: 工厂bean name到beanWrapper的映射缓存池factoryBeanInstanceCache中：没有则开始真正的创建@createBeanInstance()
														#@：先解析beanClass, 如果mbd里有则直接返回，AbstractBeanFactory.resolveBeanClass()
															#没有则或带安全框架进行真正的解析beanClass: AbstractBeanFactory.doResolveBeanClass()。过程分为几步：先必然要获取加载器
																>获取beanClassLoader: AbstractBeanFactory.beanClassLoader属性，
																#如果mbd的bean类名就是null: 那么直接调用mbd的AbstractBeanDefinition.resolveBeanClass(cl)返回null , 该方法非常简单：就是用ClassUtils.forName(className, classLoader)来加载类字节码Class<?>对象---显然需要类名和类加载器：：最基本的加载一个Class的条件数据。
																	>这个加载过程：用了缓存;考虑了名称的--基本数据类型、考虑了数组类型、考虑列表类型,做了不同的处理，统一返回带类型的数组类型Array.newInstance(ec,0).getClass()；
																		#如果cl也为null: 那么开始考虑使用的其他类加载器来加载，尝试的cl顺序为：当前线程上下文加载器Thread.currentThread().getContextClassLoader() > 本工具ClassUtils类的类加载器ClassUtils.class.getClassLoader() > 系统加载器/根加载器/bootstrap 类加载器/sun.misc.Launcher类的加载器
																		>最后使用：java的Class.forName(name, false, clToUse)来加载类字节码
																#否则不为null: 先评估beanDefinition， 
																	@转发给专门的评估类：AbstractBeanFactory.beanExpressionResolver.evaluate(beanName, BeanExpressionContext)
																		>对Expression和StandardEvaluationContext使用了缓存模式：说明个数不多。expr.getValue(context)的评估结果：评估工作简单：LiteralExpression直接返回.literalValue,而SpelExpression则多一些工作。
																	#如果上述评估结果和className一样：说明className是正常名，则可以直接mdb.resolveBeanClass(cl)加载类字节码对象。
																	#否则是一个表达式名或者Class对象：需要专门解析：如果是Class对象，直接返回。 
																		#否则是表达式名：其实也是一个类名cn, 此时优先使用前面获取到的cl来加载.loadClass(cn)--比较客户化, 没有才使用比较官方的ClassUtils.forName(className, dynamicLoader)来加载，然后返回。
														#此时：已经解析 获取到Class对象，还要判断：Bean Class是否public和可以access, 不行的话抛出异常。
														-准备创建实例：按照一个顺序从各种渠道工具来创建实例：instanceSupplier > factoryMethod > 手动
														#如果实例提供器不为null: 用这个工具创建，三步走，结果直接返回。
															>设置线程局部变量-当前正在创建的Bean: AbstractAutowireCapableBeanFactory.currentlyCreatedBean为给定的beanName
															>调用实例提供器的get()方法 
															>恢复设置线程局部变量-当前正在创建的Bean：为设置之前的beanName
															#创建的实例为null: 则设置为new NullBean()实例 
															>将实例直接封装为BeanWrapperImpl实例：bw
															@对这个bw初始化：AbstractBeanFactory.initBeanWrapper() 核心事务概述：注册属性编辑器
																>设置bw的转换服务：conversionService
																@注册客户的编辑器：bw实现了PropertyEditorRegistry接口，其中有注册方法，来注册一些PropertyEditorRegistrar实例，来辅助bean的属性值的注入。AbstractBeanFactory.registerCustomEditors()
																	@注册方法：ResourceEditorRegistrar.registerCustomEditors()
																		@实际注册方法：ResourceEditorRegistrar.doRegisterEditor()
																			#判断registry类型而分别存放：PropertyEditorRegistrySupport类型则存放到：map:PropertyEditorRegistrySupport.overriddenDefaultEditors
																			#否则注册到：可能是map:PropertyEditorRegistrySupport.customEditors属性里。DataBinder也是。
																			-上述map:都是key为资源类型如：File.class/URL.class/InputStream.class/Resource.class/Reader.class等，value则为对应的编辑器：FileEditor/ReaderEditor等
															>返回这个bw
														#@如果mbd的工厂BeanName不为null: 调用工厂方法进行创建：instantiateUsingFactoryMethod()结果直接返回。
															@统一转发给ConstructorResolver.instantiateUsingFactoryMethod()实现：先给ConstructorResolver实例注入工厂引用本身AbstractAutowireCapableBeanFactory
																>直接new BeanWrapperImpl()实例：bw
																@调用工厂的初始化方法初始化bw: AbstractBeanFactory.initBeanWrapper() 同上方法。
																#如果工厂beanName和beanName一样：则不正确，抛出异常。
																#否则不一样：开始获取bean: 获取方式即递归最开始的方法：this.beanFactory.getBean(factoryBeanName)。AbstractBeanFactory.getBean(String name)
																>开始创建前，要做存在性判断：入股mbd是单例模式，且单例池中已经存在该bean: singletonObjects.containsKey(beanName) 则抛出异常
																#到此则说明单例池没有，该bean还没有创建：对构造参数explicitArgs开始判断，如果不是null:赋值给argsToUse变量备用。
																	#如果mbd.resolvedConstructorOrFactoryMethod不为null 且constructorArgumentsResolved为true则 argsToUse赋值为mbd.resolvedConstructorArguments ，此值为null则将待解析参数argsToResolve赋值为预备参数：mbd.preparedConstructorArguments; 
																		#如果待解析参数argsToResolve不是null: 使用了预备参数：则需要进一步解析处理：解析获取参数：ConstructorResolver.resolvePreparedArguments()
																			-需要解析每个方法参数：类型和值，需要进行引用解析，因为可能是未解析类型，甚至需要重新beanFactory.getBean(name)、加入依赖表beanFactory.registerDependentBean(refName, beanName)
																			>准备工作：构造一个值解析器BeanDefinitionValueResolver实例valueResolver
																			#如果某个方法参数值类型为：BeanMetadataElement
																				@使用值解析器解析值：(BeanDefinitionValueResolver)valueResolver.resolveValueIfNecessary("constructor argument", argValue)
																					-根据值类型的不同 而调用不同的解析方法，也返回不同的类型：直接返回bean或者直接返回beanName
																					#如果值是运行时引用RuntimeBeanReference类型：
																						@调用值解析器的解析引用方法：BeanDefinitionValueResolver.resolveReference()
																							>先评估这个值的BeanName名：BeanName
																							#看这个值是否是父类的工厂方法创建：是则用父类工厂getBean(refName)
																							#否则用本beanFactory来getBean(): 之后保存依赖关系对：beanFactory.registerDependentBean(refName,beanName)即保存到了dependentBeanMap和dependenciesForBeanMap里。
																					#如果值是运行时名称引用RuntimeBeanNameReference类型：
																						>先评估这个refName,评估结果转换为name, 如果它不在beanFactory中，抛出错误
																						#在，则返回这个评估结果。
																					#如果值是bean定义持有类型BeanDefinitionHolder：bh
																						@转发调用解析内部bean：valueResolver.resolveInnerBean()
																							@调用统一的方法合并为mbd:RootBeanDefinition类型：beanFactory.getMergedBeanDefinition() 该方法之前已经讲解过。
																							-因为bh的beanName就是innerBeanName
																							#当mbd是单例模式：这个innerBeanName需要调整。
																								@调整方法调用：BeanDefinitionValueResolver.adaptInnerBeanName()功能在于对innerBeanName后面添加#1, 即认为这个name可能被使用过，则数字累加：alias中使用map:aliasMap, 单例池singletonObjects使用map:, 定义map:beanDefinitionMap使用，或者是工厂Bean?FactoryBean--解析一下看是否能解析成功， 或者依赖map里有：dependentBeanMap。
																							-此时则得到了真正的内部beanName:actualInnerBeanName
																							@开始注册到“一个bean包含的所有bean的map”中：DefaultSingletonBeanRegistry.registerContainedBean() containedBeanMap			
																								#如果注册成功：那么继续注册依赖：@注册到依赖map:dependentBeanMap/dependenciesForBeanMap。方法同之前。beanFactory.registerDependentBean()
																							>将mdb所有的依赖bean创建和注册：mbd.getDependsOn()对每个依赖的bean, 注册依赖关系beanFactory.registerDependentBean(), 第二，获取依赖bean: beanFactory.getBean(String name)					
																							@此时才开始真正创建bean: 调用bean工厂创建:this.beanFactory.createBean(actualInnerBeanName, mbd, null) 这就是递归了。
																							-此时创建完毕，但是bean的类型可能还是工厂bean类型：
																							#如果创建的结果bean是工厂bean类型：FactoryBean	那么需要通过工厂bean的方式创建它：beanFactory.getObjectFromFactoryBean()前面使用过此方法。
																							#如果结果bean是NullBean类型：返回null
																							#否则直接返回innerBean。#				
																					#如果值是bean定义类型BeanDefinition：
																						>先获取innerBeanName: (inner bean)#4fesx 其中#后面的就是值的hashcode的十六进制字符串。
																						@转发调用解析内部bean：valueResolver.resolveInnerBean()
																					#如果是ManagedArray: 则元素类型需要考虑
																						>加载元素类型：array.resolvedElementType使用：ClassUtils.forName(elementTypeName, this.beanFactory.getBeanClassLoader())
																						@专门解析每个元素类型：BeanDefinitionValueResolver.resolveManagedArray()
																							>遍历每个元素：递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																							#解析完成则返回。
																					#如果是ManagedList：
																						@专门解析resolveManagedList(): 
																							>遍历每个元素：递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																								#解析完成则返回。
																					#如果是ManagedSet：
																						@专门解析resolveManagedSet(): 
																							>遍历每个元素：递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																								#解析完成则返回。	
																					#如果是ManagedMap：
																						@专门解析resolveManagedMap(): 
																							>遍历每个key-value：两个都递归解析BeanDefinitionValueResolver.resolveValueIfNecessary() 
																								#解析完成则返回。	
																					#如果是ManagedProperties类型：
																						>转换为Properties类型：所有的键值都要评估。
																						#只要有一个评估结果为null都抛出异常。
																					#如果是TypedStringValue类型：
																						>先评估：得出评估结果
																						>再解析这个值的目标类：BeanDefinitionValueResolver.resolveTargetType() 目标类就是要求类
																							#属性有目标类：即targetType属性是Class实例类型，直接返回。
																							#否则需要借助beanClassLoader来解析：
																								@调用接口：TypedStringValue.resolveTargetType()来解析
																									#看属性targetType是是什么类型：string, class, 都可以获取为string, 然后反射加载对应的Class: ClassUtils.forName(typeName, classLoader)
																									#为null则返回null, 否则就是加载的结果。
																						#如果此时的解析后的目标类Class不为null: 需要转换为要求的类型。即上述解析的类型。将值转换为这个类型。
																							@统一调用：this.typeConverter.convertIfNecessary()
																								@统一封装调用：TypeConverterSupport.doConvert()
																									@再次委托调用：TypeConverterDelegate.convertIfNecessary()
																										@再次转到统一参数接口：TypeConverterDelegate.convertIfNecessary()
																											>先根据要求类型获取属性编辑器：propertyEditorRegistry.findCustomEditor()
																												@转发调用统一的从用户定制的编辑器里获取属性编辑器：PropertyEditorRegistrySupport.getCustomEditor()
																													>获取顺序：map:customEditors  > map:customEditorCache
																													#如果获取的结果仍然为null: 那么猜测可能要求类是 customEditors里的key的子类，这样的话，也可以；就用这个超类的属性编辑器；同时缓存起来customEditorCache，key=requiredType, value=editor
																											>再从属性注册器仓库获取转换服务：propertyEditorRegistry.getConversionService()
																											#如果没有编辑器但是有转换服务：那么考虑使用转换服务来转换：
																												@统一调用GenericConversionService.convert() 结果直接返回作为convertIfNecessary()返回值。
																													@根据源类型和目标类型 统一获取转换器：GenericConverter.getConverter()
																														>先缓存里获取：converterCache
																														#没有则调用发现服务来获取：
																															@统一发现转换器服务：converters.find(sourceType, targetType)来获取：
																																>两个类的由近及远的类继承体系：通过这个两两组合对ConvertiblePair 作为key参数，调用map:converters来获取出ConvertersForPair，
																																@根据每个组合Pair获取注册的converter:getRegisteredConverter()
																																	@统一调用ConvertersForPair.getConverter(): ConvertersForPair有list:converters属性，
																																		@遍历每个converter进行匹配：ConditionalGenericConverter.matches() 
																																			@如果匹配成功：立即返回该converter
																																	
																																	#如果此时没有匹配成功：则继续从globalConverters属性里获取GenericConverter来一个个的匹配：
																																		#如果匹配成功则返回。否则返回null
																																#如果此时converter不为null:那么返回。否则没有一个组合满足，直接返回null。
																															#如果此时没有发现converter:	那么 调用默认转换器获取方法获取@getDefaultConverter()
																																#只看源类是否可以赋值给目标类(isAssignableTo)：可以则返回new NoOpConverter("NO_OP")实例。 
																															#此时converter不是null：存到map:converterCache属性里 并返回它,否则存一个new NoOpConverter("NO_MATCH")实例--并返回null。	
																													#获取的转换器不为Null: 那么统一使用@ConversionUtils.invokeConverter()来转换为目标值。
																														>转换器就直接转换：converter.convert(source, sourceType, targetType)，得到一个转换结果。
																														#对结果handler一下处理：@GenericConversionService.handleResult() 
																															#如果结果为null, @assertNotPrimitiveTargetType():由于null不能赋值给基本类型，所以判断targetType是否是基本类型primitive type, 是则抛出异常：ConversionFailedException 。。其他情况下都直接返回result;
																													#没有发现转换器的处理：handleConverterNotFound() ，有的话则会抛出。
																														#此时对转换之前的值进行判断：source为null,那么还是null-基本类型是否抛出错误判断：@assertNotPrimitiveTargetType()
																														-当源类型可以赋值给目标类型且source是目标类型(基本类型也可以)的实例(instanceof , isInstance(obj))，那么直接返回source就可以。条件是：sourceType 是null。其他情况都抛出未发现异常：ConverterNotFoundException
																											#如果转换后的值不是requireType要求类型：			
																												#如果要求类型是集合类型且转换后的值是字符串类型：从赋值角度检查Collection.class.isAssignableFrom()		
																													@将逗号分隔的字符串转换为字符串数组：@StringUtils.commaDelimitedListToStringArray(str)
																														@统一转发给：@delimitedListToStringArray()
																															@再转发给统一参数入口的接口：@delimitedListToStringArray()
																																>内容描述：从逗号分隔indexOf找到位置，不断substring出来放到一个集合里，最后集合转换为数组：collection.toArray(new String[0])---自己之前也曾使用过。	
																												-此时可能已经获取到了转换后的字符串数组，需要其他方式进一步转换“字符串数组”
																												#如果编辑器为null, 那么就获取默认的：@findDefaultEditor(requiredType)
																													>从属性编辑器仓库获取：@TypeConverterDelegate.propertyEditorRegistry.getDefaultEditor(rt)	
																														#查看默认编辑器激活开关：是否启用。开启才用。
																														>先尝试从map:overriddenDefaultEditors属性获取，有则返回。
																														#没有则看defaultEditors属性，如果为null: 则创建它@createDefaultEditors()
																															>除了注册常规的编辑器如：CharsetEditor/FileEditor/PathEditor/URLEditor/UUIDEditor/, configValueEditorsActive
																															>也注册集合编辑器如：new CustomCollectionEditor(Set.class)/new CustomMapEditor(SortedMap.class)
																															>也注册基本类型及其数组、包装类编辑器：new CustomNumberEditor(Double.class, false)/new CustomNumberEditor(Double.class, true))
																															>在configValueEditorsActive激活时注册：	new StringArrayPropertyEditor() 给short[]/int[]/long[]/String[]类型。
																														>从默认编辑器里取：map:defaultEditors, 直接get返回。
																													#如果此时依然没有发现编辑器：通过转换服务获取BeanUtils.findEditorByConvention()：
																														#不处理数组、不知道的targetType:直接返回null 
																														-尝试使用“加载编辑器类”的方式，而假设编辑器类类名等同于targetType的name+"Editor"
																														>所以先获取加载器：顺序：targetType.getClassLoader() > ClassLoader.getSystemClassLoader()
																														>构造编辑器名字：editorName=targetType.name + "Editor"
																														#开始加载cl.loadClass(editorName)，如果加载成功：检查Class对象是否可以赋值给PropertyEditor
																															#如果不可以：放入垃圾堆-不知道的编辑器类型map:unknownEditorTypes.add(targetType)，返回null 
																															#如果可以：需要对Class对象初始化：@BeanUtils.instantiateClass(ec) 里面会捕获可能发生的各种BeanInstantiationException异常。结果直接返回findEditorByConvention()
																																#使用构造器方法初始化：统一调用@instantiateClass(Constructor<T> ctor, Object... args)
																																	>设置构造方法可访问：ReflectionUtils.makeAccessible(ctor)， 几个判断。
																																	#如果构造方法类是特殊类：KotlinDetector.isKotlinType() 那么委托进行初始化：@KotlinDelegate.instantiateClass(ctor, args)
																																		-基本内容就是：使用KFunction实例ReflectJvmMapping.getKotlinFunction(ctor)的.callBy(argParameters)方法进行初始化。
																																	#否则简单的直接反射的构造方法调用：@ctor.newInstance(args)	
																																		-里面最终调用ConstructorAccessor.newInstance() 里面又BootstrapConstructorAccessorImpl.newInstance() 里面又：UnsafeFieldAccessorImpl.unsafe.allocateInstance(this.constructor.getDeclaringClass())
																													#返回编辑器。					
																												-此时编辑器获取完毕，开始利用来进行实质的转换值为目标类型：doConvertValue()						
																													#如果值不是字符串：调用编辑器setValue()又取出getValue()，如果两个值不相等，那么取出的值作为最新的值，下一步使用。同时该编辑器不再使用。						
																													-此时如果要求的类型不是数组，但是此时的转换值是字符串数组，则调用方法将字符串数组转换为逗号分隔的字符串：@StringUtils.arrayToCommaDelimitedString()					
																													-此时如果转换值是字符串：
																														#如果编辑器不为null: 统一转换设置@doConvertTextValue()
																															>直接设置转换前的值editor.setValue(oldValue)，设置当前转换值editor.setAsText(newTextValue)，返回值editor.getValue() 
																															#直接返回doConvertValue()
																														#否则如果要求类型就是字符串：那么直接返回当前转换值
																													-返回doConvertValue()		
																											-此时如果要求要求类型不是null: 还需要应用一些标准的类型转换规则。						
																												#此时的转换值不为null时：如果要求类型是Object那么直接返回转换值。			
																													#否则如果要求类型是数组：如果转换值是String且要求类型的元素类型可以赋值给Enum枚举类型，那么将字符串转换为字符串数组：@StringUtils.commaDelimitedListToStringArray()						
																														-此时统一再次进行转换值的转换：@convertToTypedArray()					
																															#如果转换值是集合Collection类型：构建一个该元素类型的数组Array.newInstance(componentType, coll.size())，并将集合元素值处理后设置set进去Arrary.set(r,i,v)				
																																-元素值的处理：先属性名转换，后按需转换：
																																@将属性名转换：@buildIndexedPropertyName() , 在属性名后面加[i] 这样的数组元素标记
																																@按需转换：走统一的按需转换方法：@TypeConverterDelegate.convertIfNecessary()
																																>直接返回
																															#否则如果转换值是数组Array类型：
																																#判断属性编辑器仓库里是否有组成元素的编辑器：调用@propertyEditorRegistry.hasCustomEditorForElement()
																																	>遍历“路径属性编辑器”map: PropertyEditorRegistrySupport.customEditorsForPath	
																																		#如果某个编辑器entry的key匹配到了属性名：@PropertyAccessorUtils.matchesProperty() 并且entry.value即CustomEditorHolder类型的属性编辑器存在--元素类型可以赋值给要求类型：那么返回true	
																																	-如果上述遍历都没有找到，那么就从“一般的定制编辑器”map:PropertyEditorRegistrySupport.customEditors里找：包含则返回true,否则其他情况都是false		
																																#如果没有包含:那么直接返回输入值，不再转换处理。			
																																#否则包含：那么直接按照之前的处理方法：构建一个该元素类型的数组Array.newInstance(componentType, Array.getLength(input))	并将集合元素值处理后设置set进去Arrary.set(r,i,v)	
																															#否则其他任意类型：
																																>统一直接上述的构建数组后，逐个元素处理后设置。
																													#否则如果转换值值是集合Collection类型：
																														>调用统一的方法转换集合元素类型为目标类型：@convertToTypedCollection() 并设置standardConversion=true标记为标准转换。
																															#如果要求类型不是各种基本的集合类型：@CollectionFactory.isApproximableCollectionType(requiredType)				
																																#进一步如果要求类也不可以创建实例：canCreateCopy(requiredType) ---可创建条件：Modifier.isAbstract()非抽象和接口，是public且有构造方法。。那么返回集合不做处理。			
																															#否则此时检查 如果值可以赋值给要求类型，且属性编辑器仓库没有null&这个属性名的编辑器@propertyEditorRegistry.hasCustomEditorForElement()：那么不做处理，直接返回。
																															#否则检测可迭代？不可以则返回。
																															#否则可以迭代，且如果前面检测出的是基本集合类型，那么获取最近似的集合类型：@CollectionFactory.createApproximateCollection()
																																>逐个基本集合类型判断：看值是否是它的实例instanceof ，是则返回这个。List/SortedSet			
																															#否则不是基本集合类型的集合类型：那么先设置反射允许再反射构造。@ReflectionUtils.accessibleConstructor(rt).newInstance()				
																															-此时已经构造出复制的集合：下面开始往里面添加内容。
																															>遍历原始集合：获取每个元素，进行上述的buildIndexedPropertyName+convertIfNecessary获取结果，添加到集合里。
																															#如果转换后的元素全部都和转换前的集合元素相等==，且待转换值就是要求类的值，那么直接返回入参里的原始转换值。
																																#否则才返回这个新的各个元素转换后的集合。
																													#否则如果是此时的转换值是Map类型：		
																														>调用统一的转换方法：@TypeConverterDelegate.convertToTypedMap()	
																															#如果要求类可以赋值给Map直接返回。不转换。
																															-判断是否存在近似的基本Map类型：CollectionFactory.isApproximableMapType()，基本map就是常见的HashMap等。
																															#同上在无近似且要求类不可复制时：直接返回。不转换。 
																															#同上在值可以赋值给要求类 且  属性编辑器仓库没有null&这个属性名的编辑器：直接返回，不转换。 
																															#同上查看是否可迭代：不可，直接返回。 
																															#如果有近似Map：那么创建近似Map:@CollectionFactory.createApproximateMap() 
																															#没有近似Map则直接反射创建：ReflectionUtils.accessibleConstructor(requiredType).newInstance()
																															-此时已经构造出新的Map,但没有元素，下面开始加元素。
																															>遍历原始Map: 同样方式按需转化key:buildKeyedPropertyName+convertIfNecessary, value则直接转换convertIfNecessary()
																															#同理，再如果每次转换前后值都没变且老值可以赋值给requireType那么返回老值，否则返回这个新的集合。
																													-此时可能转换已经进行了一部分。		
																													#如果值是数组array且长度为1，那么：将元素取出来赋给转换值。	标记standardConversion=true	
																													#如果要求类型是字符串，而转换值是基本类型或者其包装类：tostring()返回。	
																													#否则如果转换值是字符串 且 转换值不是要求的类型：
																														#如果要求类不是接口 且不是枚举：那么获取要去类的单str参数构造方法，然后用这个构造方法和转换值 来构造实例：@BeanUtils.instantiateClass(ct,args) 前面已经描述。
																														-细碎的判断：如果转换值字符串为空串且要求类是枚举，那么直接返回null
																														@尝试转换值为枚举：attemptToConvertStringToEnum()
																															#如果要求类是枚举类Enum：那么尝试将字符串认为是 枚举类型.fieldName ,而恢复它的枚举类Class,和属性Field; 方法就是分割为2半，类则用ClassUtils.forName()加载，再反射Field.get(null)获取属性的值作为新的转换值。
																															#作为一个退路：兜底，如果新的转换值和原来的值一样，那么用要求类直接反射获取Field(原来值作为参数),再Field获取转换值。	
																														-再次标记设置standardConversion = true	
																													#否则如果转换值是Number类型且要求类可以赋值给Number: 那么统一方法转换为目标类类型：@NumberUtils.convertNumberToTargetClass()		
																														>对目标类可能的各种包装类类型：都需要专门处理：由于转换值具体可能是BigInteger/BigDecimal类型， 再检查值域，未通过可能会抛出异常。
																														-再次标记standardConversion = true 
																												#否则：转换值为null.需要小的处理：目标类是Optional类型时，赋值为Optional.empty()	
																												-此时转换值可能已经被处理过。还需要一些处理。
																												#如果此时转换值还属于不能赋值给要求类：
																													#先看转换服务是否可用：就是看有没有转换器@GenericConversionService.canConvert()，前面有讲述getConverter();如果有那么直接用这个转换服务转换@GenericConversionService.convert()，并将转换结果直接返回。
																													#否则不可用：开始构造抛错信息，直接抛出错误new IllegalArgumentException(msg.toString())
																														
																											>返回转换值	。返回TypeConverterDelegate.convertIfNecessary()按需转换。
																						#如果解析后的目标类是null: 那么直接返回上一步返回的评估结果。								
																					#如果是NullBean类型：返回null 
																					#其他情况都统一返回评估结果：入参就是值，@evaluate(value)
																						#值是字符串：直接真正评估：@doEvaluate(v)
																							@统一转发给统一的评估bean定义接口：beanFactory.evaluateBeanDefinitionString()
																								@转发给专门的评估类：AbstractBeanFactory.beanExpressionResolver.evaluate(beanName, BeanExpressionContext)
																						#如果值是字符串数组,则遍历每个元素，每个元素都进行转换真正的转换并设置：@doEvaluate(v)		
																						#其他类型直接返回。
																			#如果参数值类型为AutowiredArgumentMarker：调用统一的自动绑定参数解析方法@ConstructorResolver.resolveAutowiredArgument()
																				#如果方法参数可以赋值给InjectionPoint类型：则从线程局部变量currentInjectionPoint里取出InjectionPoint对象，没有则抛错，有则返回。 
																				>开始统一的解析依赖：把方法参数传递进来。@DefaultListableBeanFactory.resolveDependency()
																					#初始化方法参数名发现器：parameterNameDiscoverer   @DependencyDescriptor.initParameterNameDiscovery()
																					#如果依赖类型是Optional：统一调用依赖创建@createOptionalDependency()
																						#构造一个NestedDependencyDescriptor对象---覆盖某些方法。
																						@统一调用解析依赖接口@doResolveDependency() 结果放到Optional返回。
																							>先设置注入点线程局部变量：@ConstructorResolver.setCurrentInjectionPoint()	,内容就是描述符设置到ConstructorResolver.currentInjectionPoint属性里。		
																							>解析shortcut捷径:@ShortcutDependencyDescriptor.resolveShortcut(BeanFactory beanFactory) ，本质上就是调用beanFactory.getBean()获取。
																							#如果shortcut不为null: 那么可以返回它。
																							-否则此时需要专门处理。
																							>获取自动绑定候选解析器autowireCandidateResolver来 获取注解值@QualifierAnnotationAutowireCandidateResolver.getSuggestedValue(DependencyDescriptor descriptor)
																								@统一调用从注解中获取值方法：@QualifierAnnotationAutowireCandidateResolver.findValue(Annotation[]) 
																									>先将注解放到AnnotatedElement对象，AnnotatedElementUtils.forAnnotations()很巧妙，直接放到类定义的返回值上。
																									>再获取注解属性：@AnnotatedElementUtils.getMergedAnnotationAttributes()	
																										@先统一调用根据类型或者名称搜索查找注解方法@searchWithGetSemantics() ,注入一个实例MergedAnnotationAttributesProcessor切面处理器, 和目标注解类型valueAnnotationType---后面会放到一个集合里。
																											@统一转发给统一参数接口@searchWithGetSemantics()
																												>获取声明的注解，利用了缓存declaredAnnotationsCache,也利用了之前的元素AnnotatedElement @AnnotationUtils.getDeclaredAnnotations()
																												>再次统一转发给专门的接口：@searchWithGetSemanticsInAnnotations()再里面遍历注解，来获取正确的匹配注解。
																													>遍历上一步获取的声明注解：对每个注解
																														#如果注解类型不在java注解包下：
																															#如果目标注解类型集合包含它：
																																>先用处理器处理：@processor.process()
																																	@统一调用注解属性解析方法：@AnnotationUtils.retrieveAnnotationAttributes()
																																		>获取注解的定义类字节码Class: .annotationType()：封装到一个new AnnotationAttributes()实例中
																																		>通过注解的定义类Class对象获取它所有的属性：@AnnotationUtils.getAttributeMethods() 使用了缓存机制attributeMethodsCache
																																			>只需要用这个Class对象.getDeclaredMethods() 就获取到了：需要过滤一下--确认是注解方法：返回类型不等于void.class 且getParameterCount()为0， 当然方法要setAccessible
																																		>对每个注解方法：反射，获取invoke(annotation)获取注解值，getDefaultValue()获取默认的注解值。
																																		#如果设置值和默认值相等：设置值重新赋值为：new DefaultValueHolder(dfv)
																																		>统一放到AnnotationAttributes实例中：key:注解方法名、调整值@adaptValue()
																																			#如果类值作为字符串：
																																				#如果设置值就是Class类型，直接返回设置值的name()
																																				#否则如果是Class[]类型，则遍历，每个元素也获取name(),从而返回字符串数组。
																																			#如果设置值是注解类型Annotation：
																																				#如果允许嵌套注解：统一调用解析方法@getAnnotationAttributes() 内容和searchWithGetSemantics()类似：
																																					>先解析注解属性：@retrieveAnnotationAttributes()
																																					>再注解属性获取之后的处理器处理：@postProcessAnnotationAttributes()
																																				#否则不允许嵌套：那么只进行同步：@synthesizeAnnotation() 结果直接返回。
																																					>设置值是SynthesizedAnnotation类型或者设置值仅仅是不同的java类型：@hasPlainJavaAnnotationsOnly那么直接返回这个设置值，不做处理。
																																					>查看是否可以同步：@isSynthesizable() 基本注解类型不能同步。
																																						>获取注解类Class对象：采用缓存机制：map:synthesizableCache
																																						>获取注解Class对象的所有属性方法：即注解属性。遍历：
																																							>对每个方法：查看它的别称@getAttributeAliasNames():其实就是看有没有AliasFor注解-及其内容，如果有并且验证通过而没有报错：@AliasDescriptor.validate()  $
																																							#如果有别称：那么就认为可以同步，直接退出循环，缓存一下，而返回。
																																							>否则再看这个方法的返回类型ReturnType():
																																								#如果可以赋值给Annotation[]：把返回类型的数组元素类型取出来，递归看是否可以同步@isSynthesizable();如果可以，那么可以同步，退出循环，缓存一下，返回。
																																								#否则如果可以赋值给Annotation：那么对这个返回类型也进行递归看是否可以同步@isSynthesizable();如果可以，认为可以同步，退出循环，缓存一下，返回。
																																					#如果不可以同步：那么直接返回，不做处理。		
																																					>否则可以同步：构造默认注解属性提取器new DefaultAnnotationAttributeExtractor()	注入一个新构造的同步注解InvocationHandler:new SynthesizedAnnotationInvocationHandler()
																																					>定义代理类的实现接口：SynthesizedAnnotation和本注解类
																																					>使用java动态代理生成这两个接口的代理类：Proxy.newProxyInstance()返回这个动态代理类。
																																			#如果设置值是注解数组类型Annotation[]：
																																				#同理如果允许嵌套：设置值转换为注解数组，遍历每一个，并获取每个注解的注解属性封装到一个AnnotationAttributes对象，最终得到它的数组而直接返回。									
																																					>这个封装过程为：调用统一方法@getAnnotationAttributes()	,同上方法。
																																				#否则不允许嵌套：调用统一的处理方法@synthesizeAnnotationArray()	结果直接返回。	
																																					#如果是普通java注解：直接返回注解数组。
																																					#否则构造一个注解数组：Array.newInstance(),元素类型就是 入参注解数组的元素类型	
																																					>开始遍历这个入参注解数组：对每一个注解，调用上述@synthesizeAnnotation()同步方法获取结果，设置到新建数组中。		
																																			>返回传入值。				
																																		>返回这个AnnotationAttributes实例即可。					
																																>如果上一步处理结果不为null:
																																	#如果需要聚合结果：则将处理结果放到聚合list里：processor.aggregatedResults					
																																	#否则直接就返回这个处理结果result了。作为@searchWithGetSemanticsInAnnotations()的返回。
																															>否则不包含，如果当前这个注解 和容器注解类型相同：
																																@决定获取批量的注解@getRawAnnotationsFromContainer()			
																																	>先获取容器的注解：@AnnotationUtils.getValue()							
																																		@统一转发给标准入参接口：获取注解的value属性的值AnnotationUtils.getValue(annotation, attrName);返回的值认为是一个注解数组A[],不为null则返回到getRawAnnotationsFromContainer()，否则返回一个空数组。
																																>然后遍历获取到的注解数组，对每个注解用处理器处理：@processor.process()	
																																	#如果处理结果不为null,那么放到聚合list列表里：list: processor.aggregatedResults				
																													>再次遍历上次获取到的声明注解：对每个注解，做一些递归性质的处理。
																														#如果注解类型不在java注解包/spring语言包下：直接递归标准的入参最多的最后一层的@searchWithGetSemantics()，得到搜索结果。
																															#如果这个搜索结果不为null: 
																																@进行处理器的后置处理@MergedAnnotationAttributesProcessor.postProcess()。
																																	>获取注解合成结果：@AnnotationUtils.synthesizeAnnotation()
																																	>遍历参数注解的所有方法：使用了缓存机制获取所有的方法。	对每个方法： 
																																		>获取本身的名字和覆盖的名字----覆盖的名字的作用：过滤器容器的作用：一旦某个属性覆盖了，那么其他属性如果还覆盖，那么不做处理直接退出。
																																		>如果覆盖属性不为null:
																																			>获取这个方法的别称属性集合：@AliasDescriptor.getAttributeAliasNames() $$
																																				>如果不为null:遍历这个别称属性集合：第一次获取的所有别称+方法的覆盖名称，作为一个参数，它们在AnnotationAttribute中的值应该是一样的，所以需要调用来覆盖：@overrideAttributes()
																																					>设置相同值之前，需要获取这个相同值：@getAdaptedValue()
																																						>获取注解的这个属性的值：@AnnotationUtils.getValue()
																																						>值需要调整一下：@AnnotationUtils.adaptValue() 然后将值直接返回。
																																					>然后才开始对属性多个键设置同一个转换值：AnnotationAttributes.put()
																																		>否则为null,进一步如果属性名不是value,且属性map:AnnotationAttributes不包含这个属性名：
																																			>直接使用覆盖方法：@overrideAttribute()---仅仅覆盖这一个属性的值。
																																#如果允许聚合且metaDepth==0(入参确实是0)：那么增加这个递归结果到processor.aggregatedResults																										
																																#否则：直接返回这个递归结果。返回到@searchWithGetSemanticsInAnnotations()																										
																													>到此都没有返回，则返回null.																														
																												>此时已经获取了注解的语义结果: 如果结果不为null那么就直接返回了。返回到searchWithGetSemantics()																															
																												#否则此时注解的语义结果为null:	最后一次机会处理。																														
																													#如果AnnotatedElement是Class类型：获取ele的父类，																														
																														#如果父类不是Object，不是null:	那么从ele的所有注解getAnnotations()里排除声明注解getDeclaredAnnotations()而获取的继承的注解集合：																												
																														>对这个继承注解集合：也进行语义上的搜索处理@searchWithGetSemanticsInAnnotations()得到一个处理结果。																													
																															#如果这个结果不为null:直接返回这个结果。																												
																												>到此还没有获取到语义结果而返回，那么直接返回null。																															
																										>此时已经获取到了注解属性map:AnnotationAttributes对象：开始处理器的后置处理：@AnnotationUtils.postProcessAnnotationAttributes()																																		
																											#没有属性，直接返回null 
																											#有属性，获取注解的Class对象：	
																											#如果属性还没有验证：需要做一些验证工作。																																	
																												>获取注解类的"方法-别名list“的这样的map:@getAttributeAliasMap()																																
																												>开始遍历这个map: 同时建立一个set,来过滤掉已经处理过的同一类的属性名---中间可能加进来别称属性。																																
																													>从入参属性里获取属性值，如果不为null且不是DefaultValueHolder类型，那么认为是当前值：valuePresent=true																															
																													>遍历别称list：同理set记录处理过的别称，后面不再处理。																															
																														>从入参属性里获取别称的值，同理确定是否有别称值：如果不为null且不是DefaultValueHolder类型																												
																														#如果属性值或者别称值至少有一个有：	需要验证																													
																															#两个都有：	且不相等@!ObjectUtils.nullSafeEquals(),那么抛出异常new AnnotationConfigurationException()																												
																															#否则如果仅仅别称值有：则把别称值适配一下@adaptValue()再设置到入参属性里.																													
																															#否则如果仅仅属性值有: 则把属性值适配一下@adaptValue()再设置到入参属性里.																													
																												>此时遍历完成:设置验证标记为true: attributes.validated = true																															
																											>验证完成，需要对默认值做处理：																																	
																												>遍历入参属性的所有kv: 对于上一步已经验证过的---加入set的，不再处理，对于其他的：																																
																													#如果属性值是DefaultValueHolder类型，那么获取这个类型的defaultValue属性值，适配一下@adaptValue()设置到入参属性里。																															
																											>返回。																																	
																									>此时已经进行了获取注解属性的过程，如果获取的注解属性AnnotationAttributes不为null:	则提取value值：@extractValue()														
																										>直接取"value"键的值：结果为null要抛出异常new IllegalStateException(),否则返回这个结果。	
																								>此时已经获取值完成：如果结果不为null:获取描述符的方法参数MethodParameter				
																									>如果不为null:需要再次寻找它的方法注解@getMethodAnnotations()的值：@findValue()	来替换上一步find的value
																								>此时返回值value作为最终的建议值。		
																							#如果获取的注解值不为null: 那么稍微处理就可以返回了。			
																								#获取的注解值是string类型：则必须要经过一系列的内嵌值解析器的过滤处理：@AbstractBeanFactory.resolveEmbeddedValue()		
																									#对所有的值解析器：只要有一个解析结果为null就没通过，直接返回。过滤过程调用：@PlaceholderResolvingStringValueResolver.resolveStringValue()	
																										@统一调用格式替换：@PropertyPlaceholderHelper.replacePlaceholders() 替换占位符为实际值。占位符有前缀和后缀、还可能嵌套。
																											@统一转发给带占位符的解析出值的方法：@parseStringValue() 处理算法：
																												>确定占位符前缀开始位置:indexOf()，再确定占位符结束位置：@findPlaceholderEndIndex()
																													#对结束位置的寻找：从前缀的下一个位置开始：匹配占位符后缀字符串@StringUtils.substringMatch()
																														#如果匹配到了：那么可以直接返回当前这个位置。
																														#否则如果匹配到了前缀：那么说明有了嵌套，则必须经过两个后缀才可以退出，所以有一个嵌套个数标记withinNestedPlaceholder。并从这个前缀的后一个字符开始，下一轮匹配。
																														#否则其他情况：仅仅直接index++,向后移动一个字符即可。
																													>那么最后就找到了输入的前缀的后缀的开始index位置。否则返回-1
																												#如果得到的后缀位置不是-1: 那么前缀和后缀之间的字符串就是 占位符。
																													>截取这个中间的占位符：考虑到嵌套占位符的存在，需要递归解析：所以调用解析@parseStringValue(),由于只允许最多2次嵌套，所以得到的解析结果认为就是最终的 无嵌套的占位符(变量名)。
																													>开始调用占位符解析器解析：@PropertyPlaceholderConfigurerResolver.resolvePlaceholder(String placeholderName)
																														@统一转发给解析PropertyPlaceholderConfigurer.this.resolvePlaceholder(): 入参之一为“系统解析模式”/系统属性模式快速失败
																															>此模式下调用：@resolveSystemProperty()
																																>值从系统属性里取：System.getProperty(key)，为null时如果可以还从 System.getenv(key)里获取结果里返回。
																													#如果此时获取的属性值是null,且值分割符不为null: 那么需要将值按分割符分割处理，分割符之前的一半是真正的属性名，分隔符之后的是默认值。
																														>调用解析器解析真实值：@resolvePlaceholder() 和上述一样，获取了一个系统属性值，如果这个属性值为null,那么就设置属性值为默认值。
																													>此时如果属性值不是null了：再次递归式的解析这个属性值@parseStringValue() 得到一个新的属性值。这个属性值，才用来替换 占位符开始和结束之间的内容。
																														>那么下一步的替换和解析就是从替换之后的那个位置的下一个字符开始。	
																													#否则如果可以忽视未解析的占位符：那么直接从占位符的下一个字符开始，继续解析。
																													#否则其他情况：抛出异常。
																												#否则可以直接退出了。			
																										#占位符替换成功之后：需要trim则要trim()一下，如果是空串则返回null,否则还是原样返回。						
																									#如果解析结果为null:就认为没通过，而直接返回null到resolveEmbeddedValue()								
																								>此时考虑bean定义合并：先看当前工厂/父类工厂是否包含bean：	
																									>查询是否包含：@containsBean()											
																										>转换为标准名										
																										>如果单例池或者bean定义map:beanDefinitionMap中包含：那么直接返回：包含条件：不是$开头，或者是factoryBean:(!BeanFactoryUtils.isFactoryDereference(name) || isFactoryBean(name)) $$
																											@是否是工厂bean: isFactoryBean() 结果直接返回。
																												>转换为标准名 
																												>从单例池中获取：(不从提前单例池中获取)
																												#如果存在：则如果是FactoryBean实例则是工厂bean，否则就不是，直接返回。
																												>此时不存在：可能没创建：
																													#如果bean定义map:beanDefinitionMap不包含, 且父类工厂不是ConfigurableBeanFactory实例：那么调用父类工厂递归判断：getParentBeanFactory().isFactoryBean() 结果直接返回。
																												>最后的判断：先获取融合本地bean定义：@getMergedLocalBeanDefinition()前面已将；结果作为入参继续判断：@isFactoryBean(name, bd)	
																													>猜测bean的类型：@predictBeanType()
																														>bd的目标类有则返回：否则直接解析bean类：@resolveBeanClass()---所谓的带权限解析。结果Class对象直接返回。
																													#如果结果Class可以赋值给FactoryBean：那么就是工厂类，否则不是。
																										>获取父bean工厂：检查父工厂中是否包含：@containsBean()	作为直接结果返回。		
																									>如果包含：获取合并定义@getMergedBeanDefinition()；不包含则结果为null										
																									>开始评估bean定义：@evaluateBeanDefinitionString()	评估的值，覆盖之前的值。											
																									>开始使用转换器转换：也是按需转换：先获取类转换器@getTypeConverter()												
																										>先获取用户定制的类转换器：@getCustomTypeConverter() 												
																											>直接返回AbstractBeanFactory.typeConverter													
																										#如果不为null:则直接返回这个转换器。
																										#否则构造一个转换器：注入转换服务，并且注册：new SimpleTypeConverter()	 注册为：@registerCustomEditors()
																										>然后才返回这个构造的类转换器。																	
																									>开始按需转换：如果描述符中Field属性不为null:则先用Field属性值进行值的转换：@converter.convertIfNecessary()	转换后的值直接返回@doResolveDependency()																
																							>此时则建议值为null: 则可能是多个bean,那么解析获取之后 也可以返回了：解析多bean的方法为：@resolveMultipleBeans()																				
																								#根据依赖描述的不同类型而分别处理：如果是StreamDependencyDescriptor类型：																				
																									>获取和自动绑定匹配的符合要求类型的候选bean集合：@findAutowireCandidates()																				
																										@直接调用统一的方法获取候选的names数组：BeanFactoryUtils.beanNamesForTypeIncludingAncestors()																				
																											@先获取该类的所有beanNames:@DefaultListableBeanFactory.getBeanNamesForType()																		
																												#如果配置冻结、要求类为null、不允许提前初始化：	调用统一的实质类解析方法@doGetBeanNamesForType()																	
																													>遍历所有的bean定义：DefaultListableBeanFactory.beanDefinitionNames	, 对每个beanName																		
																														#如果不是别称：																			
																															>获取融合定义：@getMergedLocalBeanDefinition(bn)	
																															#如果不是抽象类型、且(允许提前初始化|有beanClass|非延迟初始化|允许提前类加载)且	不要求提交对类初始化@requiresEagerInitForType()----是工厂bean且单例池中没有：那么就“要求提前对类初始化”		
																																>获取是否是工厂bean: @isFactoryBean()			
																																#判断是否匹配：非工厂bean|允许提前初始化|...且类匹配@isTypeMatch(beanName, type)--其实是看遍历的当前beanName是否和目标类Type相匹配：
																																	>名称转换为权威名：@transformedBeanName()
																																	>单例池中非提前池中获取实例：@getSingleton()
																																	#如果获取到的实例不为null不是NullBean的实例：
																																		#如果是FactoryBean类型: 
																																			#如果name不是&开头：那么实例直接强转为FactoryBean类型，进一步用带权限框架的方式获取这个bean的类型：@getTypeForFactoryBean()(@FactoryBean.getObjectType())
																																				#在获得这个bean类型之后：如果不是null, 那么就开始用@ResolvableType.isAssignableFrom()进行比较
																																					>即看获得的这个Type是否可以赋值给开始初始化时给的那个类：如果可以返回可以匹配，否则返回不能匹配。
																																			#否则不是&开头：那么判断这个单例是否是入参ResolvableType实例的实例：@ResolvableType.isInstance()即可以赋值给这个ResolvableType类。可以则返回true,否则false:返回到isTypeMatch()
																																		#否则如果不是&开头：
																																			#直接判断实例是否可以赋值给ResolvableType：	@ResolvableType.isInstance()， 是那么就直接返回了。
																																			#否则不是ResolvableType的实例：进一步判断是否有一般参数@ResolvableType.hasGenerics() 和map:beanDefinitionMap包含@containsBeanDefinition()
																																				@先获取是否一般参数：@getGenerics()的长度>0就是true
																																					>基于ResolvableType.generics属性：属性不为null直接返回。
																																					#如果该属性为null: 需要构造。
																																						#如果type属性是Class: 
																																							>获取这个type属性的getTypeParameters()参数数组
																																							>构造一个ResolvableType[]数组
																																							>开始遍历获取到的参数数组：对每个参数类型：
																																								>转换后设置到ResolvableType[]相应的位置：转换方法为@ResolvableType.forType()
																																									@统一转发给@ResolvableType.forType() ：对给定类型返回ResolvableType类型。
																																										//其他情况下会SerializableTypeWrapper.forTypeProvider()调用访问，但此时不会。
																																										>如果给定类型是Class:则直接new ResolvableType()返回。
																																										-否则考虑使用ConcurrentReferenceHashMap<ResolvableType, ResolvableType>来进行缓存：
																																										>先清空：ConcurrentReferenceHashMap.purgeUnreferencedEntries()
																																										>再构造：new ResolvableType()
																																										>再缓存：cache.put()
																																						#否则如果type是ParameterizedType类型：
																																							>获取这个type的真实type数组：@getActualTypeArguments()
																																							>遍历这个数组：对每个type:进行统一的解析获取解析type:ResolvableType 转换方法@ResolvableType.forType()
																																						#否则其他任何类型：都统一处理：获取解析类@ResolvableType.resolveType()之后 获取一般解析类型getGenerics()结果需要设置到舒兴国generics里。
																																							@对于resolveType()处理： 
																																								#如果type属性是ParameterizedType类型：
																																									>获取它的type簇后转发到forType() 结果也直接返回@resolveType()
																																								#否则如果type是WildcardType类型：
																																									>则获取泛型变量type的上边界：@WildcardType.getUpperBounds() 然后获取第一个类型：@resolveBounds()
																																									#如果这个类型为null: 再次尝试：此时获取泛型变量的下边界：@WildcardType.getLowerBounds() 同样进行过滤。
																																									>最后统一调用@forType():入参就是此时的转换类型.返回 
																																								#否则如果type是TypeVariable类型：
																																									#如果变量解析器不是null:则调用变量解析器来解析这个类型变量为解析类型：@variableResolver.resolveVariable()
																																										>遍历TypeVariablesVariableResolver.variables属性：对每个TypeVariable对象，unwap之后和入参的TypeVariable同样unwrap之后进行比较，如果相等，那么就返回对应索引位置的ResolvableType.TypeVariablesVariableResolver.generics[i]解析类。
																																											@SerializableTypeWrapper.unwrap() 解开方法：是一个迭代的过程。
																																									>如果此时得到的解析类型不是null:则直接返回。
																																									#否则到此时，需要进行统一的转发给@forType()处理	：入参包含：获取变量的边界(上下)
																																								#否则其他类型直接返回None: new ResolvableType(EmptyType.INSTANCE, null, null, 0)		
																																							@对于@getGenerics()处理： 
																																								>要么递归：要么是返回一个空对象：new ResolvableType[0]
																																						>最后就是设置给generics属性	
																																					>此时就可以直接返回generics属性了。
																																				@再看定义map是否包含：直接。
																																				>如果上述两个都是true:
																																					>获取融合bean定义mbd：getMergedLocalBeanDefinition()
																																					#如果mbd.targetType不是null且不是 “用户类”：这个用户类的获取需要专门方法@ClassUtils.getUserClass(),因为这个实例可能是cglib的代理类---而不是用户定义的类：
																																						-@转发给ClassUtils.getUserClass(): 判定是否是cglib代理类：看className是否包含"$$"分隔符，包含则是代理类，需要返回它的父类；
																																						#如果bean不是解析类的实例：返回false 
																																						#如果目标类型可以赋值给解析类：返回true 
																																					>此时先后从mbd.targetType/factoryMethodReturnType获取解析类：来判定是否可以赋值给入参解析类：如果可以返回true,否则false
																																		>此时就直接返回false了。
																																	#否则如果包含单例，但是不包含定义：那么不正常，返回false 
																																	-此时已经明确没有实例：开始一般的处理，还进行各种尝试。
																																	#如果父工厂bean不是null调用他来匹配：parentBeanFactory.isTypeMatch() 入参为复原的带&的beanName。。结果直接返回。 
																																	>再次获取融合bean: 尝试从装饰bean定义来获取到匹配是否的信息
																																	#获取装饰定义holder: 如果不是null且name不是&开头： 
																																		>获取融合bean: 
																																		>猜测装饰hodler的class类型：@predictBeanType()
																																			#如果这个猜测类型不是null且 类型不能赋值给FactoryBean：那么直接只看入参解析类型是否可以接受这个猜测类型ResolvableType.isAssignableFrom() 并且结果直接返回。
																																	#开始获取权威名的预测类型：@predictBeanType() 为null则返回false 
																																	#否则不是null,那么判断是否可以赋值给FactoryBean类型：
																																		#进一步不是&开头，获取的实例为null:
																																			>获取工厂bean创建的bean的类型：@getTypeForFactoryBean()
																																			#如果这个类型为null:则不匹配返回。
																																	#否则如果权威名&开头： 
																																		>猜测beanName的类型：类型不存在或者不可以赋值给FactoryBean：那么也返回false
																																	>最后尝试顺序：targetType/factoryMethodReturnType属性当做解析类，
																																		#如果不是null:那么看是否可以赋值给入参解析类，是否值直接返回。
																																	>最后就是一般的赋值可否的检查：入参解析类.isAssignableFrom(预测类型)，结果直接返回。
																																
																																#如果不匹配且是工厂bean类型：需要重新判断是否匹配。				
																																	>先beanName恢复：加前缀&		
																																	>赋值是否匹配：也是以类匹配为主：@isTypeMatch(beanName, type)		
																																#此时如果匹配了：则结果里加上这个beanName----作为候选的names之一。			
																													>此时开始遍历检查人工注册的单例名集合：						
																														>对每个beanName,如果是工厂bean:@isFactoryBean()	,专门做些处理：	
																															#进一步如果是单例@isSingleton() 且匹配@isTypeMatch() 也加到结果集合里；继续循环。
																															#否则beanName复原：加前缀&;继续下面一步。
																														>再看能否类型匹配：@isTypeMatch(beanName, type)，能则要将这beanName加到结果集合里。					
																													>此时结果集已经加完：转换为字符串数组：StringUtils.toStringArray(rs)返回。					
																												>否则考虑从全局缓存属性allBeanNamesByType/singletonBeanNamesByType里查找，这个类型的解析名集合，有则返回。 						
																												#否则没有，继续构造解析类ResolvableType.forRawClass(type)后调用实质解析@doGetBeanNamesForType()	获取解析名数组						
																												#判断入参type是否是classLoader属性加载器加载的或其父加载器加载的@ClassUtils.isCacheSafe()							
																													#如果是那么要将解析结果放到上述缓存属性里。
																												>此时可以返回解析字符串数组结果了。
																											#当入参中的bean工厂如果是垂直bean工厂HierarchicalBeanFactory，那么需要专门处理：								
																												#进一步看父工厂是否是ListableBeanFactory类型
																													#如果是：那么需要递归的解析@beanNamesForTypeIncludingAncestors()结果为父工厂 的解析结果，所以需要和本工厂的解析结果合并：@mergeNamesWithParent()--合并为去重式合并。
																											>返回合并结果。								
																										-此时已经得到了候选的解析后的beanNames数组：但是本方法的自动绑定候选结果map内容不止来此	：所以先								
																										>从依赖解析map:DefaultListableBeanFactory.resolvableDependencies里解析一部分：遍历它：									
																											#键为绑定类型，如果要求类型可以赋值给它：
																												#获取值，值就是绑定值：将值解析为要求的类型：@AutowireUtils.resolveAutowiringValue()
																													@如果值是ObjectFactory类型，且不是要求类型：需要处理。
																														#如果值可序列化 而要求类是接口：
																															>那么生成一个要求类的动态代理：@Proxy.newProxyInstance()，且handler类为：new ObjectFactoryDelegatingInvocationHandler(值)，返回这个动态代理。
																														#否则：直接调用工厂方法返回：.getObject()返回。	
																													#否则：直接返回值。
																												>此时如果值是要求类型：
																													>添加到结果map: key为：@ObjectUtils.identityToString(v)即类名@十六进制的hashcode, 值为v
																										>此时开始遍历候选数组：对每个候选，检查是否循环引用、
																											@是否循环引用：@isSelfReference()
																												#只要候选和原名相同 或者 (beanDefinitionMap包含候选 且 候选融合@getMergedLocalBeanDefinition()之后的工厂beanName西鞥等于原名) 就认为是循环引用。							
																											@是否自动绑定候选：@isAutowireCandidate()
																												@获取候选解析器后统一转发给统一入参@isAutowireCandidate()
																													#如果候选名的标准名 在定义map里：那么循环检查@isAutowireCandidate(),入参之二融合这个标准名的定义@getMergedLocalBeanDefinition()						
																													#否则如果单例池包含候选名：也循环检查@isAutowireCandidate() 入参之二为新的构造mbd:new RootBeanDefinition(), 先获取候选名的Class对象：@getType()				
																														@获取候选的Class是一个转门方法@AbstractBeanFactory.getType()					
																															>获取权威名，再取对应单例池中的对象：如果单例不为null:且不是NullBean,需要以下处理
																																#如果单例是FactoryBean且不以&开头：直接转发给@getTypeForFactoryBean()并结果返回。
																																#否则直接返回单例的getClass()返回。			
																															-否则为null: 进行父工厂尝试、装饰Class尝试、猜测BeanType尝试、
																															#如果父工厂不为null 且不在定义map里：那么递归@parentBeanFactory.getType()	
																															#否则获取融合bean mbd的装饰bean: BeanDefinitionHolder	如果装饰bean存在且原名不以&开头：进行一下处理并返回。			
																																#再次融合@getMergedBeanDefinition()	,之后用来预测@predictBeanType()	:如果预测结果不为null且不可以赋值给FactoryBean，那么就可以返回它。
																															#否则直接预测：@predictBeanType()		
																																#如果此时预测结果可以赋值给FactoryBean：			
																																	#如果不是&开头：专门转发获取@getTypeForFactoryBean()并返回： 		
																																	#否则直接返回预测结果		
																																#否则如果不是&开头：直接返回预测结果：否则返回null			
																													#否则尝试父工厂：如果是DefaultListableBeanFactory类型：直接递归：@parent.isAutowireCandidate()
																													#否则如果是ConfigurableListableBeanFactory类型：不带解析器递归：@parent.isAutowireCandidate()	
																													#否则就返回true了。							
																											#如果上述两个条件满足：不是循环引用、且是自动绑定：	那么需要增加这个候选entry:@addCandidateEntry()							
																												#按描述符分：如果是MultiElementDescriptor类型：							
																													#先从解析器解析：@resolveCandidate()认为就是从beanFactory.getBean()这样子。
																														#只要结果不是NullBean：都放到候选map里。
																												#否则如果不在单例池或(描述符是StreamDependencyDescriptor类型且有序)	：那么也直接解析@resolveCandidate()后放到候选map里。
																												#否则直接获取type@getType()的Class后放到候选map里：	
																										>此时直接看候选map是否为空：空则要兜底：									
																											#是否多bean检测：@indicatesMultipleBeans()--即看是否是数组、集合、Map								
																											#获取描述符的回滚依赖描述符：@forFallbackMatch()true返回。
																											#再次遍历候选数组：对每个候选：	
																												#如果非自引用 且 自动绑定 ：那么加入候选map:@addCandidateEntry()
																												#如果不是多bean: 那么也要加入候选map:@addCandidateEntry()	
																											#此时如果候选map还是空且不是多bean:								
																												#再次遍历候选数组： 对每个候选： 
																													#是自引用 且 ((描述符不是MultiElementDescriptor类型) 或候选bean不等于beanName）且自动绑定候选：则加入候选map:@addCandidateEntry()
																										>此时就直接返回候选map:result了。
																									>候选map的key直接加到候选name集合中：
																									>但是返回的是流对象：通过上一步的候选map的key流转换而来：
																										#先map()转换：@resolveCandidate()描述符解析：即直接从beanFactory.getBean()获取。
																										#再filter()过滤掉NullBean类型：
																										#如果描述符有序：那么这个流需要进一步处理：先构造一个比较器：@adaptOrderComparator() 流使用这个比较器：.sorted(cp) 然后就可以返回这个流。
																											>取依赖比较器：dependencyComparator：无论是否是OrderComparator类型，都会转换为这种类型
																											>取资源提供者：@createFactoryAwareOrderSourceProvider()
																												>新建IdentityHashMap对象：加入new FactoryAwareOrderSourceProvider()对象，返回。
																											>构造lamda比较器：@withSourceProvider() (o1, o2) -> doCompare(o1, o2, sourceProvider);
																												@其中@OrderComparator.doCompare()比较就是order大小的比较。
																										
																								#如果类型是数组：											
																									>先获取组件类型、描述符的解析类型@getResolvableType()										
																										>直接取resolvableType属性：如果是null需要构造：
																											#field不是null通过它来构造：@ResolvableType.forField()
																												@转发给@forType()得到解析类后再次转换@ResolvableType.as(),对于后者：							
																													#先查看解析resolve(),如果是null或者和入参type相等：返回本实例。
																													#否则先获取所有的解析接口：@getInterfaces()
																														#无解析则返回空：
																														#否则看interfaces属性：当不为null则直接返回。否则一下处理
																															@解析类获取一般接口@getGenericInterfaces(),遍历这个一般接口：对每个type进行转换@forType()之后设置到一个接口数组里。
																														>然后将接口数组赋值给interfacs属性。
																													#遍历每个解析类：对每个类递归解析处理@as()只要不为null就返回它。
																													>此时获取解析类父类：@getSuperType()之后再次递归.as()后直接返回递归结果。
																														#先属性superType， 不为null则返回 
																														#为null则：调用解析类的getGenericSuperclass()再转换@forType()，结果设置到superType，返回它。
																												@再次转发给@forType()：但是入参new FieldTypeProvider()		
																												>再将结果获取它指定嵌套级别的解析类：@getNested()		
																													>转发给统一的@getNested()	
																														>从第二级嵌套开始往上：
																															#如果当前解析类是数组：重新赋值为它的组元素类型@getComponentType()
																															#否则：获取父类，直到没有一般类@hasGenerics()为止：然后获取最后一个解析类getGeneric(index)
																														>最终的解析类则直接返回。
																											#否则用方法参数来构造：methodParameter， @ResolvableType.forMethodParameter()			
																												>统一转发给@forMethodParameter()		
																													#先获取类型@forType()再as()的解析类	
																													#再次@forType(),入参之二new MethodParameterTypeProvider()	
																													#最后再次获取嵌套级别的解析类@getNested()	
																									>获取此时的解析类：解析type:@resolve(), 如果结果和type不相等：那么获取解析类的成分类型的解析类
																										#如果这个成分解析类为null:也返回null
																									>利用成分获取自动绑定map:@findAutowireCandidates():如果结果为null则返回null了。否则要把结果key放到自动绑定names集合中。	
																									>使用类型转换器：转换 上述绑定map的values:@convertIfNecessary(),转换结果不是Object[]则直接返回，否则需要比较器排序后返回：
																										@获取比较器@adaptDependencyComparator()
																											>取依赖转换器dependencyComparator:如果不是OrderComparator类型：直接返回；否则填充资源提供者：@withSourceProvider()中调用@createFactoryAwareOrderSourceProvider()
																										>进一步利用比较器来排序：@Arrays.sort()
																									>直接返回转换结果。
																								#如果是集合类型且是接口：
																									>描述符获取解析类@getResolvableType()，转换为集合.as(Collection.class), 获取第一个元素解析类的Class:@resolveGeneric()
																									#如果这个元素Class为null: 返回不处理。
																									#否则不是null: 获取自动绑定候选map:@findAutowireCandidates(),为null也直接返回，否则也将key放到候选names里，在转换器按需转换@convertIfNecessary()
																									#如果转换结果是List类型：
																										>获取比较器@adaptDependencyComparator()后排序处理.sort()后直接返回。
																									>直接返回转换结果。 
																								#如果类型是Map类型：
																									>描述符获取解析类@getResolvableType()，转换为Map.as(Map.class), 获取第一个元素解析类的Class:@resolveGeneric(0) 即key的类型
																										#如果不是String类型：直接返回null
																									#获取值类型：如果是null返回Null
																									#否则不是null: 获取自动绑定候选map:@findAutowireCandidates(),为null也直接返回，否则key加入候选names集合。
																									>返回获取的自动绑定候选map
																								#其他所有情况返回null。至此多bean解析完成。
																							>此时获取了多bean解析结果：如果不是null,直接返回。否则还有几条尝试。
																							>获取候选map:@findAutowireCandidates()
																								#如果map为空：看描述符是否要求@isRequired()	 如果true即强制要求 要有值：则抛出异常。否则返回null
																									@转发给自动绑定候选解析器autowireCandidateResolver.isRequired()
																										@转发给描述符的@DependencyDescriptor.isRequired() 
																											#如果required顺序为false:则一定是false
																											#否则要继续判断：
																												#如果field属性为null: 看方法参数methodParameter属性是否可选的@isOptional()
																													#参数类型是Optional类型@getParameterType() | 方法参数有可为null注解@hasNullableAnnotation()---获取参数注解列表@getParameterAnnotations() | KotlinDetector之类的检测 $$
																												#否则 看: field的类型是Optional, 方法参数有空注解、Kotlin类型判断 ; 有一个满足都返回“不要求”(不强制有值) $$
																							>如果候选map大小>1: 
																								>获取其中自动绑定的beanName:@determineAutowireCandidate()					
																									>获取描述符的依赖类型：@getDependencyType()	
																										#如果field属性为null: 取方法参数methodParameter后获取嵌套参数类型@getNestedParameterType()
																											#如果嵌套级别>1: 
																												#获取一般方法参数类型@getGenericParameterType() $$	
																												>从2开始递增嵌套级别：如果当前type是ParameterizedType类型：获取真实参数类@getActualTypeArguments(), 获取当前嵌套级别index的Type
																												#如果这个type是Class类型：直接返回。
																												#否则如果是ParameterizedType类型：获取声明类型@getRawType()如果它是Class直接返回。否则就返回Object.class
																													
																											#否则直接按index获取方法参数类型：@getParameterType()
																										#否则不是null:如果嵌套级别<=1:那么直接返回field.getType()声明类
																										#否则嵌套级别>1: 获取field的一般type:@getGenericType()(泛型的参数类型),后面的处理和上述嵌套级别>1的一样。
																									>查询候选中的基础候选：@determinePrimaryCandidate()	
																										-遍历候选的每个：对每个候选：判定是否是基本类型@isPrimary() 
																											>定义map:beanDefinitionMap里包含则：融合后@getMergedLocalBeanDefinition()看primary属性。是则是。
																											#否则看父类bean工厂：如果是DefaultListableBeanFactory类型，且递归@isPrimary()找到是：则是。
																										>如果是基本类型：先将候选设置给基本类型beanName, 后面不断覆盖：其实只会出现一个在定义map里：否则超过一个要抛出异常new NoUniqueBeanDefinitionException()。	
																									#基础候选不为null:直接返回这个基础候选。	
																									#否则查看最高优先级候选：@determineHighestPriorityCandidate()
																										-遍历候选的每个：对每个候选的key-val: 看val这个bean实例的优先级@getPriority()
																											>先获取依赖比较器：@getDependencyComparator()如果是OrderComparator类型，那么就可以有序：@AnnotationAwareOrderComparator.getPriority(Object obj)
																												#如果是Class类型：@OrderUtils.getPriority() 使用了缓存模式
																													>获取优先级注解：@AnnotationUtils.findAnnotation() 这个注解类为："javax.annotation.Priority"
																													>从这个注解里获取注解属性值--value属性的值：@AnnotationUtils.getValue() 这个就是优先级，缓存后可以返回了。
																												#否则用obj的Class来获取优先级:@OrderUtils.getPriority()
																												#如果优先级还是为null: 则看能否用装饰类来解决：要求是DecoratingProxy类型，然后才能获取装饰类getDecoratedClass(),然后来获取优先级@OrderUtils.getPriority()			
																										>如果优先级不是null: 同样如果发现两个优先级相等，那么抛出异常NoUniqueBeanDefinitionException() 否则找出最小值的优先级对应的bean：即最高优先级。
																									#优先级候选不是null:返回它 
																									#回落措施：遍历每个候选，进行以下处理：
																										#如果解析依赖map:resolvableDependencies包含, 且候选的别称集合包含描述符的依赖name:@matchesBeanName() ::则直接返回这个候选。
																									>此时就只有返回null
																								>如果寻找的这个候选不为null:那么直接用name从候选map:里查出来即可 就是候选实例。						
																								#否则考虑直接返回：先进行一些处理：
																									#如果要求有值@isRequired() 或者 类型不是多bean: @indicatesMultipleBeans()
																										>那么使用描述符解析：@DependencyDescriptor.resolveNotUnique() 内容为抛出异常new NoUniqueBeanDefinitionException()
																									#否则返回null
																							#否则候选<=1: 直接获取候选k-v
																							>自动绑定names集合增加：解析出来的自动装备beanName
																							#如果候选是Class类型：							
																								#使用描述器解析：@resolveCandidate()	得到候选。										
																							#如果此时候选是NullBean类型：描述符要求有值，那么就抛出异常。其他都值设置为null
																							#如果解析结果不能赋值给type:那么 抛出异常：new BeanNotOfRequiredTypeException()	
																							>最后finally一定会做的事情：将设置描述符之前的内容设置回去ConstructorResolver.setCurrentInjectionPoint()												
																					#否则如果描述符的依赖类型是ObjectFactory 或者ObjectProvider： 那么直接返回一个实例:new DependencyObjectProvider()														
																					#否则如果描述符的依赖类型是javax.inject.Provider类型：	那么间接new Jsr330Factory() 调用@createDependencyProvider()--内部new 一个Jsr330Provider()对象													
																					#否则其他所有的情形：
																						>先用自动装配解析器获取懒加载的代理：@getLazyResolutionProxyIfNecessary()
																							@先看是否懒加载：@isLazy()如果是懒加载：那么执行懒加载获取代理。否则返回null。	
																								#从所有注解中查看是否带有Lazy.class注解：有返回true 		
																								#否则查看方法上的注解是否有Lazy.class注解：有返回true												
																							@构建懒加载获取代理：@buildLazyResolutionProxy()	直接返回。												
																								#构建一个资源：new TargetSource	()对象；
																								#构建一个代理工厂ProxyFactory: 设置ts;描述符的依赖类型@getDependencyType() 如果是接口，也要设置到pf里；
																								>创建代理：@.ProxyFactory.getProxy()
																									@转发@createAopProxy()
																										@激活@activate(): 设置属性active，也发送通知：调用所有的监听器：AdvisedSupportListener执行.activated()方法。
																										>使用aop工厂创建代理：@DefaultAopProxyFactory.createAopProxy()	返回代理。
																											#只要满足：充分使用、代理目标类、无用户提供代理接口：									
																												#如果目标类是接口，或者已经是一个代理类(代理缓存中)：	返回jdk动态代理：new JdkDynamicAopProxy(config)							
																												#其他情况：使用cglib来代理：new ObjenesisCglibAopProxy()								
																											#否则都是用jdk动态代理：new JdkDynamicAopProxy()									
																									@得到的代理获取代理实例：@getProxy():	JdkDynamicAopProxy/CglibAopProxy两类实现：										
																							>如果此时得到的代理是null: 重新解析依赖@doResolveDependency()	
																						>返回代理。	
																			#如果参数值类型是String：直接bean工厂评估：@evaluateBeanDefinitionString()
																			>用转换器按需转换：@convertIfNecessary()
																			>转换结果设置到相应的结果参数位置。遍历完成，直接返回结果参数数组。							
																>此时argsToUse基本不是null了，但是可以可能是null: 为了预备，要额外做些工作；同时如果mbd.resolvedConstructorOrFactoryMethod为null也要相同的一些工作：	来决定使用的工厂方法和方法参数。									
																	>从工厂类Class中寻找满足方法参数的方法：工厂类首先需要获取到非cglib代理类：@ClassUtils.getUserClass(cls) 即如果name包含$$取它的父类。
																		@从工厂类中获取候选方法数组：@getCandidateMethods()
																			#待权限框架的判断：是否允许访问非公开构造方法：
																				#如果是：那么反射方式获取工厂类及其父类的所有declare方法：@ReflectionUtils.getAllDeclaredMethods()
																					@统一转发给标准入参方法@doWithMethods()
																						#获取本类宣称方法和继承的接口方法合并起来：@getDeclaredMethods() 使用缓存模式。
																						>遍历方法数组：并且用@doWith()过滤---设置到方法回调入参的注解和发现的方法。
																						>遍历完成：开始两次递归。第一次：父类递归@doWithMethods() 第二次：如果cls是接口那么获取所有接口每个都递归@doWithMethods()
																					>将获取的方法列表转数组返回：List<Method>.toArray(new Method[0])
																				#否则不是：则反射方式获取工厂类的所有方法：getMethods()--包括继承的公开方法。
																		>遍历这个方法数组：过滤查找：是静态方法且和mbd的工厂方法名同，那么加到候选方法列表里。								
																		#如果这个候选列表长度为1：则再加些条件，就可以简单处理而返回了。额外条件为：explicitArgs==null且mbd无构造方法参数值
																			#满足则取出这个候选：确认参数数量为0：开始设置设置方法：mbd.factoryMethodToIntrospect=这个候选方法；mbd.resolvedConstructorOrFactoryMethod=这个候选 ；额外的mbd.constructorArgumentsResolved = true;mbd.resolvedConstructorArguments = EMPTY_ARGS;
																				>开始设置bw的bean实例：需要实例化：统一调用@ConstructorResolver.instantiate()
																					@统一转发给bean工厂的初始化策略InstantiationStrategy的实例化方法：@instantiate()
																						#先带权限框架的设置工厂方法可访问：
																						#方法反射调用前：设置线程局部变量currentlyInvokedFactoryMethod.set(fm)为当前工厂方法	
																						#方法反射执行：factoryMethod.invoke(factoryBean, args)	反射结果如果为null设置为NullBean()			
																						#方法反射调用后：设置线程局部变量currentlyInvokedFactoryMethod.set(old)为之前的值 。				
																					>设置到beanInstance()：额外的事：wrappedObject=rootObject=获取的初始化值。类型转换器typeConverterDelegate=new TypeConverterDelegate()而cachedIntrospectionResults设置=此值的Class					
																				>设置完成就返回bw
																		#此时考虑候选列表超过1：先列表排序：@AutowireUtils.sortFactoryMethods()按照：方法修饰公到私,方法参数多到少 二级排序。
																			>设置最小参数量minNrOfArgs：一般是explicitArgs.length否则如果explicitArgs是null:需要专门处理：
																				#如果mbd有构造方法参数值：调用@resolveConstructorArguments()来解析。结果赋值给minNrOfArgs
																					>类型转换器的获取和设置到一个new BeanDefinitionValueResolver():入参加ConstructorArgumentValues一个参数值容器：
																					>遍历构造方法索引参数值map:键是索引index即参数位置, 值是ConstructorArgumentValues.ValueHolder				
																						#如果index大于	minNrOfArgs,那么这个minNrOfArgs要更新为index			
																						#如果值已经转换：k-v加入 入参参数值容器索引参数值集合。					
																						>否则没有转换：将值转换一下@ConstructorResolver.resolveValueIfNecessary(),也设置到入参参数值容器		
																					>遍历构造方法一般参数值map：此时目的是增加到入参参数值容器。					
																						#如果valueHolder已经转换过，则直接加入参数值容器一般参数值集合。
																						#否则没有转换：按需转换@BeanDefinitionValueResolver.resolveValueIfNecessary(),转换之后再增加到 入参参数值容器。
																				#否则没有构造参数值：直接赋值minNrOfArgs=0			
																		>开始遍历排序后的候选方法列表：检错和 一些参数的确定。
																			#获取方法参数类型列表：如果此列表>minNrOfArgs:那么满足要求需要处理：比如argsHolder的确定
																				#如果explicitArgs不是null: 那么需要匹配，如果explicitArgs长度和方法参数列表长度不相等；直接continue;	
																					#否则长度相等：直接 new ArgumentsHolder(explicitArgs)赋值给argsHolder。。。ACC_SYNTHETIC由编译器生成的方法的方法在反射中的标记。
																				#否则需要解析构造参数：类型转换和必要的自动绑定；从测试环境获取参数名发现器DefaultParameterNameDiscoverer：注入discover: StandardReflectionParameterNameDiscoverer/LocalVariableTableParameterNameDiscoverer/KotlinReflectionParameterNameDiscoverer 。遍历每个discover:
																					@统一获取方法参数名：@AnnotationParameterNameDiscoverer.getParameterNames(Method method)
																						@先统一获取入参桥接方法的原来的方法：@BridgeMethodResolver.findBridgedMethod()
																							#如果入参方法不是桥接方法：不处理。返回。
																							-否则一定是桥接方法：
																							>获取桥接方法的所在类的所有方法：@ReflectionUtils.getAllDeclaredMethods()			
																							>遍历这个所有方法集合：先得到一个候选集合：@isBridgedCandidateFor()			
																								#显然这个候选方法：不能还是桥接方法、名字必须相等于桥接方法名、方法参数个数一定相等		
																									#满足上述条件，加入；否则忽略。
																							-此时就得到了同名非桥接且同参数量的候选方法集合：
																							#如果此候选集合大小为1：直接返回这个元素。
																							#否则从候选集合里查找合适的：@searchCandidates()
																								#遍历此集合：对每个候选处理：
																									#@匹配检查@isBridgeMethodFor()
																										@函数签名检测：@isResolvedTypeMatch()
																											#参数类型检测：方法的参数列表对应的类型列表 个数比较，不同返回false，相同则遍历：
																												#只要有一个参数类型不一致：就返回false
																												#如果参数类型是数组：那么如果数组类型元素不一致也返回false;
																											#此时则认为名、参数个数且类型都相同，返回true 
																										#如果结果为true, 检查通过，返回true 
																										#否则检测桥接方法的父类和所在类继承的接口的方法：认为也是相同的：所以查找所有的父/接口方法：@findGenericDeclaration()
																											@从父类中寻找匹配候选的方法：@searchForMatch()
																												#如果找到了同名同参数类型的非桥接方法：那么返回这个方法。
																											>如果父类没有寻找到这个方法，那么递归父类的父类来寻找。直到Object.class
																											#否则开始检测接口：获取所有接口：@ClassUtils.getAllInterfacesForClass() 然后在接口方法里搜索匹配@searchInterfaces()
																												@接口方法里匹配：@searchForMatch()
																												#如果没有匹配到：那么使用接口的接口来递归寻找：@searchInterfaces()
																											>直接返回。 
																										#返回结果。
																							#返回结果 
																						@再寻找方法的参数名数组：@lookupParameterNames()
																							@各个参都可能有多个注解：所以先获取这些注解，统一转发给特定方法@ParameterNameFactory.findParameterAnnotations()
																								>使用反射方式获取所有参数的所有注解：@getParameterAnnotations()		
																								>遍历所有的参数：对每个参数的注解数组：@发现合适的参数名@findParameterName()		
																									#合适的标准为：注解名在属性set:annotationClassesToUse中，则返回这个注解的“value”属性。
																								>以此获取所有的参数名。返回参数名数组。 	
																						#没有找到：则找所在类的接口某个匹配到的方法：进行@lookupParameterNames()	而返回。		
																					@第二种：	StandardReflectionParameterNameDiscoverer.getParameterNames()				
																						>最简单的通过反射获取参数列表@getParameters()：然后获取参数名getName()。			
																					@第三种：	LocalVariableTableParameterNameDiscoverer.getParameterNames()	使用了缓存模式。		
																						@获取桥接方法的原始方法：@BridgeMethodResolver.findBridgedMethod()			
																						>按缓存有无：而获取/保存到缓存：获取方法所在类的log信息：@inspectClass()			
																							>获取类名进一步类字节码输入流：@Class.getResourceAsStream() 没有输入流返回空map
																							#否则封装输入流到ClassReader对象，调用@accept(new ParameterNameDiscoveringVisitor())入参就有map,结果就会放入这个map
																								@统一转发给@accept()获取字节码的元素结构：从字节码的字节数组里获取：字节数组属性@b里取。
																									>依次获取的信息：flags/本类名/父类名/接口名数组，所有的属性/EnclosingMethod/运行时可见的注解/嵌套属性/接口属性/一般的成员属性+方法  
																										#内部有关于合成/桥接/静态方法的判断：通过标记常量如spring.asm中的Opcodes.ACC_SYNTHETIC
																										#而在内部引用的new LocalVariableTableVisitor()类中：有存放到map的信息方法：@visitEnd()里面的key:Member获取：@resolveMember() 值就是参数名数组
																											#如果方法名是构造方法：<init>那么返回这个类的构造方法@getDeclaredConstructor()
																											#否则：一般方法：返回名称和参数类型数组都匹配的方法@getDeclaredMethod() 因为Method本身也实现了Member接口
																							>返回map 		
																						>按map的含义：就返回value:参数名数组。	
																				>给参数持有者argsHolder	赋值：而调用@createArgumentArray() 即给构造方法/工厂方法的入参数组。同时传入的还有解析后的全部参数值ConstructorArgumentValues对象：前面通过@resolveConstructorArguments()方法已经获取并存入。 					
																					>遍历参数类型数组：对每个参数类型:				
																						>通过参数值对象 获取这个参数类型对应的参数值ConstructorArgumentValues.ValueHolder：@getArgumentValue()			
																						#如果值为null: 那么补偿：如果非自动绑定，那么退一步从一般参数值数组里找到匹配的参数值：@getGenericArgumentValue() 其他参数使用过则忽略这个值。
																						#此时如果值holder不是null:	
																							#如果值已经转换：获取转换值，设置到属性preparedArguments[]里。	
																							#否则手动转换：
																								>先获取方法参数：@MethodParameter.forExecutable()	直接new MethodParameter()放入Method即可。	
																								>调用转换器按需转换：@convertIfNecessary()得到转换值	
																								>虽然没有转换，但是可以获取源持有者：如果它是ConstructorArgumentValues.ValueHolder类型：那么直接获取值getValue() 再设置到preparedArguments属性里。resolveNecessary = true
																							>转换值再次设置到arguments属性，而原始值设置到rawArguments属性。		
																						#否则值holder是null: 此时如果非自动绑定，则要抛出：new UnsatisfiedDependencyException()否则才下一步处理：
																							>再次获取方法参数：@MethodParameter.forExecutable()
																							>作为入参调用获取自动绑定的解析值：@resolveAutowiredArgument()	前面已经讲述过程。此值赋值给rawArguments/arguments, 而preparedArguments=new AutowiredArgumentMarker()新值。resolveNecessary=true	
																					>在自动绑定参数解析的时候可能填充了自动绑定beans集合：此时需要对这些beanName注册依赖于入参beanName。@registerDependentBean() 第一个入参依赖第二个入参。		
																					>返回各个参数值数组的容器：ArgumentsHolder
																				>开始确定使用哪个工厂方法、参数值：
																					#是否进行宽大的构造方法解析:而不是严格的模式。
																						#是则进行@参数值.getTypeDifferenceWeight() 入参：参数类型
																							>两个权重差决定：每个权重都由：@MethodInvoker.getTypeDifferenceWeight()决定，入参主要为arguments/rawArguments
																								#权重高低决定：遍历参数类型数组：对每个参数类型： 
																									#如果值不可以赋值给参数类型：直接返回最大整数。
																									#参数值不为null: 寻找参数值的父类Class,如果和参数类型相等/可以赋值给参数类型，权重值+2；递进获取父类的父类，一直到相等位置获取null
																									#如果参数值类型是接口，那么权重值还要+1。
																								>可见权重值就是参数值和参数类型的类型相似层次最小的匹配程度。
																							>返回更小的那个权重。
																						#否则进行严格的计算模式：@getAssignabilityWeight()		
																							>对arguments匹配：只要一个不能对应赋值，返回最大整数。
																							>否则对rawArguments匹配：只要一个不能对应匹配，返回最大整数-512
																							#否则返回最大整数-1024
																				#只要权重不是最大整数：则使用之前计算的工厂/参数		
																				#否则：进一步判断：如果参数类型和工厂方法参数类型不匹配、严格模式：那么就认为是工厂方法是含糊的：需要记录到ambiguousFactoryMethods变量。
																		>退出循环，开始进一步的判断：判断待使用的工厂方法是否为null:如果是：那么进行以下处理：
																			#如果在前面的参数名解析时报错了：那么需要在这里：增加异常到bean工厂：onSuppressedException().并进一步抛出异常。
																			#只要explicitArgs不是null:封装参数类型名列表：从explicitArgs					
																			#否则如果是null:进一步如果解析值resolvedValues不是null：继续封装参数类型列表：从它的索引参数值列表+一般参数值列表 遍历中获取。					
																			>转换上述参数集合为逗号分隔字符串：封装抛出错误：new BeanCreationException()					
																		#否则如果待用工厂方法返回值是void.class类型：也抛错误:new BeanCreationException()
																		#否则如果含糊工厂方法名集合ambiguousFactoryMethods不是null: 也要抛出错误：new BeanCreationException()
																		>此时：都正常了。则只要explicitArgs == null && argsHolderToUse != null：那么设置mbd.factoryMethodToIntrospect = factoryMethodToUse 同时参数值holder要缓存一下@storeCache()--将对mbd里各值调整、转移。
																			>调整为：resolvedConstructorOrFactoryMethod=入参值， 已经解析constructorArgumentsResolved=true, 如果需要解析resolveNecessary=true:则preparedConstructorArguments=preparedArguments；否则resolvedConstructorArguments=arguments
																>此时如果argsToUse还是null，就要抛出状态错误：new IllegalStateException()工厂方法参数未解析。								
																>否则此时：就可以开始实例化并设置了：工厂方法方式实例化@instantiate()，然后设置到bw里：@setBeanInstance()							
															>到此：终于完成了工厂方法的实例化，直接返回到：@createBeanInstance()										
														-此时则既没有实例提供者、也没有工厂方法：但是mbd中的某些属性可能可以利用来实例化：
														#如果mbd.resolvedConstructorOrFactoryMethod	不是null: 那么考虑用它来实例化：进一步区分：
															#如果参数已经解析：constructorArgumentsResolved=true:则认为可以使用自动绑定构造方法来实例化：统一调用@autowireConstructor()
																@转发统一调用@new ConstructorResolver(this).autowireConstructor() 此方法非常类似@instantiateUsingFactoryMethod()
																	#用bean工厂对bw进行初始化：如注册一些属性编辑器：@initBeanWrapper()								
																	#由于上述两个mbd参数值:所以这里获取待使用的参数值：赋值给argsToUse=mbd.resolvedConstructorArguments如果为null 则argsToUse需要重新赋值：用一个未解析的参数数组，所以需要先解析：调用@resolvePreparedArguments()入参为mbd.preparedConstructorArguments 结果就是解析了的：赋值给argsToUse
																	#此时如果argsToUse还是null(根据入参，是可能的): 
																		#由于入参中：候选的构造方法是null:所以需要重新设置：直接反射的方式从mbd.getBeanClass()获取getDeclaredConstructors()--允许访问私有方法，或者getConstructors()						
																		#此时如果经过设置候选构造方法一定不是null了：如果长度为1，(大概率走这里) 且mbd没有构造方法参数：那么可以考虑直接用无参构造方法实例化：同样也是设置resolvedConstructorOrFactoryMethod=候选,constructorArgumentsResolved=true属性后，新设置resolvedConstructorArguments=空数组，开始实例化和设置：@instantiate()之后mbd.setBeanInstance()就可以直接返回了。
																		#否则候选构造方法多于1：考虑解析构造方法：同样也是解析构造方法参数值设置到ConstructorArgumentValues对象，@resolveConstructorArguments()	
																		>进一步排序候选：@AutowireUtils.sortConstructors()	公共方法前面/都公共时参数多前面
																		>开始遍历候选：对每一个候选：
																			#过滤参数长度不匹配的：
																			#如果解析值不是null: 
																				>获取注解的方式获取参数名数组：@ConstructorPropertiesChecker.evaluate()
																					>即获取ConstructorProperties注解，然后取注解的value值，为一个字符串数组，自然要比较长度。长度不匹配抛状态异常：new IllegalStateException()。					
																				>如果获取的参数名数组是null:补救措施：获取bean工厂的getParameterNameDiscoverer()参数名发现者，调用它的@getParameterNames()方法解析获取，同上。
																				>类似的，再次构造参数值数组：@createArgumentArray()赋值给argsHolder; 入参之一为：@getUserDeclaredConstructor()---通过候选所在类--如果cblib代理则父类的反射方式获取参数类型匹配的构造方法即可。
																			#否则解析值是null: 则直接argsHolder = new ArgumentsHolder(explicitArgs)新建赋值。后面类似继续寻找匹配的近似高的候选：有调用@getTypeDifferenceWeight()之类。没有相似则添加候选到ambiguousConstructors模糊集合。
																		>看此时待使用的构造方法：如果是null:要抛异常new BeanCreationException()/UnsatisfiedDependencyException	
																		#否则如果有模糊的构造方法 且 严格模式构造：那么抛异常：new BeanCreationException()
																		>同理在explicitArgs == null && argsHolderToUse != null时 转存属性@storeCache()
																	>此时如果argsToUse还是null：状态异常抛出。new IllegalStateException()
																	>否则此时：就可以开始实例化并设置了：工厂方法方式实例化@instantiate()，然后设置到bw里：@setBeanInstance()			
															#否则构造方法参数值没有解析：constructorArgumentsResolved=false 则用默认构造方法实例化：@instantiateBean()				
																>带安全框架的执行：@getInstantiationStrategy().instantiate()来实例化。此时考虑@SimpleInstantiationStrategy.instantiate()实例化方法：
																	#如果没有覆盖方法：
																		#是接口要抛异常：new BeanInstantiationException()
																		#否则带安全框架的反射获取构造方法：@.getDeclaredConstructor()	赋值给解析构造方法mbd.resolvedConstructorOrFactoryMethod属性。
																		>统一的实例化接口@BeanUtils.instantiateClass()调用后直接返回。
																	#否则有覆盖方法：则方法注入后实例化：需要使用字节码工具，借助cglib封装的asm，于是调用@instantiateWithMethodInjection()方法完成实例化，直接返回。 
																		@统一转发给CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection()
																			>统一转发给：@new CglibSubclassCreator(bd, owner).instantiate()
																				#创建mbd的增强子类：@createEnhancedSubclass()
																					>新建new Enhancer()；@setSuperclass(mbd.getBeanClass())
																					>设置命名策略：SpringNamingPolicy.INSTANCE
																					>如果bean工厂是ConfigurableBeanFactory类型：设置策略：new ClassLoaderAwareGeneratorStrategy()
																					>设置回调过滤器：setCallbackFilter(new MethodOverrideCallbackFilter()---过滤覆盖方法类型)	
																					>设置方法拦截类：setCallbackTypes() LookupOverrideMethodInterceptor---拦截目的：bean工厂获取mbd获取的LookupOverride类型的方法的beanName对应的bean；。ReplaceOverrideMethodInterceptor---拦截目的：mbd中获取ReplaceOverride类型方法，从bean工厂获取MethodReplacer为要求类型的同名的bean
																					>创建类：createClass()	并返回			
																				#此时获取到了cblig创建的子类：如果入参构造方法为null: 则直接@BeanUtils.instantiateClass()统一实例化
																				#否则构造方法不是null:反射获取参数类型匹配的构造方法@getConstructor().newInstance()实现构造。
																				>在这个实例上设置增加回调：而不是在增加类上设置：为了避免内存泄漏：先强转实例为Factory类型：然后设置3个回调：setCallbacks():NoOp.INSTANCE/new LookupOverrideMethodInterceptor/new ReplaceOverrideMethodInterceptor
																				>如此之后，才返回实例。
																>此时有了实例：则构造bw包装：new BeanWrapperImpl() 然后初始化即可：@AbstractBeanFactory.initBeanWrapper() 内容也是注册转换服务和用户定制属性编辑器。
														>剩下的工作：有可能还有 候选构造方法自动绑定：所以先确定构造方法：@determineConstructorsFromBeanPostProcessors()		
															#查出所有的实例化感知后置bean处理器：遍历它：对每个：bean后置处理器：				
																#如果是SmartInstantiationAwareBeanPostProcessor类型：
																	@转发决定：@determineCandidateConstructors()
																		>检查lookup方法-使用缓存方式：@ReflectionUtils.doWithMethods():即对该Class的所有方法在匹配情况下进行回调：回调执行：	
																			>查询方法上的Lookup.class注解：一旦找到：那么封装到new LookupOverride()里并设置到mbd.getMethodOverrides().addOverride()里。
																		>继续采用缓存方式寻找候选构造方法：缓存为candidateConstructorsCache：key为class	
																			>预备候选为：kotlin class的构造方法：@BeanUtils.findPrimaryConstructor()
																				>只有一个KotlinDelegate.findPrimaryConstructor()
																					>首先：KClasses.getPrimaryConstructor(JvmClassMappingKt.getKotlinClass(clazz))有返回
																					#没有则：ReflectJvmMapping.getJavaConstructor(primaryCtor) 有返回																		
																			>首先候选为：反射获取getDeclaredConstructors() 多个：遍历：对每个候选：
																				>统计非合成方法数：
																				#否则是合成方法：进一步如果基础构造方法不是null,如下，那么continue;
																				>获取候选构造方法的注解属性：@findAutowiredAnnotation()
																					>遍历属性autowiredAnnotationTypes，对每个自动绑定注解类，获取融合的注解：@AnnotatedElementUtils.getMergedAnnotationAttributes() 得到注解属性AnnotationAttributes，如果不是null,立即返回。
																				#如果注解属性为null:重新赋值：尝试用用户定义类ClassUtils.getUserClass()来获取：获取匹配参数类型的构造方法@getDeclaredConstructor()后也@findAutowiredAnnotation()来获取注解属性 
																				#如果此时注解属性不是null: 考虑加入结果候选：
																					#但如果要求构造requiredConstructor不是null,要抛异常：	new BeanCreationException()
																					#如果注解不包含required属性或者required==true:即等同于@determineRequiredStatus()那么就有可能抛异常：
																						#再检查结果候选列表不是null:那么抛出异常：new BeanCreationException()
																						#否则设置requiredConstructor为这个候选。
																					>候选加入结果候选列表。
																				#否则注解属性是null: 则进一步看参数个数是0？是则设置defaultConstructor=这个候选。
																			>退出循环：如果候选不是空：
																				#要求构造为null：
																					#defaultConstructor!=null: 那么直接加入候选。	
																					#否则打些日志
																				#候选列表转数组---将要返回的。
																			#否则如果候选rawCandidates长度为1：且第一个元素的参数个数>0, 则赋值给candidateConstructors = new Constructor<?>[] {rawCandidates[0]}
																			#否则如果非合成方法数统计为2：基础构造和默认构造都非空且不相等：那么两个都赋值给candidateConstructors = new Constructor<?>[] {primaryConstructor, defaultConstructor};
																			#否则如果非合成方法数统计为1：基础构造非空：那么拿他赋值：candidateConstructors = new Constructor<?>[] {primaryConstructor}
																			#否则只能赋值为空：candidateConstructors = new Constructor<?>[0]
																			>缓存到candidateConstructorsCache
																		>返回这个候选构造数组：candidateConstructors
																	>结果不是空：直接返回这个构造方法数组。
															>到这里就只能直接返回null了。															
														>此时如果得到的构造方法数组不是null: 或者mbd解析模式是自动绑定构造方法 或 入参args非空 或者 mbd有构造方法参数值：都可以考虑 补救：调用@autowireConstructor()	结果直接返回。						
														#否则：继续补救：看mbd.getPreferredConstructors()偏好构造方法：如果不是null,那么也用来自动构造：@autowireConstructor()结果直接返回。							
														#否则：考虑直接实例化了；@AbstractAutowireCapableBeanFactory.instantiateBean()	有述，略。返回@AbstractAutowireCapableBeanFactory.createBeanInstance()
												>事情2：应用 对合并后的bean定义 修改的 所有后置处理器：mbd.postProcessed标记是否已经应用过了---因为只应用一次：@applyMergedBeanDefinitionPostProcessors()
													>遍历bean后置处理器：AbstractBeanFactory.beanPostProcessors属性保存：对每个bean处理器：
														#如果是MergedBeanDefinitionPostProcessor类型：则开始调用修改方法@postProcessMergedBeanDefinition()
															#分不同的实现类：@AutowiredAnnotationBeanPostProcessor实现类的处理：
																>获取自动绑定的元数据：@findAutowiringMetadata() 采用缓存模式，key=beanName 
																	#如果需要刷新：即没有元数据或者目标类已经改变：需要重新构建元数据
																		>首先就是清除元数据对象InjectionMetadata里的属性值PropertyValues对象：
																		>然后构建并注入属性：@buildAutowiringMetadata() 主要是注入元素列表list:InjectionMetadata.InjectedElement
																			>获取Class的所有宣称的Field属性并回调执行注入的lamda表达式的框架调用：@ReflectionUtils.doWithLocalFields()， 其中注入的lamda表达式：对field的处理为：
																				>获取Field上的所有自动绑定注解(三个@Autowired/@Value/@javax.inject.Inject)：@findAutowiredAnnotation()
																					#遍历这三个注解Class: 对每个都先获取融合注解属性：@getMergedAnnotationAttributes() 只要结果不是null，那么退出遍历循环，直接返回结果。 前面已经描述。 但有必要再次描述大略：
																						#通过MergedAnnotationAttributesProcessor.postProcess()给AnnotationAttributes.put(attrName, value)注入属性键值对-转换后的值。
																						#通过AnnotationUtils.postProcessAnnotationAttributes()再次给AnnotationAttributes.put(attrName, value)注入属性键值对-转换后的值。
																				#如果注解属性不是null:那么需要处理：
																					#如果是静态方法：忽略
																					#否则再看注解属性中的"required"属性的值:new AutowiredFieldElement(field, required)来注入然后将对象加入一个列表。
																			>获取Class所有宣称方法并遍历处理：回调注入的lamda表达式处理每个方法的处理框架：ReflectionUtils.doWithLocalMethods()	注入的lamda处理为：
																				#获取桥接方法的原始方法：@BridgeMethodResolver.findBridgedMethod()
																				>从参数类型是否一致来判定桥接方法和原始方法是否一致：BridgeMethodResolver.isVisibilityBridgeMethodPair()如果不一致，那么直接不处理。
																				#否则一致：也开始寻找方法上的自动绑定注解@findAutowiredAnnotation()
																					#如果不是null：则先获取目标类中同名/同方法参数类型的方法：@ClassUtils.getMostSpecificMethod(),然后和本方法比较--如果相等：需要处理：
																						#同样：静态方法不处理：直接返回
																						#0参数方法发出告警信息：继续处理 
																					#获取注解的required值：获取桥接方法对应的属性描述：@BeanUtils.findPropertyForMethod();;认为这种方法就是get/set方法 
																						#先以内省的方式从BeanInfo.getPropertyDescriptors()获取到属性描述数组PropertyDescriptor[]，然后遍历: 对每个元素，重新包装为GenericTypeAwarePropertyDescriptor类型--注入属性的读方法/写方法/编辑类
																							#而BeanInfo的生成：是new Introspector().getBeanInfo()--里面基础信息获取后封装到new GenericBeanInfo()而直接生成的。内省机制Introspector.getBeanInfo(class)。$$$$
																							>返回匹配到的属性描述PropertyDescriptor对象。
																						>遍历这个属性描述数组：如果某个属性描述的读方法/写方法和入参方法相等：那么就直接返回这个属性描述。
																						>否则就返回null
																					#将属性描述封装到new AutowiredMethodElement()对象里，然后加入InjectedElement元素列表。
																				>框架回调返回。
																			>获取目标类的父类：继续循环：进行两次宣称回调；直到父类为null或者Object。并且每次的元素列表都防止最前面；
																			>退出循环后：将元素列表封装到new InjectionMetadata()里，并返回
																		>缓存这个元数据后：返回。 
																	>返回。 
																>调用元数据的检查方法：@checkConfigMembers()
																	>使用元数据里的元素列表：遍历这个元素列表：对每个元素InjectedElement， 
																		>取对应的Member
																			#如果不是外部管理配置的：@mbd.externallyManagedConfigMembers():则注册：@registerExternallyManagedConfigMember() 加入externallyManagedConfigMembers属性; 并加入检查过的元素集合：set:checkedElements里。
																>返回 		
												>事情3：提前缓存单例：先判断是否允许暴露“提前单例”：mbd是单例 且 AbstractAutowireCapableBeanFactory.allowCircularReferences ==true 且 单例正在创建中@isSingletonCurrentlyInCreation()---即当前单例池中包含：DefaultSingletonBeanRegistry.singletonsCurrentlyInCreation
													#如果上述判断结果是true: 一是打印日志。二是修改单例池相关：@addSingletonFactory()
														#如果单例池singletonObjects没有包含：则加入单例工厂池singletonFactories：key=beanName, value=构造的一个工厂方法；提前单例对象池earlySingletonObjects要移除这个beanName; 已经注册的单例池registeredSingletons：添加。
															#上述的单例工厂方法如下：是一个lamda表达式：()->获取提前bean引用@getEarlyBeanReference()
																#只要mbd非合成 且 有 实例化感知 bean后置处理器：那么就要处理：遍历所有的bean后置处理器：对每个处理器，如果是SmartInstantiationAwareBeanPostProcessor类型： 则继续处理：调用它的提前bean应用接口@getEarlyBeanReference() 应用的结果就是下一次的入参--继续代理：相等于层层代理, 对于AbstractAutoProxyCreator实现：
																	>获取缓存key：Class或者原生beanName(FactoryBean类型要加&开头)
																	>此key加入提前代理池earlyProxyReferences里：
																	>有必要包装一下：@wrapIfNecessary()
																		#beanName不是空 且 目标源beans池Set:targetSourcedBeans包含bn：那么没必要包装
																		#或者通知beans Map:advisedBeans中取缓存key的值是true: 也没必要包装。
																		#或者是不应该被代理的基础设施类：@isInfrastructureClass():Advice/Pointcut/Advisor/AopInfrastructureBean：那么通知beans Map存放这个类：值为false。同时返回不包装。
																		#或者是应该忽略的类：即类名以.ORIGINAL结尾：@AutoProxyUtils.isOriginalInstance() 同上处理：
																		#其他情况下的类需要包装：包装就是注入通知：@getAdvicesAndAdvisorsForBean(), 以spring aop框架下的BeanNameAutoProxyCreator为例：看实现
																			#首先已经注入了一个需要代理的beanName的特征的集合list：beanNames, 遍历这个集合，对每个匹配模式，看是否和准备代理的beanName/class匹配，然后才代理：
																				#如果待代理类是FactoryBean类型：但模式name不是以&开头：继续循环。否则是&开头：则取&后面的模式为新的模式
																				>对此时的模式name和beanName进行匹配：@isMatch() 如果匹配到了，那么返回空数组：认为没有额外的拦截器，返回无需拦截器的代理标记。
																					>内容就是看beanName是否包含模式：@PatternMatchUtils.simpleMatch()包含则匹配。
																				#否则此时没有匹配：查bean工厂：查出beanName的别名数组：遍历别名数组：对每个别名，也看是否和模式匹配：@isMatch()，如果匹配那么也同样返回空数组：认为无需拦截器的代理。
																			>到此：则认为无需代理：返回null 
																		#如果结果是无需代理：那么什么也不做：
																		#否则要代理：首先advisedBeans通知beans要增加：key=cacheKey,value=true ;然后创建代理@createProxy(), 创建的代理存入map:proxyTypes属性：key=cacheKey,value=代理实例的Class。返回这个代理。
																			#如果beanFactory是ConfigurableListableBeanFactory类型：那么需要在beanDefinition里增加一个属性kv: 具体调用@AutoProxyUtils.exposeTargetClass()
																				#如果beanFactory包含这个beanName：那么需要在合并定义@beanFactory.getMergedBeanDefinition()之后增加一个属性：key="AutoProxyUtils.originalTargetClass", v=targetClass
																			#开始真正的代理：创建代理工厂：new ProxyFactory() 先获取一些配置信息@copyFrom(this)就从当前配置类
																			#如果不是代理目标类：@isProxyTargetClass()--默认为false: 	
																				#判断是用bean的目标类进行代理还是用bean的接口：@shouldProxyTargetClass()
																					#beanFactory是ConfigurableListableBeanFactory类型 且转发确认 @AutoProxyUtils.shouldProxyTargetClass() 返回true
																						#返回应该的条件：beanFactory包含这个bean定义 且 定义里的属性"AutoProxyUtils.preserveTargetClass"=true 
																					#其他情况返回false
																				#如果是用目标类：直接代理工厂设置属性：proxyFactory.setProxyTargetClass(true);
																				#否则评估代理接口：@evaluateProxyInterfaces()
																					#获取bean类的所有接口：遍历：对每个接口类：
																						#看是否是一个合理的代理接口：@isConfigurationCallbackInterface() 容器配置回调则不是合理的。不合理的包括：InitializingBean/AutoCloseable/DisposableBean/Closeable/接口里有Aware：@ObjectUtils.containsElement() 
																						#看是否是一个内部语言接口：@isInternalLanguageInterface() 是内部语言接口那么是不能代理的。这些接口类包括：name: 相等于groovy.lang.GroovyObject， 结尾与.cglib.proxy.Factory，结尾于.bytebuddy.MockAccess
																						>如果上述两个条件都表明：这是一个可以的代理接口，那么直接退出循环。认为合理。
																					#如果认为合理：那么开始代理接口：即把接口加入代理工厂：proxyFactory.addInterface()
																					#否则不合理：仅仅设置为代理类：setProxyTargetClass()
																			>开始构建加入通知和拦截器：@buildAdvisors()	共同拦截器和具体拦截器都加入。
																				#先解析具体拦截器：@resolveInterceptorNames()
																					#遍历拦截器名数组：AbstractAutoProxyCreator.interceptorNames
																						#如果bf不是ConfigurableBeanFactory类型 或者 bf表明beanName当前不在创建中,那么如果bf为null要抛状态异常，bf获取这个拦截器名对应的实例.getBean()然后经过@advisorAdapterRegistry.wrap()包装就可以加入通知数组了：
																							@isCurrentlyInCreation() 以DefaultSingletonBeanRegistry的实现为例：
																								#不在当前创建中的条件为：set:inCreationCheckExclusions不包含 且 singletonsCurrentlyInCreation包含： 
																							@advisorAdapterRegistry.wrap():以DefaultAdvisorAdapterRegistry实现为例：
																								#Advisor类型直接返回
																								#不是Advice类型直接抛出异常。UnknownAdviceTypeException
																								#MethodInterceptor类型：直接封装到new DefaultPointcutAdvisor()注入Pointcut.TRUE属性 而返回。
																								#此时开始遍历三大适配器：MethodBeforeAdviceAdapter/AfterReturningAdviceAdapter/ThrowsAdviceAdapter
																									#如果有一个适配器支持；@supportsAdvice()那么就直接封装返回new DefaultPointcutAdvisor()，也注入Pointcut.TRUE属性。
																									-MethodBeforeAdviceAdapter类型：advice是MethodBeforeAdvice就支持。
																									-AfterReturningAdviceAdapter类型：advice是AfterReturningAdvice类型就支持。
																									-ThrowsAdviceAdapter类型：advice是ThrowsAdvice就支持。
																								#到此时，则说明不支持了，直接抛出异常：@UnknownAdviceTypeException()
																					>通知列表可以转换为通知数组返回了。
																				#此时相当于获取了共同拦截器：入参才是具体拦截器。
																				#如果入参拦截器不是null: 那么加入一个全部拦截器list里：如果applyCommonInterceptorsFirst==true那么接着把共同拦截器加到 全部拦截器前面， 否则在后面。
																				-打点日志
																				>遍历全部拦截器：对每个拦截器都再次包装一下：@.advisorAdapterRegistry.wrap()尽管名为全局通知适配注册中心：但是依然是和上述的包装过程一样：略。 
																				>返回这些拦截器：即通知器数组：Advisor[]
																			>将构建出的拦截器数组加入代理工厂：@proxyFactory.addAdvisors()
																				@统一转发给@addAdvisors()
																					#如果代理配置表明已经冻结：ProxyConfig.frozen=true :抛出异常new AopConfigException()
																					#遍历所有的通知器：
																						#如果是IntroductionAdvisor类型：需要先验证：@validateIntroductionAdvisor()
																							#验证接口：看有没有实现所有的接口：以DefaultIntroductionAdvisor实现为例：
																								#遍历注入的所有接口：如果通知是DynamicIntroductionAdvice类型 且没有实现这个接口：那么要抛出不合法的参数异常：new IllegalArgumentException()
																							>获取通知器的所有接口：遍历：将接口增加到interfaces属性里：@addInterface()
																								#增加还不够，还要清空methodCache:map属性。
																							-验证完毕返回。
																						>然后通知器加入advisors列表属性。
																					>通知器列表转数组：@updateAdvisorArray()放到advisorArray属性。
																					>再次通知改变：@adviceChanged()
																			>定制代理工厂：比如可能改变暴露的接口：@customizeProxyFactory() 都没有实现。什么也没做。
																			>设置冻结状态：false默认。来自freezeProxy属性。
																			>是否先于过滤器：@advisorsPreFiltered()默认false 
																			>开始实质创建代理：@getProxy() 前述已闭。
																		#否则就是无需代理：直接advisedBeans.put(cacheKey, Boolean.FALSE)而返回入参bean。
																	
												>事情4：添加数据和初始化：@populateBean()@initializeBean()：
													>先填充属性值：@populateBean()
														#如果bw是null: 则没有实例，是有问题的：要么抛异常，要么返回。
															#mbd有属性值hasPropertyValues()则抛异常：new BeanCreationException()
															#直接返回。无法属性填充。
														-此时则不是null: 则属性填充前需要 实例化感知bean后置处理器InstantiationAwareBeanPostProcessor 调用 实例化后方法postProcessAfterInstantiation 处理一下
														>后置处理的要求是mbd是非合成的：直接获取所有的bean后置处理器beanPostProcessors，遍历：对每个处理器：
															#如果是InstantiationAwareBeanPostProcessor类型：则进一步处理：
																#调用处理器的实例化后 处理方法@postProcessAfterInstantiation() 当然入参为bw的解包装@ObjectUtils.unwrapOptional()即是Optional.get()后的内容。
																	#很多具体实现都是true直接返回。尽管此方法可能具有支持field注入的功能---作者说的。但是从继承体系看确实一个实现也没有找到。
														#如果上述处理器有处理：且返回false:那么就直接返回了。但从实际看，都是true，所以继续下一步：
														>获取mbd中的属性值：PropertyValues
														#如果mbd表明自动绑定模式是 按名称/按类型：@getResolvedAutowireMode()那么都要重新包装一下属性值。
															#模式是AUTOWIRE_AUTODETECT时：构造方法有无参的: 按类型。否则按构造方法。
															#其他情况按其他情况。
														#如果上述成立：
															>先封装到new MutablePropertyValues() ---是一个属性值数组转换为列表的过程。
															#如果是按名称绑定模式：@autowireByName()
																>获取未填充的非基本类型属性：@unsatisfiedNonSimpleProperties()不包括基本类型和String
																	#遍历属性描述符数组：
																		#有写方法 
																		#且 在依赖检查之外@isExcludedFromDependencyCheck()
																			#普通依赖检查之外：@AutowireUtils.isExcludedFromDependencyCheck()
																				#无写方法/
																				#否则类名不含有$$/
																				#否则这个cglib代理的父类有属性描述代表的方法@ClassUtils.hasMethod()
																				-上述条件就是返回false 
																			#忽视依赖类型包含描述符类型：ignoredDependencyTypes.contains()
																			#属性是否有写方法：@isSetterDefinedInInterface()
																				#有 且 有一个接口有这个写方法
																			-三个条件有一个满足返回true
																		#属性值不包含属性描述符名
																		#不是简单属性类型：@BeanUtils.isSimpleProperty()
																		-以上条件都满足：那么这个描述符加到结果集合里。
																	#结果列表转换为数组退出。
																-此时得到了属性名:开始遍历；对每个属性名：
																	
																	
																
															#如果是按照类型绑定模式：@autowireByType()
														
												>事情5：提前暴露模式的缓存处理：
												>事情6：一次性注册bean: @registerDisposableBeanIfNecessary()
																					
																					
																					
																					
																					
																					
																					
																					
																					
																					
																					
																			
																			
																			
																			
																			
																			
																			
																			
											>返回实质创建结果。
											
																
															
															
															
															
															
												
												
												
												
												
												
												
												
												
								>后置处理：同前述 
								>加入单例池：singletonObjects加入，单例工厂singletonFactories中移除name, 提前单例池earlySingletonObjects中移除，带注册顺序的注册单例池：registeredSingletons添加。
							>返回单例。
					#否则如果mbd是原型模式时：
					#否则其他所有情况：
				>如果创建的bean的类型就是参数中requireType，需要做一些后续处理：		
													
													
													
 >AbstractBeanFactory.getBean(String name, Class<T> requiredType)开始的：
 
 
 
 
 
 
 
 
 
 
 
 
世界观： 
 >容器：具有活跃、关闭状态。
 >bean注册器中的单例: 
  >singletonObjects: map: beanName --> bean instance引用
  >singletonsCurrentlyInCreation: set: 正在创建中的单例
  >earlySingletonObjects: map:  beanName --> bean instance引用， 提前单例引用map
  >singletonFactories： 单例工厂：有getObject()方法，
  
  
>待研究课题：
	>springmvc切面代理：方法拦截：@RestControllerAdvice--异常捕获，@Log日志记录 , @DataScope方法权限验证(如直接查库，或者加where部分限制--角色限制也加到sql里)@RequiresPermissions方法权限验证(如文件访问权限)
									@DataSource数据源切换--加到服务Service级别。
	>spring-jdbc手动数据源切换关键：AbstractRoutingDataSource继承并实现的类实例，会在每次都调用determineCurrentLookupKey()方法返回一个注册的数据源名---来从配置的数据源即左边那类型的实例(路由型数据源)的一个属性map:targetDataSources里找到数据源对象，然后才开始具体的发送sql等等，那么就可以在该方法里读取一个数据源名线程局部变量--那么外面就可以动态存放到这个局部变量里---如做一个注解切面做在一个服务bean上，每次执行方法的时候在执行切面的时候从注解中获取数据源而设置到该线程局部变量里，然后之后才执行正式的代码。

>重要结论：
	>可以给任意的每个bean都增加切面：那么可以对@Entity也进行切面，切面配置为：加了某个注解的类的所有方法，或者加了某个注解的所有方法 都被切。然后获取类和获取方法。
	>可以运行时修改类上注解的某个属性的值：同理，方法上也可以。
	>可以查看定时任务自己的线程池：org.quartz.simpl.SimpleThreadPool
		>定时任务框架Quatz核心概念-世界观：主方法-cron表达式调度一个任务：Scheduler.scheduleJob(JobDetail, CronTrigger)，(其中JobDetail由Job类创建) 此外，可以删除和暂停job: deleteJob(JobKey)和pauseJob(JobKey) ，另外，可以立即激活triggerJob(JobKey jobKey, JobDataMap data)
			>根据上述世界观-四个调度方法(排-删-停-起)：完全可以构造出一个任务调度系统
	>公共的方法：其实合并了逻辑：合并了多个业务在这里的逻辑，导致看不出分别的逻辑，是逻辑的合成和兼容。
	>不要仅仅罗列动作：而不看功能和目的。
	>不要被迷惑：一定是根本的原因而不是直接的原因才是本质：要到达根本，问到根本。比如：桥接方法生成的目的？为了1.5兼容？什么内容不兼容？(1.5之前没有泛型，所以为了兼容，1.5以后编译为字节码之后也要没有泛型---泛型要擦除；擦除的实现机制就是泛型接口中的泛型编译为Object而在子类生成桥接方法--继承实现这个Object方法：而且内容就是调用子类的具体化泛型的覆盖方法)