//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
>加载bean: 
 >AbstractApplicationContext.getBean(String name)开始的：
	@考虑到(什么情况)(预防)：beanFactory的活跃状态、关闭状态影响是否获取bean, 如不活跃则不获取。决定(做一件什么事)：判断beanFactory活跃，否则抛出错误。世界观：容器有active,closed状态
		#当容器不活跃(标记：active=false)甚至关闭(closed=true)时抛出异常。
	@由于：本质上bean加载是beanFactory的功能，决定：获取上下文里的beanFactory让它去获取这个bean: getBean(name)
		#当采用AbstractBeanFactory实现时：
			@由于：为了各种各样的入参情形适配，决定：转发给一个统一的参数调用接口：doGetBean(name, null, null, false)
				@由于：name取值各种格式，需要转化为权威的：
					@由于：可能存在前缀&，需要全部去除；同时额外的事情：缓存下来，无需每次都这样去除。//要做多件事情 ，而不是仅仅就解析而已。如缓存。
					@由于：这个name可能是alias即别称，需要转换为权威的。决定：通过aliasMap来找到别称对应的权威名称。SimpleAliasRegistry中存在这个aliasMap
				@2由于： 决定：获取name的单例：getSingleton(beanName)
					@由于：经常存在获取单例的不同入参的需求，决定：统一调用一个统一的单例获取接口：DefaultSingletonBeanRegistry.getSingleton(...)，其中一个参数：是否允许提前引用allowEarlyReference。。。整体试图从各个工具那里获取bean的顺序--三次尝试：单例对象map-->提前单例对象map(正在创建过程中--应该是存在循环引用)--->单例工厂里先获取对象工厂(正在创建过程中)。。。三次尝试都不行，那么可能是个工厂bean--&开头。
						#当单例map:singletonObjects包含时：取它。
						#没有则当“正在创建的bean集合”set:singletonsCurrentlyInCreation包含name时：进入同步
							#当提前单例map:earlySingletonObjects包含时：取它 
							#没有则当“允许提前引用”时：从单例工厂map:singletonFactories里取它的对象工厂
							#当存在时：从工厂里获取.getObject(), 并保存在提前单例map里--以便并发获取时下一个线程直接从这里获取，并从单例工厂里移出name, 从而不会再调用.getObject()---保证了工厂创建只执行一次。
				@3由于：第二步返回的instance可能满足：instance != null && args == null, 决定：专门处理
					#当name是&开头说明是FactoryBean：如果instance不是FactoryBean类型则要抛出错误。NullBean类型直接返回。否则继续。
					#此时name可能：&开头的FactoryBean类型实例，不是&开头的任意类型。对于第一种，决定：直接返回。对于第二种：如果instance不是FactoryBean类型也直接返回。
					#此时name可能：不是&开头的FactoryBean类型。
						#由于： 效率考虑，工厂bean也进行缓存。决定：先从工厂bean缓存map:FactoryBeanRegistrySupport.factoryBeanObjectCache中取，有则直接返回它。
						#此时如果没有：
 >AbstractBeanFactory.getBean(String name, Class<T> requiredType)开始的：
 
 
 
 
 
 
 
 
 
 
 
 
世界观： 
 >容器：具有活跃、关闭状态。
 >bean注册器中的单例: 
  >singletonObjects: map: beanName --> bean instance引用
  >singletonsCurrentlyInCreation: set: 正在创建中的单例
  >earlySingletonObjects: map:  beanName --> bean instance引用， 提前单例引用map
  >singletonFactories： 单例工厂：有getObject()方法，
  
  