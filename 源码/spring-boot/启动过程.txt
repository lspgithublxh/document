//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备；化被动为主动去做)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
//大的想法，具体行动。
//出现了if-else就是因为有不同的考虑。
//阅读文档达到直接可以看出思路编写程序的清晰逻辑的地步。
//一个大函数功能直接看懂而描述。
//从网上找答案变为从源码中找答案。
//功能组织体系，而不是动作实现体系。是目标，是事情，而不是精细到实现方案的动作。
//数据源-数据结果模式：而不是全部动作过程。
//能够主动猜某个方法的功能和猜测它的实现。
//情况-通用处理。
//情况-精细结构。
//数据结构-与处理。
//某个时刻某个地方：所有可能用户做的事情。
//就像是军队打仗一样：AbstractApplicationContext上下文就是总部主帅，负责整个流程，但实现个别子流程；ServletWebServerApplicationContext就是地区主帅，负责使用总部流程且根据区域情况具体化部分流程实现，同时负责分给不同的人去实现更细的子流程(用人/用器：如事件广播器、bean工厂、生命周期处理器; 向它们发号命令：调用/叫他们做什么)，层层下去到事务的精细结构。(负责事务的精细级别 就看出 和一线的和当前的距离)
	>对一个事物类：他是有属性
	>对一个组织类：他是有人；属性当作人。人可能是为他办事的，也可能是监听他的监听器。
	>对一个系统类：他是有组件/器具；属性当作器具
//为什么层次多：因为连续地向上进行了抽象，每层都分类了/拆分了不同的功能，每层连续往下拆分。
//行为模式目的：代码一般化。
>SpringApplication 静态部分：
	>日志Log实例的创建： 
		>获取日志工厂：可能是SLF/commons-logging
			>获取线程上下文加载器：
			>加载配置文件："commons-logging.properties" , 使用@loader.getResources(name)来获得路径URL,然后利用@url.openStream()-->Properties.load(stream)即可实现资源流入Properties里；
				>这个配置文件里可能有“org.apache.commons.logging.LogFactory”的key, 则取出value: 作为Class进行实例化 
			>系统配置里取："org.apache.commons.logging.LogFactory" 为key的值，System.getProperty()	 第一个进行实例化
			>如果上述没有找到：开始 寻找"META-INF/services/org.apache.commons.logging.LogFactory"资源，加载进来：@getResourceAsStream(contextClassLoader,SERVICE_ID), 读取首行当做工厂名，进行加载和实例化
			>如果还是没有找到：就使用上上步骤从commons-logging.properties 里找到的工厂名，进行实例化，并且将props里的其他k-v一并设置加入；	
			---并且有缓存模式；
		>根据工厂获取实例：@getInstance(Class clazz)
			---org.apache.commons.logging.impl.LogFactoryImpl的实现：直接构造方法实例化创建实现；
			---org.apache.commons.logging.impl.SLF4JLogFactory的实现：很明显要：适配一下。。。注意不是桥梁模式(桥梁交错模式，就像”机枪+人“的交错，实现各种人持有各种抢的效果！两个维度的交错，从直角坐标系下可以直观看出)
				>先是：Logger slf4jLogger = LoggerFactory.getLogger(name) 即slf4j独有的，后注入到：new SLF4JLog(slf4jLogger)/new SLF4JLocationAwareLog((LocationAwareLogger) slf4jLogger) 来实现
>SpringApplication.run()开始：
	>new SpringApplication()：主要任务：
		>判断web应用类型(特定类加载是否成功)：webApplicationType:servlet/reactive/none
		>加载spring工厂实例集合：先从classpath所有jar中查找所有的工厂名，然后过滤出 ApplicationContextInitializer 的子类，然后实例化； //归结为一个基本问题；对于一个文件(如log4j2.component.properties)，如何找到而加载它的？
			>预备：
				>加载器：(jar里的任何部分都可以寻找和加载)
					>三级加载器(先后尝试加载xx file)：上下文加载器-->类加载器-->系统加载器
						>具体调用：@Enumeration<URL> cl.getResources(string:resource) 实现为双亲委派;迭代的每次，返回一个要寻找的jar包；java.lang.ClassLoader类的实现；
							>则先用 URLClassPath--Launcher.BootClassPathHolder.bcp 来加载：
								>@Enumeration<URL> getBootstrapClassPath()
									>@Enumeration<Resource> getResources(String var1) 内部实现就是 它的6个加载器--对应6个jar来尝试从中加载；sun.misc.URLClassPath.loaders:list 共有6种：分别对应jre/lib/下的resource.jar\rt.jar\jce.jar\jsse.jar\charsets.jar\jfr.jar
										>封装过程: string-->new URL()-->URLConnection-->JarURLConnection-->JarFile-->new Resource()
										>对一个name: 会先@getResource(String var1, true)尝试加载：JarLoader
											>主线：先name的包名 匹配，MetaIndex的实例，其contents属性值里含有如“javax/crypto”字符串，为包名匹配，一旦匹配到了，进入@Resource getResource(String var1, boolean var2, Set<String> var3)详细匹配：
												>主线：将根据csu基本属性(值如file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jce.jar)构造URL, 然后构造new URLClassPath.JarLoader()，放到 lmap 属性里：
												>这个方法里：已经解析了一个jar的完整META-INF结构：在index.indexMap属性里；
												
									>后直接將Enumeration<Resource>转换为 new Enumeration<URL>()返回；
							>后用@findResources(name) 用户的实现来寻找和加载；这个就是并列于上述的@getResource(string,boolean)方法的；---加载路径不同。
								>直接看这个方法返回new Enumeration<URL>(){}里面的@next()的实现：
									>也是一个循环：先取下一个loader-->后用这个loader来加载资源 ..
										>其中：第一步：@URLClassPath.this.getNextLoader(int[],int)第二个参数就是index++索引。此方法的实现：直接走@this.getLoader(var2)，里面的实现则更直接：按索引获取list中的元素-加载器即可：(URLClassPath.Loader)this.loaders.get(index) 这里的loaders有288个，各个jar的加载器都专门有---且地址不一样即使不同的加载器实例；而每个加载器都有记录它加载的是哪个jar；
											>这样：就相当于遍历了288个jar.	
											>loaders: 如何填满的；lmap 同理又是如何填满的。
												>填满过程：遍历jar路径过程中：对找到的每个jar的完整路径名字，直接新建一个 加载器对象：@new URLClassPath.JarLoader(), 加载器直接放到loaders里，而name-loader 则put到lmap里！！
													>new加载器方法正是：@URLClassPath.Loader getLoader(final URL var1)
												>整体过程：在第一个组件请求被加载的时候，因为要寻找匹配的，所以加载的很多没有匹配的jar-实际已经先存到loaders/lmap里缓存下来了。这个依赖从urls弹出 完整的 url jar路径。
											>urls： 初始化：
												>初始化： 
												>补充：@URLClassLoader.getLoader(int var1)有一次补充的过程:@push(URL[]),数据来源：@URL[] URLClassPath.JarLoader.getClassPath()，这个loader就是 @this.getLoader(var2)也就是返回new ..JarLoader()的方法；因此确实走的 JarLoader的获取URL[]实现：
													>来源获取过程：@JarLoader.getClassPath()的实现：
														>@ensureOpen()： 确保jar打开，设置JarLoader.jar/.index/.lmap属性； 
															>lmap: key:file:///C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/access-bridge-64.jar, value=JarLoader实例
														>@parseExtensionsDependencies()
														>@jarFileHasClassPathAttribute() 查看jar是否有class-path属性, 有，那么就要读取出来，然后把这个jar路径也包含进来，即@push()进来；但这里十分奇怪
															>@parseClassPath(URL var1, String var2) ： 将class-path里的jar，封装为URL时：直接替换最后的位置：new URL(URL,string)最后形成 file:/D:/mvn/repository/com/sun/xml/bind/jaxb-impl/2.2.7/jaxb-api.jar 这种奇怪的路径
													>有个native方法：@native URL[] getLookupCacheURLs(ClassLoader var0)
												>但是来自URLClassLoader实例为主：从 URLClassLoader 的实例化过程看，很多URL[]注入；
													----LauncherImpl中的实例化看：
														>是从jar属性里的JavaFX-Class-Path 属性 对应的 值 ---空格分隔的所有jar路径；封装到new File()里，然后file.getCanonicalFile().toURI().toURL()来获取URL,最终为数组；
													----tomcat-embed-core的org.apache.catalina.startup.Tool.main()函数的实现：
														>路径1：${catalina.home}/lib , ${catalina.home}/classes  其中，对于/lib下，会当做目录，从而寻找目录下的所有file:list()然后遍历封装为new File()加入集合；
														>路径2：运行入参里有-common, -server, -shared ,则加入  ${catalina.home}/common/lib|classes,  common|server/shared 可见跟自己的路径有关；
													----org.aspectj.util.Reflection.runMainInSameVM(String classpath, String className, String[] args)的实现： 
														>直接从classpath里：split之后每个部分都封装为URL(string)
													----javax.tools.ToolProvider.findSystemToolClass()实现： 
														>寻找 System.getProperty("java.home")， 然后 拼接 /lib/tools.jar  来构造File().toURI().toURL()为URL对象
													----ReflectionBasedReferenceTypeDelegate 也有实现：aspectweaver    Class.forName加载 org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate 时
															>出自：bean inititial之时 获取processor执行的时候：核心processor: 获取匹配的Advisor切点/通知: AnnotationAwareAspectJAutoProxyCreator 其中在 @wrapIfNecessary()时候  有关键的方法：// Create proxy if we have advice.  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName,null);
													----sun.misc.Launcher()的实现： 
														>Launcher类的静态属性：就有 @new Launcher()的一个属性。赋值给了launcher静态属性；构造方法的实现：
															>静态方式获取一个扩展类加载器：@Launcher.ExtClassLoader.getExtClassLoader()
																>经典的单利模式实现：双重锁定+volatile; 静态方法获取：具体内容：
																	>获取扩展路径：@Launcher.ExtClassLoader.getExtDirs()  
																		>@System.getProperty("java.ext.dirs")为核心，进行split处理得到File[]
																	>对每个File,注册元索引数据：@MetaIndex.registerDirectory(File)
																		>核心：@获取file/meta-index 这个子文件，如果存在，那么FileReader其内容，一行行读取：每一行提取封装为key:new File(var0, var4), value: new MetaIndex(var6, var5)  放到静态属性 MetaIndex.jarMap里；
																	>利用File[]新建扩展类对象：@new Launcher.ExtClassLoader(var1)
																		>获取每个File下所有的文件中非meta-index名字的文件，封装到new File()里，再转URL:@getCanonicalFile(); 再路径编码@ParseUtil.fileToEncodedURL()统一为/xx/xx/格式URL,这样就获取了一个URL数组，：@getExtURLs(var1)
																		>非常振奋的，开始调用@new URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)这个父类接口，也就是实例化父类：终于有了 URLClassLoader.ucp=new URLClassPath(urls, factory, acc)的执行；
																		>很关键的，先回调方式保存的ucp，这里获取它：调用@ucp.initLookupCache(this)--this就是 ExtClassLoader 实例；
																			>获取URLs:@getLookupCacheURLs(var1) 赋值给 实例 URLClassPath.lookupCacheURLs
																				>获取的实现：这个方法是一个静态方法：@native URL[] getLookupCacheURLs(ClassLoader var0)
																		---至此：ExtClassLoader实例创建完毕！！
															>利用上述扩展类加载器实例，获取一个实例化的AppClassLoader:@Launcher.AppClassLoader.getAppClassLoader(ClassLoader) ,后赋值给loader属性；
																>获取类路径配置：@System.getProperty("java.class.path")， 然后切割字符串，每个部分都直接new File(string),然后将这File[]返回； 
																>File[]转URL[]: @Launcher.pathToURLs(var2), 也就是逐个@getFileURL()--->内容就是 v0.getCanonicalFile() 后通过@ParseUtil.fileToEncodedURL(file)来返回。
																>进一步利用URL[],开始构造 AppClassLoader 实例：@new Launcher.AppClassLoader(var1x, var0)
																	>调用父类：@new URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)
																	>直接的：@this.ucp.initLookupCache(this) this就是 AppClassLoader实例；
															>线程上下文加载器的设定：@Thread.currentThread().setContextClassLoader(this.loader) 就是上一步得到 的 AppClassLoader实例。
															>安全管理器的实例化：@System.getProperty("java.security.manager")获取，后用this.loader来加载并实例化：@this.loader.loadClass(var2).newInstance() 后设置到 安全上下文：@System.setSecurityManager(var3)
														>额外重要一点：Laucher的被使用：
															>ClassLoader.initSystemClassLoader()里：既获取了@sun.misc.Launcher.getLauncher() 又获取了AppclassLoader 设置到了ClassLoader.scl静态属性里；
															>ClassLoader.getSystemClassLoader()里：@checkClassLoaderPermission(scl,Reflection.getCallerClass()) 参数方法是个native方法，获取调用方法所在类Class:A, 如果A的类加载器B是 scl的父类，那么无需检查，否则需要安全检查：@ sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION)
																>实际返回的还是：scl
																--引用的其他地方：@ClassLoader.getSystemResources(String name)
															>补充：scl加载一个类：@scl.loadClass(String name) 实际就是 ClassLoader的加载
																>加锁：每个name都给一个Object()锁对象：parallelLockMap
																	>首先尝试native加载：@native final Class<?> findLoadedClass0(String name)
																	#如果null：双亲委派加载：@native Class<?> findBootstrapClass(String name)
																	#再次null: 调用自类的实现：这里就是 URLClassLoader的实现：@Class<?> findClass(final String name)
																		>核心：即上述已经表达了的：加权方式：将name替换为xxx/xxx/xx.class形式后@ucp.getResource(path, false) 得Resource, 后：@defineClass(name, res)实现加载Class。。。自然就是从所有的urls里去寻找匹配的部分，匹配到为止；
																			>注意后面的@defineClass(name,res)方法，因为：@java.nio.ByteBuffer bb = res.getByteBuffer()很明显，已经得到了jar的byte[]后面 大家在就很自然了；！
																				>另外：Resource.url:URL的值是类似这样的完整类型的：protocol:jar,file:"file:/C:/Users/lonel/AppData/Local/JetBrains/IntelliJIdea2020.2/captureAgent/debugger-agent.jar!/com/intellij/rt/debugger/agent/CaptureAgent$KeyProvider.class"
																				>涉及的：Resource获取Inputstream： 
																					>第一种：@JarLoader.this.jar.getInputStream(this.jar.getJarEntry("com/intellij/rt/debugger/agent/CaptureAgent$InstrumentPoint.class")) 即jar+class明确
																						>获取class名后加载：得com/intellij/rt/debugger/agent/CaptureAgent$ParamKeyProvider.class的byte[]数组，调用@native long getEntry(long jzfile, byte[] name,boolean addSlash)方法 后@new ZipFileInputStream(jzentry)实现得到流；从这个流里又可以读出数据到byte[]里；为@Resource.getBytes()方法 ，到这个地步，调用 到 @defineClass1()就很自然 了；
																					>第二种：
															>补充2：ClassLoader.getResource(string)里最后一步调用的@findResource(string)的实现： 
																>加权：调用@ucp.findResource(name, true)来实现；
																	>核心：也是 @getNextLoader()---直接从loaders里按索引获取；然后 直接new URL()@URL findResource(String var1, boolean var2)
																>出处： @org.apache.logging.log4j.core.util.Loader.getResource(final String resource, final ClassLoader defaultLoader)	
																	>出处：获取配置：测试时甚至名字是随机的：@org.apache.logging.log4j.core.config.ConfigurationFactory.getConfiguration(loggerContext, name, configLocation) 后设置配置；
																		>出处：启动LoggerContext.start() 日志上下文的启动
																			>出处：上下文的获取@LogManager.getContext(cl, false)
																				>出处：获取logger:@AbstractLoggerAdapter.getLogger(final String name)
																					>出处：@org.slf4j.LoggerFactory.getLogger(String name) 进一步出自：@getLogger(Class<?> clazz)
																						>解析出处：@@Slf4j这个注解导致。
													----sun.misc.Launcher的静态方法实现：
														>出处：ClassLoader的@Enumeration<URL> getResources(String name)方法里的@getBootstrapResources(String name)方法实现：真正最主要的出处！！
															>核心：@getBootstrapClassPath() 
																>直接：sun.misc.Launcher.getBootstrapClassPath()
																	>直接返回：@auncher.BootClassPathHolder.bcp
																		>这个静态属性采用static{}初始化的方式实现：
																			>如果根路径存在：@bootClassPath = System.getProperty("sun.boot.class.path")
																				>直接转File[]:@Launcher.getClassPath(Launcher.bootClassPath)
																					>对每个的Parent进行注册一次：@MetaIndex.registerDirectory(var5)
																				>对每个File: 常见方法转URL：@getFileURL(File var0)	
																			>不存在：则new URL[0] 来设置，@bcp = new URLClassPath(var0, Launcher.factory, (AccessControlContext)null)；然后进行初始化：@bcp.initLookupCache((ClassLoader)null)	
															>然后：@getResources(name) 内容就是常见的 nextloader()+load()来实现；
														>出处的出处：最常见的就是SPI机制实现中的ServiceLoader中加载 @loader.getResources(fullName)	，而这里的fullName=如："META-INF/services/javax.management.remote.JMXConnectorServerProvider"
															>出处： SPI机制获取 JMXConnectorServerProvider.class接口的实现类， 而实现类Provider提供的则是如：@new RMIConnectorServer(serviceURL, environment, mbeanServer)这样的货物；
																>出处：@JMXConnectorServerFactory.newJMXConnectorServer(var4, var0, var3) 
																	>出处： @ConnectorBootstrap.startLocalConnectorServer()
																		>出处：@sun.management.Agent.startAgent()
																			---自定义同名方法出处：@javassist.util.HotSwapAgent.redefine(Class<?> oldClass, CtClass newClass) 而byte-buddy里也有类似利用asm的重新定义类的方法；
																			...
																				>出处：@PostVMInitHook.run()直接调用@trackJavaUsage() 实现内容：@new UsageTrackerClient().run("VM start", System.getProperty("sun.java.command"))
										>第二步：@var1x.findResource(var1, var2) 其中 var1x 就是上一步获取的某个序号对应的加载器实例；
											>调用@Resource getResource(String var1, boolean var2)：就是从jar里加载 路径var1 匹配的部分：但是对一个name 只有固定的urls个数，仅仅在urls里所有的jar路径匹配完了就不再寻找；找到了则可以@defineClass(name, res)定义了，但是没有找到则：
												>核心：@JarEntry var3 = this.jar.getJarEntry(var1)很明显是尝试获取匹配的内容；这个var1如"META-INF/log4j-provider.properties"；(也包括初始化加载--获取META-INF内的索引内容结构内容)
													>成功例子：输入org/apache/logging/log4j/core/selector/ContextSelector.class， 在 file:/D:/mvn/repository/org/apache/logging/log4j/log4j-core/2.12.1/log4j-core-2.12.1.jar 里寻找；
													>成功之后的验证：构造new URL(), 封装到new Resource(){}里返回。@Resource checkResource()
								>扩展类加载器：ext路径下，12个jar
								>应用类加载器：Launcher$AppClassLoader ：就是6+12+工程的target/classes+ pom仓库路径如288个。这些信息在.ucp.path|lmap|loaders都有记录；
							>另外：URLClassLoader.findClass(final String name)也是利用 URLClassPath.getResource(path, false)来实现，且内部依然使用URLClassPath的@getNextLoader()+@getResource(var1, var2)来实现加载目标类的；
								>当用@URLClassPath.getResource("xx/xx/xx/xx.class", false)没有找到,也直接退出，返回null;找到了Resource,则@defineClass(name, res)定义了--加载byte[]数据...native方法调用；
								
						>然后遍历这个枚举的所有可能寻找jar包路径：从URL 封装为new UrlResource();则返回 Collection<UrlResource> @Collection<UrlResource> findUrlResources(final String resource)。。为 org.apache.logging.log4j.util.LoaderUtil的实现；
					>完成后往往：重新将 Collection<UrlResource> 转为 Collection<Url>, 而此时可以遍历url，然后利用url.openStream():InputStream-->Properties	从而被加载；典型为@PropertiesPropertySource.loadPropertiesFile(final String fileName)的实现；(这个类的目的：然后将Properties里的kv放到System.setProperty(key, value))。。所在PropertiesUtil类 ，则又利用SPI机制来加载实现类。
						>SPI机制加载接口类的实现类：@ServiceLoader.load(PropertySource.class, classLoader)  就是加载 PropertySource 接口的实现类；注入的cl就是三级加载器的依次；
							>返回的ServiceLoader是个迭代器： new的同时还 new LazyIterator(service, loader) 另一个迭代器。外层迭代--是直接先调用providers属性的迭代--没有了则以LazyIterator的迭代进行补充；重点为 LazyIterator的迭代：
								>hasNext(): 主线逻辑就是@Enumeration<URL> loader.getResources("META-INF/services/" + service.name);加载这个文件；然后获取这个文件内容按行构成的集合的迭代器：name-value
								>next(): 主线逻辑就是加载 上述 的最后的 name(某行的name-类名)： @Class.forName(cn, false, loader)，后实例化且强制转换为目标接口类service.cast(c.newInstance())， 再放到providers里；
							--是通过 jdk里的接口加载classpath目录下jar里的实现类；而 显然 AppClassLoader实例可以---因为里面的urls里包含了java.class.path里的每个jar的路径，但不能直接获取，但因为设置到了线程上下文里，所有直接无需新接口，而直接可以线程隔离地、内部不同地方又共享/分时共享的前后共享的获取到这个 AppClassLoader 实例。
						>非SPI机制但也加载了实现类：通过遍历jar寻找目标文件，然后解析文件而得：
							>先@getResourceAsStream(contextClassLoader, "META-INF/services/org.apache.commons.logging.LogFactory")
								>出处：
							>然后读取第一行：接着直接当做类名加载：@classLoader.loadClass(factoryClass)然后实例化@.newInstance()
				>加载jar: jar的路径封装到URL里后openConnection() JarURLConnection	
					>路径例子：jar:file:/D:/mvn/repository/org/apache/logging/log4j/log4j-slf4j-impl/2.12.1/log4j-slf4j-impl-2.12.1.jar!/org/slf4j/impl/StaticLoggerBinder.class
					>一般(转换)过程：文件名-->URL-->
			>查找工厂名：@SpringFactoriesLoader.loadFactoryNames(type, classLoader) , 入参类就是 ApplicationContextInitializer ；加载器：默认的三级顺序；
				>查找全部工厂文件中的工厂名-实现类列表：@loadSpringFactories(@Nullable ClassLoader classLoader)
					>查找工厂文件：先@classLoader.getResources("META-INF/spring.factories") 方式，后@ClassLoader.getSystemResources("META-INF/spring.factories"))方式 
					>对找到的每个文件：封装到 Properties , 后 遍历每行，key=工厂name, value=工厂实现类名集合；存到map里；返回这个map;
				>获取org.springframework.context.ApplicationContextInitializer为name的所有工厂实现类集合：get一下而已；
			>实例化工厂名：@createSpringFactoriesInstances()
				>遍历：逐个加载@ClassUtils.forName(name, classLoader) 后，分kotlin和java分别进行构造和实例化:@BeanUtils.instantiateClass(constructor, args)
			>按优先级注解排序：@AnnotationAwareOrderComparator.sort(instances)
			-工厂实例集合 设置到 SpringApplication.initializers属性里；
			-----典型的实现类：
			--DubboApplicationContextInitializer: dubbo相关。因为在.run()阶段会执行@prepareContext()方法，里面包含执行遍历每个intializer的@initialize()方法，所以看它的实现
				>核心：在上下文里增加 beanPostProcessor:OverrideBeanDefinitionRegistryPostProcessor 实例 ，这个处理器的执行在@refresh()里的-->@invokeBeanFactoryPostProcessors()里面加载执行。(工厂处理器的执行)先@postProcessBeanDefinitionRegistry()非空实现；后执行@postProcessBeanFactory()方法---但是本处理器为空。
					>核心看：@postProcessBeanDefinitionRegistry()的实现： 
						>核心就是注册@DubboConfigBeanCustomizer 这个类 为 namePropertyDefaultValueDubboConfigBeanCustomizer 名字，到普通的beanFactory里。
							>使用地方：在 @AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization() 里调用 Processor的@ConfigurationBeanBindingPostProcessor.postProcessBeforeInitialization()方法，对于配置bean,就会执行@customize()方法；就会遍历 @ConfigurationBeanBindingPostProcessor::configurationBeanCustomizers:ConfigurationBeanCustomizer 属性; 从而执行@customize(String beanName, Object configurationBean)方法 
								>则看 @DubboConfigBeanCustomizer.customize(String beanName, Object configurationBean)的实现：
									>这里的 beanName 是 "org.apache.dubbo.config.ApplicationConfig#0" 这个bean里会有 spring.application.name 的信息；显然是 org.apache.dubbo.config.ApplicationConfig 的实例,#0说明是第一个实例。
									
									
		>同上方法获取 ApplicationListener 的 所有实现类集合；设置到	SpringApplication.listeners里；	
			--典型实现： org.apache.dubbo.spring.boot.context.event.DubboConfigBeanDefinitionConflictApplicationListener
			--典型实现2： org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener  (实现了org.springframework.context.ApplicationListener)
				>看应用上下文刷新事件/关闭事件：@onApplicationContextEvent(ApplicationContextEvent event)
					>看刷新事件@onContextRefreshedEvent()
						--注意：DubboBootstrapApplicationListener 的构造方法里 就有 ：单例获取 DubboBootstrap.getInstance() 赋值给 dubboBootstrap
						>直接启动：@dubboBootstrap.start()
							>初始化：@initialize()
							>输出接口：@exportServices()
							>如果不只是注册provider 或者 已经输出服务：则：
								>输出元数据服务：@exportMetadataService()
								>注册本地服务实例：@registerServiceInstance()
							>引用服务：@referServices()	
		>获取main方法的所在类Class：@deduceMainApplicationClass()设置到 SpringApplication.mainApplicationClass
	>@run()运行： 
		>配置系统属性：java.awt.headless
		>获取全部运行的监听器：@getRunListeners(String[] args) 
			>即获取 SpringApplicationRunListener 的实现类集合；封装到SpringApplicationRunListeners
		>启动监听器：@listeners.starting() 启动了全部的listeners
		>环境准备：
			>获取环境、配置环境：@new StandardServletEnvironment()，配置：
				>构建转换服务: 各种基本数据类型之间的转换converter：数据格式的统一format格式化工具的注册；转换器+格式化工具+值解析器resolver
					>实现：对ApplicationConversionService单例获取 中就实现了；
				>设置到环境里：
				>配置环境的属性资源：propertySources 
				>配置环境的profiles: @configureProfiles(environment, args)
				>属性资源attach到环境：@ConfigurationPropertySources.attach(environment)
				>配置绑定：@bindToSpringApplication(environment)
		>配置属性：@configureIgnoreBeanInfo(environment) spring.beaninfo.ignore
		>打印广告牌：@printBanner(ConfigurableEnvironment environment) 利用@SpringApplicationBannerPrinter类
		>创建应用上下文：servlet类型，所以直接反射 加载 ：org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext 并实例化：BeanUtils.instantiateClass(contextClass) --入口方法：   @createApplicationContext() 构造方法最终使用： sun.reflect.DelegatingConstructorAccessorImpl/sun.reflect.NativeConstructorAccessorImpl 的本地方法实现创建。
			>这个类本身就是registry: 所以bean可以通过它注册；
			>构造方法：
				>构建注解bean定义的阅读器：@new AnnotatedBeanDefinitionReader(this)
					>核心：注册大量beanpostPosser到 registry:@AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)
						>核心：因为registry是GenericApplicationContext 实例， 所以 通过@getDefaultListableBeanFactory()获取到 beanFactory:DefaultListableBeanFactory
				>构建类路径bean定义的浏览器：@ new ClassPathBeanDefinitionScanner(this)
		>获取异常报告器:再次工厂方式获取 SpringBootExceptionReporter 接口的实现类；
		>预备上下文：@prepareContext() 	
			>设置加载器、转换器：@postProcessApplicationContext(context)
			>遍历SpringApplication.initializers来执行.@initialize()方法。 @applyInitializers(context)
			>打印一点开始日志：
				>获取日志logger:@LogFactory.getLog(this.mainApplicationClass) 
				>输出日志内容info级别：为@org.springframework.boot.StartupInfoLogger.getStartingMessage()。。debug级别：@getRunningMessage()
			>打印一点profile配置信息日志：info级别	。。@logStartupProfileInfo()
				>从环境变量里获取 spring.profiles.active 的值，设置到 org.springframework.core.env.AbstractEnvironmt.activeProfiles 属性里；
			>加载资源：@load()	
				>构造beanDefinition加载器：@createBeanDefinitionLoader()
					>直接构造：@new BeanDefinitionLoader(registry, sources) 而内容：则 顺便：赋值 scnaner=new ClassPathBeanDefinitionScanner()和 给scanner增加过滤器：excludeFilters 这个属性在 @ClassPathScanningCandidateComponentProvider 类里，因为 scanner 是这个二类的继承类；
						>excludeFilters其中的filer: 直接对load的资源的封装：@new ClassExcludeFilter(source)而已。
				>这个资源就是@SpringApplication注解的类，main()函数启动类.
					>加载的最后动作：直接加载注册这个Class: @BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);注册到上述的context上下文里；
						>一般此时：beanDefinitionMap 里面 有 几个前面注册的 processor，5个；如 org.springframework.context.annotation.internalConfigurationAnnotationProcessor
			>刷新上下文：即最重要的方法：
				>@AbstractApplicationContext.refresh()	
				>最后动作：注册一个jvm shutdown回调 方法：@context.registerShutdownHook()  ---> Runtime.getRuntime().addShutdownHook(this.shutdownHook)
					>回调内容：执行@AbstractApplicationContext.doClose()
			>运行Runner集合：@callRunners(context, applicationArguments);	
				>上下文bf里获取 ApplicationRunner/CommandLineRunner的所有实现类：逐个运行它的方法：@(runner).run(args)
					>典型例如：org.springframework.cloud.task.batch.handler.TaskJobLauncherCommandLineRunner
												org.springframework.cloud.task.batch.partition.DeployerStepExecutionHandler

>spring-boot启动过程总结：概括：
	>第一：加载资源： 应用加载器 加载classpath下的所有spring.factories文件里的名值并选出 ApplicationContextInitializer 实现 来new实例化；再加载classpath下所有jar里的spring.factories里的名值 过滤出 ApplicationListener 的实现：来设置到属性里。
	>第二： 创建上下文、准备上下文并刷新上下文：
		>创建上下文： 两件事 
			>A: 反射加载 上下文类
			>B: 实例化上下文类：
				>创建 注解解析bd reader/类路径bd scanner 实例: new AnnotatedBeanDefinitionReader(this)/new ClassPathBeanDefinitionScanner(this) 
					>创建reader过程中: 有向bf里注册多个beanPostProcessor的bd
		>准备上下文：二件事 
			>A: load加载资源的名义注册了 启动类Class的bd到bf
			>B: 初始化上述找到的 ApplicationContextInitializer 实例。
		>刷新：三件事
			>A: 注册所有的bd : (包路径大部分A+遍历A滤配置类而专门新增(@Import/@ImportResource/@Bean方法指定(registar/selector)))
				>以bean工厂处理器的名义 来加载bd: 处理器来源bf/application
					>配置类处理器ConfigurationClassPostProcessor为例：来自bf: invoke内容；构造配置类解析器 解析bf中的配置型bean--往往就是启动类Class的bd所代表的Class: 解析内容就是它的五大注解@Component/ComponentScan/PropertySource/ImportResource,如 加载包下路径通过 PathMatchingResourcePatternResolver加载器加载资源方式加载；。。后面还有@Import/@ImportReSource 解析加载  
						>又有配置Class专门额外解析：如方法上的@Bean/ 类上@Import要求的类 的bd注册。例如org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration配置类的父类里有个方法上有@Bean注解：requestMappingHandlerMapping 这个名bean：实例：RequestMappingHandlerMapping类型。
						>又如import资源xml的专门解析：dubbo
			>B: 实例化所有的bd
				>注意：mapper的bd实例化时候：会加载对应的xml资源：就在@afterPropertiesSet()初始化方法执行阶段--->实际执行了 @org.mybatis.spring.mapper.MapperFactoryBean#checkDaoConfig() 里面-->MapperAnnotationBuilder 类里做的。
			>C: 新增new Tomcat(),封装到new TomcatWebServer()并启动服务器。
	>第三： 发布一个上下文准备好的事件。	
-----------------------------------------------------------------------------------------------------------------												
-------专项问题：
>spring-boot如何获取所有的beanDefinition的？-->哪些地方调用了@beanFactory.registerBeanDefinition(beanName, beanDefinition)
	>第一批：beanprocessor  来源：spring-boot 启动 创建上下文：AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)  具体如：
		>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
		>org.springframework.context.annotation.internalAutowiredAnnotationProcessor
		>org.springframework.context.event.internalEventListenerProcessor
		>org.springframework.context.event.internalEventListenerFactory
	>第二批：MyApplication 来源： spring-boot 启动 @load() 使用 上面获取的AnnotatedBeanDefinitionReader 来注册 ,
	>第三批：FactoryPostProcessor 来源：如spring-boot new SpringBootApplication()构造-->加载的 initailizers实现类集合 在 @run()时 执行各自的@initialize() ---> 直接new 各个processor放到 ApplicationContext 的 beanFactoryPostProcessors列表里；从而在后续阶段 @refresh()-->@invokeBeanFactoryPostProcessors(beanFactory) 会使用到：
		>筛选 beanFactoryPostProcessor 是 BeanDefinitionRegistryPostProcessor 类型， 使用 processer自身自带方法注册到 registry:beanFactory 里。例如：org.apache.dubbo.spring.boot.beans.factory.config.OverrideBeanDefinitionRegistryPostProcessor bean的名字则是processor自己取的。
		>第三.1批：从先前注入了processor,现在开始调用使用@refresh()-->@invokeBeanFactoryPostProcessors()中： 
			>首先是：@org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())
				>处理1：对上述init阶段注册的4个processor遍历处理：如果是BeanDefinitionRegistryPostProcessor 类型，就调用它的@postProcessBeanDefinitionRegistry(registry) 注册部分的 bean:
					>1：org.apache.dubbo.spring.boot.beans.factory.config.OverrideBeanDefinitionRegistryPostProcessor ：这个则注册infrastructionBean---DubboConfigBeanCustomizer:名字为"namePropertyDefaultValueDubboConfigBeanCustomizer" 注册方式：@com.alibaba.spring.util.BeanRegistrar#registerInfrastructureBean()
					>2: org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer: 如注册 名字 为 org.springframework.context.annotation.internalConfigurationAnnotationProcessor 的实例：org.springframework.context.annotation.ConfigurationClassPostProcessor 实例 
				>处理2：对上述获取的configProcessor 处理：@invokeBeanDefinitionRegistryPostProcessors()  内部就是调用每个processor的@postProcessBeanDefinitionRegistry(registry)
					---对 ConfigurationClassPostProcessor 的实现： 
						>核心：转发给@processConfigBeanDefinitions(registry)
							>先解析@new ConfigurationClassBeanDefinitionReader()来加载通过@new ConfigurationClassParser()来获取的classes：：：@reader.loadBeanDefinitions(configClasses)
								>对每个class: @loadBeanDefinitionsForConfigurationClass()专门 的解析每个配置类型的class:
									>@Bean方法+输入资源importResource+输入仓库：而对于启动类myApplication的输入仓库里就有一个特殊的输入仓库ImportRegistrar：AutoConfigurationPackages$Registrar;;;另外还有 DubboComponentScanRegistrar/DubboConfigConfigurationRegistrar/DubboLifecycleComponentRegistrar/AspectJAutoProxyRegistrar ; 
										>上述: 就是@EnableDubbo 和 @EnableAspectJAutoProxy引入的。而@SpringBootApplication会引入的：配置注解@SpringBootConfiguration  自动注解@EnableAutoConfiguration---进一步import:AutoConfigurationImportSelector+AutoConfigurationPackages.Registrar  因此启动类作为配置类在被解析的时候，就会加载import仓库--即：AutoConfigurationPackages.Registrar这个仓库。
									>在解析import仓库的时候：@loadBeanDefinitionsFromRegistrars() 获取了myApplication的仓库，调用它的注册方法@registrar.registerBeanDefinitions() 这个仓库即上述；看它的注册实现：	
										>转到@AutoConfigurationPackages.register()：直接新建@new GenericBeanDefinition()封装：设置beanClass=BasePackages ;然后注册了一个名为"org.springframework.boot.autoconfigure.AutoConfigurationPackages"的bd
					>核心：新建一个解析器：@new ConfigurationClassParser().parse(candidates)来解析 过滤出来的：主processor： myApplication 这个bean
						>认为是源类，继续调用解析源类/启动类的各种配置注解：@doProcessConfigurationClass(configClass, sourceClass, filter)来解析 
							>寻找源类的@Component注解 ： 有则先进行@processMemberClasses(configClass, sourceClass, filter)：一般无动作
							>寻找源类的@PropertySources 注解：有则@processPropertySource(propertySource);处理 ：一般也无动作
							>寻找源类的@ComponentScan注解： 找到之后：开始遍历：这个注解有11个属性；对每个注解(一般就一个)：
								>先解析11个属性并返回basePackages属性匹配到的类集合：this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()):org.springframework.context.annotation.ComponentScanAnnotationParser 这个类的解析方法。
									>对于 excludeFilters 属性： 先封装@typeFiltersFor()为TypeFilter,再 加到scanner.addExcludeFilter(typeFilter)
									>对于 basePackages 配置项 ：字符串内容；分号分隔每个包；提取出来；放到list;
									>对于 basePackageClasses 配置项： 提取其package出来：即上一级路径；
									>如果此时仍然为空：即上述没有配置；那么就获取 myApplication 类的上一级路径 ； 加到list
									>开始用scanner.doScan()浏览 包下类：org.springframework.context.annotation.ClassPathBeanDefinitionScanner 。
										>对每个package: 调用父类@findCandidateComponents(basePackage)来获取所有的BeanDefinition；
											--对 ClassPathScanningCandidateComponentProvider 实现： 直接走@scanCandidateComponents()
												>构造包路径加载全部class: @getResources(packageSearchPath)
												>遍历过滤：
													>第一层：filter过滤： includeFilters/excludeFilters
														>excludeFilters: 和过滤器声明的类名同，则过滤--启动类过滤；2.是@Configuration配置注解类 又在spring.factories里的EnableAutoConfiguration类型配置项的实例里；3.是TypeExcludeFilter本身；
														>includeFilters: 1.类上有@Component注解 2.主类 3.
													>第二层： 独立而坚固 或者 抽象且有@Lookup注解；
													---所以：项目里没有任何注解的类是不会在浏览包的过程中被实例化的--除非被动--直接new后添加到容器。
											>先构造包的完整路径：如 "classpath*:com/ihuaben/**/*.class"
											>使用资源模式解析器解析这个路径：PathMatchingResourcePatternResolver
												>最终使用@org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResources(path)来解析：分模式来寻找匹配的资源。classpath*开头就是一类：
													>再分：如果 classpath*: 后面部分包含{}或者* ，则模式拆解：调用@findPathMatchingResources(locationPattern)解析，否则调用@findAllClassPathResources()
														>@findPathMatchingResources(locationPattern): 将路径拆截取分为：路径+类模式字符串 两部分；对于路径部分，递归得获取资源@getResources(path)	---这种方式取的是“com.ihuaben”包下所有的.class--包括没有任何注解的类；且对于项目来说--资源路径都是file://D:/xxx/target/classes/下的.class
															>此时没有了类模式：所以直接走了@findAllClassPathResources():
																>此时核心来了：直接采用 应用类加载器AppClassLoader 对 该路径加载：@cl.getResources(path)  ，其中遍历的一个结果是：如： URL: protocol="file", file="/D:/document/%e5%b7%a5%e4%bd%9c%e6%96%87%e6%a1%a3/workspace/shardingutil/target/classes/com/ihuaben/config/"   。。这样的信息封装到 new Resource()里，即路径资源，还不是实际的文件资源；
															>利用上述路径资源：判断路径的类型：jar/file?, 整理得到完整路径“D:/document/工作文档/workspace/shardingutil/target/classes/com/ihuaben/config”	， 再封装为匹配类字符串：“D:/document/工作文档/workspace/shardingutil/target/classes/com/ihuaben/config/**/*.class”
																>最终还是通过 @dir.listFiles() 文件方式获取了路径下的所有文件，然后通过文件模式匹配出 和模式一致的：匹配方式：@org.springframework.util.AntPathMatcher#match(pattern, path)判断是否匹配；实际就把其中所有的.class匹配到了加到了结果里返回；
															--这样，就从 scan的这个 basePackage下找到了全部的匹配class文件路径为内容的Resource数组			
														>@findAllClassPathResources():
											>找到资源之后，继续逐个和includeFilter/excludeFilters进行匹配，看是否要采纳；是，则将该class封装到@new ScannedGenericBeanDefinition()里，则形成了一个 BeanDefinition 了，加到结果里。
												>非常关键：includeFilters 其实有三个默认的：都是 org.springframework.core.type.filter.AnnotationTypeFilter ，内部注解类型分别是："org.springframework.stereotype.Component"  "javax.annotation.ManagedBean" "javax.inject.Named"
													>包含上述山歌注解：就是true；匹配！！再看是否有@Conditional注解，专门处理一下；是否依赖其他条件表明的类？
														>具体有@ConditionalOnClass时：
										>找到的bd集合：遍历，对 AbstractBeanDefinition/AnnotatedBeanDefinition 的实例，专门处理；剩下的：
											>生成每个bd的名字：@org.springframework.context.annotation.ClassPathBeanDefinitionScanner.beanNameGenerator.generateBeanName(candidate, this.registry) 名字一般是 Class类的名字的首字母小写；如 "dataSourceConfig" "bookShelfShardingService"
											>再次经过一些例常处理 如代理 后：封装到@new BeanDefinitionHolder()里；然后调用工具注册到bf:@BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry) 后面就是常见的了。
											--从而把 basePackage 注解包路径下的所有匹配的 bean 层层解析 一一注册到容器bf里了。
								>对于上一步解析到的basePackages等包路径下的所有类定义集合：遍历：
									>检查这个Class是否是配置类：即有@Configuration注解 是，则进一步解析--获取里面的@Bean: 转调用@org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass()
										--检查是否是配置类的条件：@Configuration注解为条件1；条件2：@isConfigurationCandidate() --->即这个类的元数据里是否有 5个注解之一：Import/Component/ImportResource/ComponentScan/Bean  条件很弱；所以几乎全部都会进入解析！：
										>核心为递归解析：将这个Class当作配置类参数注入，调用@doProcessConfigurationClass() ，则会将这个配置类里的所有@Bean也或取到，加到 beanMethods属性里。 因为这个方法里，会分三种类型：即直接@Component注解类型：@PropertySources 注解类型， @ComponentScan注解类型
									#不是配置类：那么这里直接忽略；
							>寻找@Import注解来处理：@processImports()
								>先是递归方式获取 类上的注解的注解...含有@Import注解的：把这个注解里配置的Class解析出来：如@MapperScan注解的@Import注解里的MapperScannerRegistrar.class， @EnableTransactionManagement注解的@Import注解里的 TransactionManagementConfigurationSelector.class 类 
								>然后遍历这个Import类集合：对每个分 ImportSelector/ImportBeanDefinitionRegistrar/other 实现类专门处理：
									>对 ImportSelector 实现类： 则直接实例化+ 感知 属性注入：@ParserStrategyUtils.invokeAwareMethods()
									>对 其他：
										>获取全部输入类名：手动写死：@org.springframework.transaction.annotation.TransactionManagementConfigurationSelector#selectImports() : 返回：AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration 的类名；
										>反射加载：
										>加载后处理：@processImports()  遍历分：ImportSelector/ImportBeanDefinitionRegistrar/其他 实现类 来处理：
											>对于 ImportBeanDefinitionRegistrar 实现类： 直接实例化并 注入 感知属性：@ParserStrategyUtils.instantiateClass()
												>然后存到内部的map里：org.springframework.context.annotation.ConfigurationClass::importBeanDefinitionRegistrars
											>对于其他 实现类： 先注册：@importStack.registerImport()
												>然后开始处理解析类：@processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter)
													>先用评估器评估是否应该过滤：@conditionEvaluator.shouldSkip()
														>获取这个类的@Conditional 注解中的类，加载并实例化：放到一个list里：遍历，对每个条件：匹配判断：@org.springframework.boot.autoconfigure.condition.SpringBootCondition#matches() 这里比如WebSocketServletAutoConfiguration类的2个条件：一个是@ConditionalonClass注解--定义声明的@Conditional注解条件OnClassCondition条件，web..这个注解的值则是：(Servlet,ServletContainer);;;另一个是@ConditionalOnWebApplication注解---这个注解定义上的@Conditioanl条件 OnWebApplicationCondition
															>outcome匹配：@getMatchOutcome() 不同的条件有不同 的实现： 
																---OnClassCondition条件的实现：
																	>查找要求有的候选Class: 即这个类上的@ConditionalOnClass注解里的Class列表: @getCandidates(metadata, ConditionalOnClass.class)
																	>过滤：加载这条件要求有的Class 列表: 加载方法1：@classLoader.loadClass(className) ，其次加载方法：@Class.forName(className)  在@org.springframework.boot.autoconfigure.condition.FilteringSpringBootCondition#resolve()有描述。入口匹配方法：@org.springframework.boot.autoconfigure.condition.FilteringSpringBootCondition.ClassNameFilter.matches()
																		>加载成功说明匹配：如果没有成功，那么记录下来，直接封装信息到@ConditionOutcome.noMatch()里返回了。陈宫了也要封装信息到一个@ConditionMessage()对象里
																	>再次查找 要求没有的Class:	@getCandidates(metadata, ConditionalOnMissingClass.class)  同理再次过滤，信息封装处理。
																---OnWebApplicationCondition 条件的实现：
																	>直接看有无@ConditionalOnWebApplication注解，
																	>再看是否web应用：@isWebApplication()
																		>核心看bf里注册的scope是否包含session: @getBeanFactory().getRegisteredScopeNames()
																		>是包含： 则返回@ConditionOutcome.match(message.foundExactly("'session' scope"))匹配	
															>尝试打日志：@logOutcome(classOrMethodName, outcome)
															>记录一下评估情况：@org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport#recordConditionEvaluation()
															>返回是否匹配：就是 条件有的有了，条件不应该有的没有；则true;
													>开始循环到父类的解析配置类：@doProcessConfigurationClass(configClass, sourceClass, filter)		
							>寻找@ImportResource注解来处理：获取三个属性：尤其是 locations 属性 的值： 即是资源文件的地址：String[], 如“classpath:dubbo-consumer.xml”
								>遍历每个资源路径：解析填充 占位符：最终使用@org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders()来解析；几乎没改变；直接放到 ConfigurationClass.importedResources属性里。
							>对类的@bean方法处理：如对 ProxyTransactionManagementConfiguration 这个类解析，因为里面有三个方法上有@Bean注解，所以返回了3个；实际处理中，还会有一个过滤：
								>后遍历转换为new BeanMethod()加到ConfigurationClass里；比如  com.ihuaben.config.DataSourceConfig 配置类里就有8个bean方法, 都会加到 org.springframework.context.annotation.ConfigurationClass::beanMethods 属性里；
							>处理类的接口上是否有@Bean注解方法：有则还需要加入：@processInterfaces():	
							>返回父类：继续递归@doProcessConfigurationClass()
							-没有：则配置类会加到 org.springframework.context.annotation.ConfigurationClassParser::configurationClasses  属性里：
						>在第一级@parse()下，最后进行一个import选择器的handle@deferredImportSelectorHandler.process()
							>最后一步：@handler.processGroupImports()  也是 ConfigurationClassParser 的方法。
								>转调用@processImports() 而入参里的候选类只有一个：org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration 这个类一个直接的@Conditional即要求有指定的bean在bf中(这里是要求有ResourceBundleCondition这个类)， 一个@ConditionalOnMissingBean--即要求bf里不能有某个bean --这里是要求不能有 "messageSource"名字的bean，内部又有2个@Bean方法。 
					>核心2：利用上一步填充的 configurationClasses 配置bean , 使用reader来加载注册bd:@reader.loadBeanDefinitions(configClasses) : org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader  这种 configClasses可能达99个之多--但是有第一步的过滤@shouldSkip()：@org.springframework.context.annotation.ConditionEvaluator#shouldSkip()来过滤。
						>第一步：注册配置bean自己：条件：@configClass.isImported()为true: 从而会注册它自己：@registerBeanDefinitionForImportedConfigurationClass(configClass) --包括生成它的名字、bdh信息等；
						>第二步：注册配置bean里的beanMethods里的bean: 遍历每个BeanMethod:调用@loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod)来注册：
							>专门封装到：@new ConfigurationClassBeanDefinition(configClass, metadata)对象里
							>后进行一系列级别属性的设置：通用的一批由@AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata)来处理。
							>最后还是 DefaultListableBeanFactory@registerBeanDefinition(String beanName, BeanDefinition beanDefinition)来注册。
							---注意：比较奇怪：对于 org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration 这个配置bean的bean: 不是直接在类定义上写死的，而是外部注入的20个bean: 名字不同，但类型都是：org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport
						>第三步：注册importResource注解的类：@loadBeanDefinitionsFromImportedResources(configClass.getImportedResources())
							>当有配置@ImportResource注解时：就会执行：最终是执行@reader.loadBeanDefinitions(resource)来加载。reader:org.springframework.beans.factory.xml.XmlBeanDefinitionReader 这个。
								>后面的流程几乎同spring的加载和解析注册bean: 如先用：@((ResourcePatternResolver) resourceLoader).getResources(location)转换为Resource对象；后@loadBeanDefinitions(resources)
									>加载资源文件到流里：@getResource().getInputStream()， 然后解析为Document: @doLoadDocument(inputSource, resource) 
									>遍历整个Document文档所有的节点： org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions() 对每个节点：分default/custom进行分别的解析：@parseDefaultElement(ele, delegate)/delegate.parseCustomElement(ele) 例如对 <dubbo:custom> 就是后者来解析。<dubbo:import>则是按前者---：因为会继续加载指定的xml配置来解析。
										>对<dubbo-reference> 则是使用 org.apache.dubbo.config.spring.schema.DubboBeanDefinitionParser 类来解析：
											>最后直接@new RootBeanDefinition()封装，而设置它各个属性：
												>beanClass="org.apache.dubbo.config.spring.ReferenceBean"
												>id=节点的name配置, 即当做beanName
											>然后就直接注册了：@getRegistry().registerBeanDefinition(id, beanDefinition)
											>最后还会遍历ReferenceBean的所有方法-给bd增加属性：从节点里配置取出的：设置包括：@setApplicationContext()/protocol/url/consumer
										>解析注册bean：@registerBeanDefinitions(doc, resource)
											>通过获取文档的名称空间的handler来进行解析：@readerContext.getNamespaceHandlerResolver().resolve(namespaceUri) ，自然得到了dubbo的xml名称空间handler:org.apache.dubbo.config.spring.schema.DubboNamespaceHandler  @parse(Element element, ParserContext parserContext)
												>此时有注册listeners： @registerApplicationListeners(registry)
												>正式解析：parse()
													>注册别名工具：DubboConfigAliasPostProcessor
													>注册consumer配置：org.apache.dubbo.config.ConsumerConfig
													>嵌套解析：@parseNested()
													>设置这个ConsumerConfig的各个属性：值从xml里提取。反射的方式进行的。
													>最后返回这个bd: 这样，就解析好了一个xml节点。
												--注意：在@AnnotationBeanDefinitionParser.doParse()解析的时候：内部注册了一个reference注解处理器: 所以bdM里新增了"referenceAnnotationBeanPostProcessor"名字的bd	
						>第四步：注册仓库里的类：获取 configClass 里的importBdRegistrars仓库，注册这些仓库里的bean: 这里共有2个registrar
							>org.springframework.context.annotation.AspectJAutoProxyRegistrar: 跟 aspectj 有关。 一般为空
							>org.mybatis.spring.annotation.MapperScannerRegistrar： 跟mybatis加载mapper文件有关：
								>先是获取配置类的@MapperScan注解：
								>生成仓库代理的名字："com.ihuaben.config.DataSourceConfig#MapperScannerRegistrar#0"
								>开始构建bean的过程：先是beanclass 类型：@BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class)
									>然后是：各种属性的添加：从@ManagedBean里取的beanName从bf获取的实例：属性包括：annotationClass/markerInterface/nameGenerator/factoryBean/sqlSessionTemplateRef/sqlSessionFactoryRef/basePackages/basePackageClasses/
									>最后还是用bf来注册这个建造者模式生成的bd:@registry.registerBeanDefinition(beanName, builder.getBeanDefinition())
						----myApplication 也是一个配置bean: 它的四步：
							>在
				>处理3：激活其他的 BeanDefinitionRegistryPostProcessor ： 从bf里取出来，过滤掉已经处理过的。再次调用@invokeBeanDefinitionRegistryPostProcessors()		
					>此时往往三个processor： @postProcessBeanDefinitionRegistry()
						>org.mybatis.spring.mapper.MapperScannerConfigurer 
							>事情1： 设置属性占位符替换holders: 配置 sessionFactory,sessionTemplate等到@processPropertyPlaceHolders()
								>动作1：直接取@applicationContext.getBeansOfType(PropertyResourceConfigurer.class), 从 bf里取(实际上已经有bd了，只是实例化而已)， name就变成“propertySourcesPlaceholderConfigurer” ，而最终直接 使用工厂方法方式：然后以这个name为方法名，反射调用：PropertyPlaceholderAutoConfiguration@propertySourcesPlaceholderConfigurer()获取实例---非常暴力；而方法的实现也非常直接：@new PropertySourcesPlaceholderConfigurer()
									>顺便注册了："com.ihuaben.config.BookDataSourceConfig#MapperScannerRegistrar#0" 这个bean，非常神奇。
									>执行这个实例的：@prc.postProcessBeanFactory(factory)
							>事情2： 新建new ClassPathMapperScanner(registry)同理设置各种sessionFactory/template属性，资源记载器等之后；进行浏览：@scanner.scan()
								>真正的scan: 先调用父类的org.springframework.context.annotation.ClassPathBeanDefinitionScanner@doScan(basePackages) 前面已经表达。浏览包下所有的类；
									>这里浏览的就是：Mapper类；生成的名字也是“bookShelfCountMapper”首字母小写；所以就注册了mapper的beanDefinition
									>上述发现的所有的bd: 本类doscan()会进一步的处理：@processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions)
										>关键1： 设置bd的beanClass=org.mybatis.spring.mapper.MapperFactoryBean.class
										>关键2： 设置bd.属性值map新增sessionTemplate：@.getPropertyValues().add("sqlSessionTemplate",new RuntimeBeanReference(this.sqlSessionTemplateBeanName))
								>注册注解配置proccessor: @AnnotationConfigUtils.registerAnnotationConfigProcessors()
						>org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigAliasPostProcessor
						>org.apache.dubbo.config.spring.beans.factory.annotation.ServiceAnnotationBeanPostProcessor
							>事情1：注册 DubboBootstrapApplicationListener 类。实现方式：@new AnnotatedBeanDefinitionReader(registry).register(Class)
								>最后还是封装到new AnnotatedGenericBeanDefinition(beanClass)--> new BeanDefinitionHolder(abd, beanName)-->@BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry)
							>事情2： 包浏览和占位符解析：即注解中的dubbo服务类所在包： "com.ihuaben"	@registerServiceBeans(resolvedPackagesToScan, registry)
								>浏览包下类必须有浏览器scanner: 这里新建@new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader)； 后增加过滤器：注解过滤器类型：@new AnnotationTypeFilter(Service.class)//这里两种Service:org.apache.dubbo.config.annotation.Service/com.alibaba.dubbo.config.annotation.Service
								>开始浏览：@scanner.scan(packageToScan) 注册@Service注解的类
									>先转调@doScan(basePackages)
										>转到父类：@doScan(basePackages) 即前面已经讲述：org.springframework.context.annotation.ClassPathBeanDefinitionScanner
									>注册可能的注解配置处理器：@AnnotationConfigUtils.registerAnnotationConfigProcessors()
								>注册具体的@Service注解 bean并且进行详细的配置：dubbo自己的专门的设置配置。后也一一注册到 bf;
				>处理4：开始beanFactory处理器的激发：@invokeBeanFactoryPostProcessors()				
					>此时7个往往processor:@postProcessBeanFactory(beanFactory)
						>org.springframework.context.annotation.ConfigurationClassPostProcessor 的实现处理：使用cglib增强子类的方式处理：
							>对注入的bf: 生成bfid,然后开始增强：@enhanceConfigurationClasses(beanFactory)
								>遍历bf里面的所有beanDefinition: 对于其中的配置类：开始解析了---即反射加载：@ClassUtils.forName(className, classLoader) 然后收集配置bd起来
								>遍历配置bd: 对于每个，进行增强@new ConfigurationClassEnhancer().enhance() ；
									>先包装适配一层：@org.springframework.cglib.proxy.Enhancer()后用来创建其增强类：@enhancer.createClass()
										>动态类的byte[]的生成：@org.springframework.cglib.core.DefaultGeneratorStrategy#generate()
											>新增classVisitor:@DebuggingClassWriter()
											>获取目标类的所有方法：进行过滤：@CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC))
											>实际生成类的方法：@org.springframework.cglib.proxy.Enhancer#generateClass()
												>使用new ClassEmitter(v)完全从0开始生成Class的byte[]: 
												>开始部分：@e.begin_class()
													>如类定义信息：@Lcom/ihuaben/config/JdbcTemplateDataSourceConfig$$EnhancerBySpringCGLIB$$639cdd09;
													>开始详细的设置：@org.springframework.asm.ClassWriter#visit()
												>属性部分：@e.declare_field() 私有公有/静态final/
													>终使用@org.springframework.cglib.core.ClassEmitter#visitField()来设置 
												>方法部分：@org.springframework.cglib.proxy.Enhancer#emitMethods()开始一个字节码字一个节码的的写入。CodeEmitter	/se.dup()/e.invoke_constructor()/se.putfield()等；
												>结束部分：@e.end_class()
										>最后在轻量级的反射中加载了byte[]表达的新类：@org.springframework.cglib.core.ReflectUtils#defineClass() ，反射方法就是clasloader的 defineClass()  生成之后的类似名就是：com.ihuaben.config.DataSourceConfig$$EnhancerBySpringCGLIB$$be17c634
										>最后普通反射实例化：@ReflectUtils.newInstance(type)
									>后将bd.beanClass=新的这个生成的Class:	如像 com.ihuaben.MyApplication$$EnhancerBySpringCGLIB$$9d3f8c25
							>bf增加处理器：@beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory))	
						>org.springframework.boot.context.config.ConfigFileApplicationListener.PropertySourceOrderingPostProcessor 的实现： 给环境增加一些属性：@reorderSources()
				>处理5：获取bf里的剩下的 BeanFactoryPostProcessor 来处理： 	过滤之后再次：@invokeBeanFactoryPostProcessors()
					>org.springframework.boot.context.properties.ConfigurationPropertiesBeanDefinitionValidator 的实现：	
						>从bf里的bd遍历中过滤出：ConfigurationPropertiesValueObjectBeanDefinition 类型且不在单例池中的 ：验证：@BindMethod.forType(beanClass) == BindMethod.VALUE_OBJECT
							>本质上：就是 有 @EnableConfigurationProperties注解的一定要有@ConstructorBinding 注解。 
					>org.springframework.context.event.EventListenerMethodProcessor 的实现： 
					>org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration.PreserveErrorControllerTargetClassPostProcessor 实现：
						>bf里获取 ErrorController 实现： 取bd设置 org.springframework.aop.framework.autoproxy.AutoProxyUtils.preserveTargetClass 新属性。
		---后续注册beanPostprocessor：refresh()-->@registerBeanPostProcessors(beanFactory)
			>核心：PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this)	
				>直接获取bf里全部processor: 分类：之后开始注册：@registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors)
					>即：加到 bf里。
				>额外增加了2个processor: new BeanPostProcessorChecker() . new ApplicationListenerDetector(applicationContext)		
		--增加消息资源时：refresh()-->@initMessageSource() 注册了一个单例：@beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource)	名字为：“messageSource”		
		--增加上下文广播器也是：@refresh()-->@initApplicationEventMulticaster()  核心： @beanFactory.registerSingleton() 名字“applicationEventMulticaster”
		--启动tomcat：@onRefresh() 
			>对org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext实现： 
				>调用父类onRefresh()之后：@createWebServer()
					>从bf里获取 org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory 实现： 开始创建webServer：@factory.getWebServer(getSelfInitializer())
						>内部new Tomcat()之后封装到new TomcatWebServer(tomcat, getPort() >= 0) 内部大量的实现和初始化。
		--注册listeners: 将上下文监听器+bf里的listener增加到：上下文广播器里：.applicationEventMulticaster
		--实例化所有非懒初始化的单例 bean:@finishBeanFactoryInitialization(beanFactory)	此时已经说明没有再注册bd了。
			>核心：@beanFactory.preInstantiateSingletons()
				>遍历全部的bd: 对每个，分是factoryBean还是普通Bean：来分别 @getBean()
					>是工厂bean: 则 @getBean(FACTORY_BEAN_PREFIX + beanName)
					#否则： @getBean(beanName)
				>再次遍历遍历bd: 对每个，取单例，如果单例是 SmartInitializingSingleton 实现： 
					>调用单例的：@afterSingletonsInstantiated()完成其他工作。
		--完成刷新：@finishRefresh()
			>对 org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext 的实现： 
				>父类的finishRefresh()后启动webserver:@startWebServer() 后发布启动事件：@publishEvent(new ServletWebServerInitializedEvent(webServer, this))
		---附加：spring-boot最后：还会发布一个事件：@context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context)) 应用准备好事件。run()就完成了。所以run（）不会阻塞，从而继续执行main()后面的内容。	

>spring-boot-autoconfigure的原因：@EnableAutoConfiguration注解会加入大量的配置类
	>在它的spring.factories里：org.springframework.boot.autoconfigure.EnableAutoConfiguration的值非常多。都是自动配置类。典型的和tomcat有关的：org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration
	
>spring-boot在对scan的类中过滤出的配置类的解析，主要是解析新增哪些类？@processConfigBeanDefinitions()....@processConfigurationClass() 
		>@Import 注解指定的类：
			>ImportSelector类型：实例化它，后执行@selectImports()方法，返回更多的依赖的类名；这个心的类名数组--进行递归import:@processImports()  
			--例子：对myApplication 解析时： 这里增加的 具体类 就是： AutoConfigurationImportSelector 在 解析 myApplication的最后执行了@deferredImportSelectorHandler.process() --> 转向@ConfigurationClassParser.process()再转向@processGroupImports(), 此时就开始 取imports来遍历：
				>取的过程中就执行了@AutoConfigurationImportSelector.process()
					>先获取自动配置元数据：@getAutoConfigurationMetadata()
						>核心：@AutoConfigurationMetadataLoader.loadMetadata()
							>使用加载器加载"META-INF/spring-autoconfigure-metadata.properties", 然后封装到Properties,然后封装到new PropertiesAutoConfigurationMetadata(properties)
						>获取自动配置实体：@getAutoConfigurationEntry()
							>使用jar浏览方式浏览spring.factories来加载 EnableAutoConfiguration.class 的配置项实现类： @SpringFactoriesLoader.loadFactoryNames()	往往有100+个
							>从spring.factories里加载@SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter)然后 用来过滤。@filter.match(candidates, autoConfigurationMetadata) 过滤之后，只剩下一半 48+. 里面包括很多重要的配置类。然后再逐个遍历-执行@processImports() --这个执行内容是：ConfigurationClassParser@doProcessConfigurationClass(configClass, sourceClass, filter) 从后面的调用链知道，这个类会加到 configurationClasses 属性里。
								>这个do...方法：解析@Componet/@ComponentScan/@PropertySources@ImportResource/@Bean方法分别都加到configClass.add()进去，以备后用。@ComponentScan则继续浏览。do方法最后自己又加到 configurationClasses 属性里。
								--过滤后的配置包括： 
									>org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration   注册后name="propertySourcesPlaceholderConfigurer"
									>org/springframework/boot/autoconfigure/web/servlet/ServletWebServerFactoryAutoConfiguration 这个配置类有@Bean方法-所以是工厂类，工厂方法就是6个@Bean方法，
									>org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration
									>org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration
									>org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration
			>ImportBeanDefinitionRegistrar 类型： 实例化它，并且 增加到 @configClass.addImportBeanDefinitionRegistrar()以备后面的专门使用输入仓库。
			>其他类型： 直接增加到imports属性里，然后直接递归性质的当做配置类来处理了@processConfigurationClass() -->@doProcessConfigurationClass()
			--何时解析@Import：从处理bd仓库开始 @postProcessBeanDefinitionRegistry()-->@processConfigBeanDefinitions()-->@parse()的最后：@deferredImportSelectorHandler.process()-->@processGroupImports()-->@processImports()-->@processConfigurationClass()有注册到configurationClasses-->@doProcessConfigurationClass()就是解析@Component各种注解，从而会有各种递归解析-@Component解析member(内部类)时到@processConfigurationClass()， 而@ComponentScan 解析则递归到了@componentScanParser.parse()-->@scanner.doScan()-->后面就是注册bd到bf了。
				>configurationClasses中的class何时加载和注册到bf：@processConfigBeanDefinitions()-->在parse()后就是@reader.loadBeanDefinitions(configClasses)-->遍历每个class,对每个@loadBeanDefinitionsForConfigurationClass()来注册：包括注册：
					>这个配置类自己：@registerBeanDefinitionForImportedConfigurationClass(configClass)
					>bean方法：@loadBeanDefinitionsForBeanMethod(beanMethod)
					>importResource文件的解析加载：@loadBeanDefinitionsFromImportedResources(configClass.getImportedResources())
					>注解上的所有仓库的自己的注册方法：@loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars()) --> 对每个仓库@registrar.registerBeanDefinitions()
				--专门强调：解析一个配置类时：第一步 @processMemberClasses()解析成员：就是解析静态内部类--这个类上如果有@Configuration注解(含@Component注解)就可以当做候选的。因为5个条件满足其一：含注解@Component/@ComponentScan/@Import/@ImportResource/@Bean之一；一旦作为候选，从而开始解析它@processConfigurationClass()
					>典型有这种静态内部类的：
						>org/springframework/boot/autoconfigure/web/servlet/DispatcherServletAutoConfiguration
						>org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
						>org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration
						>org.apache.dubbo.spring.boot.autoconfigure.DubboAutoConfiguration  显然，在 dubbo-spring-boot-autoconfigure.jar里spring.factories里就有EnableAutoConfiguration的配置项；值之一就是这个配置类。
						>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration 在 spring-boot-autoconfigure.jar里，spring.factories里有最多的自动配置。
					>spring.factories里有的典型类：
						>ServletWebServerFactoryAutoConfiguration： 这个类又@Import ServletWebServerFactoryConfiguration.EmbeddedTomcat类(这个类又有@Bean方法--产生一个@TomcatServletWebServerFactory()实例)  ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar 之类，但是 spring.factories里是没有直接ServletWebServerFactoryConfiguration的，即它不是自动配置类；所以没有；所以即便在最后的bdm里，也没有直接实例化ServletWebServerFactoryConfiguration！！--仅仅是前面注入的它的内部类。
		>@ImportResource 指定的xml解析加载的类:
			>熟悉的操作：放到configClass里：@configClass.addImportedResource(resolvedResource, readerClass)
		>@Bean 方法指定的类 
>spring-boot 如何控制各个bean是否生成？
	>@ConditionalOnProperty 注解的@Bean ,则是通过yml配置文件中的属性来控制 这个bean是否有效/是否要生成。如@ConditionalOnProperty(value = "server.forward-headers-strategy", havingValue = "framework") 则 要求 server.forward-headers-strategy=framework;; 显然没有，就不会被实例化。
	
>aspectj 的植入代码的时机？https://www.jianshu.com/p/3c5b09f6f563
	>compile-time : 编译期： 在maven编译几千，有专门插件(aspectj-maven-plugin)来编译.aj切面文件，并将代码植入 . 
	>post-time: 编译后：已经生成.class/jar之后，读取.class来织入。来增强jar/class。。此时需要新建一个项目，加入切面类，配置pom:aspectj-maven-plugin 指定要增强的jar:(<weaveDependency>标签内) 然后对这个项目编译： mvn package；那么就会生成指定增强jar里的类到项目的target/classes目录下；。。当然这个项目的pom.dependency本身没有依赖这个jar---因此无冲突。 那么就使用了一个增强的jar! 。。即：其实没有 真正的改变jar里的内容。
	>load-time: jvm加载类的时候织入。需要vm启动参数：-javaagent:/Users/hongjie/.m2/repository/org/aspectj/aspectjweaver/1.8.13/aspectjweaver-1.8.13.jar  同时需要META-INF/aop.xml配置：指定切面+方法所在位置。
		--注意：maven-surefire-plugin 插件 中也可以配置vm启动参数：
	---运行时通过加方法拦截器的方式：拦截，只能对controller/service等才行；而对非spring创建的代理bean则无效！甚至比如dubbo 客户端代理服务接口生成的也不行。	
	
>spring-jdbc: 根据事务隔离级别 路由到不同的数据源？
	>核心控制类：IsolationLevelDataSourceRouter， 只需要@Bean化这个类就可以了,同时配置 targetDataSources 属性:--隔离级别-数据源的map，然后在@afterPropertiesSet()时就会解析到内部形成一个 传播级别int---数据源的map; 
	>何时使用：因为上述 IsolationLevelDataSourceRouter 继承了 AbstractRoutingDataSource ，后者又实现了 javax.sql.DataSource，所以其实这是一个数据源，是一个路由型数据源。作为一个数据源被使用的。所以它的@getConnection() 和 @getConnection(String username, String password)方法就是对外提供使用的，而且Driud 使用数据源 使用了这个接口，所以可能使用。。而实际内容就是根据事务传播级别，而事务传播级别这个参数只能从ThreadLocal里获取了：这个ThreadLocal就通过@TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()来获取到值；设置值也自然是：spring-tx的@AbstractPlatformTransactionManager.prepareSynchronization()方法阿调用时就设置了，这个正式初始化事务同步的时候。
	>事务如何打开的：从事务拦截器 TransactionInterceptor .invoke()开始： 即某个方法被反射执行之前，执行方法拦截器链，进入的其中之一方法拦截器：
		>事务方式环绕执行：TransactionAspectSupport@invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed)
			>查看是否有事务注解标签：TransactionAspectSupport@getTransactionAttributeSource() ,有则开始确定事务管理器：@determineTransactionManager(txAttr)
			>并将tm转为核心的平台事务管理器：PlatformTransactionManager ptm
			>后开始根据情况创建事务：TransactionAspectSupport@createTransactionIfNecessary(ptm, txAttr, joinpointIdentification):TransactionAspectSupport
				>获取事务：@tm.getTransaction(txAttr):TransactionAspectSupport/AbstractPlatformTransactionManager
					>获取事务：@doGetTransaction() 抽象方法 需要实现：看 spring-jdbc的：DataSourceTransactionManager
						>直接新建：@new DataSourceTransactionObject()
						>设置属性：允许保存点？=允许嵌套事务？；；；连接保持者ConnectionHolder: @TransactionSynchronizationManager.getResource(obtainDataSource()) 显然需要获取数据源：@obtainDataSource()---数据源来自 @DataSourceTransactionManager.getDataSource()-->内容：用当前线程中的事务隔离级别 从隔离级别-DataSource map 里查询出来。	
							>因此要看数据源的来源：则是用户配置时写的方法@Bean DataSourceTransactionManager 实例的时候，注入的：@DataSourceTransactionManager(DataSource dataSource) 注入完成。这里的数据源就是用户的。而用户现在创建的数据源是sharding-jdbc的：new ShardingDataSource()
								>自然的：获取的连接就是 sharding的连接：new ShardingConnection()
					>根据事务传播级别确定对事务的操作：如果要开启一个新事务：则@startTransaction(def, transaction, debugEnabled, suspendedResources) AbstractPlatformTransactionManager
						>真正开启事务：@doBegin(transaction, definition) 是抽象，需要实现：DataSourceTransactionManager 的实现：
							>设置只读、隔离级别等。
						>准备同步：@prepareSynchronization(status, definition)
							>使用事务同步管理器设置：事务活跃状态(是否有事务)、当前事务隔离级别、当前事务是否只读、当前事务名字；然后开始初始化同步：@TransactionSynchronizationManager.initSynchronization()
								--注意：事务隔离级别、是否只读、名字 都来自 事务定义TransactionDefinition--应该来自标签属性配置--即 TransactionAttribute。设置隔离级别：@TransactionSynchronizationManager.setCurrentTransactionIsolationLevel() 这个就是 路由数据源 在getConnection()时候根据的事务传播级别来源和选择哪个数据源---即将会使用的。
				>准备事务信息：@prepareTransactionInfo(tm, txAttr, joinpointIdentification, status)
	>事务拦截器如何被创建的？
		>渠道1：@JpaRepositoryBean.create()
			>转到：@CdiRepositoryBean.create() spring-data-commons
				>转到：@RepositoryFactorySupport.getRepository()
					>最后遍历processor处理：@processor.postProcess(result, information) TransactionalRepositoryProxyPostProcessor
						>直接new事务拦截器：@new TransactionInterceptor()...
		>渠道2： 用户自己编写一个@@Bean("txAdvice") 方法，方法内直接new TransactionInterceptor(TransactionManager ptm, TransactionAttributeSource tas)并设置相关属性。其中后者属性：map: 配置：方法特征string--事务特征 RuleBasedTransactionAttribute； 事务特征-包括事务传播级别/回滚规则/超时时间	
			>利用TransactionAttributeSource根据方法名+类获取匹配这个方法的事务规则配置 RuleBasedTransactionAttribute ：@tas.getTransactionAttribute(method, targetClass):NameMatchTransactionAttributeSource
				>
>service方法执行之前如何开启事务的？
	>如何确定使用哪个数据源？：	

>spring通过事务传播级别获取到了数据源，可能这个数据源是 ShardingDataSource, 这个是包装的，不是真正的数据源；所以使用这个数据源的时候，如何路由到真正的数据源？(master/slave)(sharding0-8)	
	>使用数据源：就是使用它的获取连接@getConnection()--实际上也只有这个重载方法。获取到了 Connection实例- ShardingConnection 对象。而连接使用的目的： 创建"语句声明"@createStatement()、 "准备声明"对象@prepareStatement(String sql)、设置自动提交状态、回滚@rollback()提交@commit()， 所以看 ShardingConnection的创建声明 PreparedStatement 实现：返回new ShardingPreparedStatement()对象，因此sharding的核心重心工作在声明类的实现里：聚焦关注这个声明类对 PreparedStatement 接口的实现 @PreparedStatement@executeQuery()、PreparedStatement@executeUpdate()等接口：所以 ShardingDataSource 就是通过重写这些方法， 而再内部重新路由到真正的数据源，用真正的数据源来发送sql请求的。因此看：@executeQuery()实现：
		>直接看 ResultSet ShardingPreparedStatement@executeQuery(): 
			>先清除：@clearPrevious() 包括: 声明、连接、结果集
			>再准备：@prepare()
				>使用准备引擎 创建 执行上下文：@prepareEngine.prepare(sql, getParameters())
					>参数复制：
					>执行路由：BasePrepareEngine@executeRoute(sql, clonedParameters)
						>注册路由装饰器：@registerRouteDecorator()
							>再次以SPI机制获取 RouteDecorator 的Class： 遍历，对每个： 
								>用 rules来过滤：如果规则类和 装饰器类 一致： 则使用路由器执行注册 规则-装饰器：@router.registerDecorator(rule, routeDecorator) ：就放到了 decorators :map里。
						>执行路由：@route(router, sql, clonedParameters)
							---PreparedQueryPrepareEngine 实现为例： 
								>直接路由器路由：@dataNodeRouter.route(sql, parameters, true)
									>核心：@executeRoute()
										>遍历每个装饰器：调用它的装饰方法：@decorate()并且是流水线一样的装饰，所以最终结果直接返回。
											---MasterSlaveRouteDecorator 主从装饰器实现：
												>将主从规则放到主从数据源路由器：然后调用路由器的路由方法：@new MasterSlaveDataSourceRouter(masterSlaveRule).route(routeContext.getSqlStatementContext().getSqlStatement())
													--最核心的路由逻辑出现：
													>先判断是否是主路由：@isMasterRoute(sqlstatement):是则设置主访问过：@MasterVisitedManager.setMasterVisited() 然后从主从规则获取主数据源名返回：@masterSlaveRule.getMasterDataSourceName()
														>主路由条件：满足其中之一
															>包含lock的select语句：
															>非select语句：
															>master已经访问过：@MasterVisitedManager.isMasterVisited()
															>hint只读主：@HintManager.isMasterRouteOnly()
													>不是主路由：则使用负载均衡算法 获取一个从数据源名：@masterSlaveRule.getLoadBalanceAlgorithm().getDataSource()
														---RoundRobinMasterSlaveLoadBalanceAlgorithm 轮询算法：自增数自增取模。
														---RandomMasterSlaveLoadBalanceAlgorithm 随机算法为例： 就是随机取一个。ThreadLocalRandom.current().nextInt(范围)
											---ShardingRouteDecorator 分区装饰器实现：
												>获取分区条件：@getShardingConditions()  确定列名-表名的映射。对于分区列，建立专门映射。
													>分insert: 无where
													>非insert: 有where
												>创建分区路由引擎：@ShardingRouteEngineFactory.newInstance()  语句不同 则 引擎专门。
												>执行路由：	@shardingRouteEngine.route(shardingRule)
													--ShardingDefaultDatabaseRoutingEngine 实现： 获取默认数据源名+ 逻辑表名集合。
													--ShardingStandardRoutingEngine 实现： 
														>根据规则获取数据节点：@getDataNodes()
														>生成路由结果：@generateRouteResult()
															>是否走hint路由：即数据库分区策略 和 表分区策略都是 HintShardingStrategy 实例。 
															>只要不走hint，就走分区条件路路由：@isRoutingByShardingConditions()
																>执行分区条件路由：@routeByShardingConditions()-->@routeByShardingConditionsWithCondition()-->@route0()-->@routeTables()
																	>核心：通过规则获取分区策略并进行分区：@shardingRule.getTableShardingStrategy(tableRule).doSharding()
																		---InlineShardingStrategy 策略为例：
																			>核心：对每个分区值 PreciseShardingValue 进行解析执行：@execute(each)
																				>使用groovy表达式来解析：@closure.rehydrate(new Expando(), null, null)
					>直接创建执行引擎：new ExecutionContext(routeContext.getSqlStatementContext())
					>执行引擎增加执行单元：@result.getExecutionUnits().addAll(executeRewrite(sql, clonedParameters, routeContext))	显然，入参有个重写方法：
						>重写执行：@executeRewrite()
							>注册重写装饰器：@registerRewriteDecorator()
								>获取 使用SPI机制加载的 SQLRewriteContextDecorator 实现类Class：遍历 ，对每个：反射创建实例, 用 rules 属性来过滤，如果规则类实例中有一个和 当前装饰器实例相同 ， 那么就 使用重写器注册 规则+装饰器：@rewriter.registerDecorator(rule, rewriteContextDecorator)
							>创建SQL重写上下文：@rewriter.createSQLRewriteContext(...)
								>创建重新上下文：new SQLRewriteContext()
								>进行装饰：@decorate(decorators, result, routeContext)
									>遍历前述的 规则-重写装饰器：对每个装饰器：逐个调用装饰方法：@decorator.decorate(rule, properties, sqlRewriteContext)
										--ShardingSQLRewriteContextDecorator 实现为例：
											>获取所有需要重写的参数：进行重写：@each.rewrite(): ParameterRewriter
								>重写引擎生成sqltokens: @result.generateSQLTokens()
							>开始重写：@rewrite(...)
								>新建重写引擎重写：@new SQLRewriteEngine().rewrite(sqlRewriteContext)
									>直接轮询机制获取一个数据源名，后封装到一个执行单元里：返回：@new ExecutionUnit()
			>初始化 准备声明执行器：@initPreparedStatementExecutor()
				>
			>合并查询：@mergeQuery()
			>获取结果集合并返回：@new ShardingResultSet(preparedStatementExecutor.getResultSets()...)	
			
>spring-boot环境下，代理类的advised如何设置值的，值的来源有哪些？
	>来源1：bean工厂方式创建的对象，即便是mapper的接口的代理，后也会经过 初始化完成后的应用beanpostprocessor:AbstractAutowireCapableBeanFactory@applyBeanPostProcessorsAfterInitialization()遍历processor:	
		>对于 PersistenceExceptionTranslationPostProcessor ： 调用到其父类：@postProcessAfterInitialization(result, beanName)
			>如果是候选：@isEligible(bean, beanName)，切点匹配；
			>匹配则：添加自己的advisor:@proxyFactory.addAdvisor(this.advisor):org.springframework.dao.annotation.PersistenceExceptionTranslationAdvisor  是sprint-tx内部自己的。
			--最终创建的是：JDKDynamicProxy, 且只有一个 advisor
		>对于 org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator ： 进入包装方法：AbstractAutoProxyCreator@wrapIfNecessary(bean, beanName, cacheKey)
			>先也有：@shouldSkip(bean.getClass(), beanName))过程。
			>核心：直接获取适合这个类的 通知 + 建议者：@getAdvicesAndAdvisorsForBean()
				>直接转：寻找合格的@findEligibleAdvisors(beanClass, beanName)
					>先找候选：@findCandidateAdvisors()
						>先父类：@super.findCandidateAdvisors()-->父类转：@this.advisorRetrievalHelper.findAdvisorBeans()
							>内部有缓存advisor名：@cachedAdvisorBeanNames属性里；否则从bf里查找Advisor类型的全部bd来补充：@BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false)
							>遍历使用bf创建：@beanFactory.getBean(name, Advisor.class) 收集起来返回。
							----注意：此时不会发现@Asepct注解的类及其通知，因为 @Asepct没有@Componet等注解，非spring一套。
						>后尝试从aspectJ中补充：@aspectJAdvisorsBuilder.buildAspectJAdvisors()	
							>启动寻找有aspectj注解的类：
								>从bf里查找所有Object的子类的bn:@BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false) 非单例也包括。
									>遍历每个bn: 从bf里获取类型：查看这个类型是否是aspect切面类@this.advisorFactory.isAspect(beanType) 
										>即有@Aspect 注解：@AnnotationUtils.findAnnotation(clazz, Aspect.class) 且 方法的 field 名称 中至少有一个 是 "ajc$" 开头的---即已经被aspectj 字节码修改过了/编辑过了。
										#如果都有：那么就是，加到 aspectNames 属性里。接着，获取类里的全部Advisor:@this.advisorFactory.getAdvisors(factory:BeanFactoryAspectInstanceFactory)
											>获取全部的Advisor:@getAdvisorMethods(aspectClass)
												>即遍历类：获取@AnnotationUtils.getAnnotation(method, Pointcut.class)有 Pointcut 注解的方法：
												>对每个注解方法：获取Advisor:@getAdvisor(method...)
													>获取表达式等：@getPointcut()
														>获取一种通知类型：@findAspectJAnnotationOnMethod(): Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class
														>取这个通知类型的切点表达式：@aspectJAnnotation.getPointcutExpression()，封装到新增的一个切点表达式类里：@new AspectJExpressionPointcut()
													>封装而返回：@new InstantiationModelAwarePointcutAdvisorImpl()
														>对 单例切面，需要实例化通知：@this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut)
															>@this.aspectJAdvisorFactory.getAdvice()
																>从切点取通知：@.aspectJAdvisorFactory.getAdvice(pointcut...):ReflectiveAspectJAdvisorFactory, 入参有切点方法
																	>根据切点方法的注解类型：@aspectJAnnotation.getAnnotationType(): AtPointcut, AtAround, AtBefore, AtAfter, AtAfterReturning, AtAfterThrowing 封装到不同对象里：如：@new AspectJAroundAdvice()
																	--这个就是最终返回的 需要的 Advice 
												>加到结果集合里，List<Advisor>, 然后可能增加：SyntheticInstantiationAdvisor:Advisor	
												>遍历类的每个Field: 如果上面有@DeclareParents主机， 那么需要封装到@new DeclareParentsAdvisor()返回。加到结果集里。
							>返回结果集即可。					
					>过滤可以应用的：@findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName)
						>核心：转@AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)
							>遍历每个候选Advisor:合格条件： 是 IntroductionAdvisor 类型， 第二：@org.springframework.aop.support.AopUtils#canApply(org.springframework.aop.Advisor, java.lang.Class<?>, boolean)为true:
								>如果是 IntroductionAdvisor ： 需要类过滤器匹配:ClassFilter:TransactionAttributeSourceClassFilter
								>如果是 PointcutAdvisor 类型： 需要切点匹配；方法匹配：直接转：@canApply(pca.getPointcut(), targetClass, hasIntroductions)
									>核心为遍历这个类的所有方法：至少有一个方法匹配到@org.springframework.aop.aspectj.AspectJExpressionPointcut.matches(method, targetClass, hasIntroductions)	才返回true: 
									>遍历这个类的所有方法：至少有一个方法匹配到：@methodMatcher.matches(method, targetClass) 才返回true;否则false。。@org.springframework.aop.support.MethodMatchers.UnionMethodMatcher#matches(java.lang.reflect.Method, java.lang.Class<?>)
										>类匹配+方法匹配：@matchesClass1(targetClass) && this.mm1.matches(method, targetClass)) 方法匹配要求方法有xx注解。
							---ProxyTransactionManagementConfiguration 需要研究，里面有事务建议者。	
					>再次以扩展方式增加Advisors:@extendAdvisors(eligibleAdvisors)
						>在advice chain前面增加 ExposeInvocationIntercepter:@AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors), 条件是：
							>advisors不是空且有advisor是 aspectj通知： 条件满足之一：通知者类型=InstantiationModelAwarePointcutAdvisor，通知类型=AbstractAspectJAdvice，PointcutAdvisor通知者但是切点=AspectJExpressionPointcut
				>如果没有通知者：那么不会代理，不需要代理。
				#否则创建代理：AbstractAutoProxyCreator@createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean))	
					>直接构造@new ProxyFactory()配置后.@proxyFactory.getProxy(getProxyClassLoader())
		>对于 org.apache.shardingsphere.transaction.spring.ShardingTransactionTypeScanner： 构造方法就设置this.advisor = new ShardingTransactionTypeAdvisor()
			>直接转父类 AbstractAdvisingBeanPostProcessor :
				>先看是否合格：@isEligible(bean, beanName)
					>就是看advisor是否用于这个类：@AopUtils.canApply(this.advisor, targetClass)
				>合格: 则直接新建new ProxyFactory()配置，增加advisor: @proxyFactory.addAdvisor(this.advisor) 然后也是创建：@proxyFactory.getProxy(getProxyClassLoader())
	>来源2：bf创建中，实例化之前：也会应用processor: @AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation()	
		>对 org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator ： 调用父类 AbstractAutoProxyCreator@postProcessBeforeInstantiation(Class<?> beanClass, String beanName) ---其实没有用；因为根本不会加到任何advisors里。
			>如果这个是基础设施类：@isInfrastructureClass(beanClass)--即Pointcut/Advisor/Advice/AopInfrastructureBean, 则要添加到@this.advisedBeans 属性里。 
			>或者是应该忽略的：@shouldSkip(beanClass, beanName) 转到 AspectJAwareAdvisorAutoProxyCreator 实现看：
				>寻找候选通知者：@findCandidateAdvisors()
					>先父类：@super.findCandidateAdvisors() -->@this.advisorRetrievalHelper.findAdvisorBeans() 和上述同。
					>后自己构建：@this.aspectJAdvisorsBuilder.buildAspectJAdvisors() 同上。