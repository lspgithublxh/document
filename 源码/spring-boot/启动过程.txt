//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备；化被动为主动去做)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
//大的想法，具体行动。
//出现了if-else就是因为有不同的考虑。
//阅读文档达到直接可以看出思路编写程序的清晰逻辑的地步。
//一个大函数功能直接看懂而描述。
//从网上找答案变为从源码中找答案。
//功能组织体系，而不是动作实现体系。是目标，是事情，而不是精细到实现方案的动作。
//数据源-数据结果模式：而不是全部动作过程。
//能够主动猜某个方法的功能和猜测它的实现。
//情况-通用处理。
//情况-精细结构。
//数据结构-与处理。
//某个时刻某个地方：所有可能用户做的事情。
//就像是军队打仗一样：AbstractApplicationContext上下文就是总部主帅，负责整个流程，但实现个别子流程；ServletWebServerApplicationContext就是地区主帅，负责使用总部流程且根据区域情况具体化部分流程实现，同时负责分给不同的人去实现更细的子流程(用人/用器：如事件广播器、bean工厂、生命周期处理器; 向它们发号命令：调用/叫他们做什么)，层层下去到事务的精细结构。(负责事务的精细级别 就看出 和一线的和当前的距离)
	>对一个事物类：他是有属性
	>对一个组织类：他是有人；属性当作人。人可能是为他办事的，也可能是监听他的监听器。
	>对一个系统类：他是有组件/器具；属性当作器具
//为什么层次多：因为连续地向上进行了抽象，每层都分类了/拆分了不同的功能，每层连续往下拆分。
>SpringApplication 静态部分：
	>日志Log实例的创建： 
		>获取日志工厂：可能是SLF/commons-logging
			>获取线程上下文加载器：
			>加载配置文件："commons-logging.properties" , 使用@loader.getResources(name)来获得路径URL,然后利用@url.openStream()-->Properties.load(stream)即可实现资源流入Properties里；
				>这个配置文件里可能有“org.apache.commons.logging.LogFactory”的key, 则取出value: 作为Class进行实例化 
			>系统配置里取："org.apache.commons.logging.LogFactory" 为key的值，System.getProperty()	 第一个进行实例化
			>如果上述没有找到：开始 寻找"META-INF/services/org.apache.commons.logging.LogFactory"资源，加载进来：@getResourceAsStream(contextClassLoader,SERVICE_ID), 读取首行当做工厂名，进行加载和实例化
			>如果还是没有找到：就使用上上步骤从commons-logging.properties 里找到的工厂名，进行实例化，并且将props里的其他k-v一并设置加入；	
			---并且有缓存模式；
		>根据工厂获取实例：@getInstance(Class clazz)
			---org.apache.commons.logging.impl.LogFactoryImpl的实现：直接构造方法实例化创建实现；
			---org.apache.commons.logging.impl.SLF4JLogFactory的实现：很明显要：适配一下。。。注意不是桥梁模式(桥梁交错模式，就像”机枪+人“的交错，实现各种人持有各种抢的效果！两个维度的交错，从直角坐标系下可以直观看出)
				>先是：Logger slf4jLogger = LoggerFactory.getLogger(name) 即slf4j独有的，后注入到：new SLF4JLog(slf4jLogger)/new SLF4JLocationAwareLog((LocationAwareLogger) slf4jLogger) 来实现
>SpringApplication.run()开始：
	>new SpringApplication()：主要任务：
		>判断web应用类型(特定类加载是否成功)：webApplicationType:servlet/reactive/none
		>加载spring工厂实例集合：先从classpath所有jar中查找所有的工厂名，然后过滤出 ApplicationContextInitializer 的子类，然后实例化； //归结为一个基本问题；对于一个文件(如log4j2.component.properties)，如何找到而加载它的？
			>预备：
				>加载器：(jar里的任何部分都可以寻找和加载)
					>三级加载器(先后尝试加载xx file)：上下文加载器-->类加载器-->系统加载器
						>具体调用：@Enumeration<URL> cl.getResources(string:resource) 实现为双亲委派;迭代的每次，返回一个要寻找的jar包；java.lang.ClassLoader类的实现；
							>则先用 URLClassPath--Launcher.BootClassPathHolder.bcp 来加载：
								>@Enumeration<URL> getBootstrapClassPath()
									>@Enumeration<Resource> getResources(String var1) 内部实现就是 它的6个加载器--对应6个jar来尝试从中加载；sun.misc.URLClassPath.loaders:list 共有6种：分别对应jre/lib/下的resource.jar\rt.jar\jce.jar\jsse.jar\charsets.jar\jfr.jar
										>封装过程: string-->new URL()-->URLConnection-->JarURLConnection-->JarFile-->new Resource()
										>对一个name: 会先@getResource(String var1, true)尝试加载：JarLoader
											>主线：先name的包名 匹配，MetaIndex的实例，其contents属性值里含有如“javax/crypto”字符串，为包名匹配，一旦匹配到了，进入@Resource getResource(String var1, boolean var2, Set<String> var3)详细匹配：
												>主线：将根据csu基本属性(值如file:/C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jce.jar)构造URL, 然后构造new URLClassPath.JarLoader()，放到 lmap 属性里：
												>这个方法里：已经解析了一个jar的完整META-INF结构：在index.indexMap属性里；
												
									>后直接將Enumeration<Resource>转换为 new Enumeration<URL>()返回；
							>后用@findResources(name) 用户的实现来寻找和加载；这个就是并列于上述的@getResource(string,boolean)方法的；---加载路径不同。
								>直接看这个方法返回new Enumeration<URL>(){}里面的@next()的实现：
									>也是一个循环：先取下一个loader-->后用这个loader来加载资源 ..
										>其中：第一步：@URLClassPath.this.getNextLoader(int[],int)第二个参数就是index++索引。此方法的实现：直接走@this.getLoader(var2)，里面的实现则更直接：按索引获取list中的元素-加载器即可：(URLClassPath.Loader)this.loaders.get(index) 这里的loaders有288个，各个jar的加载器都专门有---且地址不一样即使不同的加载器实例；而每个加载器都有记录它加载的是哪个jar；
											>这样：就相当于遍历了288个jar.	
											>loaders: 如何填满的；lmap 同理又是如何填满的。
												>填满过程：遍历jar路径过程中：对找到的每个jar的完整路径名字，直接新建一个 加载器对象：@new URLClassPath.JarLoader(), 加载器直接放到loaders里，而name-loader 则put到lmap里！！
													>new加载器方法正是：@URLClassPath.Loader getLoader(final URL var1)
												>整体过程：在第一个组件请求被加载的时候，因为要寻找匹配的，所以加载的很多没有匹配的jar-实际已经先存到loaders/lmap里缓存下来了。这个依赖从urls弹出 完整的 url jar路径。
											>urls： 初始化：
												>初始化： 
												>补充：@URLClassLoader.getLoader(int var1)有一次补充的过程:@push(URL[]),数据来源：@URL[] URLClassPath.JarLoader.getClassPath()，这个loader就是 @this.getLoader(var2)也就是返回new ..JarLoader()的方法；因此确实走的 JarLoader的获取URL[]实现：
													>来源获取过程：@JarLoader.getClassPath()的实现：
														>@ensureOpen()： 确保jar打开，设置JarLoader.jar/.index/.lmap属性； 
															>lmap: key:file:///C:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/access-bridge-64.jar, value=JarLoader实例
														>@parseExtensionsDependencies()
														>@jarFileHasClassPathAttribute() 查看jar是否有class-path属性, 有，那么就要读取出来，然后把这个jar路径也包含进来，即@push()进来；但这里十分奇怪
															>@parseClassPath(URL var1, String var2) ： 将class-path里的jar，封装为URL时：直接替换最后的位置：new URL(URL,string)最后形成 file:/D:/mvn/repository/com/sun/xml/bind/jaxb-impl/2.2.7/jaxb-api.jar 这种奇怪的路径
													>有个native方法：@native URL[] getLookupCacheURLs(ClassLoader var0)
												>但是来自URLClassLoader实例为主：从 URLClassLoader 的实例化过程看，很多URL[]注入；
													----LauncherImpl中的实例化看：
														>是从jar属性里的JavaFX-Class-Path 属性 对应的 值 ---空格分隔的所有jar路径；封装到new File()里，然后file.getCanonicalFile().toURI().toURL()来获取URL,最终为数组；
													----tomcat-embed-core的org.apache.catalina.startup.Tool.main()函数的实现：
														>路径1：${catalina.home}/lib , ${catalina.home}/classes  其中，对于/lib下，会当做目录，从而寻找目录下的所有file:list()然后遍历封装为new File()加入集合；
														>路径2：运行入参里有-common, -server, -shared ,则加入  ${catalina.home}/common/lib|classes,  common|server/shared 可见跟自己的路径有关；
													----org.aspectj.util.Reflection.runMainInSameVM(String classpath, String className, String[] args)的实现： 
														>直接从classpath里：split之后每个部分都封装为URL(string)
													----javax.tools.ToolProvider.findSystemToolClass()实现： 
														>寻找 System.getProperty("java.home")， 然后 拼接 /lib/tools.jar  来构造File().toURI().toURL()为URL对象
													----ReflectionBasedReferenceTypeDelegate 也有实现：aspectweaver    Class.forName加载 org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate 时
															>出自：bean inititial之时 获取processor执行的时候：核心processor: 获取匹配的Advisor切点/通知: AnnotationAwareAspectJAutoProxyCreator 其中在 @wrapIfNecessary()时候  有关键的方法：// Create proxy if we have advice.  Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName,null);
													----sun.misc.Launcher()的实现： 
														>Launcher类的静态属性：就有 @new Launcher()的一个属性。赋值给了launcher静态属性；构造方法的实现：
															>静态方式获取一个扩展类加载器：@Launcher.ExtClassLoader.getExtClassLoader()
																>经典的单利模式实现：双重锁定+volatile; 静态方法获取：具体内容：
																	>获取扩展路径：@Launcher.ExtClassLoader.getExtDirs()  
																		>@System.getProperty("java.ext.dirs")为核心，进行split处理得到File[]
																	>对每个File,注册元索引数据：@MetaIndex.registerDirectory(File)
																		>核心：@获取file/meta-index 这个子文件，如果存在，那么FileReader其内容，一行行读取：每一行提取封装为key:new File(var0, var4), value: new MetaIndex(var6, var5)  放到静态属性 MetaIndex.jarMap里；
																	>利用File[]新建扩展类对象：@new Launcher.ExtClassLoader(var1)
																		>获取每个File下所有的文件中非meta-index名字的文件，封装到new File()里，再转URL:@getCanonicalFile(); 再路径编码@ParseUtil.fileToEncodedURL()统一为/xx/xx/格式URL,这样就获取了一个URL数组，：@getExtURLs(var1)
																		>非常振奋的，开始调用@new URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)这个父类接口，也就是实例化父类：终于有了 URLClassLoader.ucp=new URLClassPath(urls, factory, acc)的执行；
																		>很关键的，先回调方式保存的ucp，这里获取它：调用@ucp.initLookupCache(this)--this就是 ExtClassLoader 实例；
																			>获取URLs:@getLookupCacheURLs(var1) 赋值给 实例 URLClassPath.lookupCacheURLs
																				>获取的实现：这个方法是一个静态方法：@native URL[] getLookupCacheURLs(ClassLoader var0)
																		---至此：ExtClassLoader实例创建完毕！！
															>利用上述扩展类加载器实例，获取一个实例化的AppClassLoader:@Launcher.AppClassLoader.getAppClassLoader(ClassLoader) ,后赋值给loader属性；
																>获取类路径配置：@System.getProperty("java.class.path")， 然后切割字符串，每个部分都直接new File(string),然后将这File[]返回； 
																>File[]转URL[]: @Launcher.pathToURLs(var2), 也就是逐个@getFileURL()--->内容就是 v0.getCanonicalFile() 后通过@ParseUtil.fileToEncodedURL(file)来返回。
																>进一步利用URL[],开始构造 AppClassLoader 实例：@new Launcher.AppClassLoader(var1x, var0)
																	>调用父类：@new URLClassLoader(URL[] urls, ClassLoader parent, URLStreamHandlerFactory factory)
																	>直接的：@this.ucp.initLookupCache(this) this就是 AppClassLoader实例；
															>线程上下文加载器的设定：@Thread.currentThread().setContextClassLoader(this.loader) 就是上一步得到 的 AppClassLoader实例。
															>安全管理器的实例化：@System.getProperty("java.security.manager")获取，后用this.loader来加载并实例化：@this.loader.loadClass(var2).newInstance() 后设置到 安全上下文：@System.setSecurityManager(var3)
														>额外重要一点：Laucher的被使用：
															>ClassLoader.initSystemClassLoader()里：既获取了@sun.misc.Launcher.getLauncher() 又获取了AppclassLoader 设置到了ClassLoader.scl静态属性里；
															>ClassLoader.getSystemClassLoader()里：@checkClassLoaderPermission(scl,Reflection.getCallerClass()) 参数方法是个native方法，获取调用方法所在类Class:A, 如果A的类加载器B是 scl的父类，那么无需检查，否则需要安全检查：@ sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION)
																>实际返回的还是：scl
																--引用的其他地方：@ClassLoader.getSystemResources(String name)
															>补充：scl加载一个类：@scl.loadClass(String name) 实际就是 ClassLoader的加载
																>加锁：每个name都给一个Object()锁对象：parallelLockMap
																	>首先尝试native加载：@native final Class<?> findLoadedClass0(String name)
																	#如果null：双亲委派加载：@native Class<?> findBootstrapClass(String name)
																	#再次null: 调用自类的实现：这里就是 URLClassLoader的实现：@Class<?> findClass(final String name)
																		>核心：即上述已经表达了的：加权方式：将name替换为xxx/xxx/xx.class形式后@ucp.getResource(path, false) 得Resource, 后：@defineClass(name, res)实现加载Class。。。自然就是从所有的urls里去寻找匹配的部分，匹配到为止；
																			>注意后面的@defineClass(name,res)方法，因为：@java.nio.ByteBuffer bb = res.getByteBuffer()很明显，已经得到了jar的byte[]后面 大家在就很自然了；！
																				>另外：Resource.url:URL的值是类似这样的完整类型的：protocol:jar,file:"file:/C:/Users/lonel/AppData/Local/JetBrains/IntelliJIdea2020.2/captureAgent/debugger-agent.jar!/com/intellij/rt/debugger/agent/CaptureAgent$KeyProvider.class"
																				>涉及的：Resource获取Inputstream： 
																					>第一种：@JarLoader.this.jar.getInputStream(this.jar.getJarEntry("com/intellij/rt/debugger/agent/CaptureAgent$InstrumentPoint.class")) 即jar+class明确
																						>获取class名后加载：得com/intellij/rt/debugger/agent/CaptureAgent$ParamKeyProvider.class的byte[]数组，调用@native long getEntry(long jzfile, byte[] name,boolean addSlash)方法 后@new ZipFileInputStream(jzentry)实现得到流；从这个流里又可以读出数据到byte[]里；为@Resource.getBytes()方法 ，到这个地步，调用 到 @defineClass1()就很自然 了；
																					>第二种：
															>补充2：ClassLoader.getResource(string)里最后一步调用的@findResource(string)的实现： 
																>加权：调用@ucp.findResource(name, true)来实现；
																	>核心：也是 @getNextLoader()---直接从loaders里按索引获取；然后 直接new URL()@URL findResource(String var1, boolean var2)
																>出处： @org.apache.logging.log4j.core.util.Loader.getResource(final String resource, final ClassLoader defaultLoader)	
																	>出处：获取配置：测试时甚至名字是随机的：@org.apache.logging.log4j.core.config.ConfigurationFactory.getConfiguration(loggerContext, name, configLocation) 后设置配置；
																		>出处：启动LoggerContext.start() 日志上下文的启动
																			>出处：上下文的获取@LogManager.getContext(cl, false)
																				>出处：获取logger:@AbstractLoggerAdapter.getLogger(final String name)
																					>出处：@org.slf4j.LoggerFactory.getLogger(String name) 进一步出自：@getLogger(Class<?> clazz)
																						>解析出处：@@Slf4j这个注解导致。
													----sun.misc.Launcher的静态方法实现：
														>出处：ClassLoader的@Enumeration<URL> getResources(String name)方法里的@getBootstrapResources(String name)方法实现：真正最主要的出处！！
															>核心：@getBootstrapClassPath() 
																>直接：sun.misc.Launcher.getBootstrapClassPath()
																	>直接返回：@auncher.BootClassPathHolder.bcp
																		>这个静态属性采用static{}初始化的方式实现：
																			>如果根路径存在：@bootClassPath = System.getProperty("sun.boot.class.path")
																				>直接转File[]:@Launcher.getClassPath(Launcher.bootClassPath)
																					>对每个的Parent进行注册一次：@MetaIndex.registerDirectory(var5)
																				>对每个File: 常见方法转URL：@getFileURL(File var0)	
																			>不存在：则new URL[0] 来设置，@bcp = new URLClassPath(var0, Launcher.factory, (AccessControlContext)null)；然后进行初始化：@bcp.initLookupCache((ClassLoader)null)	
															>然后：@getResources(name) 内容就是常见的 nextloader()+load()来实现；
														>出处的出处：最常见的就是SPI机制实现中的ServiceLoader中加载 @loader.getResources(fullName)	，而这里的fullName=如："META-INF/services/javax.management.remote.JMXConnectorServerProvider"
															>出处： SPI机制获取 JMXConnectorServerProvider.class接口的实现类， 而实现类Provider提供的则是如：@new RMIConnectorServer(serviceURL, environment, mbeanServer)这样的货物；
																>出处：@JMXConnectorServerFactory.newJMXConnectorServer(var4, var0, var3) 
																	>出处： @ConnectorBootstrap.startLocalConnectorServer()
																		>出处：@sun.management.Agent.startAgent()
																			---自定义同名方法出处：@javassist.util.HotSwapAgent.redefine(Class<?> oldClass, CtClass newClass) 而byte-buddy里也有类似利用asm的重新定义类的方法；
																			...
																				>出处：@PostVMInitHook.run()直接调用@trackJavaUsage() 实现内容：@new UsageTrackerClient().run("VM start", System.getProperty("sun.java.command"))
										>第二步：@var1x.findResource(var1, var2) 其中 var1x 就是上一步获取的某个序号对应的加载器实例；
											>调用@Resource getResource(String var1, boolean var2)：就是从jar里加载 路径var1 匹配的部分：但是对一个name 只有固定的urls个数，仅仅在urls里所有的jar路径匹配完了就不再寻找；找到了则可以@defineClass(name, res)定义了，但是没有找到则：
												>核心：@JarEntry var3 = this.jar.getJarEntry(var1)很明显是尝试获取匹配的内容；这个var1如"META-INF/log4j-provider.properties"；(也包括初始化加载--获取META-INF内的索引内容结构内容)
													>成功例子：输入org/apache/logging/log4j/core/selector/ContextSelector.class， 在 file:/D:/mvn/repository/org/apache/logging/log4j/log4j-core/2.12.1/log4j-core-2.12.1.jar 里寻找；
													>成功之后的验证：构造new URL(), 封装到new Resource(){}里返回。@Resource checkResource()
								>扩展类加载器：ext路径下，12个jar
								>应用类加载器：Launcher$AppClassLoader ：就是6+12+工程的target/classes+ pom仓库路径如288个。这些信息在.ucp.path|lmap|loaders都有记录；
							>另外：URLClassLoader.findClass(final String name)也是利用 URLClassPath.getResource(path, false)来实现，且内部依然使用URLClassPath的@getNextLoader()+@getResource(var1, var2)来实现加载目标类的；
								>当用@URLClassPath.getResource("xx/xx/xx/xx.class", false)没有找到,也直接退出，返回null;找到了Resource,则@defineClass(name, res)定义了--加载byte[]数据...native方法调用；
								
						>然后遍历这个枚举的所有可能寻找jar包路径：从URL 封装为new UrlResource();则返回 Collection<UrlResource> @Collection<UrlResource> findUrlResources(final String resource)。。为 org.apache.logging.log4j.util.LoaderUtil的实现；
					>完成后往往：重新将 Collection<UrlResource> 转为 Collection<Url>, 而此时可以遍历url，然后利用url.openStream():InputStream-->Properties	从而被加载；典型为@PropertiesPropertySource.loadPropertiesFile(final String fileName)的实现；(这个类的目的：然后将Properties里的kv放到System.setProperty(key, value))。。所在PropertiesUtil类 ，则又利用SPI机制来加载实现类。
						>SPI机制加载接口类的实现类：@ServiceLoader.load(PropertySource.class, classLoader)  就是加载 PropertySource 接口的实现类；注入的cl就是三级加载器的依次；
							>返回的ServiceLoader是个迭代器： new的同时还 new LazyIterator(service, loader) 另一个迭代器。外层迭代--是直接先调用providers属性的迭代--没有了则以LazyIterator的迭代进行补充；重点为 LazyIterator的迭代：
								>hasNext(): 主线逻辑就是@Enumeration<URL> loader.getResources("META-INF/services/" + service.name);加载这个文件；然后获取这个文件内容按行构成的集合的迭代器：name-value
								>next(): 主线逻辑就是加载 上述 的最后的 name(某行的name-类名)： @Class.forName(cn, false, loader)，后实例化且强制转换为目标接口类service.cast(c.newInstance())， 再放到providers里；
							--是通过 jdk里的接口加载classpath目录下jar里的实现类；而 显然 AppClassLoader实例可以---因为里面的urls里包含了java.class.path里的每个jar的路径，但不能直接获取，但因为设置到了线程上下文里，所有直接无需新接口，而直接可以线程隔离地、内部不同地方又共享/分时共享的前后共享的获取到这个 AppClassLoader 实例。
						>非SPI机制但也加载了实现类：通过遍历jar寻找目标文件，然后解析文件而得：
							>先@getResourceAsStream(contextClassLoader, "META-INF/services/org.apache.commons.logging.LogFactory")
								>出处：
							>然后读取第一行：接着直接当做类名加载：@classLoader.loadClass(factoryClass)然后实例化@.newInstance()
				>加载jar: jar的路径封装到URL里后openConnection() JarURLConnection	
					>路径例子：jar:file:/D:/mvn/repository/org/apache/logging/log4j/log4j-slf4j-impl/2.12.1/log4j-slf4j-impl-2.12.1.jar!/org/slf4j/impl/StaticLoggerBinder.class
					>一般(转换)过程：文件名-->URL-->
			>查找工厂名：@SpringFactoriesLoader.loadFactoryNames(type, classLoader) , 入参类就是 ApplicationContextInitializer ；加载器：默认的三级顺序；
				>查找全部工厂文件中的工厂名-实现类列表：@loadSpringFactories(@Nullable ClassLoader classLoader)
					>查找工厂文件：先@classLoader.getResources("META-INF/spring.factories") 方式，后@ClassLoader.getSystemResources("META-INF/spring.factories"))方式 
					>对找到的每个文件：封装到 Properties , 后 遍历每行，key=工厂name, value=工厂实现类名集合；存到map里；返回这个map;
				>获取org.springframework.context.ApplicationContextInitializer为name的所有工厂实现类集合：get一下而已；
			>实例化工厂名：@createSpringFactoriesInstances()
				>遍历：逐个加载@ClassUtils.forName(name, classLoader) 后，分kotlin和java分别进行构造和实例化:@BeanUtils.instantiateClass(constructor, args)
			>按优先级注解排序：@AnnotationAwareOrderComparator.sort(instances)
			-工厂实例集合 设置到 SpringApplication.initializers属性里；
			-----典型的实现类：
			--DubboApplicationContextInitializer: dubbo相关。因为在.run()阶段会执行@prepareContext()方法，里面包含执行遍历每个intializer的@initialize()方法，所以看它的实现
				>核心：在上下文里增加 beanPostProcessor:OverrideBeanDefinitionRegistryPostProcessor 实例 ，这个处理器的执行在@refresh()里的-->@invokeBeanFactoryPostProcessors()里面加载执行。(工厂处理器的执行)先@postProcessBeanDefinitionRegistry()非空实现；后执行@postProcessBeanFactory()方法---但是本处理器为空。
					>核心看：@postProcessBeanDefinitionRegistry()的实现： 
						>核心就是注册@DubboConfigBeanCustomizer 这个类 为 namePropertyDefaultValueDubboConfigBeanCustomizer 名字，到普通的beanFactory里。
							>使用地方：在 @AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization() 里调用 Processor的@ConfigurationBeanBindingPostProcessor.postProcessBeforeInitialization()方法，对于配置bean,就会执行@customize()方法；就会遍历 @ConfigurationBeanBindingPostProcessor::configurationBeanCustomizers:ConfigurationBeanCustomizer 属性; 从而执行@customize(String beanName, Object configurationBean)方法 
								>则看 @DubboConfigBeanCustomizer.customize(String beanName, Object configurationBean)的实现：
									>这里的 beanName 是 "org.apache.dubbo.config.ApplicationConfig#0" 这个bean里会有 spring.application.name 的信息；显然是 org.apache.dubbo.config.ApplicationConfig 的实例,#0说明是第一个实例。
									
									
		>同上方法获取 ApplicationListener 的 所有实现类集合；设置到	SpringApplication.listeners里；	
			--典型实现： org.apache.dubbo.spring.boot.context.event.DubboConfigBeanDefinitionConflictApplicationListener
			--典型实现2： org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener  (实现了org.springframework.context.ApplicationListener)
				>看应用上下文刷新事件/关闭事件：@onApplicationContextEvent(ApplicationContextEvent event)
					>看刷新事件@onContextRefreshedEvent()
						--注意：DubboBootstrapApplicationListener 的构造方法里 就有 ：单例获取 DubboBootstrap.getInstance() 赋值给 dubboBootstrap
						>直接启动：@dubboBootstrap.start()
							>初始化：@initialize()
							>输出接口：@exportServices()
							>如果不只是注册provider 或者 已经输出服务：则：
								>输出元数据服务：@exportMetadataService()
								>注册本地服务实例：@registerServiceInstance()
							>引用服务：@referServices()	
		>获取main方法的所在类Class：@deduceMainApplicationClass()设置到 SpringApplication.mainApplicationClass
	>@run()运行： 
		>配置系统属性：java.awt.headless
		>获取全部运行的监听器：@getRunListeners(String[] args) 
			>即获取 SpringApplicationRunListener 的实现类集合；封装到SpringApplicationRunListeners
		>启动监听器：@listeners.starting() 启动了全部的listeners
		>环境准备：
			>获取环境、配置环境：@new StandardServletEnvironment()，配置：
				>构建转换服务: 各种基本数据类型之间的转换converter：数据格式的统一format格式化工具的注册；转换器+格式化工具+值解析器resolver
					>实现：对ApplicationConversionService单例获取 中就实现了；
				>设置到环境里：
				>配置环境的属性资源：propertySources 
				>配置环境的profiles: @configureProfiles(environment, args)
				>属性资源attach到环境：@ConfigurationPropertySources.attach(environment)
				>配置绑定：@bindToSpringApplication(environment)
		>配置属性：@configureIgnoreBeanInfo(environment) spring.beaninfo.ignore
		>打印广告牌：@printBanner(ConfigurableEnvironment environment) 利用@SpringApplicationBannerPrinter类
		>创建应用上下文：servlet类型，所以直接反射 加载 ：org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext 并实例化：BeanUtils.instantiateClass(contextClass) --入口方法：   @createApplicationContext() 构造方法最终使用： sun.reflect.DelegatingConstructorAccessorImpl/sun.reflect.NativeConstructorAccessorImpl 的本地方法实现创建。
			>这个类本身就是registry: 所以bean可以通过它注册；
			>构造方法：
				>构建注解bean定义的阅读器：@new AnnotatedBeanDefinitionReader(this)
					>核心：注册大量beanpostPosser到 registry:@AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)
						>核心：因为registry是GenericApplicationContext 实例， 所以 通过@getDefaultListableBeanFactory()获取到 beanFactory:DefaultListableBeanFactory
				>构建类路径bean定义的浏览器：@ new ClassPathBeanDefinitionScanner(this)
		>获取异常报告器:再次工厂方式获取 SpringBootExceptionReporter 接口的实现类；
		>预备上下文：@prepareContext() 	
			>设置加载器、转换器：@postProcessApplicationContext(context)
			>遍历SpringApplication.initializers来执行.@initialize()方法。 @applyInitializers(context)
			>打印一点开始日志：
				>获取日志logger:@LogFactory.getLog(this.mainApplicationClass) 
				>输出日志内容info级别：为@org.springframework.boot.StartupInfoLogger.getStartingMessage()。。debug级别：@getRunningMessage()
			>打印一点profile配置信息日志：info级别	。。@logStartupProfileInfo()
				>从环境变量里获取 spring.profiles.active 的值，设置到 org.springframework.core.env.AbstractEnvironmt.activeProfiles 属性里；
			>加载资源：@load()	
				>构造beanDefinition加载器：@createBeanDefinitionLoader()
					>直接构造：@new BeanDefinitionLoader(registry, sources) 而内容：则 顺便：赋值 scnaner=new ClassPathBeanDefinitionScanner()和 给scanner增加过滤器：excludeFilters 这个属性在 @ClassPathScanningCandidateComponentProvider 类里，因为 scanner 是这个二类的继承类；
						>excludeFilters其中的filer: 直接对load的资源的封装：@new ClassExcludeFilter(source)而已。
				>这个资源就是@SpringApplication注解的类，main()函数启动类.
					>加载的最后动作：直接加载注册这个Class: @BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);注册到上述的context上下文里；
						>一般此时：beanDefinitionMap 里面 有 几个前面注册的 processor，5个；如 org.springframework.context.annotation.internalConfigurationAnnotationProcessor
			>刷新上下文：即最重要的方法：
				>@AbstractApplicationContext.refresh()	
				>最后动作：注册一个jvm shutdown回调 方法：@context.registerShutdownHook()  ---> Runtime.getRuntime().addShutdownHook(this.shutdownHook)
					>回调内容：执行@AbstractApplicationContext.doClose()
			>运行Runner集合：@callRunners(context, applicationArguments);	
				>上下文bf里获取 ApplicationRunner/CommandLineRunner的所有实现类：逐个运行它的方法：@(runner).run(args)
					>典型例如：org.springframework.cloud.task.batch.handler.TaskJobLauncherCommandLineRunner
												org.springframework.cloud.task.batch.partition.DeployerStepExecutionHandler

>spring-boot启动过程总结：概括：
	>第一：加载资源： 应用加载器 加载classpath下的所有spring.factories文件里的名值并选出 ApplicationContextInitializer 实现 来new实例化；再加载classpath下所有jar里的spring.factories里的名值 过滤出 ApplicationListener 的实现：来设置到属性里。
	>第二： 创建上下文、准备上下文并刷新上下文：
		>创建上下文： 两件事 
			>A: 反射加载 上下文类
			>B: 实例化上下文类：
				>创建 注解解析bd reader/类路径bd scanner 实例: new AnnotatedBeanDefinitionReader(this)/new ClassPathBeanDefinitionScanner(this) 
					>创建reader过程中: 有向bf里注册多个beanPostProcessor的bd
		>准备上下文：一件事 
			>A: load加载资源的名义注册了 启动类Class的bd到bf
		>刷新：三件事
			>A: 注册所有的bd : 
				>以bean工厂处理器的名义 来加载bd: 处理器来源bf/application
					>配置类处理器ConfigurationClassPostProcessor为例：来自bf: invoke内容；构造配置类解析器 解析bf中的配置型bean--往往就是启动类Class的bd所代表的Class: 解析内容就是它的四大注解@Component/ComponentScan/PropertySource/,如 加载包下路径通过 PathMatchingResourcePatternResolver加载器加载资源方式加载；。。后面还有@Import/@ImportReSource 解析加载  
			>B: 实例化所有的bd
			>C: 新增new Tomcat(),封装到new TomcatWebServer()并启动服务器。
	>第三： 发布一个上下文准备好的事件。	
-----------------------------------------------------------------------------------------------------------------												
-------专项问题：
>spring-boot如何获取所有的beanDefinition的？-->哪些地方调用了@beanFactory.registerBeanDefinition(beanName, beanDefinition)
	>第一批：beanprocessor  来源：spring-boot 启动 创建上下文：AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)  具体如：
		>org.springframework.context.annotation.internalConfigurationAnnotationProcessor
		>org.springframework.context.annotation.internalAutowiredAnnotationProcessor
		>org.springframework.context.event.internalEventListenerProcessor
		>org.springframework.context.event.internalEventListenerFactory
	>第二批：MyApplication 来源： spring-boot 启动 @load() 使用 上面获取的AnnotatedBeanDefinitionReader 来注册 ,
	>第三批：FactoryPostProcessor 来源：如spring-boot new SpringBootApplication()构造-->加载的 initailizers实现类集合 在 @run()时 执行各自的@initialize() ---> 直接new 各个processor放到 ApplicationContext 的 beanFactoryPostProcessors列表里；从而在后续阶段 @refresh()-->@invokeBeanFactoryPostProcessors(beanFactory) 会使用到：
		>筛选 beanFactoryPostProcessor 是 BeanDefinitionRegistryPostProcessor 类型， 使用 processer自身自带方法注册到 registry:beanFactory 里。例如：org.apache.dubbo.spring.boot.beans.factory.config.OverrideBeanDefinitionRegistryPostProcessor bean的名字则是processor自己取的。
		>第三.1批：从先前注入了processor,现在开始调用使用@refresh()-->@invokeBeanFactoryPostProcessors()中： 
			>首先是：@org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())
				>处理1：对上述init阶段注册的4个processor遍历处理：如果是BeanDefinitionRegistryPostProcessor 类型，就调用它的@postProcessBeanDefinitionRegistry(registry) 注册部分的 bean:
					>1：org.apache.dubbo.spring.boot.beans.factory.config.OverrideBeanDefinitionRegistryPostProcessor ：这个则注册infrastructionBean---DubboConfigBeanCustomizer:名字为"namePropertyDefaultValueDubboConfigBeanCustomizer" 注册方式：@com.alibaba.spring.util.BeanRegistrar#registerInfrastructureBean()
					>2: org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer: 如注册 名字 为 org.springframework.context.annotation.internalConfigurationAnnotationProcessor 的实例：org.springframework.context.annotation.ConfigurationClassPostProcessor 实例 
				>处理2：对上述获取的configProcessor 处理：@invokeBeanDefinitionRegistryPostProcessors()  内部就是调用每个processor的@postProcessBeanDefinitionRegistry(registry)
					>核心：新建一个解析器：@new ConfigurationClassParser().parse(candidates)来解析 过滤出来的：主processor： myApplication 这个bean
						>认为是源类，继续调用解析源类/启动类的各种配置注解：@doProcessConfigurationClass(configClass, sourceClass, filter)来解析 
							>寻找源类的@Component注解 ： 有则先进行@processMemberClasses(configClass, sourceClass, filter)：一般无动作
							>寻找源类的@PropertySources 注解：有则@processPropertySource(propertySource);处理 ：一般也无动作
							>寻找源类的@ComponentScan注解： 找到之后：开始遍历：这个注解有11个属性；对每个注解(一般就一个)：
								>先解析11个属性并返回basePackages属性匹配到的类集合：this.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName()):org.springframework.context.annotation.ComponentScanAnnotationParser 这个类的解析方法。
									>对于 excludeFilters 属性： 先封装@typeFiltersFor()为TypeFilter,再 加到scanner.addExcludeFilter(typeFilter)
									>对于 basePackages 配置项 ：字符串内容；分号分隔每个包；提取出来；放到list;
									>对于 basePackageClasses 配置项： 提取其package出来：即上一级路径；
									>如果此时仍然为空：即上述没有配置；那么就获取 myApplication 类的上一级路径 ； 加到list
									>开始用scanner.doScan()浏览 包下类：org.springframework.context.annotation.ClassPathBeanDefinitionScanner 。
										>对每个package: 调用父类@findCandidateComponents(basePackage)来获取所有的BeanDefinition；
											>先构造包的完整路径：如 "classpath*:com/ihuaben/**/*.class"
											>使用资源模式解析器解析这个路径：PathMatchingResourcePatternResolver
												>最终使用@org.springframework.core.io.support.PathMatchingResourcePatternResolver#getResources(path)来解析：分模式来寻找匹配的资源。classpath*开头就是一类：
													>再分：如果 classpath*: 后面部分包含{}或者* ，则模式拆解：调用@findPathMatchingResources(locationPattern)解析，否则调用@findAllClassPathResources()
														>@findPathMatchingResources(locationPattern): 将路径拆截取分为：路径+类模式字符串 两部分；对于路径部分，递归得获取资源@getResources(path)	
															>此时没有了类模式：所以直接走了@findAllClassPathResources():
																>此时核心来了：直接采用 应用类加载器AppClassLoader 对 该路径加载：@cl.getResources(path)  ，其中遍历的一个结果是：如： URL: protocol="file", file="/D:/document/%e5%b7%a5%e4%bd%9c%e6%96%87%e6%a1%a3/workspace/shardingutil/target/classes/com/ihuaben/config/"   。。这样的信息封装到 new Resource()里，即路径资源，还不是实际的文件资源；
															>利用上述路径资源：判断路径的类型：jar/file?, 整理得到完整路径“D:/document/工作文档/workspace/shardingutil/target/classes/com/ihuaben/config”	， 再封装为匹配类字符串：“D:/document/工作文档/workspace/shardingutil/target/classes/com/ihuaben/config/**/*.class”
																>最终还是通过 @dir.listFiles() 文件方式获取了路径下的所有文件，然后通过文件模式匹配出 和模式一致的：匹配方式：@org.springframework.util.AntPathMatcher#match(pattern, path)判断是否匹配；实际就把其中所有的.class匹配到了加到了结果里返回；
															--这样，就从 scan的这个 basePackage下找到了全部的匹配class文件路径为内容的Resource数组			
														>@findAllClassPathResources():
											>找到资源之后，继续逐个和includeFilter/excludeFilters进行匹配，看是否要采纳；是，则将该class封装到@new ScannedGenericBeanDefinition()里，则形成了一个 BeanDefinition 了，加到结果里。
												>非常关键：includeFilters 其实有三个默认的：都是 org.springframework.core.type.filter.AnnotationTypeFilter ，内部注解类型分别是："org.springframework.stereotype.Component"  "javax.annotation.ManagedBean" "javax.inject.Named"
													>包含上述山歌注解：就是true；匹配！！再看是否有@Conditional注解，专门处理一下；是否依赖其他条件表明的类？
														>具体有@ConditionalOnClass时：
										>找到的bd集合：遍历，对 AbstractBeanDefinition/AnnotatedBeanDefinition 的实例，专门处理；剩下的：
											>生成每个bd的名字：@org.springframework.context.annotation.ClassPathBeanDefinitionScanner.beanNameGenerator.generateBeanName(candidate, this.registry) 名字一般是 Class类的名字的首字母小写；如 "dataSourceConfig" "bookShelfShardingService"
											>再次经过一些例常处理 如代理 后：封装到@new BeanDefinitionHolder()里；然后调用工具注册到bf:@BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry) 后面就是常见的了。
											--从而把 basePackage 注解包路径下的所有匹配的 bean 层层解析 一一注册到容器bf里了。
								>对于上一步解析到的basePackages等包路径下的所有类定义集合：遍历：
									>检查这个Class是否是配置类：即有@Configuration注解 是，则进一步解析--获取里面的@Bean: 转调用@org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass()
										--检查是否是配置类的条件：@Configuration注解为条件1；条件2：@isConfigurationCandidate() --->即这个类的元数据里是否有 5个注解之一：Import/Component/ImportResource/ComponentScan/Bean  条件很弱；所以几乎全部都会进入解析！：
										>核心为递归解析：将这个Class当作配置类参数注入，调用@doProcessConfigurationClass() ，则会将这个配置类里的所有@Bean也或取到，加到 beanMethods属性里。 因为这个方法里，会分三种类型：即直接@Component注解类型：@PropertySources 注解类型， @ComponentScan注解类型
									#不是配置类：那么这里直接忽略；
							>寻找@Import注解来处理：@processImports()
								>先是递归方式获取 类上的注解的注解...含有@Import注解的：把这个注解里配置的Class解析出来：如@MapperScan注解的@Import注解里的MapperScannerRegistrar.class， @EnableTransactionManagement注解的@Import注解里的 TransactionManagementConfigurationSelector.class 类 
								>然后遍历这个Import类集合：对每个分 ImportSelector/ImportBeanDefinitionRegistrar/other 实现类专门处理：
									>对 ImportSelector 实现类： 则直接实例化+ 感知 属性注入：@ParserStrategyUtils.invokeAwareMethods()
									>对 其他：
										>获取全部输入类名：手动写死：@org.springframework.transaction.annotation.TransactionManagementConfigurationSelector#selectImports() : 返回：AutoProxyRegistrar 和 ProxyTransactionManagementConfiguration 的类名；
										>反射加载：
										>加载后处理：@processImports()  遍历分：ImportSelector/ImportBeanDefinitionRegistrar/其他 实现类 来处理：
											>对于 ImportBeanDefinitionRegistrar 实现类： 直接实例化并 注入 感知属性：@ParserStrategyUtils.instantiateClass()
												>然后存到内部的map里：org.springframework.context.annotation.ConfigurationClass::importBeanDefinitionRegistrars
											>对于其他 实现类： 先注册：@importStack.registerImport()
												>然后开始处理解析类：@processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter)
													>先用评估器评估是否应该过滤：@conditionEvaluator.shouldSkip()
														>获取这个类的@Conditional 注解中的类，加载并实例化：放到一个list里：遍历，对每个条件：匹配判断：@org.springframework.boot.autoconfigure.condition.SpringBootCondition#matches() 这里比如WebSocketServletAutoConfiguration类的2个条件：一个是@ConditionalonClass注解--定义声明的@Conditional注解条件OnClassCondition条件，web..这个注解的值则是：(Servlet,ServletContainer);;;另一个是@ConditionalOnWebApplication注解---这个注解定义上的@Conditioanl条件 OnWebApplicationCondition
															>outcome匹配：@getMatchOutcome() 不同的条件有不同 的实现： 
																---OnClassCondition条件的实现：
																	>查找要求有的候选Class: 即这个类上的@ConditionalOnClass注解里的Class列表: @getCandidates(metadata, ConditionalOnClass.class)
																	>过滤：加载这条件要求有的Class 列表: 加载方法1：@classLoader.loadClass(className) ，其次加载方法：@Class.forName(className)  在@org.springframework.boot.autoconfigure.condition.FilteringSpringBootCondition#resolve()有描述。入口匹配方法：@org.springframework.boot.autoconfigure.condition.FilteringSpringBootCondition.ClassNameFilter.matches()
																		>加载成功说明匹配：如果没有成功，那么记录下来，直接封装信息到@ConditionOutcome.noMatch()里返回了。陈宫了也要封装信息到一个@ConditionMessage()对象里
																	>再次查找 要求没有的Class:	@getCandidates(metadata, ConditionalOnMissingClass.class)  同理再次过滤，信息封装处理。
																---OnWebApplicationCondition 条件的实现：
																	>直接看有无@ConditionalOnWebApplication注解，
																	>再看是否web应用：@isWebApplication()
																		>核心看bf里注册的scope是否包含session: @getBeanFactory().getRegisteredScopeNames()
																		>是包含： 则返回@ConditionOutcome.match(message.foundExactly("'session' scope"))匹配	
															>尝试打日志：@logOutcome(classOrMethodName, outcome)
															>记录一下评估情况：@org.springframework.boot.autoconfigure.condition.ConditionEvaluationReport#recordConditionEvaluation()
															>返回是否匹配：就是 条件有的有了，条件不应该有的没有；则true;
													>开始循环到父类的解析配置类：@doProcessConfigurationClass(configClass, sourceClass, filter)		
							>寻找@ImportResource注解来处理：获取三个属性：尤其是 locations 属性 的值： 即是资源文件的地址：String[], 如“classpath:dubbo-consumer.xml”
								>遍历每个资源路径：解析填充 占位符：最终使用@org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders()来解析；几乎没改变；直接放到 ConfigurationClass.importedResources属性里。
							>对类的@bean方法处理：如对 ProxyTransactionManagementConfiguration 这个类解析，因为里面有三个方法上有@Bean注解，所以返回了3个；实际处理中，还会有一个过滤：
								>后遍历转换为new BeanMethod()加到ConfigurationClass里；比如  com.ihuaben.config.DataSourceConfig 配置类里就有8个bean方法, 都会加到 org.springframework.context.annotation.ConfigurationClass::beanMethods 属性里；
							>处理类的接口上是否有@Bean注解方法：有则还需要加入：@processInterfaces():	
							>返回父类：继续递归@doProcessConfigurationClass()
							-没有：则配置类会加到 org.springframework.context.annotation.ConfigurationClassParser::configurationClasses  属性里：
						>在第一级@parse()下，最后进行一个import选择器的handle@deferredImportSelectorHandler.process()
							>最后一步：@handler.processGroupImports()  也是 ConfigurationClassParser 的方法。
								>转调用@processImports() 而入参里的候选类只有一个：org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration 这个类一个直接的@Conditional即要求有指定的bean在bf中(这里是要求有ResourceBundleCondition这个类)， 一个@ConditionalOnMissingBean--即要求bf里不能有某个bean --这里是要求不能有 "messageSource"名字的bean，内部又有2个@Bean方法。 
					>核心2：利用上一步填充的 configurationClasses 配置bean , 使用reader来加载注册bd:@reader.loadBeanDefinitions(configClasses) : org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader  这种 configClasses可能达99个之多--但是有第一步的过滤@shouldSkip()：@org.springframework.context.annotation.ConditionEvaluator#shouldSkip()来过滤。
						>第一步：注册配置bean自己：条件：@configClass.isImported()为true: 从而会注册它自己：@registerBeanDefinitionForImportedConfigurationClass(configClass) --包括生成它的名字、bdh信息等；
						>第二步：注册配置bean里的beanMethods里的bean: 遍历每个BeanMethod:调用@loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod)来注册：
							>专门封装到：@new ConfigurationClassBeanDefinition(configClass, metadata)对象里
							>后进行一系列级别属性的设置：通用的一批由@AnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata)来处理。
							>最后还是 DefaultListableBeanFactory@registerBeanDefinition(String beanName, BeanDefinition beanDefinition)来注册。
							---注意：比较奇怪：对于 org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration 这个配置bean的bean: 不是直接在类定义上写死的，而是外部注入的20个bean: 名字不同，但类型都是：org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport
						>第三步：注册importResource注解的类：@loadBeanDefinitionsFromImportedResources(configClass.getImportedResources())
							>当有配置@ImportResource注解时：就会执行：最终是执行@reader.loadBeanDefinitions(resource)来加载。reader:org.springframework.beans.factory.xml.XmlBeanDefinitionReader 这个。
								>后面的流程几乎同spring的加载和解析注册bean: 如先用：@((ResourcePatternResolver) resourceLoader).getResources(location)转换为Resource对象；后@loadBeanDefinitions(resources)
									>加载资源文件到流里：@getResource().getInputStream()， 然后解析为Document: @doLoadDocument(inputSource, resource) 
									>遍历整个Document文档所有的节点： org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader#parseBeanDefinitions() 对每个节点：分default/custom进行分别的解析：@parseDefaultElement(ele, delegate)/delegate.parseCustomElement(ele) 例如对 <dubbo:custom> 就是后者来解析。<dubbo:import>则是按前者---：因为会继续加载指定的xml配置来解析。
										>对<dubbo-reference> 则是使用 org.apache.dubbo.config.spring.schema.DubboBeanDefinitionParser 类来解析：
											>最后直接@new RootBeanDefinition()封装，而设置它各个属性：
												>beanClass="org.apache.dubbo.config.spring.ReferenceBean"
												>id=节点的name配置, 即当做beanName
											>然后就直接注册了：@getRegistry().registerBeanDefinition(id, beanDefinition)
											>最后还会遍历ReferenceBean的所有方法-给bd增加属性：从节点里配置取出的：设置包括：@setApplicationContext()/protocol/url/consumer
										>解析注册bean：@registerBeanDefinitions(doc, resource)
											>通过获取文档的名称空间的handler来进行解析：@readerContext.getNamespaceHandlerResolver().resolve(namespaceUri) ，自然得到了dubbo的xml名称空间handler:org.apache.dubbo.config.spring.schema.DubboNamespaceHandler  @parse(Element element, ParserContext parserContext)
												>此时有注册listeners： @registerApplicationListeners(registry)
												>正式解析：parse()
													>注册别名工具：DubboConfigAliasPostProcessor
													>注册consumer配置：org.apache.dubbo.config.ConsumerConfig
													>嵌套解析：@parseNested()
													>设置这个ConsumerConfig的各个属性：值从xml里提取。反射的方式进行的。
													>最后返回这个bd: 这样，就解析好了一个xml节点。
						>第四步：注册仓库里的类：获取 configClass 里的importBdRegistrars仓库，注册这些仓库里的bean: 这里共有2个registrar
							>org.springframework.context.annotation.AspectJAutoProxyRegistrar: 跟 aspectj 有关。 一般为空
							>org.mybatis.spring.annotation.MapperScannerRegistrar： 跟mybatis加载mapper文件有关：
								>先是获取配置类的@MapperScan注解：
								>生成仓库代理的名字："com.ihuaben.config.DataSourceConfig#MapperScannerRegistrar#0"
								>开始构建bean的过程：先是beanclass 类型：@BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class)
									>然后是：各种属性的添加：从@ManagedBean里取的beanName从bf获取的实例：属性包括：annotationClass/markerInterface/nameGenerator/factoryBean/sqlSessionTemplateRef/sqlSessionFactoryRef/basePackages/basePackageClasses/
									>最后还是用bf来注册这个建造者模式生成的bd:@registry.registerBeanDefinition(beanName, builder.getBeanDefinition())
						----myApplication 也是一个配置bean: 它的四步：
							>在
				>处理3：激活其他的 BeanDefinitionRegistryPostProcessor ： 从bf里取出来，过滤掉已经处理过的。再次调用@invokeBeanDefinitionRegistryPostProcessors()		
					>此时往往三个processor： @postProcessBeanDefinitionRegistry()
						>org.mybatis.spring.mapper.MapperScannerConfigurer 
							>事情1： 设置属性占位符替换holders: 配置 sessionFactory,sessionTemplate等到
							>事情2： 新建new ClassPathMapperScanner(registry)同理设置各种sessionFactory/template属性，资源记载器等之后；进行浏览：@scanner.scan()
								>真正的scan: 先调用父类的org.springframework.context.annotation.ClassPathBeanDefinitionScanner@doScan(basePackages) 前面已经表达。浏览包下所有的类；
									>这里浏览的就是：Mapper类；生成的名字也是“bookShelfCountMapper”首字母小写；所以就注册了mapper的beanDefinition
									>上述发现的所有的bd: 本类doscan()会进一步的处理：@processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions)
										>关键1： 设置bd的beanClass=org.mybatis.spring.mapper.MapperFactoryBean.class
										>关键2： 设置bd.属性值map新增sessionTemplate：@.getPropertyValues().add("sqlSessionTemplate",new RuntimeBeanReference(this.sqlSessionTemplateBeanName))
								>注册注解配置proccessor: @AnnotationConfigUtils.registerAnnotationConfigProcessors()
						>org.apache.dubbo.config.spring.beans.factory.annotation.DubboConfigAliasPostProcessor
						>org.apache.dubbo.config.spring.beans.factory.annotation.ServiceAnnotationBeanPostProcessor
							>事情1：注册 DubboBootstrapApplicationListener 类。实现方式：@new AnnotatedBeanDefinitionReader(registry).register(Class)
								>最后还是封装到new AnnotatedGenericBeanDefinition(beanClass)--> new BeanDefinitionHolder(abd, beanName)-->@BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry)
							>事情2： 包浏览和占位符解析：即注解中的dubbo服务类所在包： "com.ihuaben"	@registerServiceBeans(resolvedPackagesToScan, registry)
								>浏览包下类必须有浏览器scanner: 这里新建@new DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader)； 后增加过滤器：注解过滤器类型：@new AnnotationTypeFilter(Service.class)//这里两种Service:org.apache.dubbo.config.annotation.Service/com.alibaba.dubbo.config.annotation.Service
								>开始浏览：@scanner.scan(packageToScan) 注册@Service注解的类
									>先转调@doScan(basePackages)
										>转到父类：@doScan(basePackages) 即前面已经讲述：org.springframework.context.annotation.ClassPathBeanDefinitionScanner
									>注册可能的注解配置处理器：@AnnotationConfigUtils.registerAnnotationConfigProcessors()
								>注册具体的@Service注解 bean并且进行详细的配置：dubbo自己的专门的设置配置。后也一一注册到 bf;
				>处理4：开始beanFactory处理器的激发：@invokeBeanFactoryPostProcessors()				
					>此时7个往往processor:@postProcessBeanFactory(beanFactory)
						>org.springframework.context.annotation.ConfigurationClassPostProcessor 的实现处理：使用cglib增强子类的方式处理：
							>对注入的bf: 生成bfid,然后开始增强：@enhanceConfigurationClasses(beanFactory)
								>遍历bf里面的所有beanDefinition: 对于其中的配置类：开始解析了---即反射加载：@ClassUtils.forName(className, classLoader) 然后收集配置bd起来
								>遍历配置bd: 对于每个，进行增强@new ConfigurationClassEnhancer().enhance() ；
									>先包装适配一层：@org.springframework.cglib.proxy.Enhancer()后用来创建其增强类：@enhancer.createClass()
										>动态类的byte[]的生成：@org.springframework.cglib.core.DefaultGeneratorStrategy#generate()
											>新增classVisitor:@DebuggingClassWriter()
											>获取目标类的所有方法：进行过滤：@CollectionUtils.filter(methods, new RejectModifierPredicate(Constants.ACC_STATIC))
											>实际生成类的方法：@org.springframework.cglib.proxy.Enhancer#generateClass()
												>使用new ClassEmitter(v)完全从0开始生成Class的byte[]: 
												>开始部分：@e.begin_class()
													>如类定义信息：@Lcom/ihuaben/config/JdbcTemplateDataSourceConfig$$EnhancerBySpringCGLIB$$639cdd09;
													>开始详细的设置：@org.springframework.asm.ClassWriter#visit()
												>属性部分：@e.declare_field() 私有公有/静态final/
													>终使用@org.springframework.cglib.core.ClassEmitter#visitField()来设置 
												>方法部分：@org.springframework.cglib.proxy.Enhancer#emitMethods()开始一个字节码字一个节码的的写入。CodeEmitter	/se.dup()/e.invoke_constructor()/se.putfield()等；
												>结束部分：@e.end_class()
										>最后在轻量级的反射中加载了byte[]表达的新类：@org.springframework.cglib.core.ReflectUtils#defineClass() ，反射方法就是clasloader的 defineClass()  生成之后的类似名就是：com.ihuaben.config.DataSourceConfig$$EnhancerBySpringCGLIB$$be17c634
										>最后普通反射实例化：@ReflectUtils.newInstance(type)
									>后将bd.beanClass=新的这个生成的Class:	如像 com.ihuaben.MyApplication$$EnhancerBySpringCGLIB$$9d3f8c25
							>bf增加处理器：@beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory))	
						>org.springframework.boot.context.config.ConfigFileApplicationListener.PropertySourceOrderingPostProcessor 的实现： 给环境增加一些属性：@reorderSources()
				>处理5：获取bf里的剩下的 BeanFactoryPostProcessor 来处理： 	过滤之后再次：@invokeBeanFactoryPostProcessors()
					>org.springframework.boot.context.properties.ConfigurationPropertiesBeanDefinitionValidator 的实现：	
						>从bf里的bd遍历中过滤出：ConfigurationPropertiesValueObjectBeanDefinition 类型且不在单例池中的 ：验证：@BindMethod.forType(beanClass) == BindMethod.VALUE_OBJECT
							>本质上：就是 有 @EnableConfigurationProperties注解的一定要有@ConstructorBinding 注解。 
					>org.springframework.context.event.EventListenerMethodProcessor 的实现： 
					>org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration.PreserveErrorControllerTargetClassPostProcessor 实现：
						>bf里获取 ErrorController 实现： 取bd设置 org.springframework.aop.framework.autoproxy.AutoProxyUtils.preserveTargetClass 新属性。
		---后续注册beanPostprocessor：refresh()-->@registerBeanPostProcessors(beanFactory)
			>核心：PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this)	
				>直接获取bf里全部processor: 分类：之后开始注册：@registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors)
					>即：加到 bf里。
				>额外增加了2个processor: new BeanPostProcessorChecker() . new ApplicationListenerDetector(applicationContext)		
		--增加消息资源时：refresh()-->@initMessageSource() 注册了一个单例：@beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource)	名字为：“messageSource”		
		--增加上下文广播器也是：@refresh()-->@initApplicationEventMulticaster()  核心： @beanFactory.registerSingleton() 名字“applicationEventMulticaster”
		--启动tomcat：@onRefresh() 
			>对org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext实现： 
				>调用父类onRefresh()之后：@createWebServer()
					>从bf里获取 org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory 实现： 开始创建webServer：@factory.getWebServer(getSelfInitializer())
						>内部new Tomcat()之后封装到new TomcatWebServer(tomcat, getPort() >= 0) 内部大量的实现和初始化。
		--注册listeners: 将上下文监听器+bf里的listener增加到：上下文广播器里：.applicationEventMulticaster
		--实例化所有非懒初始化的单例 bean:@finishBeanFactoryInitialization(beanFactory)	此时已经说明没有再注册bd了。
			>核心：@beanFactory.preInstantiateSingletons()
				>遍历全部的bd: 对每个，分是factoryBean还是普通Bean：来分别 @getBean()
					>是工厂bean: 则 @getBean(FACTORY_BEAN_PREFIX + beanName)
					#否则： @getBean(beanName)
				>再次遍历遍历bd: 对每个，取单例，如果单例是 SmartInitializingSingleton 实现： 
					>调用单例的：@afterSingletonsInstantiated()完成其他工作。
		--完成刷新：@finishRefresh()
			>对 org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext 的实现： 
				>父类的finishRefresh()后启动webserver:@startWebServer() 后发布启动事件：@publishEvent(new ServletWebServerInitializedEvent(webServer, this))
		---附加：spring-boot最后：还会发布一个事件：@context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context)) 应用准备好事件。run()就完成了。所以run（）不会阻塞，从而继续执行main()后面的内容。			