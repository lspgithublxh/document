//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备；化被动为主动去做)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
//大的想法，具体行动。
//出现了if-else就是因为有不同的考虑。
//阅读文档达到直接可以看出思路编写程序的清晰逻辑的地步。
//一个大函数功能直接看懂而描述。
//从网上找答案变为从源码中找答案。
//功能组织体系，而不是动作实现体系。是目标，是事情，而不是精细到实现方案的动作。
//数据源-数据结果模式：而不是全部动作过程。
//能够主动猜某个方法的功能和猜测它的实现。
//情况-通用处理。
//情况-精细结构。
//数据结构-与处理。
//某个时刻某个地方：所有可能用户做的事情。
//就像是军队打仗一样：AbstractApplicationContext上下文就是总部主帅，负责整个流程，但实现个别子流程；ServletWebServerApplicationContext就是地区主帅，负责使用总部流程且根据区域情况具体化部分流程实现，同时负责分给不同的人去实现更细的子流程(用人/用器：如事件广播器、bean工厂、生命周期处理器; 向它们发号命令：调用/叫他们做什么)，层层下去到事务的精细结构。(负责事务的精细级别 就看出 和一线的和当前的距离)
	>对一个事物类：他是有属性
	>对一个组织类：他是有人；属性当作人。人可能是为他办事的，也可能是监听他的监听器。
	>对一个系统类：他是有组件/器具；属性当作器具
//为什么层次多：因为连续地向上进行了抽象，每层都分类了/拆分了不同的功能，每层连续往下拆分。
//抽象到具体的描述。自然推理出来。才是架构。才是原本的架构。

>正向看：
	>org.apache.dubbo.container.Main类 @main(String[] args) 入口
		>
	>从@AbstractApplicationContext.refresh()开始：
		>先：@AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) 里面的代码直接有一行：@PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());来调用
			>先：@PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors()
				>先： @ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry registry) 中使用 reader来调用。@this.reader.loadBeanDefinitions(configClasses) 这里的配置类Class包括：所有的service的Class, 名字就是类的首字母小写；
					>先：@ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(Set<ConfigurationClass> configurationModel)-->@loadBeanDefinitionsFromImportedResources()
						>先：@AbstractBeanDefinitionReader.loadBeanDefinitions(String location) --> @loadBeanDefinitions(Resource... resources) 
							>核心：开始转到@XmlBeanDefinitionReader.loadBeanDefinitions(Resource resource)
								>进一步：@doLoadBeanDefinitions(InputSource inputSource, Resource resource)
									>@XmlBeanDefinitionReader/DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(Document doc, Resource resource)
										>再次到@DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(Element root)
											>@DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) 这里就会遍历xml的所有节点：开始遍历的解析ele并且注册；
												>@BeanDefinitionParserDelegate.parseCustomElement(Element ele)
													>@parseCustomElement(Element ele, @Nullable BeanDefinition containingBd): 开始实质的解析：获取解析器开始解析：@his.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri) 这里的名称空间uri就是："http://dubbo.apache.org/schema/dubbo" 类似。
														>先获取名称空间uri:@getNamespaceURI(ele)
														>然后用这个名称空间解析出 NamespaceHandler: @this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri) 
															>通过handerMappings(uri-handler类名)可以找到名称空间对应的解析处理器名："org.apache.dubbo.config.spring.schema.DubboNamespaceHandler" 或者实例Class对象---首次是string ,所以需要加载初始化，第二次就已经是Class对象了，所以直接返回即可。
															>会执行初始化方法：@DefaultNamespaceHandlerResolver::namespaceHandler.init()
															-----org.apache.dubbo.config.spring.schema.DubboNamespaceHandler 实现的@init()
																>注册分别解析xml配置文件里的各个标签的解析器：application/module/registry/config-center/metadata-server/monitor/metrics/ssl/provider/consumer/protocol/service/reference/annotation
																	>解析器：如 application标签---@new DubboBeanDefinitionParser(ApplicationConfig.class, true)
																		>基本流程：还是 获取 标签 里的 name 属性的值：当做类名，如果bf里已经定义了，那么 加后缀2/3/4/5/..数字以示区别。这个名称 就是 BeanDefinition 的名字，放入bdmap;。。例如 ServiceBean/ReferenceBean
																			>特别注意：ReferenceBean 是实现了 FactoryBean 接口的：所以这个bean的获取是@getObject() 获取ref ，但是开始ref为null 需要初始化。
																				>最终转到父类 ReferenceConfig 的 @init()： 最终抽象层次具体到：
																					>获取@DubboBootstrap.getInstance()单例；然后执行初始化@bootstrap.init()
																						>
																					>检查和更新子配置：@checkAndUpdateSubConfigs()
																					>获取服务工厂：@ApplicationModel.getServiceRepository() 并且注册消费者：@repository.registerConsumer()
																					>创建代理：@createProxy(map) 值就是赋值给 ref 
																						>先一系列配置：其次，静态属性方式已经获取了代理工厂：@ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension()
																							>开始实质的获取代理：@PROXY_FACTORY.getProxy(invoker)
																								>包装类获取代理：@StubProxyFactoryWrapper.getProxy(Invoker<T> invoker)
																									>@org.apache.dubbo.rpc.proxy.AbstractProxyFactory.getProxy(Invoker<T> invoker, Class<?>[] types)
																										>中间代理方：@JavassistProxyFactory.getProxy(Invoker<T> invoker, Class<?>[] interfaces)
																											>最终进行: 则是通过 org.apache.dubbo.common.bytecode.Proxy 来获取实例的过程： 通过javassist.jar来实现的：类名：org.apache.dubbo.common.bytecode.Proxy0/1/2/3/4/5等自增数字结尾；而利用 javassist 中的 javassist.CtClass 类可以设置增加方法、field、构造方法、设置父类等；返回Class,然后使用class的newInstance()直接实例化。
																								>通过获取invoker.getInterface()的nam + "Stub"/"Local" 之类形成类名 反射加载 用构造方法 实例化：	proxy再次，而上次那个proxy则注入。
																								>最后输出代理实例-url关联：@export(T instance, Class<T> type, URL url)
																									>转到@protocol.export(proxyFactory.getInvoker(instance, type, url))
																									---以 org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 实现为例： 
																										>拼装服务key:@ProtocolUtils.serviceKey()
																										>构造exporter:@new DubboExporter<T>(invoker, key, exporterMap) 且会最终返回。
																										>创建并打开服务器：@openServer(url)
																											>创建服务器：@createServer(url) 缓存模式
																											>url添加参数而格式化出str: 
																											>url和回调绑定：@Exchangers.bind(url, requestHandler)
																												--其中注意 requestHandler 这个属性：是 new ExchangeHandlerAdapter(){}的匿名实现。
																													>实现@CompletableFuture<Object> reply(ExchangeChannel channel, Object message)方法 
																														>先通过通道获取invoker:@getInvoker(channel, inv)
																														>后执行invoker:@invoker.invoke(inv) 获取结果 Result 返回前运用：@.thenApply(Function.identity()) 里面纯粹是 result的实现。
																												>先获取信息交换者：@getExchanger(url)
																													>扩展加载器方式加载：@ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type)
																												>后进行实际的绑定：@bind(url, handler)
																													>url绑定new DecodeHandler() :@Transporters.bind()
																														>再次扩展加载器方式加载Transporter:@ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension()
																														>然后再次@bind(): 
																															---以netty4 实现为例：@org.apache.dubbo.remoting.transport.netty4.NettyTransporter
																																>直接新建服务器：@new org.apache.dubbo.remoting.transport.netty4.NettyServer(url, listener)
																																	>从父类开始：@AbstractServer()
																																		>设置绑定ip和地址：
																																		>打开连接：@doOpen() 由子类实现；
																																			>开始全面的调用Netty api: @new io.netty.bootstrap.ServerBootstrap()
																																			>事件循环组：@new NioEventLoopGroup()
																																			>服务回调处理器：@new NettyServerHandler(getUrl(), this)
																																			>开始分组配置：@bootstrap.group(bossGroup, workerGroup).....@.childHandler(new ChannelInitializer<NioSocketChannel>() {});之类的初始化通道等；
																																			>创建执行器：@createExecutorIfAbsent(URL url)即 java的 ExcutorService;
																													>新建交换服务器：new HeaderExchangeServer()
																														>启动一个检查任务：检查闲逛的服务器Server---然后将它的通道关闭：@startIdleCheckTask(getUrl());
																											>绑定完成之后：直接返回服务器 @new DubboProtocolServer(server)		
																										>最优化的序列化：@optimizeSerialization(url)
																					>寻找引用的服务：@repository.lookupReferredService()
																					>分发一个引用配置初始化事件：@dispatch(new ReferenceConfigInitializedEvent(this, invoker))
																						>分发器分发：@EventDispatcher.getDefaultExtension().dispatch(event) 实际上是发布订阅模式；让所有的listener执行.onEvent(event)方法;
														>最后用这个NH实例进行解析：@NamespaceHandlerSupport.parse(Element element, ParserContext parserContext)
															>解析转发：寻找具体的BeanDefinitionParser 实现类：@parse(Element element, ParserContext pc)
																
																
>反向看：使用方向
	>调用一个方法开始：
	>被请求一个方法开始：
	>spring-boot启动开始：从@AbstractApplicationContext::refresh()开始
		>实例化所有剩余的非懒初始化的单例：@finishBeanFactoryInitialization(beanFactory)
			>最后交给bf实现：@beanFactory.preInstantiateSingletons();
				>获取全部的beanDefinitionNames:  里面包含 service/config/dataSource/processor/advice等等全部，如308个。
				>遍历每一个：如果是 FactoryBean 则按工厂方式获取，否则按照普通方式获取: 都是@getBean(beanName)  其中如果有构造方法来实例化：会最终走：sun.reflect.NativeConstructorAccessorImpl 的@native Object newInstance0(Constructor<?> var0, Object[] var1)---->从这里开始，就转到具体类的构造方法上了：如  org.apache.dubbo.config.spring.ServiceBean()
					>注意在@AbstractAutowireCapableBeanFactory::initializeBean()阶段会：执行 初始化方法@invokeInitMethods(beanName, wrappedBean, mbd) 内部即@InitializingBean::afterPropertiesSet()
						>而在这里：往往有的类就会执行自己的初始化方法：有的还会发事件：new MappingContextEvent<>(this, entity))
							>而发事件会进一步找广播器来广播事件给匹配的listener:@getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType)
								>而接受者 listener一定有：DubboBootstrapApplicationListener
					--这里看 "com.ihuaben.dubbo.api.iservice.manager.IChapterAuditService" 这个beanName的实例化创建过程：同样的那308个都是一样被实例化的。
						>获取 RootBeanDefinition 对象: 而其中有个属性 resolvedTargetType = "org.apache.dubbo.config.spring.ServiceBean" beanClass="org.apache.dubbo.config.spring.ServiceBean"
							>回调方式创建：解析出beanClass= ServiceBean 
								>在@doCreateBean()之前走processor: 共有14个。过滤出 InstantiationAwareBeanPostProcessor 实现类
									>org.springframework.context.annotation.ConfigurationClassPostProcessor实现了：InstantiationAwareBeanPostProcessor @postProcessBeforeInstantiation(beanClass, beanName)方法
									>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator 
									>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
									>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor
									>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
								>后在@createBeanInstance()中再次走processor: 过滤出：SmartInstantiationAwareBeanPostProcessor 实现类 
									>...再次没有应用出有意义的。
								>后在@instantiateBean()方法中对 ServiceBean 用构造方法 方式 实例化： 得到 了 ServiceBean的实例。
								>后再在@doCreateBean()中应用processor: 过滤出 MergedBeanDefinitionPostProcessor 实现类 
									>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor ： @postProcessMergedBeanDefinition()方法的执行
										>先调用父类同名方法：InitDestroyAnnotationBeanPostProcessor.postProcessMergedBeanDefinition()
											>查出初始化方法@org.apache.dubbo.config.AbstractConfig.addIntoConfigManager()
									>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor: 
										>寻找注入 的Field+Method元数据：AnnotatedInjectionMetadata  后以元数据检查beandefinition:@metadata.checkConfigMembers(beanDefinition);
									>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor	
										>寻找自动绑定的元数据：没有则构建：@buildAutowiringMetadata(clazz) 后用来检查成员：@metadata.checkConfigMembers(beanDefinition)
									>org.springframework.context.support.ApplicationListenerDetector：	
								>开始@populateBean(): 开始属性注入
									>再次先走processor: 过滤出 InstantiationAwareBeanPostProcessor 实现类： 
									>再走processor: 过滤出 InstantiationAwareBeanPostProcessor 实现类：走 @postProcessProperties()方法 ：属性处理--串联方式；不断包裹filter。
										>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor:
											>最终7个属性：id/ref/interface/version/delay/async/timeout
											>最后应用属性：@applyPropertyValues()
												>id: 值为 接口名： com.ihuaben.dubbo.api.iservice.manager.ITopSprintService 通过评估方式 @evalute() 结果还是字符串名。
													>转换服务之后：convertService 还是 字符串。
												>ref: 值为 org.springframework.beans.factory.config.RuntimeBeanReference 对象,其name="topSprintService" 。所以当做引用来解析：@resolveReference(argName, ref)
													>评估方式获取ref的beanName，还是 topSprintService 字符串值。
													>开始用beanFactory.getBean("topSprintService") 来获取 实例。发现单例池里面已经有了这个名字的单例： com.ihuaben.dubbo.service.manager.TopSprintService 的实例---即一个自己编写的service实例。
													>最后注册依赖：@this.beanFactory.registerDependentBean(resolvedName, this.beanName) ： resolvedName="topSprintService" , beanName="com.ihuaben.dubbo.api.iservice.manager.ITopSprintService"
													>返回这个 单例 bean。
												>interface：值为 接口 字符串； 解析的时候就直接走评估了；	valueResolver.resolveValueIfNecessary(pv, originalValue)--->@evalute();从而结果还是字符串。
													>解析：走评估 返回原值。
													>转换服务：直接还是 原值。
												>version: 空。	
													>解析：空 
													>转换：空。 
												>delay: 空。 
													>解析：空 
													>转换：空。 
								>开始@initializeBean（）： 开始激活意识方法：
									>实现了 BeanNameAware 接口： 则注入 beanName 
									>再次应用 processor: 不做过滤：直接执行每一个的@postProcessBeforeInitialization()
										>org.springframework.context.support.ApplicationContextAwareProcessor: 核心内容为：
											>激活感知接口：注入相关全局工具/上下文。@invokeAwareInterfaces(bean) EnvironmentAware/EmbeddedValueResolverAware/ApplicationEventPublisherAware/ApplicationContextAware
										>com.alibaba.spring.beans.factory.annotation.ConfigurationBeanBindingPostProcessor:	
											--说明：在对 "org.apache.dubbo.config.ApplicationConfig#0" 实例化构建 时，在@initializeBean()里的首先应用processor时：对当前这个配置processor进行处理：。。对 “org.apache.dubbo.config.RegistryConfig#0” 构建也是；
												>获取定义：beanDefinition
												>绑定定义：bindConfigurationBean(bean, beanDefinition)
													>直接获取bf里的attribute属性里的"configurationProperties" 属性的值：就是配置：例如zk的配置："address" -> "zookeeper://39.105.71.50:2181" ，"client" -> "curator" "timeout" -> "15000" 之类，在一个map里
													>开始实质的绑定：@org.apache.dubbo.spring.boot.autoconfigure.BinderDubboConfigBinder.bind()
														>再次：@org.springframework.boot.context.properties.bind.Binder.bind("", bindable, bindHandler);  @bindObject()
															>实现的效果：从上下文获取属性，后绑定属性到对象：@bindProperty(target, context, property)
															>没有属性则绑定数据对象：@bindDataObject(name, target, handler, context, allowRecursiveBinding)
																>核心：遍历属性：dataObjectBinders:DataObjectBinder 逐个绑定：实现类：
																	>ValueObjectBinder:
																	>JavaBeanBinder:.bind() 工作逻辑：获取全部Bean的属性，一个个遍历绑定：@bind(beanSupplier, propertyBinder, beanProperty) ，值是回调获取的supplier方式：从上下文获取属性。
												--效果：就将bf里的属性设置到了bean实例里。这个实例是：RegistryConfig#0”			
												>客户端定制化：@customize(beanName, bean)
													>遍历已经得到的customizer: 第一个是 DubboConfigBeanCustomizer ，对每一个，进行 定制化：@customizer.customize(beanName, configurationBean) 所以看 dubbo的这个实现：
														>最终到了：@NamePropertyDefaultValueDubboConfigBeanCustomizer.customize(String beanName, AbstractConfig dubboConfigBean)
															>反射获取getName()这个方法的Method, 反射执行：得到值 就是 <dubbo:application > 的 name 值：
										>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor: 即获取生命周期元数据，执行 指定的 初始化方法
											>反射方式获取Method且执行：@public void org.apache.dubbo.config.AbstractConfig.addIntoConfigManager()方法，@element.invoke(target)  target=ApplicationConfig
										>org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor
											>找到指定的初始化方法：反射方式执行：@this.method.invoke(target, (Object[]) null) 方法名：addIntoConfigManager()
									>再次外层执行初始化方法：@invokeInitMethods(beanName, wrappedBean, mbd)	此次这是找到 是否 实现了 InitializingBean 接口： 
										>实现了，则执行：@.afterPropertiesSet()
									>再次应用processor: 不做过滤：直接执行每一个的@postProcessAfterInitialization()
										>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator: 可能会执行缓存：
											>执行必要的包装：@wrapIfNecessary()
												>最经典的：获取切点：@getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)
													>寻找合格的通知者：@findEligibleAdvisors(beanClass, beanName) 类=org.apache.dubbo.config.spring.ServiceBean， name=com.ihuaben.dubbo.api.iservice.manager.ITopSprintService
														>获取候选：
															>缓存有2个：org.springframework.transaction.config.internalTransactionAdvisor   , defaultPointcutAdvisor
																>遍历这两个name: 对每个从bf里获取 实例：并确保是 Advisor 的实现类：@this.beanFactory.getBean(name, Advisor.class)
																	>实际实例：org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor  和  org.springframework.aop.support.DefaultPointcutAdvisor
														>从aspectJ里补充：@this.aspectJAdvisorsBuilder.buildAspectJAdvisors()
													>过滤出能应用的：即用ClassFilter/PointCut来匹配 过滤：@AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)
														>如果是 IntroductionAdvisor 类型 ： 那么用 ClassFilter.matches(targetClass);
														>如果是 PointCutAdvisor 类型： 那么用 .getPointCut().getMethodMatcher().matches(method, targetClass) 来对 targetClass 的全部声明方法 进行匹配。有一个能应用都说明是可以应用的。
													>进行对Advisor通知者排序：	比较器：AspectJPrecedenceComparator  先用 AnnotationAwareOrderComparator 比较。Ordered类的.getOrder()
														>获取Advisor的序号：
												>如果Advisors不是空：那么就要利用目标类Class\bean实例\Advisor来创建代理：@createProxy()
													>创建代理比较固定：new ProxyFactory() 
													>设置要代理的目标类：
													>构建Advisor组：@buildAdvisors(beanName, specificInterceptors)
														>主要目的：对每个Advsior进行一次包装：@this.advisorAdapterRegistry.wrap()
															>如果是Advisor实例：直接返回 
															>如果不是 Advice: 封装到   UnknownAdviceTypeException
															--此时一定是Advice了：
															>如果是方法拦截器：MethodInterceptor 实例，那么 封装到 	new DefaultPointcutAdvisor(advice) 里。
															>否则遍历 adapters： 对每个 AdvisorAdapter， 如果其中一个 支持 advice ：@adapter.supportsAdvice(advice) 那么直接封装到new DefaultPointcutAdvisor(advice) 返回了。
													>设置到 proxyFactory里：proxyFactory.addAdvisors(advisors)
													>构建：@proxyFactory.getProxy(getProxyClassLoader())
														>创建AOP代理：@createAopProxy()
															>分如果目标类targetClass是接口：那么用jdk动态代理：new JdkDynamicAopProxy(config)
																>最后就是常见的动态代理：@Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)
															>否则用cglib的aop代理：new ObjenesisCglibAopProxy(config)
																>最后就是：Enhancer enhancer = createEnhancer() 设置@enhancer.setCallbacks(callbacks) 回调。
														>获取代理：@getProxy(classLoader)
													>直接返回这个代理：proxy 
												>是空：则返回bean即可。		
									>返回包装的bean
								>注册销毁接口：@registerDisposableBean()   DisposableBean		
						>创建完成：返回。								
		>最后发送通信事件：@finishRefresh()	
			>发送上下文刷新事件：@publishEvent(new ContextRefreshedEvent(this))
				>采用广播模式发送事件：@getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType)
					>寻找匹配上下文事件类型的 全部 ApplicationListener： @SimpleApplicationEventMulticaster.getApplicationListeners(event, type)
						>其中就有：DubboBootstrapApplicationListener 监听器， 开始激活：@invokeListener(listener, event)
							>转到@doInvokeListener(listener, event) 执行核心的：@listener.onApplicationEvent(event)
								>转到上下文事件响应方法：@onApplicationContextEvent(ApplicationContextEvent event)
									>执行@onContextRefreshedEvent(ContextRefreshedEvent event)
										>核心：@dubboBootstrap.start() 这个 dubboBootstrap 也是单例获取：@DubboBootstrap.getInstance()
											>先初始化：@initialize()
												>框架扩展初始化：@iniFrameworkExts()
												>启动配置中心：@startConfigCenter()
													>获取配置中心集合：ConfigCenterConfig ; <dubbo:config-center ...>
													>遍历每个配置中心：
														>先刷新：@ConfigCenterConfig.refresh()
														>获取 ConfigCenterConfig的所有方法：逐个遍历：判定为设置 类型方法：@
															>很神奇：从@CompositeConfiguration.getInternalProperty(String key) 来获取值，然后又set值：---但获取的值有过滤处理。
																>CompositeConfiguration有配置属性：@configList:Configuration 遍历，如果其中一个配置包含key这个键，那么取它的值：。。所以这个configList就是属性值的来源。
													>验证配置和添加动态配置：@compositeDynamicConfiguration.addConfiguration(prepareEnvironment(configCenter))	
													>配置管理刷新所有：@configManager.refreshAll()
														>ApplicationConfig::refresh MonitorConfig::refresh  ProtocolConfig::refresh RegistryConfig::refresh ProviderConfig::refresh ConsumerConfig::refresh
													>有必要配置中心用registry：@useRegistryAsConfigCenterIfNecessary()
													>启动元数据报告：即生成一个 MetadataReport: url=“zookeeper://39.105.71.50:2181/org.apache.dubbo.metadata.report.MetadataReport”
													>检查全局配置：@checkGlobalConfigs()
													>初始化元数据服务：@initMetadataService() 
														>getExtensionLoader(WritableMetadataService.class)获取来配置：metadataService属性。
													>初始化元数据服务exporter；@initMetadataServiceExporter()类似上。
													>初始化事件监听器：@initEventListener()
														>就是addEventListener(this)；就是将 DubboBootstrap 直接注册到listerner: 一般的事件分发。只注册到：org.apache.dubbo.event.AbstractEventDispatcher
											>后执行输出全部服务：@exportServices()
												>获取全部配置：ServiceConfig, 对于某个sc, 其 beanName="com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService"是用户写的。
												>逐个遍历：放到线程池执行：@sc.export()
													>如果bootstrap null：会实例化并初始化@init()
													>继续检查子配置：@checkAndUpdateSubConfigs()
													>开始真正的输出：@doExport() 
														>核心输出：@doExportUrls()
															>获取服务仓库：@ApplicationModel.getServiceRepository()
															>使用仓库注册服务：@repository.registerService(getInterfaceClass())
															>使用仓库注册提供者：@repository.registerProvider()
															>遍历每个协议配置：再次执行注册服务，后进行实质的输出url for 协议：@doExportUrlsFor1Protocol()。。协议配置就是：<duboo:protocol ...>的实体映射。
																>核心为获取全部的方法：对方法进行输出：@getMethods()  获取到的是方法配置，后处理放到map里 
																>找到host和port: 构造url:其格式如："dubbo://192.168.3.32:20883/com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService?accepts=500&anyhost=true&application=ihuabenservice-server&bind.ip=192.168.3.32&bind.port=20883&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService&methods=saveOrUpdateApplyRecommendation,getApplyRecommendationById,getApplyRecommendations,executeApplyRecommendation,getLastApplyRecommendation&pid=10724&qos.enable=false&release=2.7.5&retries=0&side=provider&threadpool=fixed&threads=500&timeout=30000&timestamp=1600167916197"
																>获取Invoker并且包装：后使用协议 输出：@protocol.export(wrapperInvoker) 得到 Exporter  后面的实现类似上面。
																#对于本地：会使用另一个方式输出：@exportLocal(url) 但是执行之后还是会执行上述：@protocol.export(wrapperInvoker)
																	>协议的url变为：“injvm://127.0.0.1/com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService?accepts=500&anyhost=true&application=ihuabenservice-server&bind.ip=192.168.3.32&bind.port=20883&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService&methods=saveOrUpdateApplyRecommendation,getApplyRecommendationById,getApplyRecommendations,executeApplyRecommendation,getLastApplyRecommendation&pid=10724&qos.enable=false&release=2.7.5&retries=0&side=provider&threadpool=fixed&threads=500&timeout=30000&timestamp=1600167916197”
																	>再次用协议对象输出：@ protocol.export(ROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, local)) 具体实现上述已有，不再陈述。
														>发送服务配置输出事件：@dispatch(new ServiceConfigExportedEvent(this))
											>后可能输出元数据服务：@exportMetadataService()
											>可能注册服务实例：@registerServiceInstance()
											>引用全部服务：@referServices()
											
-------------------------------专项问题：
>spring-boot中：客户端一个服务请求的过程？
	>服务接口的实现肯定是一个代理，所以走回调：这个回调类就是：org.apache.dubbo.rpc.proxy.InvokerInvocationHandler, 所以看它的@invoke()方法 
		>建立一个rpc激活类：new RpcInvocation()
			>执行一个初始化参数描述工作：@initParameterDesc()
				>获取服务仓库：@ApplicationModel.getServiceRepository() 
					>核心：加载名为"repository"的扩展实现类实例：@loader.getExtension("repository") 而这个 loader也是以扩展的方式加载的：@ExtensionLoader.getExtensionLoader(FrameworkExt.class), 而这个FrameworkExt有@SPI注解，从而会返回一个：@new ExtensionLoader<T>(type)这个type就是入参FrameworkExt,而在new创建过程中会：@ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()赋值给内部 objectFactory 属性；
						--必要阐述创建合适的扩展的过程：
							>先加载全部扩展：@getExtensionClasses()
								--比如属性type=org.apache.dubbo.common.threadpool.manager.ExecutorRepository,则：
								>加载： 则加载 "META-INF/dubbo/internal/org.apache.dubbo.common.threadpool.manager.ExecutorRepository" 这个路径的资源：即以类加载器：ClassLoader.getResources(fileName)方式加载，然后读取这个URL到 BufferedBreader里：@new BufferedReader(new InputStreamReader()),然后遍历读取每一行，然后name=前缀，而Class=后面的反射加载Class.forName()这个value代表的类名，放到：exceptions 属性里。。。可以查看@loadDirectory()方法细看。加载自然是加载 classpath下的包里的。
									>实际就加载了："default":"org.apache.dubbo.common.threadpool.manager.DefaultExecutorRepository"
								>同理加载：尝试加载"META-INF/services/org.apache.dubbo.common.threadpool.manager.ExecutorRepository" 实际并不存在；
							>后创建合适的扩展类：@createAdaptiveExtensionClass()
								>
		>					
>spring-boot中：启动过程中 服务的代理过程？从而生成完整的一个个服务？猜测是解析配置注解的时候，@InputSource 注解的consumer.xml配置的解析而产生的一个个客户端bean:
	>先是创建bd时：创建了name="dubboBootstrapApplicationListener" 的 bd: 
	>后在广播事件的时候：需要寻找所有的 applicationListener, 此时就执行了从bf里寻找并创建name="dubboBootstrapApplicationListener"的bd的实例工作：bf.getBean(..)  创建的实例 就是 DubboBootstrapApplicationListener 实例。 
		--这个广播事件：就是在 org.springframework.data.mapping.context.AbstractMappingContext 的初始化方法@afterPropertiesSet()里调用出发执行的。
		--这个实例 的创建：非常多事情：核心为：@DubboBootstrap.getInstance() 单例模式创建
			>属性初始化方面：
				>创建线程池：赋值给属性
				>创建默认扩展：@EventDispatcher.getDefaultExtension()
					>核心：指定类别后 调用通用方法 获取默认扩展类： @ExtensionLoader.getExtensionLoader(EventDispatcher.class).getDefaultExtension()
						>先是获取扩展加载器--核心：new ExtensionLoader<T>(type) 这个type=EventDispatcher  其取得后放到 EXTENSION_LOADERS 属性里。
							>核心就是固定的：@ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()) 来赋值给 objectFactory 属性；关键显然是后面一个方法：@getAdaptiveExtension()
								>核心：创建扩展：@createAdaptiveExtension()
									>核心：获取扩展类来实例化：@getAdaptiveExtensionClass()
										>核心：已经有说：就是@getExtensionClasses() 加载 文件中配置的类， 但是执行的时候却很特别：在@loadExtensionClasses()里：因此此时 type=org.apache.dubbo.common.extension.ExtensionFactory 上面调用的入参已经说明了。
											>所以加载："META-INF/dubbo/internal/org.apache.dubbo.common.extension.ExtensionFactory" 而这个文件里有3行：spring=org.apache.dubbo.config.spring.extension.SpringExtensionFactory  adaptive=org.apache.dubbo.common.extension.factory.AdaptiveExtensionFactory  spi=org.apache.dubbo.common.extension.factory.SpiExtensionFactory
												>而具体的加载方法很独特：@loadDirectory()->loadResource()->loadClass(): 这个方法里，分类处理：
													>如果有 @Adaptive 注解，则调用@cacheAdaptiveClass(clazz) 来处理。而这个方法处理很简单：就是@cachedAdaptiveClass = clazz 赋值，显然，上面因为有这种类，所以赋值给了这个属性；
													>其他类，一般就是直接放到入参map里返回了：即剩下的两个都这样返回了。到了@loadDirectory()的入参里，返回作为@loadExtensionClasses()返回值返回了。
										>然后：可能创建 适配的扩展类：@createAdaptiveExtensionClass()； 但是条件是 cachedAdaptiveClass 属性 是Null,但是上一步已经 设置了，所以不会执行(内部有死循环问题？)，而是直接返回 cachedAdaptiveClass 这个属性。 但是有的就是没有@Adaptive 注解，比如 org.apache.dubbo.rpc.Protocol， 而 cachedDefaultName="dubbo", 从而会执行：@createAdaptiveExtensionClass()
											>直接生成class的java code: @new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate()
												>简单粗暴：就是 编写 package... import....class.., 且这个类是：Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol 然后将接口Protocol的方法实现补上， 重点是实现 @export()方法 + @refer()方法。。。这样，完整的类代码生成了。
											>开始编译这个java code: 先找到合适的 compiler: @ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension() 很明显，先加载文件，发现有三个：adaptive=org.apache.dubbo.common.compiler.support.AdaptiveCompiler, jdk=org.apache.dubbo.common.compiler.support.JdkCompiler, javassit=org.apache.dubbo.common.compiler.support.JavassistCompiler
												>第一个 AdaptiveClassCodeGenerator 有 Adaptive 注解：所以缓存了这个Class到 ExtensionLoader::cachedAdaptiveClass 属性里；后面两个没有--必然没有。所以在@getAdaptiveExtension()->createAdaptiveExtension()->getAdaptiveExtensionClass()这个实现里，直接返回了。不会递归@createAdaptiveExtensionClass()
												>找到之后自然就是实例化：实例化之后@injectExtension()注入即可；
												--方法名如其含义，获取到 adaptive 的扩展 为止。
											>然后开始实质的编译：@compiler.compile(code, classLoader)
												>获取编译器的默认扩展：@ExtensionLoader.getExtensionLoader(Compiler.class).getDefaultExtension() 很显然，org.apache.dubbo.common.compiler.Compiler 这个接口上@SPI("javassist") 这个注解表名 javassist 才是默认的；因此找到 JavassistCompiler 这个类来实例化。
												>使用获取到的默认扩展-编译器：来编译：@compiler.compile(code, classLoader)
													>核心：最终通过对@org.apache.dubbo.common.compiler.support.CtClassBuilder#build()的调用 实现 转到 javassist 的 字节码拼接生成：仅仅只需要指明 类名、接口名。。。。
									>上一步返回的 cacheAdaptiveClass 代表的类：	AdaptiveExtensionFactory 直接反射方式创建它的实例：@newInstance()	
										>实例创建的具体操作：
											>创建扩展工厂：@ExtensionLoader.getExtensionLoader(ExtensionFactory.class) 因为入参类是这个，所以内部 objectFactory=null 
											>遍历上述从文件获得的三个name: 对每个，获取具体扩展类实例@getExtension(String name)
												>创建先：@createExtension(name)
													>自然是 SpiExtensionFactory 类，然后反射实例化，后存储到 ExtensionLoader.EXTENSION_INSTANCES属性里；
													>注入扩展：@injectExtension() 
														>如果 objectFactory=null直接返回
														>获取这个类的所有方法，筛选 其中 setter方法 且 非 DisableInject 注解方法，然后根据方法名采取出对应的属性名，从 objectFactory里获取对应名字的工厂： objectFactory.getExtension()成功后，则反射调用这个方法设置进去这个工厂；
													>初始化扩展：@initExtension(instance)	 看有没实现 Lifecycle 接口，有则要执行初始化方法。
													>返回实例
												>存储后：将实例封装到Holder 实例里，放到 cachedInstances 属性。
												>返回这个实例。 
											>将两个工厂类实例 放到 factories 属性里：即 SpiExtensionFactory / SpringExtensionFactory 
									>注入创建的 AdaptiveExtensionFactory 实例 ：@injectExtension() 也直接返回：因为 objectFactory=null 
							>如此，完成这个type的 ExtensionLoader的 实例化。
					>后是获取默认扩展：		@getDefaultExtension() 
						>核心：先还是获取所有的扩展类：@getExtensionClasses() 但此时 type=org.apache.dubbo.event.EventDispatcher 所以 在@loadDirectory()时构造的文件路径是“META-INF/dubbo/internal/org.apache.dubbo.event.EventDispatcher”， 内部两个：direct=org.apache.dubbo.event.DirectEventDispatcher  parallel=org.apache.dubbo.event.ParallelEventDispatcher
						>然后是获取指定的扩展：@getExtension(cachedDefaultName) ，这里的 cachedDefaultName="direct"  所以结果自然是：给 EXTENSION_LOADERS 属性增加了一个扩展加载器：@new ExtensionLoader<T>(type) type=DirectEventDispatcher  而过程中实例化 DirectEventDispatcher 时候，有额外的工作：@loadEventListenerInstances() 
							>获取了 EventListener 类型扩展加载器：@ExtensionLoader.getExtensionLoader(EventListener.class) 自然的就加载了"META-INF/dubbo/internal/org.apache.dubbo.event.EventListener" 里的四个：service-mapping, config-logging, service-instance,registry-logging  对于这四个，自然是@getExtension(name) 方式获取实例
								>在对 service-mapping 的 ExtensionClass 实例化时：org.apache.dubbo.config.event.listener.ServiceNameMappingListener 有特殊操作:就是给内部属性 serviceNameMapping 赋值@getDefaultExtension()默认扩展：@getExtensionLoader(ServiceNameMapping.class).getDefaultExtension()这个，自然看会加载哪个文件，第二，看默认的选择哪个：在@SPI("default")注解里的内容，就是选择的文件里的具体的那个扩展。这里的路径就是“META-INF/dubbo/internal/org.apache.dubbo.metadata.ServiceNameMapping”
							--实例化的@loadEventListenerInstances()执行完毕后, 是@injectExtension(instance) 动作，自然有阐述；		
				>执行仓库 这个扩展的获取：@ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension() 同样，还是看加载路径和默认标签选择："META-INF/dubbo/internal/org.apache.dubbo.common.threadpool.manager.ExecutorRepository" 文件内容只有一个：DefaultExecutorRepository, 而父类上有注解@SPI("default") 所以选择了这个来实例化。
			>构造方法里的初始化：
				>设置配置管理器：@ApplicationModel.getConfigManager()
					>使用一般的加载器：@ExtensionLoader.getExtensionLoader(FrameworkExt.class) 这个加载器 ，来加载 @loader.getExtension("config")这个名字配置的 实现类 实例 org.apache.dubbo.config.context.ConfigManager。 这个文件里其他2个：environment=org.apache.dubbo.common.config.Environment, repository=org.apache.dubbo.rpc.model.ServiceRepository
						>而在实例化 ConfigManager 时 ： @injectExtension()阶段，发现它有属性：setModule()，从而属性 module需要设置，自然 objectFactory 里找不到；
				>设置环境：@ApplicationModel.getEnvironment()
					>类似上述：使用同一个loader, @loader.getExtension("environment") 而已，自然得到它的实例。
						>它实现了 Lifecycle 接口，所以会在@initExtension(instance)阶段执行 这个接口的 初始化方法@lifecycle.initialize() 一些工作，作用不大；
				>注册jvm回调处理：@ubboShutdownHook.getDubboShutdownHook().register()  
					>新建new DubboShutdownHook()--内部许多初始化 
					>注册：@Runtime.getRuntime().addShutdownHook()
					>分发注册回调事件：@dispatch(new DubboShutdownHookRegisteredEvent(dubboShutdownHook))
						>使用的事件分发器：@EventDispatcher.getDefaultExtension() 方式获取的：即 也是从扩展文件里获取的：@ExtensionLoader.getExtensionLoader(EventDispatcher.class).getDefaultExtension()
						>执行分发：@eventDispatcher.dispatch(event) 具体监听器略。
					>增加DubboShutdownHook回调：@ShutdownHookCallbacks.INSTANCE.addCallback()
						>实例的创建，首先还是补充callback:@ExtensionLoader.getExtensionLoader(ShutdownHookCallback.class) 从文件里补充。
						>调用时间：还是在注册回调事件的 DubboShutdownHook 实例的 被 线程池执行过程。
	>第二个重要节点：<dubbo:application name="dubbo-comment" ...>这样对应的 bean的 getBean()的过程中：在初始化阶段@initializeBean()-->@applyBeanPostProcessorsBeforeInitialization() 时候执行：在 InitDestroyAnnotationBeanPostProcessor 处理器 处理时：直接寻找并调用初始化方法：@invokeInitMethods(Object target, String beanName)-->发现初始化方法为“addIntoConfigManager”确实这个方法上有@PostConstruct 注解，这个方法的具体实现：
		>往配置管理器里增加一个配置：@ApplicationModel.getConfigManager().addConfig(this) ， 这个this=ApplicationConfig 
	>第三个节点：@refresh()中后面的获取接口的实例：如 getBean("com.ihuaben.dubbo.api.iservice.comment.ICommentService") ，因为从bd中看是没有构造方法的，所以走了最后的尝试：@org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean()
		>即根据设置的实例化策略来进行实例化：这个策略属性： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiationStrategy=CglibSubclassingInstantiationStrategy, 即@getInstantiationStrategy().instantiate(mbd, beanName, parent) 策略 的实例化方法：是一个模板方法，即走了父类的实现：@org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate()方法：
			>找构造方法：优先从 bd.resolvedConstructorOrFactoryMethod 这个属性里取， 发现 Constructor 是 org.apache.dubbo.config.spring.ServiceBean 的构造方法：
			>使用找到的构造方法进行实例化了：@BeanUtils.instantiateClass(constructorToUse) 具体实现，非常干脆，直接反射实例化@ctor.newInstance()，毕竟 ServiceBean也是一个类；实例化过程：
				>因为继承了 ServiceConfig 类，所以它的一些构造方法需要执行：
					>创建调度线程池：@Executors.newSingleThreadScheduledExecutor()
					>加载协议实例：@ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension() 发现也是从文件里获取，且获取合适的那个：这个文件里有19个实现！！