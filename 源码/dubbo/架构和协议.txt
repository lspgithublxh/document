//品味：慢慢
//spring的逻辑结构：情况-要做的事情； 数据-要做的事情：
//流程动作> 调用方法@  分支判断# 
//世界观：*
//不止是为了单单为了实现这单一的功能仅此而已，必须考虑更多(情况)做更多(事情，准备；化被动为主动去做)，而不是直接仅仅只做什么。
//考虑-决定-预防-收益/影响/后果-预测下一步要做什么(甚至下n步)
//大的想法，具体行动。
//出现了if-else就是因为有不同的考虑。
//阅读文档达到直接可以看出思路编写程序的清晰逻辑的地步。
//一个大函数功能直接看懂而描述。
//从网上找答案变为从源码中找答案。
//功能组织体系，而不是动作实现体系。是目标，是事情，而不是精细到实现方案的动作。
//数据源-数据结果模式：而不是全部动作过程。
//能够主动猜某个方法的功能和猜测它的实现。
//情况-通用处理。
//情况-精细结构。
//数据结构-与处理。
//某个时刻某个地方：所有可能用户做的事情。
//就像是军队打仗一样：AbstractApplicationContext上下文就是总部主帅，负责整个流程，但实现个别子流程；ServletWebServerApplicationContext就是地区主帅，负责使用总部流程且根据区域情况具体化部分流程实现，同时负责分给不同的人去实现更细的子流程(用人/用器：如事件广播器、bean工厂、生命周期处理器; 向它们发号命令：调用/叫他们做什么)，层层下去到事务的精细结构。(负责事务的精细级别 就看出 和一线的和当前的距离)
	>对一个事物类：他是有属性
	>对一个组织类：他是有人；属性当作人。人可能是为他办事的，也可能是监听他的监听器。
	>对一个系统类：他是有组件/器具；属性当作器具
//为什么层次多：因为连续地向上进行了抽象，每层都分类了/拆分了不同的功能，每层连续往下拆分。
//抽象到具体的描述。自然推理出来。才是架构。才是原本的架构。

>正向看：
	>org.apache.dubbo.container.Main类 @main(String[] args) 入口
		>
	>从@AbstractApplicationContext.refresh()开始：
		>先：@AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) 里面的代码直接有一行：@PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());来调用
			>先：@PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors()
				>先： @ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry registry) 中使用 reader来调用。@this.reader.loadBeanDefinitions(configClasses) 这里的配置类Class包括：所有的service的Class, 名字就是类的首字母小写；
					>先：@ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(Set<ConfigurationClass> configurationModel)-->@loadBeanDefinitionsFromImportedResources()
						>先：@AbstractBeanDefinitionReader.loadBeanDefinitions(String location) --> @loadBeanDefinitions(Resource... resources) 
							>核心：开始转到@XmlBeanDefinitionReader.loadBeanDefinitions(Resource resource)
								>进一步：@doLoadBeanDefinitions(InputSource inputSource, Resource resource)
									>@XmlBeanDefinitionReader/DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(Document doc, Resource resource)
										>再次到@DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions(Element root)
											>@DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) 这里就会遍历xml的所有节点：开始遍历的解析ele并且注册；
												>@BeanDefinitionParserDelegate.parseCustomElement(Element ele)
													>@parseCustomElement(Element ele, @Nullable BeanDefinition containingBd): 开始实质的解析：获取解析器开始解析：@his.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri) 这里的名称空间uri就是："http://dubbo.apache.org/schema/dubbo" 类似。
														>先获取名称空间uri:@getNamespaceURI(ele)
														>然后用这个名称空间解析出 NamespaceHandler: @this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri) 
															>通过handerMappings(uri-handler类名)可以找到名称空间对应的解析处理器名："org.apache.dubbo.config.spring.schema.DubboNamespaceHandler" 或者实例Class对象---首次是string ,所以需要加载初始化，第二次就已经是Class对象了，所以直接返回即可。
															>会执行初始化方法：@DefaultNamespaceHandlerResolver::namespaceHandler.init()
															-----org.apache.dubbo.config.spring.schema.DubboNamespaceHandler 实现的@init()
																>注册分别解析xml配置文件里的各个标签的解析器：application/module/registry/config-center/metadata-server/monitor/metrics/ssl/provider/consumer/protocol/service/reference/annotation
																	>解析器：如 application标签---@new DubboBeanDefinitionParser(ApplicationConfig.class, true)
																		>基本流程：还是 获取 标签 里的 name 属性的值：当做类名，如果bf里已经定义了，那么 加后缀2/3/4/5/..数字以示区别。这个名称 就是 BeanDefinition 的名字，放入bdmap;。。例如 ServiceBean/ReferenceBean
																			>特别注意：ReferenceBean 是实现了 FactoryBean 接口的：所以这个bean的获取是@getObject() 获取ref ，但是开始ref为null 需要初始化。
																				>最终转到父类 ReferenceConfig 的 @init()： 最终抽象层次具体到：
																					>获取@DubboBootstrap.getInstance()单例；然后执行初始化@bootstrap.init()
																						>
																					>检查和更新子配置：@checkAndUpdateSubConfigs()
																					>获取服务工厂：@ApplicationModel.getServiceRepository() 并且注册消费者：@repository.registerConsumer()
																					>创建代理：@createProxy(map) 值就是赋值给 ref 
																						>先一系列配置：其次，静态属性方式已经获取了代理工厂：@ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension()
																							>开始实质的获取代理：@PROXY_FACTORY.getProxy(invoker)
																								>包装类获取代理：@StubProxyFactoryWrapper.getProxy(Invoker<T> invoker)
																									>@org.apache.dubbo.rpc.proxy.AbstractProxyFactory.getProxy(Invoker<T> invoker, Class<?>[] types)
																										>中间代理方：@JavassistProxyFactory.getProxy(Invoker<T> invoker, Class<?>[] interfaces)
																											>最终进行: 则是通过 org.apache.dubbo.common.bytecode.Proxy 来获取实例的过程： 通过javassist.jar来实现的：类名：org.apache.dubbo.common.bytecode.Proxy0/1/2/3/4/5等自增数字结尾；而利用 javassist 中的 javassist.CtClass 类可以设置增加方法、field、构造方法、设置父类等；返回Class,然后使用class的newInstance()直接实例化。
																								>通过获取invoker.getInterface()的nam + "Stub"/"Local" 之类形成类名 反射加载 用构造方法 实例化：	proxy再次，而上次那个proxy则注入。
																								>最后输出代理实例-url关联：@export(T instance, Class<T> type, URL url)
																									>转到@protocol.export(proxyFactory.getInvoker(instance, type, url))
																									---以 org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 实现为例： 
																										>拼装服务key:@ProtocolUtils.serviceKey()
																										>构造exporter:@new DubboExporter<T>(invoker, key, exporterMap) 且会最终返回。
																										>创建并打开服务器：@openServer(url)
																											>创建服务器：@createServer(url) 缓存模式
																											>url添加参数而格式化出str: 
																											>url和回调绑定：@Exchangers.bind(url, requestHandler)
																												--其中注意 requestHandler 这个属性：是 new ExchangeHandlerAdapter(){}的匿名实现。
																													>实现@CompletableFuture<Object> reply(ExchangeChannel channel, Object message)方法 
																														>先通过通道获取invoker:@getInvoker(channel, inv)
																														>后执行invoker:@invoker.invoke(inv) 获取结果 Result 返回前运用：@.thenApply(Function.identity()) 里面纯粹是 result的实现。
																												>先获取信息交换者：@getExchanger(url)
																													>扩展加载器方式加载：@ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type)
																												>后进行实际的绑定：@bind(url, handler)
																													>url绑定new DecodeHandler() :@Transporters.bind()
																														>再次扩展加载器方式加载Transporter:@ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension()
																														>然后再次@bind(): 
																															---以netty4 实现为例：@org.apache.dubbo.remoting.transport.netty4.NettyTransporter
																																>直接新建服务器：@new org.apache.dubbo.remoting.transport.netty4.NettyServer(url, listener)
																																	>从父类开始：@AbstractServer()
																																		>设置绑定ip和地址：
																																		>打开连接：@doOpen() 由子类实现；
																																			>开始全面的调用Netty api: @new io.netty.bootstrap.ServerBootstrap()
																																			>事件循环组：@new NioEventLoopGroup()
																																			>服务回调处理器：@new NettyServerHandler(getUrl(), this)
																																			>开始分组配置：@bootstrap.group(bossGroup, workerGroup).....@.childHandler(new ChannelInitializer<NioSocketChannel>() {});之类的初始化通道等；
																																			>创建执行器：@createExecutorIfAbsent(URL url)即 java的 ExcutorService;
																													>新建交换服务器：new HeaderExchangeServer()
																														>启动一个检查任务：检查闲逛的服务器Server---然后将它的通道关闭：@startIdleCheckTask(getUrl());
																											>绑定完成之后：直接返回服务器 @new DubboProtocolServer(server)		
																										>最优化的序列化：@optimizeSerialization(url)
																					>寻找引用的服务：@repository.lookupReferredService()
																					>分发一个引用配置初始化事件：@dispatch(new ReferenceConfigInitializedEvent(this, invoker))
																						>分发器分发：@EventDispatcher.getDefaultExtension().dispatch(event) 实际上是发布订阅模式；让所有的listener执行.onEvent(event)方法;
														>最后用这个NH实例进行解析：@NamespaceHandlerSupport.parse(Element element, ParserContext parserContext)
															>解析转发：寻找具体的BeanDefinitionParser 实现类：@parse(Element element, ParserContext pc)
																
																
>反向看：使用方向
	>调用一个方法开始：
	>被请求一个方法开始：
	>spring-boot启动开始：从@AbstractApplicationContext::refresh()开始
		>实例化所有剩余的非懒初始化的单例：@finishBeanFactoryInitialization(beanFactory)
			>最后交给bf实现：@beanFactory.preInstantiateSingletons();
				>获取全部的beanDefinitionNames:  里面包含 service/config/dataSource/processor/advice等等全部，如308个。
				>遍历每一个：如果是 FactoryBean 则按工厂方式获取，否则按照普通方式获取: 都是@getBean(beanName)  其中如果有构造方法来实例化：会最终走：sun.reflect.NativeConstructorAccessorImpl 的@native Object newInstance0(Constructor<?> var0, Object[] var1)---->从这里开始，就转到具体类的构造方法上了：如  org.apache.dubbo.config.spring.ServiceBean()
					>注意在@AbstractAutowireCapableBeanFactory::initializeBean()阶段会：执行 初始化方法@invokeInitMethods(beanName, wrappedBean, mbd) 内部即@InitializingBean::afterPropertiesSet()
						>而在这里：往往有的类就会执行自己的初始化方法：有的还会发事件：new MappingContextEvent<>(this, entity))
							>而发事件会进一步找广播器来广播事件给匹配的listener:@getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType)
								>而接受者 listener一定有：DubboBootstrapApplicationListener
					--这里看 "com.ihuaben.dubbo.api.iservice.manager.IChapterAuditService" 这个beanName的实例化创建过程：同样的那308个都是一样被实例化的。
						>获取 RootBeanDefinition 对象: 而其中有个属性 resolvedTargetType = "org.apache.dubbo.config.spring.ServiceBean" beanClass="org.apache.dubbo.config.spring.ServiceBean"
							>回调方式创建：解析出beanClass= ServiceBean 
								>在@doCreateBean()之前走processor: 共有14个。过滤出 InstantiationAwareBeanPostProcessor 实现类
									>org.springframework.context.annotation.ConfigurationClassPostProcessor实现了：InstantiationAwareBeanPostProcessor @postProcessBeforeInstantiation(beanClass, beanName)方法
									>org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator 
									>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
									>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor
									>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
								>后在@createBeanInstance()中再次走processor: 过滤出：SmartInstantiationAwareBeanPostProcessor 实现类 
									>...再次没有应用出有意义的。
								>后在@instantiateBean()方法中对 ServiceBean 用构造方法 方式 实例化： 得到 了 ServiceBean的实例。
								>后再在@doCreateBean()中应用processor: 过滤出 MergedBeanDefinitionPostProcessor 实现类 
									>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor ： @postProcessMergedBeanDefinition()方法的执行
										>先调用父类同名方法：InitDestroyAnnotationBeanPostProcessor.postProcessMergedBeanDefinition()
											>查出初始化方法@org.apache.dubbo.config.AbstractConfig.addIntoConfigManager()
									>org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor: 
										>寻找注入 的Field+Method元数据：AnnotatedInjectionMetadata  后以元数据检查beandefinition:@metadata.checkConfigMembers(beanDefinition);
									>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor	
										>寻找自动绑定的元数据：没有则构建：@buildAutowiringMetadata(clazz) 后用来检查成员：@metadata.checkConfigMembers(beanDefinition)
									>org.springframework.context.support.ApplicationListenerDetector：	
								>开始@populateBean(): 开始属性注入
									>再次先走processor: 过滤出 InstantiationAwareBeanPostProcessor 实现类： 
									>再走processor: 过滤出 InstantiationAwareBeanPostProcessor 实现类：走 @postProcessProperties()方法 ：属性处理--串联方式；不断包裹filter。
										>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor:
											>最终7个属性：id/ref/interface/version/delay/async/timeout
											>最后应用属性：@applyPropertyValues()
												>id: 值为 接口名： com.ihuaben.dubbo.api.iservice.manager.ITopSprintService 通过评估方式 @evalute() 结果还是字符串名。
													>转换服务之后：convertService 还是 字符串。
												>ref: 值为 org.springframework.beans.factory.config.RuntimeBeanReference 对象,其name="topSprintService" 。所以当做引用来解析：@resolveReference(argName, ref)
													>评估方式获取ref的beanName，还是 topSprintService 字符串值。
													>开始用beanFactory.getBean("topSprintService") 来获取 实例。发现单例池里面已经有了这个名字的单例： com.ihuaben.dubbo.service.manager.TopSprintService 的实例---即一个自己编写的service实例。
													>最后注册依赖：@this.beanFactory.registerDependentBean(resolvedName, this.beanName) ： resolvedName="topSprintService" , beanName="com.ihuaben.dubbo.api.iservice.manager.ITopSprintService"
													>返回这个 单例 bean。
												>interface：值为 接口 字符串； 解析的时候就直接走评估了；	valueResolver.resolveValueIfNecessary(pv, originalValue)--->@evalute();从而结果还是字符串。
													>解析：走评估 返回原值。
													>转换服务：直接还是 原值。
												>version: 空。	
													>解析：空 
													>转换：空。 
												>delay: 空。 
													>解析：空 
													>转换：空。 
								>开始@initializeBean（）： 开始激活意识方法：
									>实现了 BeanNameAware 接口： 则注入 beanName 
									>再次应用 processor: 不做过滤：直接执行每一个的@postProcessBeforeInitialization()
										>org.springframework.context.support.ApplicationContextAwareProcessor: 核心内容为：
											>激活感知接口：注入相关全局工具/上下文。@invokeAwareInterfaces(bean) EnvironmentAware/EmbeddedValueResolverAware/ApplicationEventPublisherAware/ApplicationContextAware
										>com.alibaba.spring.beans.factory.annotation.ConfigurationBeanBindingPostProcessor:	
											--说明：在对 "org.apache.dubbo.config.ApplicationConfig#0" 实例化构建 时，在@initializeBean()里的首先应用processor时：对当前这个配置processor进行处理：。。对 “org.apache.dubbo.config.RegistryConfig#0” 构建也是；
												>获取定义：beanDefinition
												>绑定定义：bindConfigurationBean(bean, beanDefinition)
													>直接获取bf里的attribute属性里的"configurationProperties" 属性的值：就是配置：例如zk的配置："address" -> "zookeeper://39.105.71.50:2181" ，"client" -> "curator" "timeout" -> "15000" 之类，在一个map里
													>开始实质的绑定：@org.apache.dubbo.spring.boot.autoconfigure.BinderDubboConfigBinder.bind()
														>再次：@org.springframework.boot.context.properties.bind.Binder.bind("", bindable, bindHandler);  @bindObject()
															>实现的效果：从上下文获取属性，后绑定属性到对象：@bindProperty(target, context, property)
															>没有属性则绑定数据对象：@bindDataObject(name, target, handler, context, allowRecursiveBinding)
																>核心：遍历属性：dataObjectBinders:DataObjectBinder 逐个绑定：实现类：
																	>ValueObjectBinder:
																	>JavaBeanBinder:.bind() 工作逻辑：获取全部Bean的属性，一个个遍历绑定：@bind(beanSupplier, propertyBinder, beanProperty) ，值是回调获取的supplier方式：从上下文获取属性。
												--效果：就将bf里的属性设置到了bean实例里。这个实例是：RegistryConfig#0”			
												>客户端定制化：@customize(beanName, bean)
													>遍历已经得到的customizer: 第一个是 DubboConfigBeanCustomizer ，对每一个，进行 定制化：@customizer.customize(beanName, configurationBean) 所以看 dubbo的这个实现：
														>最终到了：@NamePropertyDefaultValueDubboConfigBeanCustomizer.customize(String beanName, AbstractConfig dubboConfigBean)
															>反射获取getName()这个方法的Method, 反射执行：得到值 就是 <dubbo:application > 的 name 值：
										>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor: 即获取生命周期元数据，执行 指定的 初始化方法
											>反射方式获取Method且执行：@public void org.apache.dubbo.config.AbstractConfig.addIntoConfigManager()方法，@element.invoke(target)  target=ApplicationConfig
										>org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor
											>找到指定的初始化方法：反射方式执行：@this.method.invoke(target, (Object[]) null) 方法名：addIntoConfigManager()
									>再次外层执行初始化方法：@invokeInitMethods(beanName, wrappedBean, mbd)	此次这是找到 是否 实现了 InitializingBean 接口： 
										>实现了，则执行：@.afterPropertiesSet()
									>再次应用processor: 不做过滤：直接执行每一个的@postProcessAfterInitialization()
										>org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator: 可能会执行缓存：
											>执行必要的包装：@wrapIfNecessary()
												>最经典的：获取切点：@getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null)
													>寻找合格的通知者：@findEligibleAdvisors(beanClass, beanName) 类=org.apache.dubbo.config.spring.ServiceBean， name=com.ihuaben.dubbo.api.iservice.manager.ITopSprintService
														>获取候选：
															>缓存有2个：org.springframework.transaction.config.internalTransactionAdvisor   , defaultPointcutAdvisor
																>遍历这两个name: 对每个从bf里获取 实例：并确保是 Advisor 的实现类：@this.beanFactory.getBean(name, Advisor.class)
																	>实际实例：org.springframework.transaction.interceptor.BeanFactoryTransactionAttributeSourceAdvisor  和  org.springframework.aop.support.DefaultPointcutAdvisor
														>从aspectJ里补充：@this.aspectJAdvisorsBuilder.buildAspectJAdvisors()
													>过滤出能应用的：即用ClassFilter/PointCut来匹配 过滤：@AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass)
														>如果是 IntroductionAdvisor 类型 ： 那么用 ClassFilter.matches(targetClass);
														>如果是 PointCutAdvisor 类型： 那么用 .getPointCut().getMethodMatcher().matches(method, targetClass) 来对 targetClass 的全部声明方法 进行匹配。有一个能应用都说明是可以应用的。
													>进行对Advisor通知者排序：	比较器：AspectJPrecedenceComparator  先用 AnnotationAwareOrderComparator 比较。Ordered类的.getOrder()
														>获取Advisor的序号：
												>如果Advisors不是空：那么就要利用目标类Class\bean实例\Advisor来创建代理：@createProxy()
													>创建代理比较固定：new ProxyFactory() 
													>设置要代理的目标类：
													>构建Advisor组：@buildAdvisors(beanName, specificInterceptors)
														>主要目的：对每个Advsior进行一次包装：@this.advisorAdapterRegistry.wrap()
															>如果是Advisor实例：直接返回 
															>如果不是 Advice: 封装到   UnknownAdviceTypeException
															--此时一定是Advice了：
															>如果是方法拦截器：MethodInterceptor 实例，那么 封装到 	new DefaultPointcutAdvisor(advice) 里。
															>否则遍历 adapters： 对每个 AdvisorAdapter， 如果其中一个 支持 advice ：@adapter.supportsAdvice(advice) 那么直接封装到new DefaultPointcutAdvisor(advice) 返回了。
													>设置到 proxyFactory里：proxyFactory.addAdvisors(advisors)
													>构建：@proxyFactory.getProxy(getProxyClassLoader())
														>创建AOP代理：@createAopProxy()
															>分如果目标类targetClass是接口：那么用jdk动态代理：new JdkDynamicAopProxy(config)
																>最后就是常见的动态代理：@Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)
															>否则用cglib的aop代理：new ObjenesisCglibAopProxy(config)
																>最后就是：Enhancer enhancer = createEnhancer() 设置@enhancer.setCallbacks(callbacks) 回调。
														>获取代理：@getProxy(classLoader)
													>直接返回这个代理：proxy 
												>是空：则返回bean即可。		
									>返回包装的bean
								>注册销毁接口：@registerDisposableBean()   DisposableBean		
						>创建完成：返回。								
		>最后发送通信事件：@finishRefresh()	
			>发送上下文刷新事件：@publishEvent(new ContextRefreshedEvent(this))
				>采用广播模式发送事件：@getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType)
					>寻找匹配上下文事件类型的 全部 ApplicationListener： @SimpleApplicationEventMulticaster.getApplicationListeners(event, type)
						>其中就有：DubboBootstrapApplicationListener 监听器， 开始激活：@invokeListener(listener, event)
							>转到@doInvokeListener(listener, event) 执行核心的：@listener.onApplicationEvent(event)
								>转到上下文事件响应方法：@onApplicationContextEvent(ApplicationContextEvent event)
									>执行@onContextRefreshedEvent(ContextRefreshedEvent event)
										>核心：@dubboBootstrap.start() 这个 dubboBootstrap 也是单例获取：@DubboBootstrap.getInstance()
											>先初始化：@initialize()
												>框架扩展初始化：@iniFrameworkExts()
												>启动配置中心：@startConfigCenter()
													>获取配置中心集合：ConfigCenterConfig ; <dubbo:config-center ...>
													>遍历每个配置中心：
														>先刷新：@ConfigCenterConfig.refresh()
														>获取 ConfigCenterConfig的所有方法：逐个遍历：判定为设置 类型方法：@
															>很神奇：从@CompositeConfiguration.getInternalProperty(String key) 来获取值，然后又set值：---但获取的值有过滤处理。
																>CompositeConfiguration有配置属性：@configList:Configuration 遍历，如果其中一个配置包含key这个键，那么取它的值：。。所以这个configList就是属性值的来源。
													>验证配置和添加动态配置：@compositeDynamicConfiguration.addConfiguration(prepareEnvironment(configCenter))	
													>配置管理刷新所有：@configManager.refreshAll()
														>ApplicationConfig::refresh MonitorConfig::refresh  ProtocolConfig::refresh RegistryConfig::refresh ProviderConfig::refresh ConsumerConfig::refresh
													>有必要配置中心用registry：@useRegistryAsConfigCenterIfNecessary()
													>启动元数据报告：即生成一个 MetadataReport: url=“zookeeper://39.105.71.50:2181/org.apache.dubbo.metadata.report.MetadataReport”
													>检查全局配置：@checkGlobalConfigs()
													>初始化元数据服务：@initMetadataService() 
														>getExtensionLoader(WritableMetadataService.class)获取来配置：metadataService属性。
													>初始化元数据服务exporter；@initMetadataServiceExporter()类似上。
													>初始化事件监听器：@initEventListener()
														>就是addEventListener(this)；就是将 DubboBootstrap 直接注册到listerner: 一般的事件分发。只注册到：org.apache.dubbo.event.AbstractEventDispatcher
											>后执行输出全部服务：@exportServices()
												>获取全部配置：ServiceConfig, 对于某个sc, 其 beanName="com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService"是用户写的。
												>逐个遍历：放到线程池执行：@sc.export()
													>如果bootstrap null：会实例化并初始化@init()
													>继续检查子配置：@checkAndUpdateSubConfigs()
													>开始真正的输出：@doExport() 
														>核心输出：@doExportUrls()
															>获取服务仓库：@ApplicationModel.getServiceRepository()
															>使用仓库注册服务：@repository.registerService(getInterfaceClass())
															>使用仓库注册提供者：@repository.registerProvider()
															>遍历每个协议配置：再次执行注册服务，后进行实质的输出url for 协议：@doExportUrlsFor1Protocol()。。协议配置就是：<duboo:protocol ...>的实体映射。
																>核心为获取全部的方法：对方法进行输出：@getMethods()  获取到的是方法配置，后处理放到map里 
																>找到host和port: 构造url:其格式如："dubbo://192.168.3.32:20883/com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService?accepts=500&anyhost=true&application=ihuabenservice-server&bind.ip=192.168.3.32&bind.port=20883&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService&methods=saveOrUpdateApplyRecommendation,getApplyRecommendationById,getApplyRecommendations,executeApplyRecommendation,getLastApplyRecommendation&pid=10724&qos.enable=false&release=2.7.5&retries=0&side=provider&threadpool=fixed&threads=500&timeout=30000&timestamp=1600167916197"
																>获取Invoker并且包装：后使用协议 输出：@protocol.export(wrapperInvoker) 得到 Exporter  后面的实现类似上面。
																#对于本地：会使用另一个方式输出：@exportLocal(url) 但是执行之后还是会执行上述：@protocol.export(wrapperInvoker)
																	>协议的url变为：“injvm://127.0.0.1/com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService?accepts=500&anyhost=true&application=ihuabenservice-server&bind.ip=192.168.3.32&bind.port=20883&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=com.ihuaben.dubbo.api.iservice.manager.IApplyRecommendationService&methods=saveOrUpdateApplyRecommendation,getApplyRecommendationById,getApplyRecommendations,executeApplyRecommendation,getLastApplyRecommendation&pid=10724&qos.enable=false&release=2.7.5&retries=0&side=provider&threadpool=fixed&threads=500&timeout=30000&timestamp=1600167916197”
																	>再次用协议对象输出：@ protocol.export(ROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, local)) 具体实现上述已有，不再陈述。
														>发送服务配置输出事件：@dispatch(new ServiceConfigExportedEvent(this))
											>后可能输出元数据服务：@exportMetadataService()
											>可能注册服务实例：@registerServiceInstance()
											>引用全部服务：@referServices()
											
-------------------------------专项问题：
>spring-boot中：客户端一个服务请求的过程？
	>服务接口的实现肯定是一个代理，所以走回调：这个回调类就是：org.apache.dubbo.rpc.proxy.InvokerInvocationHandler, 所以看它的@invoke()方法 
		>建立一个rpc激活类：new RpcInvocation()
			>执行一个初始化参数描述工作：@initParameterDesc()
				>获取服务仓库：@ApplicationModel.getServiceRepository() 
					>核心：加载名为"repository"的扩展实现类实例：@loader.getExtension("repository") 而这个 loader也是以扩展的方式加载的：@ExtensionLoader.getExtensionLoader(FrameworkExt.class), 而这个FrameworkExt有@SPI注解，从而会返回一个：@new ExtensionLoader<T>(type)这个type就是入参FrameworkExt,而在new创建过程中会：@ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()赋值给内部 objectFactory 属性；
						--必要阐述创建合适的扩展的过程：
							>先加载全部扩展：@getExtensionClasses()
								--比如属性type=org.apache.dubbo.common.threadpool.manager.ExecutorRepository,则：
								>加载： 则加载 "META-INF/dubbo/internal/org.apache.dubbo.common.threadpool.manager.ExecutorRepository" 这个路径的资源：即以类加载器：ClassLoader.getResources(fileName)方式加载，然后读取这个URL到 BufferedBreader里：@new BufferedReader(new InputStreamReader()),然后遍历读取每一行，然后name=前缀，而Class=后面的反射加载Class.forName()这个value代表的类名，放到：exceptions 属性里。。。可以查看@loadDirectory()方法细看。加载自然是加载 classpath下的包里的。
									>实际就加载了："default":"org.apache.dubbo.common.threadpool.manager.DefaultExecutorRepository"
								>同理加载：尝试加载"META-INF/services/org.apache.dubbo.common.threadpool.manager.ExecutorRepository" 实际并不存在；
							>后创建合适的扩展类：@createAdaptiveExtensionClass()
								>
		>					
>spring-boot中：启动过程中 服务的代理过程？从而生成完整的一个个服务？猜测是解析配置注解的时候，@InputSource 注解的consumer.xml配置的解析而产生的一个个客户端bean:
	>先是创建bd时：创建了name="dubboBootstrapApplicationListener" 的 bd: 
	>后在广播事件的时候：需要寻找所有的 applicationListener, 此时就执行了从bf里寻找并创建name="dubboBootstrapApplicationListener"的bd的实例工作：bf.getBean(..)  创建的实例 就是 DubboBootstrapApplicationListener 实例。 
		--这个广播事件：就是在 org.springframework.data.mapping.context.AbstractMappingContext 的初始化方法@afterPropertiesSet()里调用出发执行的。
		--这个实例 的创建：非常多事情：核心为：@DubboBootstrap.getInstance() 单例模式创建
			>属性初始化方面：
				>创建线程池：赋值给属性
				>创建默认扩展：@EventDispatcher.getDefaultExtension()
					>核心：指定类别后 调用通用方法 获取默认扩展类： @ExtensionLoader.getExtensionLoader(EventDispatcher.class).getDefaultExtension()
						>先是获取扩展加载器--核心：new ExtensionLoader<T>(type) 这个type=EventDispatcher  其取得后放到 EXTENSION_LOADERS 属性里。
							>核心就是固定的：@ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension()) 来赋值给 objectFactory 属性；关键显然是后面一个方法：@getAdaptiveExtension()
								>核心：创建扩展：@createAdaptiveExtension()
									>核心：获取扩展类来实例化：@getAdaptiveExtensionClass()
										>核心：已经有说：就是@getExtensionClasses() 加载 文件中配置的类， 但是执行的时候却很特别：在@loadExtensionClasses()里：因此此时 type=org.apache.dubbo.common.extension.ExtensionFactory 上面调用的入参已经说明了。
											>所以加载："META-INF/dubbo/internal/org.apache.dubbo.common.extension.ExtensionFactory" 而这个文件里有3行：spring=org.apache.dubbo.config.spring.extension.SpringExtensionFactory  adaptive=org.apache.dubbo.common.extension.factory.AdaptiveExtensionFactory  spi=org.apache.dubbo.common.extension.factory.SpiExtensionFactory
												>而具体的加载方法很独特：@loadDirectory()->loadResource()->loadClass(): 这个方法里，分类处理：
													>如果有 @Adaptive 注解，则调用@cacheAdaptiveClass(clazz) 来处理。而这个方法处理很简单：就是@cachedAdaptiveClass = clazz 赋值，显然，上面因为有这种类，所以赋值给了这个属性；
													>其他类，一般就是直接放到入参map里返回了：即剩下的两个都这样返回了。到了@loadDirectory()的入参里，返回作为@loadExtensionClasses()返回值返回了。
										>然后：可能创建 适配的扩展类：@createAdaptiveExtensionClass()； 但是条件是 cachedAdaptiveClass 属性 是Null,但是上一步已经 设置了，所以不会执行(内部有死循环问题？)，而是直接返回 cachedAdaptiveClass 这个属性。 但是有的就是没有@Adaptive 注解，比如 org.apache.dubbo.rpc.Protocol， 而 cachedDefaultName="dubbo", 从而会执行：@createAdaptiveExtensionClass()
											>直接生成class的java code: @new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate()
												>简单粗暴：就是 编写 package... import....class.., 且这个类是：Protocol$Adaptive implements org.apache.dubbo.rpc.Protocol 然后将接口Protocol的方法实现补上， 重点是实现 @export()方法 + @refer()方法。。。这样，完整的类代码生成了。
											>开始编译这个java code: 先找到合适的 compiler: @ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension() 很明显，先加载文件，发现有三个：adaptive=org.apache.dubbo.common.compiler.support.AdaptiveCompiler, jdk=org.apache.dubbo.common.compiler.support.JdkCompiler, javassit=org.apache.dubbo.common.compiler.support.JavassistCompiler
												>第一个 AdaptiveClassCodeGenerator 有 Adaptive 注解：所以缓存了这个Class到 ExtensionLoader::cachedAdaptiveClass 属性里；后面两个没有--必然没有。所以在@getAdaptiveExtension()->createAdaptiveExtension()->getAdaptiveExtensionClass()这个实现里，直接返回了。不会递归@createAdaptiveExtensionClass()
												>找到之后自然就是实例化：实例化之后@injectExtension()注入即可；
												--方法名如其含义，获取到 adaptive 的扩展 为止。
											>然后开始实质的编译：@compiler.compile(code, classLoader)
												>获取编译器的默认扩展：@ExtensionLoader.getExtensionLoader(Compiler.class).getDefaultExtension() 很显然，org.apache.dubbo.common.compiler.Compiler 这个接口上@SPI("javassist") 这个注解表名 javassist 才是默认的；因此找到 JavassistCompiler 这个类来实例化。
												>使用获取到的默认扩展-编译器：来编译：@compiler.compile(code, classLoader)
													>核心：最终通过对@org.apache.dubbo.common.compiler.support.CtClassBuilder#build()的调用 实现 转到 javassist 的 字节码拼接生成：仅仅只需要指明 类名、接口名、构造方法、方法、field等即可；；然后直接：@cls.toClass(classLoader, JavassistCompiler.class.getProtectionDomain())即可。。。。
									>上一步返回的 cacheAdaptiveClass 代表的类：	AdaptiveExtensionFactory 直接反射方式创建它的实例：@newInstance()	
										>实例创建的具体操作：
											>创建扩展工厂：@ExtensionLoader.getExtensionLoader(ExtensionFactory.class) 因为入参类是这个，所以内部 objectFactory=null 
											>遍历上述从文件获得的三个name: 对每个，获取具体扩展类实例@getExtension(String name)
												>创建先：@createExtension(name)
													>自然是 SpiExtensionFactory 类，然后反射实例化，后存储到 ExtensionLoader.EXTENSION_INSTANCES属性里；
													>注入扩展：@injectExtension() 
														>如果 objectFactory=null直接返回
														>获取这个类的所有方法，筛选 其中 setter方法 且 非 DisableInject 注解方法，然后根据方法名采取出对应的属性名，从 objectFactory里获取对应名字的工厂： objectFactory.getExtension()成功后，则反射调用这个方法设置进去这个工厂；
													>初始化扩展：@initExtension(instance)	 看有没实现 Lifecycle 接口，有则要执行初始化方法。
													>返回实例
												>存储后：将实例封装到Holder 实例里，放到 cachedInstances 属性。
												>返回这个实例。 
											>将两个工厂类实例 放到 factories 属性里：即 SpiExtensionFactory / SpringExtensionFactory 
									>注入创建的 AdaptiveExtensionFactory 实例 ：@injectExtension() 也直接返回：因为 objectFactory=null 
							>如此，完成这个type的 ExtensionLoader的 实例化。
					>后是获取默认扩展：		@getDefaultExtension() 
						>核心：先还是获取所有的扩展类：@getExtensionClasses() 但此时 type=org.apache.dubbo.event.EventDispatcher 所以 在@loadDirectory()时构造的文件路径是“META-INF/dubbo/internal/org.apache.dubbo.event.EventDispatcher”， 内部两个：direct=org.apache.dubbo.event.DirectEventDispatcher  parallel=org.apache.dubbo.event.ParallelEventDispatcher
						>然后是获取指定的扩展：@getExtension(cachedDefaultName) ，这里的 cachedDefaultName="direct"  所以结果自然是：给 EXTENSION_LOADERS 属性增加了一个扩展加载器：@new ExtensionLoader<T>(type) type=DirectEventDispatcher  而过程中实例化 DirectEventDispatcher 时候，有额外的工作：@loadEventListenerInstances() 
							>获取了 EventListener 类型扩展加载器：@ExtensionLoader.getExtensionLoader(EventListener.class) 自然的就加载了"META-INF/dubbo/internal/org.apache.dubbo.event.EventListener" 里的四个：service-mapping, config-logging, service-instance,registry-logging  对于这四个，自然是@getExtension(name) 方式获取实例
								>在对 service-mapping 的 ExtensionClass 实例化时：org.apache.dubbo.config.event.listener.ServiceNameMappingListener 有特殊操作:就是给内部属性 serviceNameMapping 赋值@getDefaultExtension()默认扩展：@getExtensionLoader(ServiceNameMapping.class).getDefaultExtension()这个，自然看会加载哪个文件，第二，看默认的选择哪个：在@SPI("default")注解里的内容，就是选择的文件里的具体的那个扩展。这里的路径就是“META-INF/dubbo/internal/org.apache.dubbo.metadata.ServiceNameMapping”
							--实例化的@loadEventListenerInstances()执行完毕后, 是@injectExtension(instance) 动作，自然有阐述；		
				>执行仓库 这个扩展的获取：@ExtensionLoader.getExtensionLoader(ExecutorRepository.class).getDefaultExtension() 同样，还是看加载路径和默认标签选择："META-INF/dubbo/internal/org.apache.dubbo.common.threadpool.manager.ExecutorRepository" 文件内容只有一个：DefaultExecutorRepository, 而父类上有注解@SPI("default") 所以选择了这个来实例化。
			>构造方法里的初始化：
				>设置配置管理器：@ApplicationModel.getConfigManager()
					>使用一般的加载器：@ExtensionLoader.getExtensionLoader(FrameworkExt.class) 这个加载器 ，来加载 @loader.getExtension("config")这个名字配置的 实现类 实例 org.apache.dubbo.config.context.ConfigManager。 这个文件里其他2个：environment=org.apache.dubbo.common.config.Environment, repository=org.apache.dubbo.rpc.model.ServiceRepository
						>而在实例化 ConfigManager 时 ： @injectExtension()阶段，发现它有属性：setModule()，从而属性 module需要设置，自然 objectFactory 里找不到；
				>设置环境：@ApplicationModel.getEnvironment()
					>类似上述：使用同一个loader, @loader.getExtension("environment") 而已，自然得到它的实例。
						>它实现了 Lifecycle 接口，所以会在@initExtension(instance)阶段执行 这个接口的 初始化方法@lifecycle.initialize() 一些工作，作用不大；
				>注册jvm回调处理：@ubboShutdownHook.getDubboShutdownHook().register()  
					>新建new DubboShutdownHook()--内部许多初始化 
					>注册：@Runtime.getRuntime().addShutdownHook()
					>分发注册回调事件：@dispatch(new DubboShutdownHookRegisteredEvent(dubboShutdownHook))
						>使用的事件分发器：@EventDispatcher.getDefaultExtension() 方式获取的：即 也是从扩展文件里获取的：@ExtensionLoader.getExtensionLoader(EventDispatcher.class).getDefaultExtension()
						>执行分发：@eventDispatcher.dispatch(event) 具体监听器略。
					>增加DubboShutdownHook回调：@ShutdownHookCallbacks.INSTANCE.addCallback()
						>实例的创建，首先还是补充callback:@ExtensionLoader.getExtensionLoader(ShutdownHookCallback.class) 从文件里补充。
						>调用时间：还是在注册回调事件的 DubboShutdownHook 实例的 被 线程池执行过程。
	>第二个重要节点：<dubbo:application name="dubbo-comment" ...>这样对应的 bean的 getBean()的过程中：在初始化阶段@initializeBean()-->@applyBeanPostProcessorsBeforeInitialization() 时候执行：在 InitDestroyAnnotationBeanPostProcessor 处理器 处理时：直接寻找并调用初始化方法：@invokeInitMethods(Object target, String beanName)-->发现初始化方法为“addIntoConfigManager”确实这个方法上有@PostConstruct 注解，这个方法的具体实现：
		>往配置管理器里增加一个配置：@ApplicationModel.getConfigManager().addConfig(this) ， 这个this=ApplicationConfig 
	>第三个节点：@refresh()中后面的获取接口的实例：如 getBean("com.ihuaben.dubbo.api.iservice.comment.ICommentService") ，因为从bd中看是没有构造方法的，所以走了最后的尝试：@org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#instantiateBean()
		>即根据设置的实例化策略来进行实例化：这个策略属性： org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiationStrategy=CglibSubclassingInstantiationStrategy, 即@getInstantiationStrategy().instantiate(mbd, beanName, parent) 策略 的实例化方法：是一个模板方法，即走了父类的实现：@org.springframework.beans.factory.support.SimpleInstantiationStrategy#instantiate()方法：
			>找构造方法：优先从 bd.resolvedConstructorOrFactoryMethod 这个属性里取， 发现 Constructor 是 org.apache.dubbo.config.spring.ServiceBean 的构造方法：
			>使用找到的构造方法进行实例化了：@BeanUtils.instantiateClass(constructorToUse) 具体实现，非常干脆，直接反射实例化@ctor.newInstance()，毕竟 ServiceBean也是一个类；实例化过程：
				>因为继承了 ServiceConfig 类，所以它的一些构造方法需要执行：
					>创建调度线程池：@Executors.newSingleThreadScheduledExecutor()
					>加载协议实例：@ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension() 发现也是从文件里获取，且获取合适的那个：这个文件里有19个实现！！而这个具体实现 是 javassist 动态编译的 结果。Protocol$Adaptive
					>加载代理工厂实例：@ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension() 尽管文件里有3个：stub=, jdk=, javassist=; 但因为这三个都没有 @Adaptive 注解， 所以导致不会使用，而还是走了 动态编译， 因为有@SPI("javassist")所以构建 ProxyFactory$javassist 的动态编译类：
			>这样构造完成的新建的ServiceBean实例：就是 "com.ihuaben.dubbo.api.iservice.comment.ICommentService"	名字bean的 实例。
	>第3.2个节点@refresh()里获取bean实体：@getBean() 时候：已经有了解析 provider.xml时建立的 关于 <dubbo:application> 这样配置的 beanName="dubbo-comment"， 它的bd指明的类型是“org.apache.dubbo.config.ApplicationConfig()” 所以创建这个类型的实体；后执行初始化方法：@PostConstruct 注解 的 @addIntoConfigManager()方法：	
		>把自己当做配置增加去而已：@ApplicationModel.getConfigManager().addConfig(this)， 核心到了：放到 configsCache 属性里，而key=application, valu=map: 所以， 再次put:key="dubbo-comment", value=ApplicationConfig它自己 。
	>第3.n个节点@refresh()的类似这种@getBean()而导致的初始化中增加自己到配置 configsCache ， 还有：
		> <dubbo:protocol> : bean类型：ProtocolConfig , 存到 configsCache里，key=protocol
		><dubbo:provider> beanName="org.apache.dubbo.config.ProviderConfig#0" org.apache.dubbo.config.ProviderConfig , key=provider , 且provider可能多个：有一个默认的，在valu=map的key=“ProviderConfig#default”
		><dubbo:service > ServiceBean , key=servie,  value=map, 这个map的key="com.ihuaben.dubbo.api.iservice.comment.ICommentService", 值就是 ServiceBean 本身。
		><dubbo:registry > beanName="org.apache.dubbo.config.RegistryConfig#0" 类型 RegistryConfig, key=registry 	值就是这个 RegistryConfig 实例。 
		><dubbo:config-center> beanName="org.apache.dubbo.config.spring.ConfigCenterBean#0" ConfigCenterBean key=config-center 值就是 这个 ConfigCenterBean
		><dubbo:metadata-report> beanName="org.apache.dubbo.config.MetadataReportConfig#0"  MetadataReportConfigBean key=metadata-report 其中 ,map里的key="MetadataReportConfig#default"
	>第四个节点：服务的初始化：从@refresh()->@finishRefresh()最后一步开始：
		>发布上下文刷新事件：@publishEvent(new ContextRefreshedEvent(this))
			>使用广播器广播事件：内部就是获取所有的listener来执行：@listener.onApplicationEvent(event) 其中有个 DubboBootstrapApplicationListener 监听器：看它实现：
				>核心代码：执行启动：@dubboBootstrap.start()  这个实例上述已经有 其 单例创建过程。 start()分四大过程： 初始化、输出服务、注册服务实例、引用服务；
					>初始化：@initialize()
						>初始化框架爱扩展：@ApplicationModel.iniFrameworkExts()()
							>获取支持的"框架"扩展实例集合：@ExtensionLoader.getExtensionLoader(FrameworkExt.class).getSupportedExtensionInstances()只看扩展实例：
								>先获取所有的文件中的：依然是三个扩展：config=, environment=,repository= 都都会获取扩展实例， 所以会实例化三个：而在仓库的创建时：
									>org.apache.dubbo.rpc.model.ServiceRepository() 构建时：
										>构建服务侦查的扩展的获取：@ExtensionLoader.getExtensionLoader(BuiltinServiceDetector.class).getSupportedExtensionInstances() 有两个：echo=org.apache.dubbo.rpc.service.EchoServiceDetector， generic=org.apache.dubbo.rpc.service.GenericServiceDetector 这个 EchoServiceDetector 和 GenericServiceDetector 的创建是直接 的；
										>注册这两个侦听的服务：服务就是写死的，去除Detector 后缀的名称类：GenericService +  EchoService， 分别封装到 ServiceDescriptor 实例，然后放到 ServiceRepository:map: services: 属性里； 
							>对三个扩展进行初始化：@ext.initialize()	环境初始化有内容：@org.apache.dubbo.common.config.Environment#initialize()
								>获取默认配置中心：@ApplicationModel.getConfigManager().getDefaultConfigCenter()
									>即从 configsCache 属性里获取"config-center" 的那个配置map: 而这个 configsCache 此时已经有内容，内容和 xml 配置是类似的；所以认为是解析xml时设置进来的；但是xml里没有详细，所以还有一部分配置从 properties 里来的，发现如 application-dubboo-test.properties里文件发现有：dubbo.registry.address=xxx, dubbo.config-center.address=xxx, dubbo.metadata-report.address=xxx 类似这样的配置；所以也是配置信息来源。则这里的解析时间？？
										>这个map只有： “ConfigCenterBean#default”->ConfigCenterBean, 核心数据 address,timeout 就是 properties 里配置的；其他默认，所以他是默认配置--从keyname也可看出来；取出来的目的：是尝试获取 externalConfiguration 等设置到 Environment 这个类的UI应属性上来；实际是空。
						>启动配置中心：@startConfigCenter()
							>遍历每个配置中心：实际只有一个；执行刷新：@configCenter.refresh()
								>调用环境获取配置：@env.getConfiguration(getPrefix(), getId())-- 前缀=dubbo.config-center, id=null。
									>构造复合配置：new CompositeConfiguration()
									>添加系统配置到复合配置：先将一个配置增加 Environment 的 systemConfigs属性里："dubbo.config-center." -- new SystemConfiguration("dubbo.config-center") 后再返回这个系统配置。
									>类似这种方法再次添加4个配置：new EnvironmentConfiguration()/new InmemoryConfiguration()2个/new PropertiesConfiguration()
								>获取源数据后封装到新的配置类适配器：@new ConfigConfigurationAdapter(this) ， 这个this=ConfigCenterConfig 即入口实例。封装了metadata---实际内容就是 configCenter  的所有属性及其值；
								>最后又将这个配置类适配器加到了复合类的 configList 里： 即和前面的 5个配置一起：且指定下标位置=4
								>遍历配置中心的每个方法，对于属性方法，进行必要的重新转换值？(因为set方法上可能有注解@Parameter)
							>配置中心的参数值验证：长度和字符串值@ConfigValidationUtils.validateConfigCenterConfig(configCenter)
							>从配置中心构造动态配置：@prepareEnvironment()  后将动态配置添加到 复合配置里。
								>获取动态配置：@getDynamicConfiguration() 是从 zk上获取。
									>工厂模式：使用动态配置工厂来获取动态配置：@getDynamicConfigurationFactory() 工厂类的加载--也是 扩展加载器方式：@getExtensionLoader(DynamicConfigurationFactory.class)..getOrDefaultExtension("zookeeper"), 文件里确实有zookeeper=org.apache.dubbo.configcenter.support.zookeeper.ZookeeperDynamicConfigurationFactory, 且有 nop/file/apollo/nacos/consul/etcd 配置。
									>实际获取：@factory.getDynamicConfiguration(connectionURL)就使用了 zookeeper 的实现：实际为模板模式：抽象类中 获取了 "39.105.71.50:2181" 可以, 调用自雷获取动态配置，联合key,形成key-value, 放到自己的属性 dynamicConfigurations里。 子类实现：@new ZookeeperDynamicConfiguration(url, zookeeperTransporter) 里面做了很多工作
										>确定根路径：/dubbo/config
										>缓存监听器+线程池构建：
										>开始连接形成zk客户端：@zookeeperTransporter.connect(url) 参数 是入参 ZookeeperTransporter， 在工厂构建时就设置了。且这个 ZookeeperTransporter 也是 接口，也是在文件中获取实例的---CuratorZookeeperTransporter 是唯一实现， 实现方法是创建客户端：@new CuratorZookeeperClient()。
											>连接的实现走 AbstractZookeeperTransporter 模板模式：
												>先调子类获取客户端：@createZookeeperClient() 即返回上述的 @new CuratorZookeeperClient() 实例： 
													>建造器模式建造框架工厂：@CuratorFrameworkFactory.builder()
													>然后建造客户端：@builder.build()
														>直接@new CuratorFrameworkImpl(this) 也有内容：此时已经进入 curator-framework 框架包。
															>构造zk工厂：@makeZookeeperFactory()---为匿名内部类：@new ZookeeperFactory()
															>以极多的入参构造客户端设置到client:@new CuratorZookeeperClient(...)
															>其他很多属性的设置：包括 authInfos 。@buildAuths(builder)
													>增加连接状态监听器：@new CuratorConnectionStateListener(url)
													>启动客户端：client.start() 也进入到 curator-framework 框架包  
														>如状态管理器的启动：@connectionStateManager.start()
														>再添加连接状态监听器：@new ConnectionStateListener()
														>实际客户端的启动：@client.start() : CuratorZookeeperClient  连接状态的启动@state.start()--->提供者启动：@ensembleProvider.start()。。。
															>zk重置：@reset() -->@zooKeeper.getZooKeeper()@最后在@org.apache.curator.utils.DefaultZookeeperFactory#newZooKeeper()里直接进行@new Zookeeper(connectString, sessionTimeout, watcher, canBeReadOnly)来创建了zk实例。转到了 zookeeper-3.4.9.jar 客户端包。
														>添加一个定时执行任务：@backgroundOperationsLoop()	
													>阻塞到连接成功：@client.blockUntilConnected(timeout, TimeUnit.MILLISECONDS)
												>添加到内部客户端map:@writeToClientMap(addressList, zookeeperClient)	
										>使用客户端添加数据监听器：@zkClient.addDataListener(rootPath, cacheListener, executor)	
										---这样就返回了动态配置。
								>从动态配置里获取属性：@dynamicConfiguration.getProperties()   其中 ，key="dubbo.properties", group="dubbo"	；实际没有获取到结果。
								>获取应用名：@getApplication().getName() 结果 comment
									>实际从configManager里获取， "application" 名的值， 获取之后先刷新@application.refresh() 刷新就是前面的@org.apache.dubbo.config.AbstractConfig#refresh()
										>然后添加了额外的属性：@appendEnvironmentProperties() 包括这个扩展：@ExtensionLoader.getExtensionLoader(InfraAdapter.class).getSupportedExtensionInstances()
								>获取app配置内容：@dynamicConfiguration.getProperties() 内部走了动态配置查：zkClient.getContent("/dubbo/config/comment/dubbo.properties")  key="dubbo.properties", group="comment"
								>使用从动态配置获取的内容来更新到Enviroment:@environment.updateExternalConfigurationMap(parseProperties(configContent)) 	environment.updateAppExternalConfigurationMap(parseProperties(appConfigContent))
							>开始全部刷新：@configManager.refreshAll()  ApplicationConfig/MonitorConfig/ModuleConfig/ProtocolConfig/RegistryConfig/ProviderConfig/ConsumerConfig
						>有必要则用仓库来代表配置中心:@useRegistryAsConfigCenterIfNecessary()实际则不会。
						>启动元数据报告：@startMetadataReport()
							>实际就是从application里 获取 元数据类型，从configManager获取 到元数据配置： MetadataReportConfig
							>配置验证后：构造元数据报告路径："metadata://39.105.71.50:2181?metadata=zookeeper", 协议=metadata
							>开始初始化：@MetadataReportInstance.init(metadataReportConfig.toUrl())
								>获取元数据报告工厂：@ExtensionLoader.getExtensionLoader(MetadataReportFactory.class).getAdaptiveExtension()
								>重组路径进行报告：zookeeper://39.105.71.50:2181 @metadataReportFactory.getMetadataReport(metadataReportURL)
									>此时路径已经处理为: "zookeeper://39.105.71.50:2181/org.apache.dubbo.metadata.report.MetadataReport" 
									>根据路径创建报告：@createMetadataReport(url)
										>直接@new ZookeeperMetadataReport(url, zookeeperTransporter)
											>使用父类接口：创建缓存文件："C:\Users\lonel/.dubbo/dubbo-metadata-null-39.105.71.50-2181.cache"
												>调用定时任务保存：@this.doHandleMetadataCollection(allMetadataReports)  内部实现：会远端和本地：
													>保存到zk上：ZookeeperMetadataReport@zkClient.create(getNodePath(metadataIdentifier), v, false) 入口@org.apache.dubbo.metadata.report.support.AbstractMetadataReport#storeProviderMetadataTask()
													>保存到本地：@new SaveProperties(version).run()--> @org.apache.dubbo.metadata.report.support.AbstractMetadataReport#doSaveProperties()
											>本类连接：@zkClient = zookeeperTransporter.connect(url) 
										--返回的报告路径：“zookeeper://39.105.71.50:2181/org.apache.dubbo.metadata.report.MetadataReport”		
						>加载远端配置：@loadRemoteConfigs()  实际仓库id和协议id都是null, 所以无操作；
						>检查全局配置：@checkGlobalConfigs()
							>验证配置：如验证 monitor :@ConfigValidationUtils.validateMonitorConfig(getMonitor()) 实际上增加了一个默认：@new MonitorConfig()， 设置到了configManager里：@configManager.setMonitor(monitorConfig)
								>同理：验证了 new MetricsConfig()/new ModuleConfig()/new SslConfig()
						>初始化元数据服务：@initMetadataService() 实际为获取扩展：@getExtension(getMetadataType())， 即获取 @getExtensionLoader(WritableMetadataService.class).getOrDefaultExtension("local")这个扩展实例。org.apache.dubbo.metadata.store.InMemoryWritableMetadataService
						>初始化元数据服务输出者：@initMetadataServiceExporter() 仅仅为DubboBootstrap属性设置：@new ConfigurableMetadataServiceExporter(metadataService)
						>初始化事件监听器：@initEventListener()	 添加了一个listener: 就是它自己：@eventDispatcher.addEventListener(listener) DubboBootstrap 					
					>输出服务：@exportServices()
						>从 configsCache 获取所有的 service: 逐个遍历：每个 是 ServiceBean , 这个实现了 ServiceConfig接口， 先设置 DubboBootstrap 实例 this 进去。后开始同步输出：@sc.export()
							>检查并更新子配置：@checkAndUpdateSubConfigs()
								>如果provider是空 还会设置：@new ProviderConfig() 操作 类似上诉。
								>同理 protocol也是：
								>ref属性 就是 服务实例-已经被springCglib增强了：而 interfaceClass 就是服务的接口类：@Class.forName()反射方式加载它；
								>接口方法检查：@checkInterfaceAndMethods(interfaceClass, getMethods())
								>ref检查：主要是看 服务实例是否是接口的实现：@checkRef()  内部自然是：@interfaceClass.isInstance(ref) 核心判断；
								>验证服务配置：@ConfigValidationUtils.validateServiceConfig(this) 检查值的字符串规范；仓库、协议、等等；
									>参数添加：@appendParameters()  
										>获取激活的参数组件：@ExtensionLoader.getExtensionLoader(AppendParametersComponent.class).getActivateExtension(appendParametersUrl, (String[]) null)
							>设置常规属性后：开始真正的输出：@doExport() 
								>输出url:@doExportUrls()
									>加载服务仓库@ApplicationModel.getServiceRepository()：loader.getExtension("repository") 
									>注册服务：@repository.registerService(getInterfaceClass()); 实际很快：而注册获取的接口就是：interfaceClass , 值就是： new ServiceDescriptor(interfaceClazz)  然后放到 ServiceRepository:services 属性里。
									>注册提供者：@repository.registerProvider() 同理： serviceKey="com.ihuaben.dubbo.api.iservice.comment.IIdCommentService",封装到 @new ProviderModel() 而放到 providers:map: ServiceRepository 里。
									>获取注册url:@得到"registry://39.105.71.50:2181/org.apache.dubbo.registry.RegistryService?application=comment&client=curator&dubbo=2.0.2&pid=19368&qos.enable=false&registry=zookeeper&release=2.7.5&timeout=15000&timestamp=1602493271451" @ConfigValidationUtils.loadRegistries(this, true)
									>遍历协议protocols: 
										>构建路径而注册服务：@repository.registerService(pathKey, interfaceClass) pathkey="com.ihuaben.dubbo.api.iservice.comment.IIdCommentService" 内部实现类似上述。
										>为协议输出：@doExportUrlsFor1Protocol(protocolConfig, registryURLs)
											>构造一个配置map: 包括本地主机号："bind.ip"
											>构造超长url: "dubbo://10.1.1.103:20884/com.ihuaben.dubbo.api.iservice.comment.IIdCommentService?accepts=500&anyhost=true&application=comment&bind.ip=10.1.1.103&bind.port=20884&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=com.ihuaben.dubbo.api.iservice.comment.IIdCommentService&methods=increaseTopicLikeId,increaseTopicId&pid=19368&qos.enable=false&release=2.7.5&retries=0&side=provider&threadpool=fixed&threads=500&timeout=30000&timestamp=1602493514428"
											>进行本地输出：@exportLocal(url)
											>获取invoker并包装：@PROXY_FACTORY.getInvoker() 包装到@DelegateProviderMetaDataInvoker()
											>实际协议的export:@protocol.export(wrapperInvoker)	
												>核心：一直转到@org.apache.dubbo.qos.protocol.QosProtocolWrapper#export()
													>尝试启动服务器：@startQosServer(invoker.getUrl())
													>再次转发：@protocol.export(invoker)RegistryProtocol
														>注册路径：zookeeper://39.105.71.50:2181/org.apache.dubbo.registry.RegistryService?application=comment&client=curator&dubbo=2.0.2&export=dubbo%3A%2F%2F10.1.1.103%3A20884%2Fcom.ihuaben.dubbo.api.iservice.comment.IIdCommentService%3Faccepts%3D500%26anyhost%3Dtrue%26application%3Dcomment%26bind.ip%3D10.1.1.103%26bind.port%3D20884%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dcom.ihuaben.dubbo.api.iservice.comment.IIdCommentService%26methods%3DincreaseTopicLikeId%2CincreaseTopicId%26pid%3D19368%26qos.enable%3Dfalse%26release%3D2.7.5%26retries%3D0%26side%3Dprovider%26threadpool%3Dfixed%26threads%3D500%26timeout%3D30000%26timestamp%3D1602493514428&pid=19368&qos.enable=false&release=2.7.5&timeout=15000&timestamp=1602493271451
														>提供者路径：dubbo://10.1.1.103:20884/com.ihuaben.dubbo.api.iservice.comment.IIdCommentService?accepts=500&anyhost=true&application=comment&bind.ip=10.1.1.103&bind.port=20884&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=com.ihuaben.dubbo.api.iservice.comment.IIdCommentService&methods=increaseTopicLikeId,increaseTopicId&pid=19368&qos.enable=false&release=2.7.5&retries=0&side=provider&threadpool=fixed&threads=500&timeout=30000&timestamp=1602493514428
														>本地输出：@doLocalExport(originInvoker, providerUrl) 添加到 RegistryProtocol.bounds:map属性而已。返回：new ExporterChangeableWrapper()
														>注册：@register(registryUrl, registeredProviderUrl) 
															>核心：获取仓库来注册：@registryFactory.getRegistry(registryUrl)..register(registeredProviderUrl)
																>既添加到本地，也实质的保存到zk:@zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, true))  源于：@org.apache.dubbo.registry.zookeeper.ZookeeperRegistry#doRegister()
														>订阅：@registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener)		
															>核心：内部实际的调用了zk:@zkClient.create(path, false) path="/dubbo/com.ihuaben.dubbo.api.iservice.comment.IIdCommentService/configurators" 
															>同时增加了子节点变动监听器：@zkClient.addChildListener(path, zkListener)
														>返回输出者：@new DestroyableExporter<>(exporter)
											>获取可写元数据服务扩展实例：@WritableMetadataService.getExtension(): key=local, value=org.apache.dubbo.metadata.store.InMemoryWritableMetadataService 来源 @getExtensionLoader(WritableMetadataService.class).getOrDefaultExtension(name)		
											>发布服务定义：@metadataService.publishServiceDefinition(url)
												>获取服务定义：@ServiceDefinitionBuilder.build(interfaceClass)
													>先@new ServiceDefinition()后注入属性：都和调用有关的：相当于进行一次抽取。：源码class位置、接口、方法。 
													>gson 序列化后保存到 InMemoryWritableMetadataService.serviceDefinitions 属性；
								>分发服务配置输出事件：@dispatch(new ServiceConfigExportedEvent(this))
									>使用扩展来分发：@EventDispatcher.getDefaultExtension().dispatch(event)
										>除了有条件时间监听器：都@listener.onEvent(event) 如 org.apache.dubbo.config.event.listener.LoggingEventListener 多个， DubboBootstrap 一个。ServiceNameMappingListener 
					>注册服务实例：@registerServiceInstance() 不会进入。
					>引用服务：@referServices() 几乎没有内容。
					
					
>spring-boot中， application-dubboo-test.properties 文件的解析时间？解析位置？最后存放位置？