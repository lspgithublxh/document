---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：

>旧观点：
  >web对外提供一个整体的服务，而这个整体的服务可以拆分为多个不相关的独立的服务：独立的服务如果其中某个想增加修改内部功能，那么web整体服务都要重新编译打包部署，影响线上环境。
  >解法/处理思想：不相关的独立服务 独立出去专门部署，而主服务只需要rpc调用这些服务即可。
  >实现中的问题：性能的保证--用socket通信。
  >带来的新问题：子服务不可用，主服务需要超时判断、服务降级。服务方需要有对调用方的限速。甚至，有服务的切换：如果A1服务不可用了，那么尝试调用A2服务--但是如果数据协议不同，开发量就还要增加。

>举动-痛点：为什么要微服务？一层一层往上就是为什么要解耦？为什么要隔离？为什么功能要扩展？为什么要多层架构？为什么要频繁迭代和频繁部署？为什么要业务拓展而几乎不需要开发太多新代码？为什么要监控？为什么要高并发、高可用、要可靠可用？为什么要更高效的维护服务？。另一个角度直接来看，就是客观本身存在的功能分解以及之间的独立和依赖---天然特征决定---微服务只是顺势而为的处理措施(就像为什么器官为什么不长在一起而是分开通过血液神经内环境来互相联系)。缺点就两个：分布式带来的：响应时间慢了一些，问题排查更复杂了。
            >采用微服务架构的时机，就是服务的子服务越来越多越来越庞大，并发量越来越高，业务扩展越来越快，子服务并行迭代的并行度越来越高，导致如果继续采用子服务一同开发、测试、发版，一方面影响进度，第二因为某个局部子服务出问题而导致系统整体都服务不可用的风险发生的概率更大，新业务的公共，独立维护独立部署带来的好处
		    >采用时的三个特征：这个项目用4个开发都已经开发维护不过来了，子服务的数量超过30个(业务区分越来越大，越来越不希望一个服务造成的异常影响到系统虚拟机而导致其他所有服务都异常)，各个子服务的并发量越来越高但请求都压在这个项目上(高并发仅仅通过粗暴的加机器，部署越多每次迭代版本升级部署机器就越多、暂停的服务就越多；服务经常震动)	(另一方面，对数据库的连接也越来越吃紧开始排队，对其他资源如内存、cpu、磁盘也是)(所有货物不放到一条船上，当然首先货物要足够多)。日志混合也是一个问题。
			>采用后本身带来的新问题和配套方案：如何访问其他服务(服务在哪里，怎么调用)？访问不到怎么办?本身不可用其他服务怎么办？访问量太大怎么办？服务调用关系调用情况错综复杂如何治理和监控？
			 >API网关：应用前端访问的问题
			 >注册中心：服务的管理。Eureka,Consul,etcd,zk
			 >网关层的反向代理：网关层的反向代理。
			 >事务补偿机制：分布式事务的一致性问题。
			>实施微服务需要具备的条件：计算和存储资源是否能快速分配？能否快速部署？基本的监控：CPU,IO,mem? 标准化的RPC
  >解法/处理思想：解耦、公共通用调用、
   >微服务架构：组件
    >服务注册：服务管理接口--注册注销，和服务查询接口--可用服务的实例。
	>服务发现：从注册中心发现服务的地址，客户端发现或者服务端发现。
	>负载均衡：调用方连接到合适的服务节点：服务端负载均衡和客户端负载均衡。
	>服务网关：服务调用唯一入口。用户鉴权、动态路由、灰度发布、A/B测试、负载限流。一个或者多个。
	>配置中心：开发、测试、生产环境中配置信息的获取。
	>API管理：接口文档管理。
	>集成框架：各组件的统一操作界面。
	>分布式事务：TCC.高可用消息服务、最大努力通知。
	>调用链：记录完成一个业务逻辑时的串行/并行的微服务调用关系。
	>支撑平台：系统的部署、运维、监控。持续集成、蓝绿发布、健康检查、性能健康。如Docker
	
   >Spring的目的：自身创建容器，将各种对外接口都统一化并提供相应的接口包, 将工具类型的开发包/框架统一化并以接口包形式提供。无论连接数据库的接口，还是任务管理器接口。
   >Spring I/O platform: maven引入spring jar时工作。
   >Spring boot: 开发和运行阶段的自动化(代劳)：自动引入项目常见依赖并根据配置文件自动装配相应对象，可以自动装配项目下的各个类对象，一起封装到Spring容器，可以自动依赖内嵌web容器jar,而将项目的Spring容器部署上去，开发者仅仅需要main函数执行启动代码即可，即可开启整个装配并部署到web容器并启动web容器。
    >是一套快速配置脚手架。  单个微服务开发。
   >Spring Framework: 基础spring框架, 如AOP和DI的实现和容器的实现。
   >Spring Cloud: 微服务工具包。提供配置管理、服务发现、断路器、智能路由、微代理、控制总线。
    >是一套全局的服务治理工具包/框架。
   >Spring XD: 一种运行时环境。采集大数据并处理。
   >Spring Data: 一种访问各种数据库的通用接口包：
   >Spring Batch: 批处理框架。批量任务执行管理器。任务调度、日志记录。
   >Spring Security: 声明式的安全访问控制解决方案。
   >Spring Integration: 编程框架，面向企业应用集成。
   >Spring shell: 开发命令。
   >Spring Roo: 使用命令行操作来生成自动化项目。
   >Spring loaded:实现java程序和web应用的热部署开源工具。
  >微服务架构设计模式：
   >聚合器微服务设计模式：聚合其他微服务，而自己前端一个负载均衡。
   >代理微服务设计模式：几乎没有业务逻辑，仅仅根据需求代理给多个不同的其他微服务。
   >链式微服务设计模式：本身有cache和数据库，同时进行同步调用其他微服务，其他微服务也同步调用其他微服务。
   >数据共享微服务设计模式：有的几个微服务共享缓存。
   >异步消息传递微服务设计模式：通过消息异步调用。通过消息传递条件，通过消息传递结果。
   (没有缓存和数据库的微服务要么就简单的是聚合服务，要么就缩减为计算工具)
   
  >微服务设计原则：
   >领域驱动设计DDD: 从代码结构中可以理解业务的设计。约定优于配置。从业务设计到代码实现的一致性。
    >领域模型：实体、值对象、集合、服务。
	>将领域元素转换为服务：值元素表示参数和返回值，集合和实体转换成独立的微服务。将领域服务匹配到独立的微服务。每个微服务处理一个完整的业务功能。
     >失血模型：基于数据库的领域设计方式。
	 >贫血模型：不依赖于持久化的领域逻辑，是否包含在领域对象中。
	 >充血模型：划分业务逻辑：大部分业务放到领域对象中。Service应该是很薄的一层。
   >分层架构：典型为MVC.
    >经典的领域模型架构：Domain层, Service层, Repositories层  领域层(Entity核心实体和值对象Value Object)、领域对象服务(Domain Service)，领域对象存储仓库(Repositories)
	 >也是包层次：project/src/domain|services|repositories|interface|gateways 调用不跨层，下层实现上层。
	>通信协议：GRPC移动设备上使用。服务之间Rest api接口通信。
	 >查询时同步，增删改时如果用异步业务上没问题其实可以建议使用。查询接口需要幂等。POST新增资源，PUT更新完整资源，PATCH部分更新，DELETE删除(返回状态：首次200,第二次204状态和数据一致)
   >单一职责：
   >服务拆分：康威定律。按照三个维度划分：   
    >AKF扩展立方体：拆分应用、拆分数据库。
   >前后端分离：代码分离、部署分离。通过HTTP请求互相通信。
   >版本控制：API的所有版本和新服务的启动。
    >在API中反映版本：放到URI/v2/remote 或者报头中。
   >围绕业务构建：构建的微服务本身描述不依赖某种实现技术栈。
   >并发流量控制：缓存、降级、限流。
   >CAP: 根本在于分布式级联调用需要经过网络中多个点，每个点都要成功，这段时间期间如果定义为不可用的则可以保证任何调用成功都满足数据一致性，而如果这段时间定义为可用的则会出现数据没有一致性变化而获得到了不一致的结果。这就是在分区下：一致性和可用性的矛盾。
    >如果在分布式数据系统中：则是备份的数据、冗余的数据的一致性变化需要一个时期，而这个时期内同一个数据的版本在不同的冗余节点副本上是不一致的。其实分布式数据系统中才是真正的数据在各个副本节点上的一致性和可用性的矛盾。此外，一部分节点发生故障也能影响系统的读写可用性。可用性高：则要副本节点多；一致性高，则希望副本节点越少越好(一致化的代价随节点增加而增加)。
	 >在容忍分区故障条件下：副本节点数多则可用性高(节点崩溃/网络故障依然有幸存的节点可用可达)，副本节点数少则一致性高(一致性实现的时间代价和通信代价低)。
     >CA模型：模型的具体过程 实现一致性和可用性，但不容忍哪怕一个网络故障--直接认为是节点崩溃故障，严格的全体一致协议--只要有一个网络故障直接整体都不可写---当作出了最严重的网络问题--出了一个网络故障就罢工---不再工作。 
	 >CP模型：模型的具体过程 实现一致性和分区容忍性：容忍部分网络故障---只要大多数节点可用并且在数据一致性同步过程中成功，这些节点设置为可用，其他节点设置为不可用(直到启动成功并且数据同步一致了) 即可看上去：获取的数据始终是一致的(因为不一致的不让看)。所以可用性会忽高忽低--因为不保证它总是很高。即限制了可用性。
	 >AP模型：模型的具体过程 实现可用性和分区容忍性：容忍部分网络故障---只要大多数节点可用，在同步中只列出冲突数据，不进行一致性化的补偿操作，这些节点设置为可用，而其他节点无论因为一致性同步失败/网络超时/网络不可访问还是自身崩溃--都设置为继续可用(重启之后也不用等到数据一致性同步完成后才恢复可用---因为有自动同步的程序在跑，不一致的时间很短)，也允许看到不一致的数据。
	 ----只要节点不是崩溃，都可用：为AP模型。节点必须数据一致后才能可用：为CP模型。节点只要有一个不可访问无论网络超时/不可访问/崩溃，整个系统都拒绝再提供写服务即都不可用--即根本没有了可用性，为CA模型。
	 ----分区是容忍/允许，一致性的补偿是专门的同步程序，可用性的补偿是更多的节点。
   >EDA事件驱动：通过消息队列耦合。
    >服务：以原子粒度更新数据库和发布对应的事件。   
	>保证数据更新和事件发布原子化的方法：
	 >开发者用本地事务来实现：一边更新事件列表，一边发布事件。
	 >监听和挖掘数据库的事务日志：从事务日志中发现事件来发布。
	 >存储使得应用状态改变的事件序列到事件仓库：可以根据这个事件序列重构实体的状态。
   >CQRS: 一种读写分离思想。保证添加、更新、删除时所基于的数据时最新的。而查询的数据不必是。
   >基础设施自动化：DNS/CDN. 负载均衡器。日志、监控、报警服务。运行容器。
   >数据一致性：三种模式保证最终一致性。
    >可靠事件模式：更新业务实体时，微服务向消息代理发送事件。
	>业务补偿模式：保证一致性的工作服务，用额外的协调服务来依次调用。
	>TCC模式：主服务和从服务。从服务提供try-confirm-cancel接口。
   >设计模式：链式、聚合器式、共享数据、异步消息控制
    >应用--网关-->微服务
	>应用--网关-->消息队列
   >DevOps: 开发测试运维。通过自动化的流程来使得开发、测试、部署更加快捷、频繁和可靠。
    >自动化闭环流程的实现框架：规划-代码-构建-测试-发布-部署-运行-监控
   >无状态服务：将状态数据存到分布式缓存，而把服务完全做为无状态的计算服务。
  >Spring boot: 开发时完成依赖引入(spring-boot-starter-xxx说明)，运行时完成装配(@SpringBootApplication说明)。
   >1.自动装配第三方jar里的bean并放到容器里，通过自己提供的统一的专门接口对开发者提供，开发者直接引用即可如@Autowired引用；使得集成第三方非常方便。 想象一个容器：内壁上是多个统一的某类功能的接口bean，外壁上是第三方框架jar,容器中是其他bean和项目中实例化后的bean
   >2.默认内置很多常见第三方jar--开发更方便--不用再maven各种依赖编写， 直接默认集成常用的第三方框架--只需要开发者提供第三方需要的数据即可。约定大于配置。
   >3.非功能特性：指标、监控、安全、健康检查。
   >4.开发工具：基础类加载器和重启类加载器。基础类加载器加载第三方jar里的bean, 开发中的类则通过重启类加载器加载，从而类路径上的文件变更，则自动重新加载这些类，实现快速的热部署。
  >Spring boot starter: 用来引入和装配和运行第三方的依赖：从redis/jpa/jdbc/amqp/actuator到定制自己的都可以。
  >AOP: Spring通过预编译和运行期动态代理实现。
   >将软件系统视作/分为横切关注点和核心关注点：AOP则就是分离横切关注点和核心关注点，分别到专门的类中，而还能保持原来的紧密执行顺序的方法。代码分开，但实际执行顺序和逻辑不变。
	>事务、日志、权限认证、数据源的切换：都是横切关注点。
   >切面：切入核心业务的横切逻辑类
   >连接点：核心业务类中横切逻辑类切入的方法。通知匹配到的方法。
   >通知：切面中的横切逻辑方法。@Before("切入点方法()") @AfterReturning("execution(...)")方法返回通知。@AfterThrowing(value="execution(...)", throwing="exception")方法抛出异常退出时执行。@After @Around
   >切入点：满足某个表达式的所有连接点。在切面中，作为一个单独的方法@PointCut("execution(...)")。这个表达式是切入点表达式，每个通知得关联一个切入点。 *表示所有匹配，...表示路径任意/多个参数,+表示类和子类，。可以约束：可见性、返回类型、方法名和参数指定和异常
   >引入：给被代理的类引入/实现更多的接口
   >目标对象：连接点所在的类。它的bean实际上是另外一个代理它的类的bean。
   >AOP代理：JDK动态代理和CGLIB代理。//修改类方法的字节码--调用切面通知(环绕通知可以通过修改通知方法-增加一个标记入参-而在连接点前后执行入参不同即可)，和重新定义一个继承类/实现类---方法的实现指向一个统一的拦截器MethodIntercept(可以在类加载时、运行时(开始执行main函数之后很快))。
   >织入：将切面和连接点连接起来。Spring在运行期完成。AspectJ在编译器完成。类加载时也可以。
   ---切面引入：@Aspect需要加入依赖：spring-boot-starter-aop
   ---log4j2日志引入：spring-boot-starter-log4j2 同时去掉exclude stater-web里的logging依赖。
  >持久化：将数据保存到存储设备中。JDBC和磁盘IO就是持久化机制。 spring-boot-stater-jpa
   >java持久层API:JPA, 持久层规范，持久层统一标准接口。Spring DATA JPA是Spring为JPA提供的一套实现，底层使用Mybatis/hibernate的JPA实现。
    >使用mybatis的starter:mybatis-spring-boot-starter。配置相应的数据源。然后@MapperScan("mapper xml包路径即可")
	>多数据源：先禁用DataSourceAutoConfiguration， 即在@SpringBootApplication(exclude={Data....class})。。。在配置文件里写配置，然后通过@Configuration一个类来引入两个db source bean: @Bean("db1")@ConfigurationProperties("spring.datasource.db1")----读取配置文件中的指定值。同时可以@MapperScan对应的配置类里加入对应的db DataSource
   >JOOQ: 访问关系型数据库的工具包，有ORM的简单安全，有SQL的灵活。实际上太麻烦。
  >事务管理：spring framework为事务管理提供了一致的抽象。声明式事务，同时和数据访问抽象完美继承。spring-boot-stater-jdbc自动装配出DataSourceTransactionManager实例。如果是spring-boot-stater-jpa则是JpaTransactionManager, 然后@EnableTransactionManagement 后在接口上@Transactional目的就是失败时能够回滚！！
   >事务传播属性：要求有事务(3个)、无事务(3个)、允许嵌套事务(1个)三大类。要求无事务的：有事务时抛出异常或者挂起当前事务或者就在这个事务中执行。要求有事务：已有事务则利用已有事务没有创建事务或者抛出异常，或者已有事务则挂起而自己新建一个事务没有事务则创建一个新事务。允许嵌套事务：当前有事务则仍然创建一个事务独立提交或者回滚，没有事务依然创建一个事务。
   >事务管理器：JTATransactionManager, TransactionManager, DataSourceTransactionManager 第1个和第3个会实现平台事务管理器，中间的不会。
   >并发引起的事务问题：读未提交(脏读)、读已提交、幻读
  >整合Redis: redis数据类型多、api丰富，可持久化。支持事务、HA高可用、主从库等数据库特性。即是缓存系统也是数据库。org.springframework.cache.CacheManager  依赖spring-boot-starter-data-redis 配置之后 StringRedisTemplate可以bean化
   >缓存指标：命中率、Miss率  ，来于从缓存中和从慢速设备中读取的次数的比较。
   >数据淘汰策略：分从已设置过期的数据中进行淘汰(最近最少访问lru, 将要过期的ttl, 随机的random)、从全部数据集中进行淘汰(最近最少访问lru, 随机的random)、不淘汰--禁止驱逐。采取看键-访问频率 的分布情况：指数下降分布lru, 平均分布random
   >spring 缓存规则：@Cacheable查缓存且存缓存 @CachePut只存  @CacheEvict清除缓存条目，
   >spring boot自动化配置合适的缓存管理器：@EnableCaching  会依次检测缓存提供者：EhCache, redis, guava
  >整合消息队列：用在：应用解耦、异步消息、流量削峰。高性能、高可用、可伸缩和最终一致性架构。标准消息队列应用层协议AMQP, 依赖spring-boot-starter-amqp
   >RabbitMQ:  @RabbitListener(queue="队列名")监听队列消息。
  >整合mongodb:更是只需要一条mongodb部署地址的配置，就可以引用MongoTemplate实例了：spring-boot-starter-data-mongodb
  >web开发的整合：spring-boot-starter-web提供内内置的tomcat和springmvc依赖，spring-boot-starter-thymeleaf引入模板引擎-默认thymeleaf 视图跳转路径可以 配置。
   >增加拦截器链：新建实现xxx接口的拦截器，继承xxx的类里重写addInterceptors(...)方法，将拦截器加入。
  >接口文档管理：swagger构建API文档并可以在浏览器里查看和测试接口。
   >引入依赖：springfox-swagger2  配置@EnableSwagger2 配置类---实例化Docket.. 在需要api文档化的controller类上进行@Api("文档注释")    在类里面的需要文档的方法上@ApiOperation("xxx") @ApiImplicitParams({}) @ApiResponse({})   。。。就可以在浏览器中/swagger-ui.html里查看
  >优化的调度：定时任务集中管理，而不是分布在工程各个地方。Spring boot 自带Scheduled可以看作是一个轻量级的Quartz ...
   >@Scheduled
  >健康：
   >配置查看和功能统计：spring-boot-starter-actuator, 则会将相关的类bean化放到容器里，同时还会因为是web项目而部署到web容器---即增加url-controller映射到web容器中。
    >访问url:/autoconfig自动配置的使用情况。/dump打印线程栈。/health查看应用健康指标。/trace查看基本追踪信息。
  >整合Dubbo:Dubbo是典型的四方参与的微服务架构：consumer-registry-provider-monitor .客户端负载均衡和服务调用降级。 consumer-provider都是spring-boot项目，registry是一个zk集群。monitor也是zk。consumer的服务接口@Refrence ,而provider的服务接口@Service, 启动zk,启动provider,启动consumer。因为也是接口依赖，所以需要服务端的接口jar。
  >Docker: 负责高效的进行应用的分发、管理和部署。
   >使用场景：一方面服务器资源闲置，另一方面缺没有服务器可用。一台机器上直接部署多个服务，会端口冲突/cpu\mem互相争抢占用互相影响，(因为没有资源分割)。扩容/缩容 效率低：机器下线到应用部署、测试，周期较长。  
		       多环境代码不一致：如果没有指定一定要让通过测试的版本来上线---而通过测试只能让专门的人来处理。
   >使用特征：单个容器运行单个应用：即面向服务的架构。
   >架构：C/S架构。守护进程和客户端进程。守护进程完成实际的工作。实际的工作包括：1.文件系统隔离(每个容器都有自己的root文件系统)。完成这些工作所依赖的条件/工具：linux内核特性Namespaces命名空间和Control groups 控制组。