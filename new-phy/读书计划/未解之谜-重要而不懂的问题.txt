1.spi机制：
	>jdbc-Driver; nio-Selector-Charset
	>需要找到**Provider,然后调用其方法来实例化一个对象。
		>如Selector.open()内部就是通过获取默认的 DefaultSelectorProvider 对象来提供 WindowsSelectorImpl实现类
	>为什么要spi: 因为为了某些api必须来自同一个实例提供者，这个提供者提供一套对象，这些对象不能使用其他提供者提供的对象--以免发生问题。
		>如jdbc,则提供者提供Driver以下的一套连接类对象。
2.可扩展性：
	>系统是否可以更强大？更多功能和更强替换？可选择可配置可替换可接入(很多接口很多各种标准接口)？
	-基本的：接口设计、插件结构、代理设计、SPI设计、模板设计、策略模式、大量的地方不定死不具体不限制死-可选择可配置可自定义---哪些地方可以再抽象一下更统一的形式结构、一切出现了之智能...的地方都抽象一般化统一化特征化变量化；
	--：参数配置、数据交换、新模块加载、已有模块在线替换、接口不定死无限制
	--：特征编程 而不是 具体编程。
3.countcell,linkedHashmap:
	>
4.锁为什么是公平的和排它的？
	>公平和非公平锁：只是新来的线程，是否给它一个碰巧的机会---碰巧获取到锁(那个时候刚好state=0),没有取到 则仍然入队等待。
	>非公平锁: 线程切换次数更少;
5.天命：也许我还要再继续修炼2-3年，才有机会去非常看重实力的厂--民营其实都看重。
	>心态平和：一生只是在修炼而已。公平的修炼就是最好的。不必责怪。不懈修炼而已。
	>自信：不是来自公司的标签；只来自强大的实力，无所不能洞察万物的实力。
		>不以物喜不以己悲
6.功能层面实现解耦，体系结构上就具备了良好的伸缩性。
7.threadlocals内存泄漏的原因：
	>当线程没有执行完毕，则里面的threadLocals里的key-value，如果出现了key被回收，则key指向变为空，当再次访问时会清空k-v，但是不再访问时则不会清空，从而产生了内存泄漏。所以手动remove可能更好。
8.Condition为什么可以释放当前的锁？
	>
9.	
