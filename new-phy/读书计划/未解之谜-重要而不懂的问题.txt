1.spi机制：
	>jdbc-Driver; nio-Selector-Charset
	>需要找到**Provider,然后调用其方法来实例化一个对象。
		>如Selector.open()内部就是通过获取默认的 DefaultSelectorProvider 对象来提供 WindowsSelectorImpl实现类
	>为什么要spi: 因为为了某些api必须来自同一个实例提供者，这个提供者提供一套对象，这些对象不能使用其他提供者提供的对象--以免发生问题。
		>如jdbc,则提供者提供Driver以下的一套连接类对象。
2.可扩展性：
	>系统是否可以更强大？更多功能和更强替换？可选择可配置可替换可接入(很多接口很多各种标准接口)？
	-基本的：接口设计、插件结构、代理设计、SPI设计、模板设计、策略模式、大量的地方不定死不具体不限制死-可选择可配置可自定义---哪些地方可以再抽象一下更统一的形式结构、一切出现了之智能...的地方都抽象一般化统一化特征化变量化；
	--：参数配置、数据交换、新模块加载、已有模块在线替换、接口不定死无限制
	--：特征编程 而不是 具体编程。
3.countcell,linkedHashmap: weakHashmap
	>linkedHashmap: 继承了HashMap
		>accessOrder: true则表明为访问顺序，即get()调用也要将那个Node移动到tail后面(同时modCount++也改变了)；否则是插入顺序，只有put()才会移动到tail
		>get(Object key)覆盖：即增加了上述的移动逻辑。
		>newNode(int hash, K key, V value, Node<K,V> next)覆盖： 即在put()的实现里新增节点时，就是调用这个方法：父类的实现 new Node<>(hash, key, value, next)，而本类的实现：new LinkedHashMap.Entry<K,V>(hash, key, value, e);并且需要将节点添加到双向链表末尾linkNodeLast(p)----即设置p的before和tail的after两个属性；同理对TreeNode也是，因为TreeNode的父类是LinkedHashMap.Entry, 所以天然有after/before属性，所以newNode()方法里只需要linkNodeLast(p)即可；
		>afterNodeRemoval(Node<K,V> e)抽象方法实现：即将e的前后连接起来。
		>replacementNode(Node<K,V> p, Node<K,V> next)覆盖：即树节点转换为单向链表节点时需要覆盖：
			>说明：树转单向链表很容易：因为TreeNode.next属性，所以是可以顺序访问的--排好序的；遍历一遍则可以得出两个链表，分别可以转换为一个LinkedHashMap.Entry类型的节点或者重新转换为一棵树；
4.锁为什么是公平的和排它的？
	>公平和非公平锁：只是新来的线程，是否给它一个碰巧的机会---碰巧获取到锁(那个时候刚好state=0),没有取到 则仍然入队等待。
	>非公平锁: 线程切换次数更少;
4.2单例模式要加volatile的原因：
	>在synchronized中赋值语句执行时，初始化和返回地址可能发生指令重排，所以第二个线程第一次if时候发现不是null了，而访问它的属性，却发现还没有初始化！！！
5.天命：也许我还要再继续修炼2-3年，才有机会去非常看重实力的厂--民营其实都看重。
	>心态平和：一生只是在修炼而已。公平的修炼就是最好的。不必责怪。不懈修炼而已。
	>自信：不是来自公司的标签；只来自强大的实力，无所不能洞察万物的实力。
		>不以物喜不以己悲
6.功能层面实现解耦，体系结构上就具备了良好的伸缩性。
7.threadlocals内存泄漏的原因：
	>当线程没有执行完毕，则里面的threadLocals里的key-value，如果出现了key被回收，则key指向变为空，当再次访问时会清空k-v，但是不再访问时则不会清空，从而产生了内存泄漏。所以手动remove可能更好。
8.Condition为什么可以释放当前的锁？
	>
9.架构，定义类的标准：建立新类的标准
	>数据结构-算法来分类：只要某个处理方法，需要依赖新的数据结构，而这个数据结构要定义为属性，但定义在这个类上，不符合这个类的含义，所以定义新的类。
	>按照客观现实的面向对象思想划分：
	>按照设计模式划分：装饰器，代理类；
9.2架构：定义方法的标准：建立新方法的标准
	>按层次思路、逻辑，一层的所有的动作，每个动作的下一层的动作；一个方法体内的动作如果有下一层，那么需要定义到新的方法里--即这个动作需要是方法--进行下一层的实现；
	>同层实现：每个方法体里的每个动作都应该是直接实现这个方法的流程中的动作--哪怕是抽象动作；直接流程中的一环；而不是一环里的具体实现也放到这个方法里。
9.3类和方法划分的重新审视：从编写方法实现上看：
	>方法：要当作是一个需求。
		>方法内：则这个需求的实现，可以自己直接用最底层的api实现，也可以指派指定给特定的/第三方的/未定义的专门类来处理，则在这里我只需要调用它的几个api来处理即可。
10.线程模型：Reactor模型：netty, redis  高性能网络编程
	>替代多线程处理方式：Reactor模型
		>例如服务端接收请求的问题：可以先将请求事件封装到消息里放到消息队列，然后另一端从队列拉取消息来处理；
			>也可以：观察者模式；
			>多线程方式：一个线程处理一个请求
		>NIO原理：调用epoll()在内核事件表注册socket事件；调用epoll_wait()等待(回调)事件发生的通知。
		>Reactor: 响应iO事件，多路分离socket,
			>负责：
				>服务器绑定端口并启动 + 注册到Selector + acttach一个Acceptor实例
				>Selector事件到达，调用key的attach对象--(第一次是Acceptor/后面则是后面attach的Acceptor)来run()
		>Acceptor: 调用ServerSocketChannel来accept(),将结果SocketChannel 交给新建一个Handler来处理
		>Handler: 注册读(到下一个Selector) + attach 自己 + 唤醒键key
			>则从Reactor可知，下次事件发生时，将调用Handler的run()方法：处理内容，就是看状态(开始是读)--分别读或者写：
				>读：从socket里读取、新建Propossor提交到线程池处理、attach一个Sender实例、selector唤醒、
				>写：直接就发送回去了。
		--注意到：Handler注册读  和  Reactor注册accept 不必一定要在同一个Selector上，而且不同的Handler也不必在同一个Selector上，操作系统就会通知相应的socket事件给对应不同的Selector， 那么就可以做到高并发。
11.设计模式组织：模式，就是统一的写法。扩展性最好的写法。
	>最好的认识：面向对象和对象拆解 ，用基本对象/核心对象 通过设计模式来得出 复合对象--功能更强更多的对象。
	>按照spring的使用：
		>创建型模式：实例的创建：单例模式(唯一)、工厂模式(批量)(数据源采用)、建造者模式(属性精确)、原型模式(clone()方法)(副本)
		>结构型模式：以结构形式对外提供服务。(接口的实例：就是实例本身？实例的装饰器？实例的代理？) (类似对A类的一个流水线处理最后生成的类)
			>桥接模式: A、B的桥接器。A类引用一个属性接口，来辅助提供对外接口服务。(桥接 是通过网桥将两个局域网络连接起来的模式，网桥本身通过以太帧格式的转换实现转发) 
			>外观模式: A、B、C的外观器。子系统的一组接口的一致操作接口。A,B，C有相类似的a,b两个方法，A,B，C属于同一个系统里的子系统；外部操作时，要同时操作三者，则建立一个外观器，直接操作这个外观器的方法即可。
			>装饰器模式: A类的装饰器 引用A的实例 来辅助 实现A的接口/A的接口的子接口---在值上增强。主要目的在增强A的功能。IO中的装饰器。
			>适配器模式: A类的适配器 引用A的实例 来辅助 实现指定的接口---在方法名上转换。主要目的在实现A类和新接口的适配--用A类的实现来完成接口指定的功能。 
			>组合模式:  A、B、C的组合器 引用多个客观含义上属于其成分的类的接口--而不是这个类本身，来辅助实现自己实现的同一个接口的方法。
			>享元模式: A的享元器。就是A的多个不同实例的集合，需要A实例时，从这个集合里取。复用。池技术：常量池、线程池、连接池。
			>静态代理动态代理模式: A的动态代理器 ，即实现 A的接口的类，其方法实现统一转向Handler的统一方法invoke(), 进行统一处理。实现对A实现的通知、统计(目标不在增强功能)。
		>行为型模式：11种流程的实现，11种请求的处理过程。角色的划分，和协作，各自负责一块。多模块协作(高效,高扩展)，各模块的不同角色和职责，角色和职责所在的流程，所实现的流程，达到的流程功能目标。
			>模板模式: 模板式流程。流程固定，且流程中只有部分动作是变化的；用模板类来描述这个流程。11种流程。按模板执行。
				>流程特征：整体步骤明确固定，中间某个/某些步骤不能确定。则划分为固定部分实现类 和 变动类实现类。
				>模块群及各自职责：抽象类---固定流程； 继承类---实现流程中需要具体实现的方法。
			>策略模式：选择流程。实现这种流程：某个动作的实现者可以有多种，注入每种都能兼容。选择执行。
				>流程特征： 某种动作有多种对象都可以提供，对象实现类型允许多种。
				>模块群及各自职责：上下文类---引用动作接口， 多个类--各自都实现了动作接口，类实例注入上下文，上下文的对外接口调用动作接口的方法。
			>观察者模式：消息订阅广播流程。
				>概念实体/模块和行为：消息、订阅者、广播通知。
				>调用流转图：消息增加订阅者-->消息广播订阅者
			>命令模式: 点早餐流程，客观现实流程，请求的处理过程。对象组织结构，对象关系结构 。 各个类的 继承-引用-实现 结构。数据流转图。方法依次触发图。按解耦执行。一次请求，一个执行者执行。
				>流程特征： 调用者发送命令，执行者执行命令。调用者-->命令-->命令实现类-->命令执行者
				>类 继承-引用-实现 结构：调用者-->接口-->实现类-->引用其他实现类
			>责任链模式： 串联执行流程。链式调用执行。请求 需要被链式调用执行。请求按链式调用执行。
				>组件构成的结构和一次请求时组件的协作完成过程：多个处理器一次都会执行，唤醒下一个invoke；额外需要一个唤醒下一个的控制类Chain类。处理器依赖Chain类；
				>类 结构图/ 调用流转图： 调用者-->Chain类-->Filter处理器类-->Chain类
			>状态模式： 状态动作转移图/流程。
				>类 调用流转图： 上下文-->状态抽象类-->状态实现类:每种状态有实现类--实现该状态下可以进行操作的上下文的动作对应的方法(抽象状态类的方法)，且方法入参是上下文，方法内容最后就是设置 在对上下文进行这样的操作之后 上下文应该变为的状态。
			>中介者模式：中介者负责注册同事和转发消息。每个都能收，每个都能发。
				>目标的常规实现流程：网状，每个节点都需要知道其他节点
				>目标的本模式实现流程：中心中介/代理节点。电话本  对手机用户 就是一个中介。
			>迭代器模式：通过迭代器访问集合内部的元素，无需知道集合内部元素的索引。
				>
			>访问者模式: 
				>调用流转图： 资源集合体-->引用资源集合(可增可减资源)-->访问方法(访问者为入参)：遍历资源，每个资源都接受访问者。
			>备忘录模式：发起者-->备忘录<--管理者
				>调用流转图： 发起者将自己的状态产生为备忘录对象-->管理者保存备忘录(可以保存多个备忘录)-->发起者根据输入的备忘录覆盖自己的状态值。
			>解释器模式:
				>编译器、正则表达式
12.数据库研发地图：
	>树形从左到右的描述：即从数据库启动开始所有的过程：抽象分层的递进描述。
	>自顶向下设计：
13.mysql的页，换页时间？操作系统 虚拟内存换页 一页的时间？
14.dev ops分别有哪些：
	>dev:源码库、持续集成、应用发布 
	>ops:服务跟踪、健康检查、日志处理
15.spring-boot原理和源码：
16.迭代器发生ConcurrentModificationException错误：迭代器访问的时候，不能进行删除操作；都是因为越界报出的。modCount只会增加。
	>迭代器内部自己的属性expectedModCount 和 注入的 list 自己的 modCount 不相等： next()中首先就判断这个，从而抛出并发修改异常。
	>迭代器next()：当 游标 cursor属性的值大于了elementData数组的长度，即因为ArrayList并发修改时删除了元素；也会抛出并发修改异常。
17.遍历删除：只可能发生越界错误：IndexOutofBounds
18.分布式系统：
	>扩展性： 系统的容量和峰值的扩展。
	>CAP:
		>raft协议：
	>设计策略：
		>超时重试：避免网络临时的抖动
		>心跳机制：确定状态Ok, 但是如果没有收到心跳，可能节点挂了/网络异常
			>Lease机制：server端签发的lease(有时限的一个证书), 客户端带上lease访问server且未超时则成功获取数据；
				>用途：client缓存server数据在client本地，来减少对server的请求，同时server承诺在lease失效之前所有到达的更新都不执行--阻塞到超时时候---才阻塞执行；或者有更新则先通知所有的client失效，如果全部失效成功，那么则开始更新本地，然后客户端重新开始请求lease+数据；如果部分失败，则退化为等待超时后更新这种；
				>用途2：选主避免脑裂，master带上lease，即当主的时间。当集群中没有master时，此时都是slave, 集群外是一个Manager, slave向Manager注册自己，Manager选择一个作为master,则slave查询或者主动推送给slave，那么slave下次就和新的master处理数据。这个过程中(即便脑裂，产生了两个master,则先走第一个master的slave成功之后，下次则会新的master,失败之后则直接切换到新的master;因此没有请求不会被处理)
		>副本策略：
		>中心化、无中心化：中心化---mysql单主多从，无中心化--zk
		>数据分发/分布策略：
			>hash取模：直接对key计算得出对应到哪个节点。
				>问题：存储倾斜、扩容困难、宕机部分数据异常、大量数据迁移 
				>策略：2倍扩容。则影响最小；---相当于均分出来；
			>一致性hash: 自适应的方式解决扩容和容灾的问题。一方面计算hash函数值，一方面节点分布在环上。
				>问题：压力集中问题
				>策略： 虚节点-实节点。
			>
19.Ip文件读取排序，使用awk? 大文件，小内存；
	>方案1：分块排序，写到文件；对两个文件块，合并，分别指针，先移动1000位，读取两个1000个元素到内存，合并后有1000-2000个结果，直接刷入另一个文件，然后再次看哪个快已经读取完了而加载对应块的剩下的内容1000个到内存里，开始合并，同理，这样一直读取合并下去。
20.代码扩展性问题：设计模式和设计原则；	