---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	>程序的执行要想象为人在执行；多线程则是交接执行权给其他人执行；
	>抽象编程与具体填充：假设编程和实现假设。面向对象中一个对象属性就假设已经填充好了，一个接口的实例就假设已经在容器中有了。代码编码层面和虚拟机执行层面，都规定/定义/设计为 将 接口和实例分开，系统启动时/甚至具体接口调用时才去容器里找接口的实例(启动时 一方面建立实例容器，另一方面 对接口寻找匹配的实例和链接到实例---进行连接和关联)。资源填充 和 接口调用(抽象调用)，资源--接口的映射对。领域抽象，资源抽象，功能抽象。
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点

--混乱的答案，宁可不说；只回答真正掌握的；。没有逻辑，因为没有进行抽象；没有找到所在的流程环节、模型中的位置
--系统、中间件的介绍，不是一来就是组成结构；这层次已经太细了太具体了太里面了，必须要从最简洁最抽象最上层开始；最表面最近开始；务实，不僵硬，不突然，要自然，不要忽视和没注意没意识和跳过很多步；而是从问题出发、从困难出发、从疑惑出发
	>从问题出发：先明确问题；先明确表达出问题、疑惑点、黑箱、痛点、矛盾点、难点，表述的范围可以很大(完全不知道是什么怎么办)后面逐渐具体问；无论多少问题，先明确下来；尤其要全部且完整的描述下来；
		>问题的提出：先明确背景，自然衍生、过渡、转折、演化，逻辑关系上，什么时候什么事情什么人，事情什么阶段遇到的什么问题、阻碍、阻挠、缺陷、瓶颈、不够简洁、不够简便、不够方便、不够优雅、离目标远、离理想情况远、离期望/极限效果远；不够抽象的地方；把它们充分描述完整叙述结构式组织起来。
			>问题抽象：归结为一类问题；去除具体和细节而明确问题模型；
		>问题产生原因：过程；条件；	
		>问题导致的恶果：阻碍、损失；
		>理想的方案特征/效果/必做必不做的动作&事情/应当改变的环节: 
			>这种特征/必做必不做的前提、必要条件、必然要求、必然说明、必然指示、必然可以确定的更多的事情/结论：
				>一系列结论、约束得到之后(结合条件/问题/情况本身)逐渐可以清晰看到/归结出该具体问题符合的/满足的通用/一般的/一类的问题模型/函数模型/服务模型/IO模型/请求响应模型的轮廓：若干个具体模型
					>方案的装饰/补充: 补充可靠性/稳定性/高性能(从而高可用/高并发)：因为暂时只是一个裸机、容易受到伤害、有功能但没有抵抗力(仅为打火机的火而不是熊熊大火)
							>方案的用法规则：在请求缓存前使用
		>能将具体方案进行分类的维度/情况/模型/环节/流程/抽象表述 的确定：然后使用 抽象-具体 的方法来得到新方案；					
		>普通的方案：已有的方案；方案的抽象，方案的取值选择评价；方案的表象缺陷、劣势；。。模型、数据结构和算法、协议约定分担 维度 上考虑；
	>任何事情/事物都有顺序/逻辑：且几乎都是几种常见逻辑中的一种: 时间先后、空间远近、因果环扣、程度递增
--大总结：含义包括：重新 深刻理解：
--通用的建模架构能力+Flink深度强化学习的推荐系统。。。。而不是做简单的业务逻辑开发；用深度强化学习来做应用/解决实际问题(用户的识别问题和抉择问题)；用抽象建模架构出逻辑完整的方案(工具方案/服务方案)；
--一体两翼的发展模型：底座：增强操作系统、网络、搜索、推荐能力； 两翼：普通项目：则架构建模；特殊项目：则深度强化学习；。。四大基础+两大实践(应用/使用)。。基础：是为了解决自己的问题；实践：为了解决别人的问题(用户的问题/大众)；
--一次彻底弄懂，而不是 反复低温加热。看架构书和源码书，不看使用书。
--对话中胜利：一个是提问，二个是不断的输出-高能输出。
--牢固的观念: 系统都是被使用的。
--任何一个系统、产品、服务、方案、东西、事情，它要解决的核心问题是什么？理想的形态效果影响应该是什么？市面上对应的哪些产品达到了或者没达到或者很难达到？没达到是为什么是否有我们的机会？是否还有我们可以满足的缺口。找市场缺口。
--从缝纫机原理看方案所属的分类和方案内的环节。抽象出分类和环节。
--把自己当做cpu,调/使用各个服务/接口/类/系统。
--全新学习掌握方法：先定问题体系，先提问，定逻辑路径，后开始找答案--推导和思考和查阅资料。
	>旧方法：还是盲目阅读，还是从头到尾的阅读一遍的阅读。
--所有系统和方案的理解/研究/制定的出发点：都是 出发顶点/问题顶点/概念顶点，找到了顶点才能出发，出发要从顶点出发，才顺畅，没有后顾之忧
--计算机解决问题的方法：采集，记录，计算，展示，通知，跟踪 数据/信息。

--商业经营才能：(全新的解决问题的方法：提出问题)
--什么问题 是可以用互联网来解决的？ 只要满足什么特征，该问题就可以用互联网方式来解决? 该问题的本质是什么问题(如是信息传递问题？)该问题抽象一般化后是什么问题(资管、记录、通知、计算、采集识别调动、代理/中介/数据中心/信息中心/信息模拟线下过程中心、信息传递)(信息展示/发布/搜索/推荐 平台；信息池；信息可以是映射描述的现实事物的信息(如商品/价值物/人)，也可以是纯虚拟信息(游戏/知识/新闻/视频))
	>能用信息发布展示/活动追踪-信息记录/通知/协作/推荐/搜索 解决的问题：信息可以是 编辑的信息/映射的信息/等价现实的信息/等价现实任何事任何物的信息。内涵BAT的老业务(电商/聊天/游戏/信息流/搜索)。
	>能用数据驱动决策抉择与调度分配/识别与推理/观测采集与调动机电-生物 而解决的问题：如alphazero/图像识别/语音识别/视频识别/云计算/智慧城市/自动驾驶。内涵BAT新业务(云计算/视频语音识别-下棋打游戏智慧体/智能音箱/自动驾驶)
--码农之家和脚本之家、异步社区。从 面向对象-->模式-->架构：由小到大。
--给其他非软件行业的工程师/人员开发软件。三高三可(高可用高并发高性能,可扩展性可维护性可重用性)。
--最佳：一边看书，一边独立思考；(比起纯看书和纯思考都好)。因为 看书 要有沉淀，积累，独立思考 结论，总结。而不是流经书，翻翻而已，左进右出。
--说话：社交场合，最重要的是：要有自己的认知、决策和行动；对形势的判断和分析和预测。而不是被别人牵着走，或者置身事外。
--什么是最重要的? 就是你想做出一个什么东西...  这是最有价值的事情,是最重要的目标(比起学位和金钱和看多少书都重要);
	>不讲在公司的项目: 只讲自己 业余时间 做出的东西; ..  和 理解的东西... 总结起来 就是 四个方面: 架构 + 源码 + 算法 + 产品/作品
--不必指责和愤怒: 只需 战胜 和提防.
--莫忘理性决策：详细的明确和计算，一点也不能含糊。看看这次搬家时机的决策失误和搬家房间选择的失误，造成了金钱和时间上的巨大浪费。又比如以前自大没有投资股市---导致损失很大！！	拒绝感情用事和感动别人。
	>不能武断：不能一厢情愿。不能只见树木不见森林。
--兴趣不仅决定能力，而且决定性格，比经历更加影响性格；总结和思考 是兴趣带来的根本也是兴趣导致的根本活动；而性格能很大程度上影响命运---作。韩信(仰仗自己聪明而希望别人只记得我的好不记得我的坏)、赵括(自己负责精彩，麻烦交给别人--希望别人帮自己解决；只知顶层逻辑不知道低层逻辑)、李广(总觉得别人对自己不好，发现不了自己的错，不按程序办事，爱自己来，当别人按程序来--总觉得别人是让自己受气，受不了别人的指责)	
--在大部分有钱人和机构都将资本+利润存入股市的时候：说明股市是会升值的，股市就是最大的公司。多余的所有钱+利润 只有在股市才能分享。
	>既要有信心，也要有担忧： 激情和忧虑 都有 ，才是 理性的人。而不是两者都没有的麻木不仁、冷血和装。
	>做人不要尖酸刻薄，说话要说别人的好，坏处知道 但是不要说出来。有的人不喜欢被戴高帽，或者认为是反讽，这只是 好 没有说到点上而已。
	>面对别人指出的问题: 改就完了,且深刻反思和各种改进, 大量的收获和扩展.更强!!!错误的反思总结得到的东西让人更强!!!
	>已经是青年人了：要敢于争取
	>不要轻易拒绝做 看不起的事情、还早的事情、不重视的事情、觉得自己不需要的事情-觉得世俗/自大的事情(世俗也要同流合污)：买车摇号、社保缴纳、公积金缴纳、找女朋友、找好的房子、考在职硕、炒股-投资。多少件事情--明明顺手就可以做，却没有做，一直拖，导致损失惨重！！
		>每一件瞧不起、不重视、还早的事情：相反，都要早点做！！
		>机会错过 难再有：往往影响是决定性的。没把握机会 就是 决策性失误！
		>其他事情：私活-阿里云-本地开发-换电脑。
	>想到就要做，错过不再有：这是最重要的名言！！只有这样才能发挥才智 并且 赢得 胜利！！！	最重要的就是时机、机会，把握机会把握时机。
		>时机、战机 转瞬即逝：稍纵即逝。错过就是一辈子，错过就是奉上身家性命。犹豫不决和瞧不上和不需要而暂时不做延后做 都是错失良机、贻误军机。
			>说小了是 酸，说理性点 就是 后悔遗憾 承受损失。
	>商业机会：大部分来自于持续观察大家的生活---什么社会事件政策会怎样的影响人们的生活/会让人们的生活发生哪些改变； 人们生活中遇到了什么瓶颈/矛盾/困难/问题/需求/不足/遗憾/不开心的事情。		
--理论观点/方法缺乏层次系统的组织，还是在等别人分配赚钱任务。概念、观点 还是片段、不连续的。
	>基本认知方式：提炼、总结、简化、抽象、封装 。
	>问题为 元素 进行组织：这次不以概念为元素，来更方便于实际使用、进行设计训练---工作也当作是设计训练。
	>填充所有的逻辑漏洞：
	>分层问题森林\分层问题 群: 一个n层的问题,其顶元素 只是 另一个n层问题的一个元素. 因此 k个 分层问题  构成 了 一个最顶层分层问题 , 整体 是一个 问题森林.
	>每一种策略/设计/具体化： 都必须明确它到底是为了解决什么问题。
	>范畴不明确：就会 陷入 “还有什么” 的困惑和迷途。范畴的向下具体划分和向上抽象统一更大范围。
	>讲一个东西的内容时：可以看出是否结构化思考，是否很明确范畴，范畴化思考，不断的抽象上升又具体下降--树上遍历。因为问题，产生目标，想到思路，立刻执行。
	>输入不必多：关键是转化 为 总结、实践  有 多少。	
	>可视化：为最佳的理解方法。
--领域、问题、逻辑。(路径/方案/思路)(条件/目标/路径)	范畴。顶级思路/顶层思路。顶层领域，顶层问题。范畴与逻辑。范畴关系(同一范畴内、不同范畴内)、比较关系、规则关系、联动关系。
	>不能只以概念入手，也要从问题、思路入手。
	>谈话永远不能泛泛而谈：回答而已，别总想着怎么回答会好-显得聪明有创意有见解之类。必须要有目标，要预见和引导 话题走势走向，进而从当前条件 寻找 路径/思路。
	>开发时：反思总结 而 扭转观念，不要一来就想着实现代码，而应该想着本层逻辑、本层事务、具体交给下层实现-下层再进行拆解-完成它要做的那部分工作-塔式调用/直到具体的专门的一个个的实现//这个也是逆封装过程，类似塑造过程。
		>链式调用：默认实现Filter 放在 最后，用户提供的放在前面；从而用户提供了实现如果想提前返回则可以直接先返回不走默认。
		>插件的发现/用户回调类的注入：往往都是自动配置类bean  注入了外部的 beanFactory，而自动配置bean里就有本框架的核心类，而获取了bf,则各种规范的实现bean就都可以获取了，从而用在框架各个位置。
	>一切技术都是简便方法：更快速的方法、更省的方法、更安全的方法。更可靠、更通用的方法。
	>调用 就是 询问：询问就是调用。
--顶级关注点：任何事物 寻找到它 最有价值的一面  对我有用有好处，如果有 则 认识到通和使用到精。没有看到组织结构，必然混乱和觉得复杂、含糊不清、仍然不懂、没有消化--分解/拆解出有营养可以被利用来构造系统的基本元素出来。
	>于社会：形势和机会：最理性的分析 -->最准确的预测 --> 最周全的方案 --> 最简便的验证。很多人不相信完美的十全十美的方案的确存在，也就不愿思考和制作和逼近，而是找了一个草率的方案，执行后失败而亏损。
		>人际关系：在不能够失败的事情上取得胜利 才叫胆子大胆略胆识,其他不能产生直接或间接作用用处的事情 失败了也无所谓--就当作给对方一个面子--做个厚道人-而不是尖酸刻薄没人接近没朋友-朋友就是大量小事上免费的互相帮助。办事：对方道德好-好心人，道德一般讲利益-合情合理，道德差坑蒙拐骗一把-就损失了。
	>于痛点：目标和思路：最理想的样子 -->最真实的现状 --> 最顶层的思路 --> 最简便的做法。
	>于业务：领域和关系：帮助用户解决的问题是什么(用户只需要有什么条件、只需要做什么)(概括) --> 最理想的方案的最顶级的思路是什么 --> 要展示什么信息 、后端计算要什么信息 --> 领域的属性结构、领域在某活动中关联的领域(如人和商品在购买活动中关联了起来)--活动的间接结果/结果描述：就是将领域和领域绑定在一起--划归到一个活动领域中而成为一个活动领域的两个属性--毕竟一个活动本身也有领域/流程/规则--单独的领域是独立无关的,只有在活动中才和无关的领域关联起来;反过来发现两个无关领域关联起来了则一定在某个活动中(如人与商品-在购物活动中；商品和地点-在物流活动中)；领域是基本不变的有限的，真正大量的不断产生的同样需要记录的是活动数据--一是活动参与者多二是活动步骤多三是活动多，此外，展示独立的领域信息 其实价值有限且固定难以增长，而不断新增的活动让领域参与者有新的参与感、活动服务了参与者、给参与者带来了新的服务价值、解决了新的问题 满足了新的需要--这些都是在活动中完成的；所以创造活动并记录活动 数据 才产生巨大价值。纯线上活动、活动的线上部分、线下活动的线上模拟活动 ，寻找、熟悉和创造 新的 活动，是对一门业务能力的三个阶段。
						 --->明确 所有的领域(属性结构)、活动和活动领域(其属性为若干个独立领域+活动本身信息) --> 各个活动领域 将各个独立领域 直接或者间接 关联了起来，则可以建立起一张关联起所有独立领域的大表；也可以判断是否存在和 存在则找出 两个独立领域的关联路径；帮助数据分析和数据挖掘。---> 使用 活动领域 记录和重新梳理 活动的过程。记录了一个活动过程，就是记录了一个服务过程(展示-交易-消费-评论)  。例子：一个购物：独立领域的关联过程： 人和商品(下单) --> 人和商家(支付) --> 商品和地点 (物流) --> 人和地点(固定信息) --> 商品和人(物流终点) --> 商品和评论(消费者对服务打分)
		>澄清 业务流程是什么-->每一步需要展示什么信息、要上传什么信息
			>信息分成哪几部分: 本质上可以归结为 哪几个独立的 领域(有明显的自己的边界)，这些领域的属性结构树是怎样的。
		>有 存储、筛选、推荐和展示海量数据 功能的 系统：供看、消费、互动。
			>展示的目的：>展示的东西：展示有价值的信息、宣传(广告)、引导用户购买、引导用户提供信息(生产/上传)、引导用户交互信息。
	>于系统：：拆解和组建。本身的规律和统一的路径。范畴式创新(补集/包集/子集)
		>认识：
			>系统一定不是一个单调的整体，而一定是组装起来的。单调的整体 只是一个部件，甚至不能用来构造复杂稳定的系统，没有这个扩展性、接口。
			>系统的运转：组装起来之后，启动系统，开始触发系统，向多米诺骨牌一样 传递下去。
			>系统的逻辑结构：假设...则有。如果...并且...,那么对...情况,则有...。假设有几个关键的暴露关联关系并好度量的事实、实验、条件、不变性，则可以得出xx间接的关联关系。具体关系直接向上抽象，将具体量消除,推导更一般的关系；。或者将关系和关系封装在一起，得出更间接更远距离的关联关系，得出对一个事物的完备的关系集合。或者规律本身特征的概括，来得出其他未知规律也一定满足的特征-抽象特征(如不变性)
			>系统的元素：系统的元素可以用来构成其他系统。因为它职责单一，可以替换别人也能被别人替换，可以共享(越单一越能被共享,越复合越不能被共享)(共享就是拿来使用,避免重复劳动)，可以互换，各个系统的若干个位置上都需要，从而用这些元素构成的若干个这类系统，一个系统报废了拆分出的组件元素 还可以放在其他系统中，从而元素利用 最节省 最经济、利用率高-浪费少。单一职责 是 有限的 ，构成一个 有限的集合。承载单一职责的元素 种类 就是 有限的，构成有限的类别的集合。从而每类元素可以批量生产，缓存起来，按需提取。
				>元素的类别：职责类别：特殊的元素--骨架型元素(支撑连接其他元素)。业务型元素(完成自己的输入输出模型)。
				>元素的接口：元素 的 可以和其他元素连接咬合起来 而传递/接收 刺激/物质/信号 从而发挥自己的作用 的部分。
				>元素的连接：一个元素的接口和另一个元素的接口咬合在了一起，形成 信号/刺激/物质 可以从一个元素传递到另一个元素的状态、复合形态、复合物形态。新的复合物有新的接口。不同于两个元素的输出输出模型 的 新的输入输出模型 产生了，这是连接起来 最大的意义和作用和目的，还具有新的状态转移图---也有使用用途。
				>元素的组建：在一个框架型/架子型/骨架型元素上(丰富的接口)(本身甚至就简单的仅仅是一个接口集合) 连接 接入 若干 功能型元素 和 骨架型元素。
					>组建的目标-条件-路径：最顶层的目标--产生一种更间接更长路径关联起输入输出的高度更高长度更长远度更远的输入输出模型的子系统/子模块(以进一步组装出更强的系统/让本系统更强)
				>元素的封装：用边界将 若干个临近的元素(无论是否连接起来) 包装起来，隔离其他 集群元素，而有自己的独有的基础资源、基本元素资源池。形成独立的环境、独立的上下文、独立的数据中心(信息中心)，统一的对外接口、复合的多模式的输入输出模型。
			>系统的状态转换：可以从外部施加给系统的动作，系统接收该动作后向内传递 而改变内部形态 最终传递反馈到外部(表面) 输出 响应，施加的每个动作每种动作都会引起系统状态的往不同路径上的迁移转化。这个状态迁移图 往往 固定的，即从某状态到另一状态可复现/永远不变的，从而沿着这些路径找到最短路径达到我们希望的具有某特征的状态---往往也是我们的目标 和有用处的事情。
			>系统的拆解分解：(自然界的系统没有飞地--即没有可以控制感知的物理隔离的另一部分; 生的属于后代属于另一个系统;甚至不能产生和发送控制用途/通讯用途的电磁信号;声音等是否算)
				>系统要解决的问题本身的拆解：问题的树形结构。问题模型。
				>系统的目标的拆解：功能的拆解，职责的拆解。从整体 最顶层 的 一句话概括  到 最底层的 若干个 元素的单一职责的表述/表示。(最高目标就是最高层的目标,而非平等的目标中最重要的目标;区分两种概念表述)
					>顶层目标的确定过程-就是需求明确的过程:
						>最简理想模型功能的明确过程：最简单目标、简单模型功能、理想模型功能、最理想条件下的模型功能、各种因素都不考虑进来的模型(正相关影响因素/负相关影响因素/微扰因素)、理想实验模型、实验功能、脆弱功能、简化功能、本质功能、核心功能的明确过程、澄清过程、细化过程、精准描述的过程。还只是一个实验理想模型。
							>理想条件的特征：其他阶段不考虑-只考虑核心阶段、其他影响变量不考虑-只考虑主要影响变量、具体细节情况不考虑-只考虑最抽象上层的情况。其他功能不考虑-只考虑单一功能。
						>其他一个个平级约束条件逐个考虑进来后 模型逐次扩展后的新而又新的模型的明确过程：新目标、新的主体架构、演化后的主体架构。扩展对基本功能的表述，将其中的具体的东西向上抽象化一般化。最苛刻条件下的模型功能。
							>约束条件的特征：限制条件、故障、条件变量值变为极值特殊值、险恶的环境、多变复杂的环境。必然会自然会发生的遇到的新需求，第一版现在就会遇到的其他需求。把这些需求明确下来--为了需求的完整和深刻 先只讨论需求有什么是什么 此环节不考虑实现。
							>考虑的目的/必要性：让系统健康成长、稳定成长、能适应险恶的环境、自愈自修复。生命力更顽强。
						>目标模型的向上抽象过程：功能增强过程。封装进其他目标模型，和其他目标模型封装到一个新的目标模型。
							>增强这个目标模型：依赖这个模型、监控这个模型、统计分析监控量并得出结论发出控制信号调节/指挥/引导/服务/治理/保护/优化/自动化/智能化 这个目标模型/系统。
							>考虑的目的/必要性：考虑到各方面各线可能增加的需求和功能-进行预留和预备、让系统扩展性更好、性能更好、功能更多还不乱、更稳定可靠、可扩展也可卸载替换功能模块、更好的可控性-更细更广可控。
						>目标模型的向下细化过程：向下一层层具体化展开明确确定。
				>系统的解决思路的拆解：方案思路的拆解。思路模型。
					>思路中的有限类型元素集合：
					>思路中的当前可以使用的条件的集合(组织成结构)：
				>系统的组件的拆解：组件模型。分解出下一层的构件，下一层的构件再到下一层的构件。一层层分解下去(如肉分解出蛋白质-蛋白质到氨基酸,来到可以被吸收的层次)(如汽车拆解出底盘-底盘拆解出发动机系统)，拆解到元素层级，最广泛被使用/重复利用的 元素级别。
		>使用：	利用和扩展。训练(它)和增强(它)。整合(到一个方案中)与改造(更适配一个方案)。
			>该系统如何应用在方案中：哪些类 哪些问题 的 方案  会使用 到 这种系统。就像用人 一样 用系统。
			>这些方案如何应用在业务中：这些方案又可以用在哪些业务中。
				>方案的评估和论证：
			>这些业务如何解决人们遇到过和将遇到的系统型的个人又难以独立解决的希望有组织-公司提供专业的服务来解决服务的问题/痛点： 
				>动作的条件、目的和规范：如伸缩 这个动作。
	>于创业：人们当前遇到了什么问题 --> 人们会遇到什么问题 --> 人们想要解决而无法解决想别人提供可以解决的哪怕是有偿的也要解决的问题是什么 --> 先 概括出用户想要而缺乏且看到则感到惊喜的服务是什么
>举动-痛点：可扩展的方案。
	>解法/解决方案：十二大要素应用。
		>Tomcat系统架构：
			>问题：开发者缺乏一个统一的web请求接收响应框架。实现一个框架，实现一个规范，框架启动时，自动发现和组装 开发者编写的符合该规范的项目 到系统里， 然后在接收到网络请求时 回调用户项目的规范的实现。
			>目标：实现一个Servlet规范的容器。
			>顶层思路：建立完全技术的和具体业务无关的 通信框架，而将请求匹配到用户代码而 回调用户的业务代码。顶层流程：只用几个关键节点和节点之间的过渡线 来表示。
				>基本领域确定：基本领域结构。从最外层巨大的边界到最内层最精细部件的边界。边界上的接口。按顶级流程 的节点  发现 每一层上 明显的边界，来确定这一层上的领域。每层上的划分规则，划分标准，划分线。划分标准：就是分工。就是认识到上一层边界内的事情 可以分工为 几件事情；分工实现。按环节，按状态，按事件。按转换的阶段(如如果上层边界内的输入输出转换路径太远，那么内层分多个边界时 每个边界的输入输出转换路径/映射路径/经过路径/层层处理路径 就要近些；例如从http请求转换为调用户项目代码 这个路径就很长，同样 将用户项目代码执行的结果 再转换为http响应 这个路径也很长)
					>Server: 最外层边界，它的边界上 只有  start()/stop()接口方法。边界上输入输出之间的转换路径长，所以边界内需要分割为若干个闭合的子边界，来层层转换，传递可以接收的变化，每次微小的变化，从而可以快速的实现且并行的实现。不断的二分/三分。
						>Acceptor: 因为从接收到响应路径太长了。所以分割为 从接收到 调用户代码；和 接收用户代码结果而到返回web请求。
							>Transfomer:接收到调用户代码这个路径依然很长，这个输入输出模型 的内在转换/联系路径还是太远，复杂则不稳定，所以再次切割为 接收请求到调用户代码之前，调用户代码到获取用户代码执行的结果 。
								>CommonTransformer: 由于请求转换为调用户的请求，两个请求之间格式差别其实很大；所以再次二分为 http请求转换为 普通调用请求所需信息准备就绪，普通调用请求信息就绪 到映射到用户具体某代码调用请求。
									>Receiver: 由于web请求本身是客户端发送的，又要经过网络环境，所以从请求里提取出调用信息是一个多步过程，根据这个情况 而再次 将 http请求转换为普通调用请求信息 分割为：web请求的解码、解密、解压、普通信息封装。
									>Decoder:
									>DeAuth:
									>DePress:
									>CommonCallInfoPackage:
								>UserCodeCallTransformer:
							>Runner: 
						>Responsor: 
				>活动领域确定：精细描述，发现新的度量，来找到新的处理环节、隐藏的处理环节、忽视的处理环节、默认的处理环节、退化后的处理环节、单调化后的处理环节、平滑后的处理环节、理想化简化后的处理环节，从而还原真实的多步骤过程样貌，还原边界清晰轮廓凹凸的真实的处理环节。
					>多租户、多用户同时访问，多开发者都有项目即多个开发者项目的隔离运行：所以要有 一个项目对应一个的 Service  活动领域。在Service下才是 Connector/Engine
					>过程分解到各个组件中：使组件充分解耦，提高服务器的扩展性和可维护性。
						>每个域名下提供若干个服务：所以要区分域名，用Host 来表示域名 这个 活动领域。 Host下才是 Context 用户服务。
							>每个用户服务可以处理 多个不同uri请求：每个可以用不同的Servlet实例来处理(尽管Spring提供一个而通过内部的uri映射而找到用户的代码)，所以Context下是 Servlet--Tomcat中称为 Wrapper
								>基于Engine/Host/Context/Servlet-Wrapper的共性，都是处理请求，所以继承父类 Container是合理的。容器可以做后台任务：所以 ContainerBase --异步启动后台处理。
								>共性2：都有启动/关闭/销毁 生命周期过程，为了完整定义生命周期过程和确保每个 都统一生命周期名称， 以便如 门面模式/反射方式处理 等，增强扩展和维护性和使用方便，因此抽象出 Lifecycle 概念。
									>其他方便：第三方外部统一观察这些 对象的生命周期行为，和在生命周期下 增加处理---监听器。
							>一次调用一次水流：对水流的处理：管道 Pipeline 包裹 和 阀门 Valve 处理。每个Container容器都有 Pipeline/Valve
							>请求的解析Connector/Coyote: Endpoint负责启动而监听端口，接收请求后调Processor处理，后者 通过 Mapper/CoyoteAdapter 映射找到 具体的容器。	
							>启动：Bootstrap 反射创建 Catalina 实例， 后者解析server.xml配置文件等。不使用Bootstrap来启动 则 直接 用  Tomcat类也可以。
		>类加载器：
			>可见性：jar放的位置 是否 为 JVM上的所有应用都可见。
			>Endorsed Standards机制：优先于JVM中的类加载。
			>不同的应用项目加载器应当不同：以便jar不冲突；
			>架构要素：
			>三个加载器：Common/Shared/Catalina(服务器自己依赖的包) ,对每个Web应用 有 Web应用加载器--WEB-INF/classes,WEB-INF/lib下。
				>要加载什么路径下的classes/jar： 就用什么加载器。
			>JVM安全策略许可：禁止 Web应用 使用服务器相关实现类。	
		>Catalina: 容器。Coyote/Jasper/Jave EL /Naming/Juli
			>Digester: 将XML转换为 Java对象。实现算法：一个类 栈 + 一个 对象栈 。解析xml类似解析Json对象。
			--Reactor 编程：就是 事件编程。
				>模式1：事件A 发生时，执行方法B/注入的lamda表达式。方法名就是事件-方法调用就是事件发生或者组装注册，方法入参就是事件发生时执行的回调函数 或者 订阅者。
					>订阅事件发生时，回调lamda表达式 生成新的可观测对象，再调这个可观测对象的订阅方法来处理源订阅者。defer(()->{})：defer具体怎么实现 则 用 处理动作 的编写 + 和老观察对象一起 封装到新的可观测对象 等主要思路来实现。
					>订阅事件发生时，调用源可观测对象的订阅方法 来处理 新的订阅者，这个新的订阅者封装了源订阅者+lamda表达式构成的辅助订阅者，而新的订阅者被调用接收数据的方法时，先给辅助订阅者 再给源订阅者： 从而就像给订阅者加了一个数据接收监听器一样：doOnTerminate(()->{})
						>订阅事件发生：即调可观测对象的subscrible(subscriber)方法。
					>取消订阅事件发生时，希望能回调lamda表达式：实现做法，就是将lamda表达式封装到 一个 Subscription 对象里 加到 订阅者里 即可。doOnUnsubscrible(()->{})
						>取消订阅事件发生：即订阅者的unsubscrible()方法。 
					---必须 叫到的 概念：事件、回调函数、订阅者。才能理解 Observable的所有方法---每个方法自己本身期望达到的目标。事件肯定会发生，联动触发推动传递，希望 回调函数 在某环节事件上 起到什么作用
					>订阅事件发生时，用回调lamda表达式 映射 源订阅者 为 新的订阅者， 再调 源可观测对象 来 订阅 新的 订阅者。：lift(()->{}) 。此需求产生的原因/场景：
			>一次请求的处理过程：pipeline + n Valve
				>过程：从 StandardEngineValve --> StandardHostValve-->StandardContextValve-->StandardWrapperValve-->ApplicationFilterChain--->Servlet
		>Coyote: 连接器实现。封装了 请求协议和 IO方式。主要负责：Socket请求 ---> Request请求
			>负责: 协议和IO的处理，所以没有涉及要实现 Servlet规范。而产生的Request/Response也跟Servlet规范没有关系，不是按照Servlet规范来实现的。会进一步转换为ServletRequest/ServletResponse才和下一级的 Catalina容器交互。
			>支持的协议：应用层
				>Http/1.1: Tomcat单独运行时。
				>AJP协议：和Web服务器如Apache HTTP Server集成，实现对静态资源的优化和集群部署。支持AJP/1.3
				>HTTP/2.0: 
			>支持的IO方式：传输层/socket
				>NIO: java nio类库实现。
				>NIO2: 采用JDK7最新NIO2类库实现
				>APR: 采用APR实现。APR是使用C/C++编写的本地库。
			>结构：Connector启动时，启动它持有的Endpoint实例。
				>EndPoint: 通信监听接口，Socket接收处理类，传输层的抽象。NioEndpoint/AprEndpoint/Nio2Endpoint
					>启动时：并行运行多个线程，每个线程运行一个Acceptor实例；
				>Acceptor: 等待请求 ,接收到请求后创建新的SocketProcessorBase对象，并异步Run它。它就-->EndpointHandler-->Processor-->Adapter-->Valve
					>监听到请求时：将请求封装为SocketWrapper实例，传递给一个SocketProcessor处理--提交到线程池中异步run。
				>Processor: 负责构造Request/Response对象；单线程运行， 同一次连接中复用Processor： 实现类：Http11Processor/AjpProcessor/StreamProcessor/UpgradeProcessorInternal
					>SocketProcessor: 是一个线程池Worker实例；判断Socket状态后，提交到ConnectionHandler处理-->后者选择合适的具体Processor如Http11Processor--根据状态不同而不同UpgradeProcessorInternal	。
				>ProtocolHandler: 封装Endpoint+Processor; 从而提供对具体协议的完整处理(协议+构造Request对象)。Http11NioProtocol/Http11AprProtocol/Http11Nio2Protocol/AjpNioProtocol/AjpAprProtocol/AjpNio2Protocol
					>
				>UpgradeProtocol: 处理变化后的/升级后的Http协议 如Websocket协议。	根据请求创建一个UpgradeToken这个令牌--->包括了具体的HTTP升级处理器HttpUpgradeHandler
				>Adapter: 对外接口方法service(Request,Response),内部实现：将请求映射找到Engine,接着找到Engine的首个Valve,开始invoke这个Valve
			>AJP协议：8kB一个包，	紧凑精简的报文。	
			>SPDY协议：HTTP/HTTPS的有效隧道。
			>HTTP2.0协议：支持明文传输，消息头压缩算法SPACK；基于帧和流的多路复用，基于一个链接的多请求并发处理。支持服务器推送。
				>帧：如同包对于TCP。HEADERS/DATA/SETTINGS/WINDOWS_UPDATE/PUSH_PROMISE特性帧。
					>9字节定长头：Length/Type/Flags/Stream Identifier
					>变长的Payload: HTTP header/body存在这里。
				>流：就是帧序列。一个完整的处理过程。
					>一个HTTP2.0链接可以并发打开多个流：
					>可以创建并被共享使用：
					>同一个流中的帧按顺序发送：接收者按顺序处理。
					>流由一个整数唯一标识：
					>流相互独立：一个流的阻塞/停止 请求响应 不会影响 其他流的处理。
					--状态转换：空闲-->打开-->关闭。。发送帧和接收帧 会导致 状态转换。
			>IO: 
				>阻塞非阻塞：调用者在等待结果前的状态。非阻塞时，调用者要轮询查看处理状态。
				>同步异步：调用者对调用结果的获取方式(主动获取/被动获取)。等待获取：同步。异步获取--交给一个回调函数(如调用者的一个方法)来被动接收结果：异步。
					>异步的方式下 调用者 完全不需要 阻塞等待了：因为如果等待，那么等待结束时，实际上结果已经被接受处理完了---相当于白等了、等就是在浪费时间、没有用、没意义。
				--并行接收、异步并行处理。	
			>NIO: 
				>Poller: 轮询线程，每个Poller维护一个Selector实例，
					>接收新的连接和注册到Selector: 接收到的新的连接 就是 SocketChannel对象，先转换为 tomcat.NioChannel对象，再封装到PollerEvent实例中，添加到事件队列；Poller运行时将 这个事件队列里的实例取出，再将SocketChannel的读事件注册到Poller持有的Selector上，然后执行Selector.select()
						>当读取到的是读事件时：构造SocketProcessor,并提交到线程池进行请求处理。
				>Acceptor: 循环 ServerSocketChannel.accept()的执行者	,将返回的SocketChannel对象即新的连接 添加到 轮转法从 多个Poller中的一个 轮询线程Poller的 事件队列里。
			--总结Tomcat: 1. 一个ServerSocketChannel,多个Selector, 每次读取到的IO读写事件交给SocketProccessor处理。	Poller单独启动的，和Acceptor一样，不占用线程池。
				>NioEndpoint: 启动 Acceptor ，也启动Poller拉取线程，来循环 拉取事件 队列里的 SocketChannel, 接着进行注册事件到Selector，并启动Selector.select()。
			--总结Tomcat: 2. Processor处理：协议的解析-->构造Request/Response-->FilterChain-->Servlet 	
			>NIO2: AIO
				>非阻塞：返回Future, 再 isDone轮询，然后获取结果。
					>非阻塞获取新链接：Future返回的连接为 AsynchronosSocketChannel
					>非阻塞获取读写数据的结果：
				>异步：实现回调处理类：CompletionHandler	
					>异步通道组：=线程池+异步通道：线程接收指令执行IO事件 将结果分发到 CompletionHandler
			>APR: 为应用程序开发提供统一的API,。提供功能：内存分配及内存池、原子操作、文件IO、锁、内存映射、哈希表、网络IO\轮询、进程和线程操作。调用本地库，所以性能接近原生处理速度。		
				>使用好处：Tomcat可以获得 高度可扩展性 和优越的性能。可以和本地服务器技术集成，从而作为一款通用的Web服务器使用。
					>Tomcat启动时自动检测是否安装了APR: 已安装则采用APR进行IO处理。显然：APR是C库。
				>APR轮询：读写事件完成的数据查询。	
				>Tomcat对外封装：AprEndpoint
			>AJP协议：性能优于 HTTP。二进制传输可读性文本，在Web服务器和Tomcat之间 保持 持久性TCP连接。	
		>Jasper: JSP引擎。JSPServletWrapper
			>jsp页面的动态编译：服务器定期检测JSP页面的更新情况，发送变更则重新编译；JSP页面采用单独的类加载器，从而重新编译 只会 导致 这个JSP页面被重新加载，而不是整个应用都被重新加载。
				>重新加载某个类：先获取类的字节码，然后调用ClassLoader中的本地方法等进行重新加载。即重新加载 是 可以开发者 手动控制的。
				>编译器类：JspCompilationContext, AntCompiler，JDTCompiler
					>Tomcat/bin下有一个 catalina-tasks.xml Ant脚本文件：描述声明了 Tomcat支持的Ant任务(编译任务)。使用Ant来执行JSP预编译。
				--Ant: 描述编译任务 并且编译构建 项目的 一个工具。	maven能编译maven格式的项目。对于一般的项目，则用Ant来描述编译任务。
				--UML图：重点只有三类：引用--用->箭头表示，继承--用三角形箭头表示, 组成--用菱形表示；
				>编译过程：先生成java源代码再编译为Class字节码	
		>Tomcat配置管理：		
			>JVM配置：
			>服务器配置：$CATALINA_BASE/conf 下的配置
			>Web应用配置：通过context.xml进行web应用定制配置。
			>管理配置：JMX,Ant 等 web应用部署管理方式。
				>会话管理器：StandardManager
			--Filter: Request的检查	
		>Web服务器集成：静态资源处理能力的前移。	
			>通过扩展模块：支持IMAP/POP3/SMTP
			>Web服务器：Apache HTTP Server, nginx, Lighttpd\IIS
			>应用服务器：Tomcat, JBoss, Weblogic, WebSphere
			>二者集成方案：静态请求直接走web服务器内部处理模块处理后返回，动态请求 通过 web服务器的代理模块 转发到 应用服务器，接收返回数据后再返回给前端。
				>转发规则：可以做到负载均衡，选择一个服务的若干个应用服务器中的一个来转发。也可以做服务转发，一个请求转发这个请求对应的多个服务中的某个。
				--Apache Haus
				>Apache HTTP Server 内部的代理模块：mod_jk, mod_proxy_ajp
				--Nginx: 支持ajp协议的模块: 阿里开发的 nginx_ajp_module
					>配置模型：两部分。server{}部分 为 配置 url-上行流的 映射 ；  upstream{} 为 配置 上姓流-ip:port 的 映射。
		>Tomcat集群：web服务器前 还有负载均衡机构。
			>集群通信框架：Apache Tribes 
			>集群动作：
				>伸缩：
					>目的：负荷的增加，降低单台机器的压力，来提高响应性能；也逐渐提高吞吐量。
					>条件：无状态服务。
					>规范：平滑过渡；负载均衡式的分发；
				>故障转移：
					>目的：恢复服务。
					>条件：需要有备服务
					>规范：检测到故障预测到故障，快速转移切换。
				>分配流量：
					>目的：平均充分利用每台服务器，而不是倾斜。
					>条件：有流控器
					>规范：流控器 做负载均衡；
			>Tomcat集群基础类：
				>容器：Cluster  被 Host持有 
				>HA: CatalinaCluster
				>通信：Channel:
		>Tomcat安全：
			>默认8005端口：发送 SHUTDOWN会关闭Tomcat。
			>默认异常由ErrorReportValve处理：会泄露系统信息；<error-page>类似的处理。
			>安全域：Realm
		>Tomcat性能调优：
			>Tomcat性能测试和诊断：
				>测试方式：
					>负载测试：逐步增加访问量，响应时间会增大；可以确定系统的伸缩性有多大；弹性有多大；但是响应时间应该在正常范围内，此时的访问量才是最大负载。
					>压力测试：持续增加访问量，直到系统崩溃；得到的是临界负载。
					>持续运行时间测试：
		>Tomcat附加功能：
			>嵌入式启动：入口类 org.apache.catalina.startup.Tomcat, new一个可以添加 Servlet
			>Websocket协议：握手协议请求：起始行、头部、报体 都一样；只是新增了head: Upgrade:websocket