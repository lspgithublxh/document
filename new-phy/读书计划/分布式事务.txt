>基本特性：
	>分布式事务：
		>Sega方式： 
			>两种执行模式： T1T2T3..Tn,  T1T2T3..TiCi...C3C2C1,  即要么全部执行，要么执行到第i步出问题而然后开始cancel i-->1 前面的成功操作全部取消。不同于TCC--这种try-commit-cancel模式，没有try这种阶段。
				>前面是 向后恢复，另一种为向前恢复： T1T2T3...TiTi...Tn, 即第i步异常则重试。
			>缺点：事务之间没有隔离性；事务1可以影响事务2，导致事务2实际上的Ck无法执行。串行加锁。
		>本地消息表：基于消息中间件的最终一致性方案。
			>两个事情做的过程：先A, 成功后异步做B--发个消息到MQ--B监听消息而执行操作,而直接返回了。B从而等到一定时间后才结束，用户稍后才感知到。(同步A异步B)(例如转账：先扣成功，后收到成功)
			>问题：
				>消息丢失：
					>解法：消息先保存到A的数据库里---通过本地事务可以保证 业务数据写入数据库和  消息写入数据库同时成功。
					>解法2：投递到MQ失败时则重试(所以B要实现幂等)。
					>情形3：投递成功但是消息系统立即崩溃了，从而B也没有收到，且MQ重启后也因为消息没有持久化而不会发送消息到B；所以此时需要一个 独立的定时任务扫描 A的消息表中 状态为 “发送中”的消息，找到后重新发送到 MQ---一直进行这种尝试 直到B成功收到并处理成功并返回消息被A听到而更新消息的状态为“成功”，然后这个定时任务不再重试。
						>为了人性化处理：当定时任务重试一个消息k次后，就不再重试，而应该短信邮件通知 相关人员 进行 人工干预。
				>B处理失败：可能要求A回滚。
					>解法： B处理成功/失败也发消息，且A 监听B的这个消息，A收到B成功的消息后更新A的数据库的消息表的消息的状态(为成功)(A发消息时仅仅为 发送中 状态)。		
			>方案完善：	
			>方案好处： 实现了可靠消息的传递；确保了分布式事务的一致性。
			>缺点： 本地消息表  和 业务耦合在一起；不通用，不能独立伸缩。本地消息表 并发处理下有性能瓶颈。一致性不高。最终一致性。
		>MQ事务：	最终一致性的分布式事务方案。(也是一种2pc实现)
			>过程：相当于 本地消息表转移到了MQ。所以MQ要实现：持久化消息，当消费者确认消费成功后 更新消息状态 为结束：否则会定时重发这个消息。
			>官方过程：1.先发 半消息 到MQ(commitlog里) 后做A。A后再发commit消息到MQ(将消息从commitlog转移到consumeQueue)(预备消息转为确认消息)。 然后MQ才将消息发送给B.。 
			>问题： 
				>A成功但是发消息到MQ失败：只需要回滚A就可以(但实际上A已经提交了--所以不可能了，只是Ci向前恢复而已；所以官方才 先发消息 后做A--避免消息系统已经不可用了还做A)。
				>B处理了但失败了返回MQ失败消息：
			>官方问题：
				>A执行本地事务时失败：则发送cancel消息给MQ,MQ直接删除 半消息。
				>A执行本地事务卡住/崩溃/成功但发commit消息失败：MQ会 定期 回查 commitlog 里的半消息, 从而告知A, A查本地数据库看状态，再反馈回MQ(cancel或者commit).
				>B失败/B服务不可用 而未消息确认：MQ重发消息。
			>方案完善： 	
			>缺点：
		>TCC: 强一致。类似直接对数据库的本地事务的实现。2PC,3PC也是强一致。国内：himly。lock-commit-cancel
			>过程：
				>Try(够不够): 每个服务 冻结 各自的 资源(资源数)(不能被其他事务操作)(比如冻结2个资源数---不能被其他事务使用)(单独提出来放到另一个预处理字段里)，即保存 一个 预操作的资源数--先隔离出来--而不直接余额上扣减增加----而是在预操作字段上增加和扣减。这个只操作 预处理字段/隔离资源/冻结部分量 的 过程 就是 T阶段。而且这个预操作字段 肯定 会因为各自的本地事务而操作成功。
				>Commit(够则做ABC)：每个服务 将预处理字段的值 应用到 资源的真正字段上。每个服务的comfirm逻辑 独立于 每个服务的try逻辑。显然这个成功 也是本地事务的成功，是永久的变更。对于没有额外字段的，如状态类型的字段，则try阶段设置为中间字段，commit阶段则更新为最新的状态。
				>Cancel(ABC某个错了则取消)：每个服务 都有 cancel逻辑，在try阶段失败时 TCC事务框架会调用各个服务的cancel逻辑，将 预处理字段  的值 恢复为操作之前。
			>问题： 
				>try的目的：看各个服务本身是否可用，以及它内部调用其他中间件：如数据库/zk/conf/mq等 是否是可以成功的；；避免有的服务在访问这些中间件时访问不同 还实际做了服务----就是没必要的，所以要先试一下/查看测试一下/是一种智能检测。如果这一步成功了，那么下一步commit也大概率会成功(或者说相比没有try的方法成功率更高)。(相反，直接做commit则成功概率会低得多)；；；且try失败了，回滚代价更低，影响更小；而直接commit则代价更高、影响更大。
				>某个服务挂了：try阶段失败，则直接回滚cancel其他已try成功服务。
				>某个服务commit/cancel失败：重试一定次数，超过则发邮件短信 人工介入。因为try已经隔离了资源，commit处理这部分，所以可以保证幂等。
			>方案完善: 	
			>适用范围：强隔离性、严格一致性。执行时间较短的各个服务。
			>缺点: 对代码侵入性大。需要专门提供try/commit/cancel接口。
		>SEATA: 微服务框架下的分布式事务。
			>领域对象：
				>TC: 独立部署，协调TM和RM。在主服务发送 全局子服务注册完毕/提交/回滚的消息后 发送 提交、回滚 信息给各个 RM，成功后发送事务组完成消息给主服务。
				>TM: 主服务上，调用其他微服务的为主服务。负责发送全局事务的 创建、开始、提交、回滚 全局事务 信息 给 TC。(全局，所以invoke方法前后进行创建/回滚/提交)
				>RM: 子服务上，子服务访问自己的数据库。RM负责发送 本地事务/分支事务的注册和报告状态 给TC，也接收TC的发送的提交、回滚 信息。
			>问题：
				>1.TC怎么知道一个全局事务到底有多少分支事务？: 主服务 告知的，主服务执行中所有的子服务都执行完了(子服务执行实际都先到TC注册) 则通知TC所有子服务都注册完毕；
				>2.RM回滚过程？：被主服务调用阶段，业务数据+回滚日志 一起作为一个事务提交到本地数据库；从而收到TC的回滚请求后，查询回滚日志上的sql重新应用到业务数据表上执行即可。收到TC的提交请求 则 清除回滚日志就可以了。----RM收到提交---说明所有的子服务实际上都执行成功了！！所以可以安全的清除回滚日志。---RM收到回滚--说明有的子服务失败了---所以回滚执行了即可。-
					>相当于一种乐观的分布式事务：只需要关注有服务失败---其他正常的情况 就应该像没有分布式事务一样；；只是有异常时 才全局阻塞进行已执行的子事务回滚。所以SEATA效率比较理想。
				>3.全局事务的隔离级别？：读已提交。所以会有全局锁定期间---其他事务不能通过这个分布式框架查询到结果。	
			>使用：@GlobalTransactional注解到主服务即可。
		>最大努力通知：发消息方式的异步调用。接收方没有回复ack则MQ会按时间梯度重发。
			>过程： A服务执行前预发消息，执行成功后确认消息；然后消息被MQ发送给接收方---带时间梯度间隔重发机制；
		>XA事务的Atomikos: Bitronix
			>过程： XA协议。事务管理器TM +  本地资源管理器RM(实现XA接口的数据库)。
				>阶段1：事务管理器：询问各个节点预提交，都返回成功后；事务管理器再 发送 提交。
			>问题：单点问题。性能不高。mysql支持不好。虽然强一致，但是甚至要避免。
			>实现：使用。配置数据源：AtomikosDataSourceBean，结合@Transactional 注解  就可以实现 @Transactional 注解的方法 里的数据库操作---尽管用的不同的数据源--但是只要都是AtomikosDataSourceBean 类型，那么都可以做到原子性---每个数据源都同时提交成功或者同时都回滚。
			>2pc: 数据库的二阶段模型。1个事务协调者 + n个参与者。AT模式。
				>过程： 1.事务协调者询问 n个参与者是否可以提交， 参与者执行事务操作写入undo\redo,但未提交, 返回协调者 是否可提交yes/no。  2.事务协调者接着可能：收到全部yes---则发送commit, 收到部分yes---则发送abort, 超时--则发送abort。3.发送commit后，参与者提交，此时基本都会成功(因为第一阶段已经成功),返回ack。同理发送abort后，参与者回滚也基本都会成功。
				>问题：提交阶段  参与者同步阻塞；提交阶段 参与者部分收到commit则数据不一致(缺乏超时后自动提交/或者自动回滚)(甚至一直锁定)。
			>3pc: 数据库的三阶段模型。1个事务协调者 + n个参与者
				>过程： 1. 先问是否可以提交，但是 参与者 仅仅直接返回yes/no, 而不做事务。仅仅为了证明网络通畅/服务可用；2.都可以提交则网络没问题 ，此时才开始预提交，发送precommit，让参与者做事务，写入undo/redo, 返回yes/no， 此时如果有参与者超时没收到--则回滚事务--自动操作。 3.根据返回的,收到全部yes---则发送commit,.... 超时--发送abort。 参与者 如果超时都没有收到commit/abort,则自动commit---即采取超时提交策略。
					>特征：参与者进入阶段1后，2次超时自动操作--第一次回滚第二次提交。
				>问题：数据不一致仍然存在。
		>TX-LCN分布式事务框架: 		
		--跨数据库、服务、消息队列 三大类 分布式事务。
	>spring事务 概念抽象 到 具体 的 设计/定义 过程：服务设计/定义过程：spring事务封装体系
		>TransactionAspectSupport： 1.负责实现事务模板流程结构：invoke_method-commit-cancel：@invokeWithinTransaction()@commitTransactionAfterReturning()@completeTransactionAfterThrowing()。2.创建事务：@createTransactionIfNecessary()。 
			>TransactionInterceptor: 继承TransactionAspectSupport的功能，实现MethodInterceptor接口，从而可以作为方法拦截器 而 应用到指定方法上--使得该方法被事务包围。
		>TransactionManager: TM类型对象的定义。声明是个TM,无需任务方法，只是个标记Marker。
			>PlatformTransactionManager: 继承TM。spring平台下  对 TM的刻画： 1.要求能够创建事务--提供一个创建事务的方法(提供条件：事务传播级别、隔离级别、超时时间) @getTransaction(TransactionDefinition). 2. 能够提交一个事务@commit(TransactionStatus status) 3.能够回滚一个事务@rollback(TransactionStatus)
				>AbstractPlatformTransactionManager: 继承PTM,1.提供 在基本的事务行为方法 上的进一步按条件封装，提供 在 运行时环境各种情况下 都满足的事务基本方法的包装方法：如 创建事务、悬挂与恢复事务、开始-提交-回滚事务。2.负责实现 在各种 事务传播级别下 分别如何 创建(获取)事务和额外操作 的规定流程，但创建一个具体事务 则 是 具体实现类 去实现。不是spring-tx的范畴。spring-tx提供在运行时环境下/各种条件情况下的各种基本事务行为的分别封装/包装。	
					>DataSourceTransactionManager: 1.提供具体事务行为的直接实现、专门实现，跟环境无关。如 创建事务对象：@doGetTransaction()直接new DataSourceTransactionObject()返回(此时ConnectionHolder为空)。无开启事务：@doBegin()内部在先获取连接：用内部自己的DataSource.getConnection()来获取连接，并封装new ConnectionHolder()再设置到txObject里，并设置连接是否自动提交，并在ThreadLocal绑定DS-Con的关系。 悬挂事务：@doSuspend()就是解除DS-Con绑定和 当前事务对象连接置空。提交事务：@doCommit()就是当前事务的连接提交。回滚事务也是。
				>ResourceTransactionManager: 继承PTM，提供 TM操作的资源工厂对象：如DS 、JMS工厂。@getResourceFactory()实际实现上返回的是个数据源对象--DataSourceTransactionManager的实现。
		
	>系统设计： 好的 设计 基于好的领域模型。领域全、划分明确.	
		
		
		
		
		
参考资料：
1.https://www.jianshu.com/p/286cac4625b6
2.https://zhuanlan.zhihu.com/p/147817106		
3.https://www.cnblogs.com/huanzi-qch/p/11057974.html
4.https://www.jianshu.com/p/21782150f043(seata)
5.https://segmentfault.com/a/1190000018057083?utm_source=sf-related(seata)