---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	

	
>举动-痛点：
	>解法/解决方案：
		>计算机组成与体系结构：
			>总线：分时共享。一个时刻只能一个部件发送指令/数据；地址、控制、数据总线三种；
			>BIOS:基本输入输出程序；
			>磁盘：盘片、盘面、磁头(每个盘面一个，径向运动，且每个磁头一致运动)、磁道(每个面n圈)、柱面(每个盘面的同一个磁道号的磁道；大文件信息优先存同一个柱面的不同磁道，后才是相邻柱面)、扇区(磁道分段,一个扇区存一个定长信息块)、定长信息块(512B)、寻道+旋转盘片
			>Cache: 内存地址-->值   这种映射的存储。存一个区的大小；
			>主存：分区(128)、分页(16)、页内地址(512KB)
			>加速比：就是任务的阶段数。
			>操作系统：5大管理功能。计算机和用户之间的接口。
				>管理计算机各类资源：软硬件资源。
					>进程管理：组织和协调用户程序对cpu的争夺使用；进行分配调度进程到cpu、管理控制进程；最大限度发挥cpu的作用。
						>存在资源共享和并发：就需要调度。
						>进程状态：就绪、运行、阻塞。另外一种：挂起(被交换到了磁盘)
						>互斥与同步：资源对进程互斥--只能同时被一个进程访问；进程同步执行--按顺序执行--一个在执行一个就不在执行；进程同步就可以实现资源对进程的互斥。
							>临界资源：只能同时被一个进程访问的资源。
							>临界区：临界资源如果是一块代码。
							--进程进入临界区的协调规则：没有可进；忙则等待；等待时必须释放cpu资源;多个都想进入必须可以快速决策出；
							--信号量：实现进程同步和互斥。java semphere的实现为对的。对资源加信号量包围:进入资源前执行p操作,退出资源后执行v操作
								>pv操作：p对信号量-1，v对信号量+1(同时唤醒阻塞队列中的一个进程); 信号量>0可以进入临界区，否则必须进入信号量的阻塞队列等待；
							--前驱图: 动作的先后执行和并行执行关系的表达; 谁在谁前面,后面;并行;父在子前,兄弟并行;	
							--调度:调度的是就绪队列里的进程 给 cpu资源;
								>进程调度的触发: 执行完毕;进程阻塞;进程主动唤醒就绪队列中进程;用完时间片;就绪队列某个进程优先级变高;
								>进程调度的算法: 就是选择下一个放到cpu上运行的就绪进程的算法: FIFO,优先级,轮转;
							--死锁的预防和检测: 降低并行程度;事前检测出资源依赖关系--将获取的资源是否被占用的记录图 查看; 银行家算法--但是检测会消耗cpu和时间;检测和处理更好;	
					>存储管理：影响系统性能;对内存的分配和回收;提高内存使用效率;(分区管理-->段页式管理)
						>内存划分:系统空间\用户空间
							>页式管理: 程序的逻辑空间和内存的物理空间按同样大小划分为若干页;以页为单位分配;
								>进程的逻辑页号和内存的物理页号:  系统为每个进程建立 一个页表, 来存储这个 页号映射关系(和状态:是否调入内存);
								>虚拟地址: 页号+位移;(p,d)
								>指令访问虚拟地址(p,d): 即先查p页是否在内存中,在则直接访问页中d位移的内容即可; 没有在内存则产生页中断,装入所需要的页;...... 即虚拟页号-->物理页号-->+偏移量 就找到了物理地址了, 否则页中断,加载页进来;
								--实现虚拟存储器: 作业信息分页存储在磁盘;执行时,加载部分页 进来,如果执行的指令的虚拟地址通过映射表找到的物理页在内存中,则找到偏移处 继续,否则 产生页中断,加载所需页面进来;...映射表就是:页表:存映射\状态(是否在内存/磁盘位置)
									>页面交换: 当需要的页不在内存,而内存无空闲空间,则选择一个页面交换到磁盘,如果这个页面被修改过,那么重新写回磁盘;
										>选择调出的页的算法: 最优算法---将来才使用的页, 随机算法, FIFO--驻留时间最长的; 最近最少使用--LRU
							>段式存储管理: 用户作业逻辑上有意义的划分出的各部分为段; 主程序\子程序\数据段;
								>段表:类似页表.	但段 单位更大;
							>段页式管理: 虚地址形式(s,p,d) ;每个进程一个段表,每个段一个页表;
								>段式分配\页式使用: 便于动态连接 和存储的动态分配;
								>页面交换: 段中部分页面加入内存或者交换出内存;
								--有查找段表页表的开销;
						>内存分配算法: 取下一个可用内存小空间的算法:
						>内存的保护和扩充:
					>设备管理：除磁盘/mem外的设备,输入输出\终端设备等;外围设备;
						>设备和cpu/mem之间数据传输方式: 速度高\开销小\充分发挥硬件资源能力
							>程序控制方式: 处理器启动 数据传输, 等待 传输完成;
							>中断方式: 进程 启动数据传输, 放弃cpu;传输完成,设备产生中断,中断处理程序 对数据处理后 唤醒相关进程为就绪状态;
							>DMA方式:DMA控制器 窃取 处理器的工作周期和控制总线, +总线浮起, 实现 外设和内存直接数据交换;(外设,一旦上电,就可以输入输出数据了--类似逻辑控制电路+存储的程序)
							>通道方式: IOP, 输入输出处理器, 执行自身的输入输出专用程序 进行 内存和外设的数据传输;
						>虚设备和SPOOLING技术: 假脱机技术,将低速独占设备--->可共享的设备; 一台物理设备 可以 对应 为 多台 虚拟的同类设备;		
					>文件管理：组织\存储\保护数据和程序; 数据和程序以文件形式存储;
						>建立修改删除文件:
						>按文件名访问文件\存放位置\存放形式\存取权限:  保护--避免被破坏;保密--避免未经授权的访问;
						>文件的逻辑结构:
							>无结构的字符流文件;
							>有结构的记录文件: 索引文件\直接文件;
						>文件的物理结构: 提高存储器的利用效率和降低存取时间;
							>分配和传输信息的基本单位: 物理块;按物理块 划分; 文件存储设备的组块策略和文件分配策略;
								>文件分配策略: 
									>顺序分配: 申请连续物理块, 按序存储; 创建即指定长度,不能动态增长;
									>链接分配: 每个物理块有后向指针,指向下一个物理块的地址;形成链接队列; 可以动态增长; 删除其中一个物理块只需要调整前后的指针; 提高存储利用率,但随机访问效率不高;
									>索引分配: 索引表. 文件的逻辑块号和物理块号的映射; 动态增长可以,随机访问也快;  .. 三级索引;  索引表先调入内存,后再根据索引的块号访问物理块;访问磁盘;
							>文件存储设备的管理: 对空闲块的组织和管理
								>空闲块的组织\分配\回收: 管理方法: 索引法\链接法\位示图法 
									>索引法: 空闲块的索引. 空闲区块的索引.
									>链接法: 分配从头取,回收从尾取;
									>位示图法: bitmap 记录文件存储器的使用情况, 每位对应文件存储器上的一个物理块;0/1为空闲和占用;
					>作业管理：
						>作业状态: 提交--作业从输入设备到外存; 后备状态--系统进行作业控制块的创建;执行状态---被作业调度程序选中而分配一定内存,建立进程,变为执行状态;  完成状态--完成;
						>用户接口: os提供给编程人员:API, 设备管理\文件管理\进程控制\进程通信\存储管理;	
				>控制程序的执行：有效地利用资源。
				--为用户提供：命令、菜单、窗口。
				--为应用程序提供：API
		>数据库系统:
			>模式和范式:
				>概念模式: 定义记录\数据项\数据的完整性约束条件,以及记录之间的联系; 全体数据的逻辑结构和特征的描述;
				>外模式: 用户可以看到的那部分数据的逻辑结构;
				>内模式: 定义存储记录的类型,存储域的表示以及存储记录的物理顺序,指引元\索引\存储路径等数据的存储组织;
			>两级独立性:物理独立性和逻辑独立性;
			>数据模型:
				>概念数据模型: ER图
				>基本数据模型: 数据结构\数据操作\完整性约束;
					>层次模型: 树形结构表示	实体类型和实体间的联系;
					>网状模型: 有向图表示实体类型和实体间的关系;
					>关系模型: 表格结构表达实体集; 外键表示实体间的联系;    -- 结构简单清晰; 有数学理论基础; 存取路径好;
					>面向对象模型:
			>关系代数:
				>并\交\差\笛卡尔积\选择\投影\连接\除法:  集合运算;
					>并:结果相并 ,显然要求记录是相同字段和类型的; union
					>交: 记录有主键,有各列值,求列值相同的行分别连接起来,形成新的集合;inner join 
					>差: A记录集合中有的某列的值,B记录集合中某列的值,取只在A中出现的记录;
					>笛卡尔积: A记录集合中每个记录都和B记录集合的每个记录相连接;形成的新的记录的集合;
					>选择: 筛选出记录,条件是 列值满足某种特征,列值和列值满足某种关系的记录,筛选出来;
			>关系模型满足的约束条件: 范式 
				>第一范式:最低的规范化要求. 要求简单域, 属性项不可再分; .. 使得 可以精细查询
				>第二范式: 所有非主属性 都直接只依赖主属性,而不是其他非主属性;..有 那么 会导致数据冗余\更新关系要全部涉及记录都更新\不能独立存储.  ... 比如:人-证书-发证部门;  办法:拆分非依赖主的字段;
				>第三范式: 即便依赖主属性,但是如不是只,即尽管主属性就可以确定B,C列的值,但是B-C自身相关,一对多/多对一, 则也要拆分;...非主属性的列列不能相关;
				---范式可以增强:增删改的速度. 减少了存储;  但是对查询,则需要更多的连接;
				--反范式设计:方便读,如增加冗余列;派生列;
			>数据库设计:
				>需求分析:
				>概念结构设计: ER图
				>逻辑结构设计:
				>物理结构设计:
			>事务管理:
				>并发控制: 并发操作带来的问题:丢失更新\不一致数据\读脏数据;
					>解法: 访问带上两种锁
				>封锁协议: 
					>一级封锁协议: 修改数据前必须带上X锁; 防止丢失更改;
					>二级封锁协议: 读取数据前必须带上S锁--读完就释放; +防止读脏数据;
					>三级封锁协议: 读取数据前必须带上S锁--事务结束前才释放: +防止重复读;	
				>两段锁协议:
					>读写数据之前: 获取封锁;
					>释放一个封锁后: 事务不能再申请和获得任何其他封锁;
				>封锁粒度:
					>属性值:
					>元组:
					>关系:
					>索引项:
					>整个关系数据库:
					>物理页:
					--问题:死锁 
						>死锁避免: 
							>预防法: 一次获取全部的封锁后才开始;或者:封锁对象按序编号-然后必须从小号开始申请(可能会串行等待一定时间);	
							>解除法: 死锁检测程序--检测死锁是否发生; 解锁程序--发现死锁了则开启解锁程序;
				>故障与恢复:
					>事务故障: 未运行至终点 就被撤销;
					>系统故障: 停电\硬件错误\操作系统错误; 事务非正常终止;
					>介质故障: 强磁场干扰;外存数据丢失; 碰撞;
					>计算机病毒: 
					--
					>故障恢复: 转储,登记日志文件;
						>事务故障的恢复: 恢复子系统应该对此事务做撤销处理
							>利用事务日志:进行反向处理.
						>系统故障的恢复: 正向扫描日志,找出故障发生前已经提交的事务, 将事务标记 放到 重做redo队列里; 同时找出 故障发生时 尚未完成的事务,放入撤销undo队列.
							>撤销队列的事务: 撤销处理:反向扫描日志, 对Undo事务的每个操作执行逆操作;
							>对重做队列的各个事务进行重做处理: 正向扫描日志,对每个re'do事务重新执行日志文件登记的操作;
						>介质故障和电脑病毒破坏的修复: 装入数据库后备副本; 使数据库恢复到最近一次转储时的一致性状态; 
							>从故障点开始反向读取日志文件: 找出其中已提交的事务,加入重做队列; 重做事务;
						>具有检查点的恢复技术： 也是从检查点 找到 此时 正在执行的事务，放入撤销undo队列， 再往回找，找到已经提交的事务，放到重做队列；然后分别先后撤销事务的做和重做事务的做；	
				>备份与恢复：
					>数据丢失尽可能少、备份时间和恢复时间尽可能短：
					>物理备份和逻辑备份：
						>物理备份：对数据库数据文件进行备份；
							>冷备份：先停数据库，后cp数据文件到新地方； 当数据库故障时，则将备份的数据复制回来；备份模式
							>热备：一种：不关闭数据库--数据文件备份状态后备份下来；二种--利用备份软件；
							--完全备份：全部备份
							--增量备份：上次完全备份以来的所有修改；
						>逻辑备份：数据库自身的备份工具进行 逻辑概念上的备份--如表、库；
				>分布式数据库：
					>坚固性好： 容忍网络分区；冗余技术；可靠性和可用性；
					>可扩展性： 增减节点；伸缩能力；
					>可改善性能： 就近访问：。减少系统响应时间；
					>自治性好： 分散管理，统一协调；
			>数据仓库：面向主题的操作型数据库，而不是面向事务处理；关注问题和关注对象的区别；
				>大量查询：修改删除少；
				>存储时间长：数年数十年；而不是一般，就几个月十几个月；
				>非实时：但是某个时刻的快照；
				>响应时间慢：秒，分钟，小时；分析很久 而不是实时简单查询；
				>OLAP: 就是数据仓库应用工具；但不是数据仓库；
			>数据挖掘：海量数据收集存储、多处理器并行计算、数据挖掘算法；
				>关联分析：同时出现的不同事情、对象；
				>序列分析：
				>分类分析：用户画像分类。利用神经网络、决策树，数理统计 建立 知识的模型；
		>计算机网络：
			>网络架构：
				>按照信息的传输过程：将网络的整体功能分解为一个个的功能层；
					>同一机器：相邻层通过接口进行信息传递；
					>不同节气：同层之间采用相同的协议；
				>OSI各层：开放系统互连参考模型。低三层--网络通信--为通信子网；高三层--信息处理--为资源子网；
					>物理层：不关心比特的含义，而只关心相邻节点0,1如何发送，接收端如何识别；正确传输和接收0或1(每次都要成功)---但是自身没有重试(0传输失败了不会重试/验证的消耗太大)。是系统和通信介质的接口；系统将信号发送到介质上；或者系统从介质上接收信号--感受介质上的信号(感受信号不断的变化)；
					>数据链路层：关心相邻节点如何无差错传输帧为单位大小的比特流；即有重试；某次某个帧传输失败了，那么重试；而物理层没有重试；其他手段：流量控制和差错控制；从而将不可靠的物理层连接 变成更加可靠的成功率更高的/无差错的数据通道(一次可能会内部重试好几次，所以正确率高)；从而对网络层显现一条可靠的链路；
					>网络层：实现整个通信子网内的连接，(不再仅仅相邻节点),将网络服务数据单元(更长的数据流)从子网的一点到另一点的正确传输；因为会跨多个节点，所以要解决路由转发；拥塞控制；多个网络互联等问题。从而产生了要对节点编号---ip的需求，负责路由的中间节点需要建立路由表的需求；。最开始：是一个编号1，2，3，4；5；如1号要连10号；发现中间隔着4号和5号；10个节点形成了一个图结构；则发现中间节点需要记录其出口线指向的数据范围；。。。。总之，建立了一条跨越多个节点的通信链路---使得数据包可以源源不断从一个节点跨越多个节点而到达另一个节点；这就是网络层的最大作用；
					>传输层：实现可靠的端到端的连接；即有重试；而网络层只专注实现路由功能，并不进行端到端的重试---所以并不可靠；另外，端上可能有多个应用要发送数据，所以还要对应用编号--端口；这样，一个计算机网络端：接收的数据分别放到对应的端口上--让对应的应用程序读取各自的数据---实现并发网络连接的功能；。。从而为高层提供了传输数据的通信端口；从而高层之间传输数据不用考虑和其他应用数据冲突的问题(指定ip对方，port自己的接收槽位即可)；
					>会话层：真正根据应用要发送的数据，而去打开传输通路--开启会话，调用传输层将数据写入进行传输；接收数据，释放连接；。。真正的通信服务代理者--更上层的视角来看这一层；
					>表示层：实现用户信息的格式化表示；传输数据，首先数据要格式化表示--才能被正确识别认识，数据的格式、编码、压缩的具体采取方案，是这一层考虑的方面；实现的是传输的数据的格式映射/信息映射/格式统一映射。。是协议的语法方面；使得被交换的数据在网络上是统一格式的；即便它在不同的端计算机上是各种不同的格式表示；但在传输过程中是共同格式的；
					>应用层：实现对格式化数据的解读(含义)展示问题(应用的事，非操作系统)(实现收集解读零散数据形成应用处理要求具有的表示格式的过程)；实现采集用户输入信息并初步表示 和 收到另一端来的数据并在表示层格式化后得到真正的数据后最终展示在进程里--用户空间里--UI控件里--可视化展示；不同格式的数据有不同的可视化展示：如邮件的展示、聊天消息的展示。
				>TCP/IP结构模型：
					>网络接口层：数据链路层+物理层的对应：基本相邻节点的通信的所有程序的集合
					>网络互联层：将数据报从信源传送到信宿；功能实现；(数据包/只是实现了传输功能)
					>网络传输层：将完整的信息集合从信源传送到信宿；这就是一个数据传输服务了(大文件)；
					>网络应用层：应用层实现的各种数据协议和通信模式，提供各种应用功能；
			>协议：
				>应用层协议：DNS,http。数据格式，含义，通信流程(功能实现的多轮通信过程)。
					>FTP: 客户机和服务器之间建立2条连接；一条传输控制信息，一条传输文件信息；
					>TFTP: 简单文件传输，提供不复杂、开销不大的文件传输服务；不提供存取授权和认证机制；
					>HTTP: 数据格式：页面等, 含义：浏览器可以识别解释；服务实现的多轮通信过程(收-解释-发流程)；请求-响应。浏览器：对页面解释和可视化；而数据-->页面 还需要一个处理过程---这个被称为可视化插件；
					>SMTP: 特定格式邮件数据的解释和可视化程序；	
					>DHCP: ip网络设定数据 由 DHCP服务器集中管理；客户端使用从服务器分配下来的ip环境数据；租约和续约；DHCP分配ip地址的方式：固定分配、动态分配、自动分配。	
					>telnet: 远程登陆一台计算机，并将响应返回。显然，服务端返回的是文件目录，和命令执行的结果。
					>DNS： 和DNS服务器交互的协议，发送域名，响应的是ip;
					>SNMP: 网络管理协议；解决Internet上路由器管理问题；
				>传输层协议：点到点的数据传输，所以需要负责 流量控制、错误校验、排序服务。
					>TCP: 利用ip层的数据包传输功能+重发 而提供一个可靠的、持续连接的全双工的数据传输服务；(功能与服务，就像我会开车和我提供客运服务 的区别一样)
						>场景使用：数据量少，可靠性要求高。
					>UDP: 不可靠无连接，错误检测少, 重试少，因此不可靠，但减少了消耗而速度快；用于传输数据量大，但可靠性要求不高的场景；即尽管传输n次，c次都失败了；
				>网络层协议：处理信息的路由和主机地址的解析。
					>IP: 网际协议。尽力传送。--可能丢失、重复、延迟、乱序。
						>数据分块和重组：来传给物理链路层--一个个帧传输；从而很大的ip数据包可以以较小的分组在网络上传输。而差错检测和流量控制没实现；
						--这一层也可以当作包切割(传输层也有包切割)。如包切割为帧--是ip层做的；而数据链路层：从上层推入的“帧队列”里取出帧(调用发送程序)发送到网络；物理层则是硬件，是一种因果响应--只要一端放上什么信号，另一端就可以接收到什么信号。
						>增加了ip号信息到帧里，才真正使得接收端接收到帧以后，决定从其他端口转发出去并知道这个帧转发到哪个端口。而做了转发这个动作才是ip层真正超越链路层的更高级的新增的独特的功能。
					>ICMP: 网际控制报文协议
						>对ip层传输的数据 进行 避免差错和差错时报告：机制的实现。
					>IGMP: 网际组管理协议
						>向相邻 多目路由器 报告多目组成员的协议。多目路由器会将组播数据发送给 组播成员---即用IGMP协议响应了多目路由器进行报告了的计算机。
					>ARP: 地址解析协议
						>动态的将ip地址转为物理地址：网卡地址。
					>RARP: 反向地址解析协议
						>动态的将网卡地址MAC转换为ip地址；
					--ipv4的主要问题：地址空间耗尽、路由表急剧膨胀、缺乏对Qos的支持、本身并不提供任何安全机制、移动性差。引入改进技术：DHCP\NAT\CIDR...所以95年ipv6设计文档已经开发出来。
						>ipv6: 地址空间更大；路由器中一条记录表示一个子网-路由表长度大大减少；组播支持和对流支持，多媒体应用更方便；自动配置--网络管理更方便；安全性更高---网络层数据进行加密；ip报文校验；
							>地址空间：128位。16*8, 8段，每段4个16进制数，冒号分割。压缩表示:: 表示连续的是0，
								>ipv6内嵌ipv4地址：在最后2段，直接用ipv4点分格式表示；
							>地址类型：
								>单播：一对一。目标地址为唯一的ipv6
								>多播：多播组的所有成员都可以接收到，每个成员唯一的ipv6地址；
								>泛播：多个节点同一个泛播地址，发送给一个泛播地址的数据包只会被其中一个收到---类似负载均衡。
						>ipv4/ipv6过渡技术：
							>双协议栈技术：节点对ipv4/ipv6都支持。
							>隧道技术：ipv4网络中部署通道，实现Ipv4网络对ipv6业务的承载；ISATAP隧道；
							>NAT-PT技术：NAT-PT网关实现两种协议的转换翻译和地址的映射；连接ipv4网络和ipv6网络；
					--局域网：
						>数据传输速率高：1000Mbps普遍。
						>误码率低：短距离基带传输；高质量传输媒体；
						>pC为主题：不设主骨干网系统。
						>网络拓扑结构：
							>星型结构：中心是网络交换设备；办公室局域网；
							>总线结构：共享通信线路--如同轴电缆；将节点连接起来；
					--无线局域网：WLAN
						>射频技术取代传输介质如同轴电缆/双绞线：来完成数据传输；网络节点从而任意分布可以；
						>拓扑结构：
							>接入点模式：整个网络使用无线通信，但系统中存在接入点AP；一个接入点覆盖一个业务域；
							>无接入点模式：整个网络无线通信，点对点无线网卡通信；无AP设备。路由和协调控制比较复杂；
						>协议标准：802.11
							>媒体访问控制层：MAC层。采用载波侦听多路访问/冲突避免 协议CSMA/CA 主动避免碰撞的方式解决冲突问题；
							>物理层：2.4GHz ISM频段上的扩频通信方式；2Mbps总传输速率；
					--3G通信：WCDMA...
						>WCDMA: 能架设在GSM上。
						>CDMA 2000: CDMA one升级，建设成本低
						>TD-SCDMA: 频谱利用率、业务支持灵活
					--4G通信：3G+WLAN 传输高质量视频图像 且 图像传输质量 和高清电视不相上下；100Mbps下载；上传20Mbps.DSL和有线电视调制解调器没有覆盖的地方部署。
						>两大方向：
							>LTE: 编解码、帧格式、空口、信令、网络架构 都和以前不同；
								>TD-LTE: 时分双工； OFDM正交频分复用技术。
								>FDD-LTE: 频分双工；最广泛的4G标准；
							>WiMAX: 全球微波互联接入；802.16 
								>工作频段：无需授权的2GHz-66GHz.  
								>传输距离：50公里的无线信号传输距离；
								>覆盖范围：3G发射塔的10倍
								--移动性差：无法满足高速50km/h下的网络的无缝链接。
					--广域网：
						>考虑因素：线路的冗余、带宽的利用、差错处理。
					--网络接入技术：
						>PSTN: 利用电话线拨号接入；64kbps; 将电话线接入调制解调器，计算机也接入调制解调器。
						>ISDN: 电话网络基础上；144kbps;
						>ADSL: 普通电话线连接；下行大于上行速度；8Mbps下行+1.5Mbps上行；分离器额外；
						>FTTx+LAN: 光前通信；传输频带宽；通信容量大；传输损耗小；抗电磁干扰能力强；
							>高速以太网：千兆以太网技术为主干；宽带技术：FTTx+LAN。光纤到路边、小区、楼、楼层、户。
							>无源光纤网络：PON技术。在光分支点安装 简单的光分支器；
								>APON：ATM+PON作为网络协议和平台；上下行采用ATM传输；下行622Mbps,上行155Mbps;光节点到前端--20km可以；
									>拓扑结构：无源双星；时分复用；时分多址；
								>EPON: 下行可达1000Mbps, 上行100Mbps, 传送可变的数据包，最长65535个字节；
						>同轴+光纤：HFC;光纤到小区，光电转换，利用有线电视的总线式同轴电缆连接到用户；	
							>光纤干线网：星型结构。
							>同轴电缆分配网：树形结构。
							--架设：需要CableModerm 电缆调制解调器：无需拨号；随时在线；频分复用+64QAM调制；上行10Mbps
					>网络互联：一般不能直接互联。
						>网络互联设备：为中间设备；实现不同网络之间的协议转换功能；
							>中继器：实现物理层协议转换、电缆之间转换二进制信号；
								>功能：将收到的信号加强后原封不同发送出去；只起到扩展传输距离的作用。只物理层。
							>网桥：实现物理层和数据链路层协议的转换；
								>功能：根据帧物理地址进行网络之间的信息转发(使用相同mac层协议)。只通过mac层的识别而转发。只数据链路层。
							>路由器： 实现网络层和以下各层协议转换；
								>功能：根据包的ip地址进行转发；只网络层工作；且子网使用的相同网络层协议；
							>网关：实现从最底层到传输层或以上各层的协议转换；
								>功能：根据甚至应用层的协议来解析数据拆分包来发送和接收数据组合包反解析为实际数据。此时即便底层跨了异构网络、网络层实现的是不同的协议都可以(可以协议转换)。
							>交换机：
								>2层交换机：多端口的网桥。
								>三层交换机：带路由功能+二层交换机。
								>多层交换机：带协议转换(如网络层协议/传输层协议)的交换机。
							>集线器：多端口的中继器。
							--基于无限网络：
								>无线网卡：
								>无线AP： 接入点。
								>无线网桥：
								>无线路由器：
							--交换技术：相距很远不采用直接点对点连，而是中间节点增加--以便共用，则采用交换技术可以找到终点。
								>电路交换：线路释放前，一对用户占用。
								>报文交换：报文从源点到终点，经过中间节点，中间节点存储转发报文；在转发节点/交换节点：需要缓冲存储、报文排队；因此报文交换不能满足实时通信的需求。
									>不适合交互式通信：较轻和间歇式负载，电路交换是合适的。电话拨号线路承载。
								>分组交换：在交换节点，报文分组发送；
									>虚电路分组交换：传送前设置虚电路。
							--路由技术：
								>内部网关协议：自治系统(同构型网关连接)内的路由选择协议；通常是由一个网络管理中心控制。
									>RIP: 路由信息协议
									>OSPF: 开放式最短路径优先
									>IGRP: 内部网关路由协议
									>EIGRP: 增强型IGRP
								>外部网关协议：两个AS自治系统之间的路由选择协议。选择下一跳的协议。
									>BGP: 边界网关协议：控制路由策略。
								>核心网关协议：AS都连接到主干网络，主干网络中的网关为核心网关---核心网关之间交换路由信息使用的是GGP
									>GGP: 核心网关之间。
								--路由协议算法分类：
									>距离向量协议：计算 网络中所有链路的距离和矢量，来确定最佳路径。协议规定 定期向相邻的路由器发送全部或者部分路由表；
									>链路状态协议：使用 每个路由器的拓扑数据库来创建 路由表--计算最短路径。协议规定 定期向相邻路由器发送网络链路状态信息。
									>平衡型协议：以上二者。
								--网络工程：通过调研 确定 网络建设方案。
									>网络规划：上网人数；地理布局；通信类型；网络容量；性能；
										>服务器数量和位置:
										>客户机的数量和位置：
										>同时访问的数量：
										>每天的用户数：同时访问的数量。
										...
									>网络设计：总体目标、设计原则；
										>网络逻辑结构：
										>网络物理结构：
									>网络实施：
			>网络存储技术：
				>直接附加存储：DAS 不带存储操作系统，通过电缆直接连接到服务器而已。是一种硬件的扩展。
					>影响服务器、数据处理处理和传输能力双双大大降低。宕机时：也会波及存储数据。
				>网络附加存储：NAS 通过网络接口访问存储系统。类似专用的文件服务器。几乎仅仅提供文件系统功能。
					>存储设备与服务器分离；访问协议：NFS/CIFS..容量足但是性能不足。
					>允许客户机与存储设备之间进行直接的数据访问：响应速度快，传输速率高。
				>存储区域网络：SAN
					>通过交换机将多个网络存储设备和服务器相连：将存储设备从以太网中分离出来。
					>访问过程：客户机-->服务器-->交换机-->网络存储设备。
					>访问协议：IP SAN ; FC SAN; IB SAN ; 
						>光纤通道：热插拔性、高速带宽、远程连接、连接设备数量大；昂贵复杂。 接口+连接设备(交换机)+协议。+存储设备+服务器。
			>系统评估：
				>性能指标：
				>指标计算：指标的计算办法
				>性能设计：性能优化
				>性能评估：评价和改进。
				--计算机：
					>主频: hz
					>高速缓存: 级数+容量
					>运算速度: MIPS (主频+核数)、
					>运算精度：直接处理的二进制位数：64位
					>内存：8G
					>存储器的存取周期；完成一次读或者写 所需的时间。连续两次读所需的最短时间 为存储周期。几十ns
					>响应时间：0.1s感觉不到延迟。1s愿意接受。
					...
				--网络：
					>设备级别：吞吐量、延迟、丢包率、转发速度
					>网络级别：船速速率、带宽利用率、平均传输延迟
					>应用级别：QOS\
					>用户级别：可靠性和可用性。吞吐量：100Mbps。网络负载。
				--操作系统： 
					>
				--数据库管理系统：
					>最大事务并发能力：
					>负载均衡能力：
					>最大连接数：
				--web服务器：
					>性能：
					>安全性：
					>最大并发连接数：
				-----指标计算： 
					>MIPS: = Fz*CPI ： Fz主频，CPI=每个时钟周期平均执行的指令条数。
			>负载均衡：
				>DNS负载均衡： 一个名字多个ip，选择一个ip返回；
					>缺点：更改配置后不能立即生效；无法感知服务器状态---负载均衡算法单一；
				>反向代理负载均衡：反向代理本身可能称为瓶颈。优点：可以和缓存结合。额外的安全性；可以采取更多的负载均衡策略。
					>安全性： 
					>缓存使用：
					>负载均衡算法：
				>基于NAT的负载均衡： 基于网络地址转换，---内网地址和外部地址之间的转换：
					>NAT: 可以多个ip外部地址：可以一一映射为内部地址；
						>硬件方式：称为交换。第四层交换机：支持负载均衡的网络地址转换。
						>软件方式：LVS免费软件。其中的NAT实现；中心负载均衡器存在带宽限制；	
				>扩展的负载均衡技术：		
		>软件开发方法：
			>软件生命周期：
				>可行性研究与计划：
					--研究：讨论、抛出、商讨、明确
					>目标: 
					>范围: 
					>风险: 
					>开发成本: 
					--得出：
						>可行性研究报告：
						>软件开发计划：
				>需求分析：软件做成什么样子：第一版
					>
				>概要设计：需求分析的结果：转换 为 技术设计方案。
					--确定：
					>系统架构：架构明细讨论会。抽象到具体的明细过程图。
					>各子系统间的关系：
					>接口规约：
					>数据库模型：
					>编码规范：
				>详细设计：更加具体的情况的明确过程。直接和开发有关了。
				>实现：编码+单元测试。
				>集成测试：集成在一起后测试：流程测试。
				>确认测试：
				>使用和维护：开发新功能也是。
			>软件开发模型：
				>瀑布模型：一个阶段往一个阶段走，阶段之间有明显的界限；
					>面向文档的开发模型：每个阶段，必须产出明确的文档，该阶段的成果文档/分析文档/设计文档/编码。
				>瀑布V模型：改进版本。更强调验证工作。
				--缺点：单向；时间顺序；后面未到的阶段只能等待。慢。文档对客户，大部分文档没意义。
				>演化模型：多次V模型。
					>螺旋模型：需求定义-->风险分析-->工程实现-->评审；；需求评审？
					>增量模型：增量发布；版本迭代。降低了风险，一个个版本的扩充起来。
					>原型法：
				>构建组装模型：	通过接口协作的构件的集合。构件可以新开发，可以利用老的。
					>软件重用的思想：粒度小；但是性能会损失。
				>统一过程：二维：横轴时间：纵轴 各个活动：
					>各个活动分四个阶段：初始、细化、构建、交付。是一种进度把控。项目管理。
					>活动包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理：：：进入项目时间---和退出时间。
					>生命周期：
						>目标里程碑：确定目标
						>架构里程碑：确定架构
						>能力里程碑：确定系统稳定和成熟,alpha测试。
						>发布里程碑：完成系统测试。
				>敏捷方法：经常交付可工作的软件。
					>XP方法：持续集成，小步快走。
					>特征驱动开发：FDD方法。不断交付可运行的软件。
						>核心过程：
							>开发整体对象模型：面向对象业务建模。整体对象模型。领域对象建模。
							>构造特征列表：特征：小的对客户有用的功能；用-动作-结果-目标 来描述；
							>计划特征开发：根据特征的依赖关系，计划安排任务。
							>特征设计：主程 带领特征小组 对特征详细设计；为后面的构建做准备。
							>特征构建：特征实现，反复迭代；完成全部特征的开发。
						>开发和维护复杂产品的框架：Scrum
							>整个开发过程：若干个短的迭代周期组成。称为一个sprint,2-4周。
							>产品backlog: 管理产品的需求。按照商业需求价值排序的需求列表。先开发对客户具有较高价值的。
								>挑选需求：
								>会议讨论、分析估算得到相应的任务列表：sprint backlog
								--开发，交付：产品增量。
								>5个活动：
									>产品待办事项列表：事项级别和升降；事项分解合并；	
									>Sprint计划会议：团队共同理解和选择即将到来的Sprint中要完成的工作；
									>每日Srum会议：上一日Scrum会议到现在，完成了什么，计划完成什么，什么阻碍？，完成Sprint目标；
									>Sprint评审会议：评审sprint的产出；展示当前产品增量情况；以便调整产品待办事项列表。
									>Sprint回顾会议：流程人际关系和工具方面。
					>水晶方法：Cystal Clear 透明水晶方法；小团队，<6人
						>七大体系特征：
							>经常交付：
							>任务依赖：
					>开放式源码：
					>ASD方法：
			>软件重用技术：中间件、应用服务器。
				>利用已有软件元素：建立新系统。
					>源代码重用：
					>架构重用：软件架构风格、设计模式的推广和应用；
					>应用框架的重用：如Spring , 	
					>业务建模的重用：领域建模方法 ；降低领域知识不足的需求风险；
				>构建技术：CORBA,Javabean/ejb/com/DCOM
			>基于架构的软件设计：架构驱动方法.ABSD方法
				>方法的输入：
					>抽象功能需求： 功能需求的抽象描述。公共需求和需求相关的粗略变化的描述。
					>用例：用例分组
					...
				>基于架构的软件开发模型：
					>架构需求：用户对目标系统在指标、功能、设计约束上的期望。获取需求，标识构件。
						>需求获取：系统质量目标；必须的软件功能；
						>生成类图：Rational Rose 自动生成类图。
						>对类进行分组：与其他类隔离的类形成一个组；
						>把类打包成构件：
						>需求评审：
					>架构设计：
						>提出架构模型：
						>映射构件：
						>分析构件相互作用：
						>产生架构：
						>设计评审：
					>架构文档化：架构需求规格说明+测试架构的质量设计说明
					>架构复审：
					>架构实现：
					>架构演化：
			>逆向工程及形式化开发方法：
		>系统规划：描述从项目提出、选择到确定的过程。
			>系统项目的提出和可行性分析：产品开发方向。可行性：技术、经济、成本、环境、收益、政策。
			>系统方案的制定、评价和改进：
				>确定软件架构：
			>新旧系统的分析和比较：
		>系统分析与设计方法：
			>理解问题的本质：
				>因果鱼骨图：类似自顶向下的架构分析/问题分析过程图
				>帕累托图：结果为纵轴，原因为横轴；值为影响度。
			>定义系统的边界：系统和外界的接口。
				>结构化分析：上下文范围图
				>面向对象分析：用例模型。
					>根据每个参与者的功能需求：识别出代表系统功能的用例，从而界定系统的边界。
			>确定系统实现的约束：
				>约束源：进度、投资收益、预算、技术问题
				>需求分析与软件设计：明确用户需求，形成完整清晰的需求说明。
			>系统设计方法：在各个系统目标之间找到一个平衡点。
				>系统目标：功能、性能、健壮性、开发周期、交付日期。
				>平时了解了大量的系统：各种设计的优缺点、局限性了解。
				>好的系统设计: 
					>组件的独立性：高内聚、低耦合。---面向对象设计。
					>例外的识别和处理：使用者不按说明书操作。
					>防错和容错：网络中断、数据库崩溃灾难事件发生时；系统会不会崩溃？。
					--改进：降低复杂性、通过合约进行设计、原型化设计、错误树分析。
					>结构化分析和设计：自顶向下逐层分解；。数据流图--->建立系统逻辑模型(逻辑流程)--->划清人机界限(交互接口/系统边缘)
						>数据流图：输入--处理---存储--输出。
							>最顶层：context图
							>DFD0层：逐层细化；子流程和子流程的边界/IO, 相互关系交界；
						>数据字典：
						>结构化语言：
						>判定表：
						>判定树：
						--软件设计原则：
							>信息屏蔽：内部封闭，暴露使用的接口而已。
							>模块独立性：是否高内聚和低耦合；
					>面向对象的分析与设计：
						>类: 属性-服务方法的抽象封装。实体类、边界类、控制类；
							>实体类：无方法；对数据库表的映射；
							>控制类：对对象的控制行为建模出的类；提供一系列操作实体类的方法；相当于一个面板；
							>边界类：参与者和系统交互的类；窗口、通信协议、打印机接口；
						>继承与泛化：继承与抽象。
						>多态与重载：多态变量、泛型；让类/实例 表现出多态行为；
						>模板类：
						>消息与消息通信：
						--面向对象的分析：OOA/OOD方法
							>标识对象类：
							>标识结构与关联：
							>划分主题：
							>定义属性：
							>定义服务：
							--Booch方法：对象图、状态图、数据流图 
						>统一建模语言：UML
							>文档化语言：
							>构造块：
								>结构事物：
								>行为事物：
								>分组事物：
								>注释事物：
								>关系：
								>图：
									>系统静态结构的静态模型：类图、对象图、包图、构件图、部署图、制品图；
									>系统动态结构的动态模型：对象图、用例图、顺序图、通信图、定时图、状态图、活动图、交互概览图
							>公共机制：逻辑视图、进程视图、实现视图、部署视图、用例视图；
								>时序图：表达行为过程
								>状态图：表达数据变化规则
								>泳道活动图：表达交互过程。对象互动过程。
								>拓扑图：计算节点的拓扑结构和通信路径。
							>架构：
		>软件架构设计：
			>软件抽象层次和表达工具：子程序-->模块化-->面向对象-->框架(黑箱对象，相互嵌入)-->中间件/购买可复用元素
			>时间：需求分析之后，概要设计之前。
			>过程：
				>架构需求：
				>设计：
				>文档化：
				>评审：
				>实现:
				>演化：
			>软件架构5种模型：
				>结构模型：通过结构反映系统重要的语义内容；系统配置、约束、隐含的假设条件、风格、性质；
				>动态模型：
				>过程模型：
				>功能模型：功能组件层次组成，下层向上层提供服务。
				>框架模型：
				--视图模型：
					>逻辑视图：来自问题领域的功能抽象；。通过抽象、封装、继承，用对象模型来表达逻辑视图。类图描述逻辑视图。
					>开发视图：软件的重用性和软件的通用性。
					>进程视图：活动 
					>物理视图：系统拓扑结构；
					>场景：重要系统活动的抽象；
				--软件指标：
					>可靠性：一定时间内无故障运行；可用性：也是。
					>鲁棒性：故障了仍然运行；健壮性和容错性；
					>可伸缩性：扩容能力。
					>可用性：错误避免成为故障措施。
						>错误检测：心跳、消息；网络超时；
						>错误恢复：表决、冗余-切换
						>错误预防：
					>可修改性：运行时注册、配置文件、多态、构件更换	
					>抵抗攻击：动态密码、一次性密码、数字证书-生物识别；
						>用户授权：
						>数据机密性：加密数据和通信链路
						>数据完整性：数据添加校验-哈希值。
			>软件架构风格：架构级别的重用。
				>讨论的问题：
					>设计词汇表是什么？
					>构件和连接件类型是什么?
					>可容许的结构模式是什么？
					>基本的计算模型是什么？
					>风格的基本不变性是什么？
					>其使用的常见例子是什么？
					>使用此风格的优缺点是什么？
					>其常见的特例是什么？
				>风格分类：
					>数据流风格：批处理序列，管道/过滤器。加工过程。从A功能到Z功能-独立平级串联的关系；
						>批处理序列：一批程序；先后顺序一步步执行；
						>管道：一个阶段的输出是另一个阶段的输入；典型的：编译器设计风格；
						>特点：高内聚、低耦合；构架简单，顺序串联；软件重用；软件替换扩展方便；任务并行；
						>缺点：性能下降；
					>调用/返回风格：请求/响应风格；主/子程序；面向对象风格；层次结构；。抽象过程；从基础功能到高级功能；
						>分而治之的策略：复杂大系统分解为提供接口可调用的子系统；
						>面向对象风格：隐藏实现，暴露接口；
						>层次结构：下一层为上一层提供接口调用服务；隐藏实现；不断向上抽象实现；同一个系统的增量层；。。分层通信协议；从底层交互到高层交互；
							>支持基于抽象层次递增的系统设计；把复杂系统按照递增的步骤进行分解；支持功能增强、重用；。。(底层和高层的功能混在一起则不是)
					>独立构件风格：进程通信，事件系统；
						>特征： 每个构件相对独立，互相不直接通信；降低耦合度，灵活性高；
						>进程通信架构风格：构件是独立的进程，连接件是消息传递：点到点-异步同步远程调用；
						>事件系统风格：构件不直接调用一个过程，而是触发一个事件广播一个事件，系统自动调用注册了监听这个事件的所有过程；
							>支持基于事件的隐式调用：编程环境的各种集成工具；。事件注册登记系统；只负责触发，但不关心调用结果？
					>虚拟机风格：解释器，基于规则的系统；
						>构建运行环境、解析和运行自定义的一些语言：增加架构的灵活性；解释器：源代码--解释器-中间数据结构--解释的结果。。。专家系统；
					>仓库风格：数据库系统；超文本系统；黑板系统；
						>数据库系统：中央共享数据源；
						>黑板系统：使得问题的表达、组织和求解变得比较容易？语音和模式识别；
					--经典层次架构风格：
						>C/S架构：后台数据管理，前台用户交互；前后台数据请求和响应；
							>二层：安全性不高；
							>三层：表示层、功能层、数据层；只有表示层放在客户机中，后两层放在服务器中；浏览器--web服务器---数据库服务器；
						>MVC架构风格：基本思想是进行关注点分离；人机交互应用3个关注点：数据可视化、UI处理逻辑、业务逻辑。三者稳定性不同；依次升高；所以不要糅合在一起，而要分开。并采用合理的方式将依赖降到最低；
							>三部分的分工和协作：
								>Model: 应用状态和业务功能的封装：当作 数据和行为的领域模型；
								>View: 可视化界面呈现和捕捉用户的交互操作；
								>Controller: 接收View发送的用户交互操作，并响应；
						>MVP架构风格：MVC中view从model中读取数据；而MVP中从Controler;。。。类似直接请求返回json数据，前端直接负责渲染；
							>使得视图更加清晰：而不是和数据结构耦合，混乱一团。
							>使得controller可以负责更多的视图：因为只负责吐出数据；复用性更高；
					--面向服务的架构：SOA; 封装好可调用接口的服务的集合。
						>独立的各个服务之间：通过总线来交互.
						>服务设计原则:
							>明确定义的接口:长时间稳定的接口
							>自包含和模块化: 封装在业务上稳定\重复出现的活动和构件,独立进行部署\版本控制\自我管理和恢复
							>粗粒度: 依靠消息交互而不是远程过程调用;
							>松耦合: 服务请求者可见的是服务的接口,其当前状态和私有数据对请求者不可见;
						>关键技术:
							>UDDI: 服务发布和查找规范; 数据模型+API+注册服务
							>WSDL: 服务描述语言; 服务接口定义规范;抽象可重用的接口的定义;
							>SOAP: 服务提供者和调用者之间的消息传输规范;XML格式化消息,HTTP承载消息; 应用程序通过网络进行数据交换和远程过程调用;
								>消息应该包含什么内容: 封装+soap头+SOAP体
								>序列化机制:
								>RPC应答协议:
								>底层传输协议:交换SOAP封装的约定;
							>REST: 设计概念和准则. .将网络上的事物当作资源;资源有资源标识;对资源的操作通用4种;操作不改变资源标识;操作是无状态的;	
						>实现: CORBA, DCOM, EJB	
						>实现方式: 
							>web service: 
								>服务提供者:描述和注册服务
								>服务调用者: 发现和调用服务;
								>服务注册中心: 服务提供者发布的地方;服务调用者查找的地方;
								--发布/查找/绑定:	
									>绑定:就是 调用者 发现之后 定位\联系并调用服务;
							>服务注册表:
								>服务注册:
								>服务位置:
								>服务绑定:
							>企业服务总线:消除服务请求者和服务实现者之间的直接连接,从而进一步解耦.
								>
							>微服务: 类似活字印刷术; 每个服务是一个组件,通过编排组合的方式 来使用, 实现 独立\解耦\组件化\以维护\可复用\可替换\高可用\,最终提高交付质量,缩短交付周期.
								>服务专一:
								>通信机制轻量级:
								>松耦合\独立部署:
								--优势:
									>技术异构性: 每个服务可以选择适合自身的技术来实现;
									>弹性: 系统中一部分出故障 会引起多大的问题; ..微服务每个服务内部有内置可用性的解决方案和功能降级方案
									>扩展: 对单个服务进行扩展,而不是整个服务;
									>简化部署: 每个服务独立部署,所以升级迭代更快,更快部署;专门部署;而不是全部都得停下来部署;
									>与组织结构匹配: 避免出现太大的代码库;
									>可组合性: 接口更细化,对外的接口可以更细化;
									>对可替代性的优化: 重写服务很安全,而大系统则很麻烦;
								--劣势:
									>性能\可靠性\数据一致性\成本:
									>运维成本: 部署\配置\日志\监控 都需要独立做;
									>部署自动化: 因为部署更加频繁,则构件自动化部署流水线\降低部署成本\提高部署频率, 是一个挑战;
									>Devops和组织结构: 传递 Devops文化的价值;开发和运维,开发者也要部署和监控,责任更多;
									>服务间依赖测试: 有效的正常工作; 异常检测;
									>服务间依赖管理: 清晰展示服务之间的依赖关系;
				>架构设计: 架构模式
					>演变交付生命周期: 需求--架构-->骨架迭代
					>属性驱动设计法: ADD 	
						>输入: 功能需求\限制条件\质量需求
					>架构文档:
						>视图\元素目录\上下文图\可变性指南\架构背景\术语表\其他信息
					--反向工程:
						>软件架构重构:
				>软件架构评估:	
					>软件对场景的支持程度:
					>ATAM方法: 架构设计满足	系统质量需求的结果 
						>架构表述:从架构文档中提炼 ,简洁可理解的.
						>业务目标的表述: 
						>场景集合捕获质量需求:
						>正面影响和负面影响的各个动作的取舍权衡:
						--步骤:
							>生成质量属性效用树:
					>CBAM: 投资效益评估法
		>设计模式: 提高系统复用性的额外的设计; 更好的复用\移植\维护;..形成的某一类问题的解决方案.GOF..1.创建对象的问题/挑战/困难; 2.使用对象的问题/挑战/困难 (使用单个的挑战:适配/装饰/代理;使用多个的挑战:门面/桥接/组合/享元)3.简化代码流程的挑战(从普通实现到可扩展实现；从重复实现到统一实现通用实现)(消除原代码流程：固定普通模式的代码流程)
			>问题1:创建型:实例的生成: 工厂\单例\建造\原型
			>问题2:结构型:让已经生成的实例满足客户需要/方便使用而新增的工具/中间服务/中间工具:实例的服务: 新增一种结构服务来满足客户需求
						客户需要:															新增中间工具:
				#功能相同但另一种接口方法描述:   					 						适配器 
				#相同方法名但功能仅抽象或简单的方法(需要增强/动态增强?访问控制):  			动态代理器/静态代理器
				#相同方法名增加更多的有用的附加的功能(非继承含义的增强而是包装形式的增强)	装饰器
				#多个维度抽象接口纵横组合简单实现各种类实现的组合生成						桥接器
				#统一的对外接口方法体系(实现与实现之间不互相调用)							门面器(如DAO)
				#组件关系统一对外提供一个整体服务											组合器:
				#串行使用的多个同类对象如何高效对外提供服务									享元器: 池化工具(连接池、线程池)
			>问题3:行为型:给用户提供框架-半成品-统一功能-固定部分(设计有可以扩展的部分)(方便用户二次开发-继续开发)/组织型/指挥对象怎样行为产生一种新的服务的一种组织方法/特殊结构形态的调用链路&调用过程/设计的流程/设计的活动(活动体验),用户直接使用的是这个整体服务--并非为了使用其中某个目标对象;
						  (编码中发现的痛点/编码某个流程/某种功能,发现常规做法的重复/不便/冗余/规律/不通用/不够简洁/麻烦)目标为:实现 流程的简化\编码简化一般化通用化\代写和构造共同的流程(而不必次次专门去实现)\代码的简化
						   xxx场景下实现一个只需要客户做最简最少动作的通用统一服务(能由服务做的事情-服务都做了-且没有副作用);服务方也最少动作/最简单动作/具备扩展结构特征(不改变已有类代码);
							通过方法调用 而不是 修改代码来实现扩展(典型扩展结构:map/filter链/template-abstract-interface/只实现结构部分的框架而非产品服务/list)
						客户需要:																										设计的组织方法/新增中间工具:
				#想一个方法内实现卅/U型调用n个有一个相同方法的k个对象(实现层层过滤效果)														责任链(用户想自己新增的过滤器都能被使用到;用户作为开发者--他在开发过滤器--想直接使用厂商提供的责任链服务)(统一拦截服务)
					(或者说厂商提供了这样一种服务: 可以让用户提供的过滤方法加入到对指定对象的调用拦截之中,即调用前后被执行到--还可以决定调用不调用)		 AOP方法拦截器链/servlet的过滤器链/controller拦截器链
				#客户希望有这样一种服务,客户自己提供"事件"-"回调方法"给它,而服务负责在事件发生时捕捉到并调用客户的"回调方法"				观察者  (统一监听服务)
					(或者说厂商实现了这种事件监听-回调服务: 只要客户注册自己感兴趣的平台能监听的事件+注册回调方法;则用户回调方法就能在事件发生后被调用--即用户被通知到)    订阅-通知/注册-间接&被动监听 
					A对象的状态的变化如何通知其他对象？普通实现则直接依赖其他对象；好的实现则是只依赖一个对象，将变化封装为实体传递给这个对象；这个对象则依赖需要被
					通知的对象，而将消息通知给这些对象。即：消息通知从分散通知改为集中通知。同时增加观察者也会更加方便；同时如果要进行分组也由中间类专门实现一遍即可。
				#客户肯定不想反复实现相同的步骤但又想某些步骤做到灵活,所以厂商提供抽象模板类,固定某个流程,具体步骤的实现交给客户		    模板template
					(厂商提供一个固定模板, 用户只需要实现其中规定的某几个步骤即可使用完整流程的模板方法)
				# 客户原本需要复杂的运算表达编码过程 才能解决一个问题, 看到其中的运算符其实是有限的且运算流程也有规律-语法规律,				解释器interpreter	(统一计算服务)		编写运算的麻烦
					从而想到用户可不可以不用编写具体调用代码--而是按语法规则描述一下这个运算过程,根据这个描述,厂商就能理解解释并				编译器-正则表达式
					做这个描述句子表达的事情.    从而设计出: 提供 符号/变量 等+语法规则, 用户使用这个语法体系来描述运算过程,得到的
					描述结果,直接交给 解释器 即可; 解释器 通过自己的词法分析-语法分析 在上下文记录相关信息, 从而则解释 其含义,
					而执行指定的事情, 最后返回用户执行的结果. 		
				#客户发出请求就可以了,即描述请求封装为一个对象然后发送出去即可, 不必知道真正的执行者,即不必把执行者耦合在自己的代码里.		命令command 	(统一执行服务)			亲自调用执行的麻烦/扩展性低/工作量多
					实现行为请求者和行为执行者解耦,而不是直接调用.-实现了异步. 	厂商规定请求对象的格式,接收,并调用合适的执行器执行.				消息系统-线程执行任务-非阻塞IO
					并将结果放到指定位置.
				#客户开发流程过程中,往往需要撤销修改功能;这是普遍需求;所以开发一个通用数据管理工具;记录用户修改前的状态,并提供恢复方法;     备忘录memento	(统一撤销服务)
					客户不直接字节存储备份,而是传递给第三方的管理者,大家都可以从第三方管理者这里取得合适的希望的备份.							事务回滚\撤销操作	
					客户只需要发出备份/恢复的两个调用,就可以实现备份和恢复的效果.而无需自己亲自查状态和保存状态;交给服务完成;服务将状态保存在数据库/线程TreadLocal/类属性都可能.	
				#集合访问的痛点:对于列表,需要维护整数索引;对于链表要记录上一个对象;对于无序集合/map,则无法直接遍历/整数遍历,需要专门接口;		迭代 iterator (统一集合遍历服务)
					则不如开发统一的遍历接口: 则只一个取元素接口显然不足,无法让元素本身决定是否还有元素.所以还得提供一个判定是否还有元素的接口;
					因此只需要统一实现两个接口方法:是否还有/取下一个元素;.则就可以遍历了;但是以集合实现接口方式,则方法含义不适合.因此让内部类来实现,并且通过统一的集合方法暴露这个内部类实例. 从而统一方法获取到这个2方法接口的实例后,就可以用来遍历集合了.操作也非常简单.
				#假如客户想做某件事情,但是这件事情依赖大量的各种实例,需要自己梳理判定使用哪个实例,显然用户和这些实例耦合太多,客户的负担太重,    中介mediator
					因此需要简化并通用化的服务来辅助完成,显然最简单用户就是依赖一个对象,然后这个对象去做梳理判定的事情,然后内部再选择用哪个
					对象来做具体的事情;这个对象则依赖大量的实例,这样客户只需要依赖这个对象就可以了;因此依赖更简单.
					--各种实例之间互相调用-耦合性太强：将网状调用变为星型调用。(大脑是眼睛鼻子手脚的中介)
																																				MVC中的C就是中介模式.
				#假如客户自己实现一个状态转移过程,普通的在一个类中,定义一个状态,定义一个转移方法,内部用switch根据不同的状态值选择				状态state
					走对应的分支--调用相关的方法;显然,状态一多,这个switch无比冗长;且方法非常多;扩展一个新的状态时需要修改switch+增加方法,
					代价很高;交给服务方如果服务也switch那么没有根本改变;所以修改switch本身,不用它;替代方案,即将每个分支的方法封装到一个对象里,
					显然可以是统一的方法,因此对象类实现统一的接口; 而判定条件为当前状态,显然--状态和处理对象类 是一一对应的等效的;所以用
					处理对象类来替代普通类里的状态属性;将switch里:变量-具体值,类比为 接口-具体实例;则直接调用接口实例方法即可;显然,接口实例
					还必须能修改普通类的状态接口,因此方法上要有普通类参数this;.所以服务方提供统一的:普通类(上下文)+状态类 即可.
																																				订单/工作流
				#假设客户需要根据不同的情况而进行不同的处理;如果放在一个方法里;则必然引进if-else/switch,则导致扩展需要改代码而不是调用          策略strategy
					方法; 代价高;因此不用if-else/switch, 同理将分支处理封装到一个对象类里,显然可以统一方法;入参条件显然不能是这个对象类
					实现的接口--这导致客户端还是要耦合具体对象;因此使用方面还是传递之前的字符串或者枚举;那么映射这个问题,已然不能靠对象本身,
					所以新增一个扩展接口map, 存储枚举字符串--分支对象类接口实例的映射,从而get方式找到接口实例,然后调用普通方法即可。而普通类
					可以对外提供扩展方法，入参为策略类+枚举即k-v参数，实现则放到map里。。从而客户方使用和之前一样，而服务方大大简化。
				#设想要编写一个访问n个对象的方法，且每个对象是不同类的实例，常规方式要分实例不同类型而进行不同处理；则会有if-else出现,			访问者visitor
					显然扩展性差；最简单的显然是直接调用对象自己的“被访问”方法，入参为当前的访问者；然后对象类自己的实现，则是调用访问者的
					访问方法，入参则是对象类实例自己，而访问者的重载方法--包含这个类作为的入参；从而新增一个被访问的类型，则只需要在访问者
					类里增加一个访问这个新类型的访问获取逻辑的方法即可。而新增类也直接同样的实现，而完全没有具体的访问逻辑。这样，用户想要
					扩展，只需要新增类和在访问者接口类新增方法即可；用户扩展性大大增加；对于这套框架(访问者框架)，用户可以直接拿去使用。
		>设计模式与软件架构：有相似性。
			>设计模式：看模式 
			>软件架构：看架构风格
				>风格：分层架构、CS架构、消息总线、面向服务架构；
			--设计模式举例：
				>抽象工厂模式：创建型。抽象工厂类 本身 不依赖具体的工厂，且不依赖 具体的产品；而 调用 具体工厂实例来创建；具体工厂实例 则创建真正的产品--即实现方法是直接new xxx()产品；但是返回的是产品的抽象接口；
				---提高系统维护性和复用性。
		>测试评审方法：
			>测试方法：测试缺陷表现背后的错误
				>测试用例：测试数据+预期结果。
				>单元测试：模块内
				>集成测试： 模块间的接口和通信问题。
				>系统测试：确认测试：软件配置复查。
					>验收测试：AB测试。	a: 开发者在现场；b:开发者不在现场；
				>白盒黑盒测试：
					>白盒测试：逻辑覆盖。语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、组合条件覆盖、路径覆盖。
						>边值分析：
						>错误推测：
			>评审方法：
				>需求评审：各项需求的合适性。
				>概要设计评审；软件概要设计在总体结构、外部接口、主要部件功能分配、全局数据结构..
				>详细设计评审：
				>软件验证和确认评审：
				>功能检查：
				>物理检查：
				>综合检查：
				>管理评审：
			>自动化测试：
				>测试用例的生成：自动化。
		>嵌入式系统设计：
			>单板计算机：微处理器、总线接口、内存、外设
			>软件架构：软件开发方法--交叉平台开发方法。
				>宿主机上开发：目标机上运行。
				>交叉编译器：将用户编写的java程序根据目标机的CPU类型生成包含二进制代码和程序数据的目标文件。输出一个可执行的镜像。	coff/elf文件格式。
			>嵌入式网络：
				>工业自动化：现场总线控制系统把单个分散的测量控制设备变成网络节点，以现场总线为纽带，分散控制设备互相沟通、协同工作。
				>家庭信息网：将家用电器、水、电、气、照明-网络设备、安全设备连接在一起的局域网；	
					>控制子网和数据子网：
				>无线数据通信网：
					>短程无线网：蓝牙,IrDA
					>无线internet:移动无线接入技术--GSM-GPRS; 固定无线接入技术---微波/卫星/无线光传输。
				>嵌入式internet技术：
					>嵌入式设备上集成了Tcp/ip协议栈和相关软件：可作为internet一个节点；分配有ip地址；与internet直接互联。
					>通过网关：接入设备。
			>开发模型：
				>瀑布模型：需求分析、系统设计、编码、测试、维护。
				>逐步求精模型：原型-求精-迭代。
				>层次模型：最高抽象层整体设计--->详细设计。
			>设计模型：
				>时序计算模型：
				>通信进程模型：
				>状态机模型：描述以控制为主的系统
					>状态：输入条件、转移到的状态。有限状态机FSM。状态可以理解为系统处于的形态-行为动作进行中。如电梯-上升/下降/开门/空闲
				>数据流模型：描述数据处理与转换
					>将系统和行为描述为一组节点和边；节点表示变换，边表示数据流向；。输入边和输出边上可以有数据。就像函数计算--输入-计算-输出。例如 (a+b)*(a-b)的数据流模型。如调制-卷积之后的变换，三个函数。节点转任务，边转通道来落地。
				>面向对象模型：UML
				>并发进程模型：最广泛。进程内顺序操作序列；进程之间并发、相互通信、交换数据；
		>开发管理：
			>项目管理成本：资源计划编制、成本估算、成本预算、成本控制：
			>项目时间管理：活动定义、活动排序、活动历时估算、进度计划编制、进度控制。
			>配置管理和文档管理：
			>软件需求管理：
			>项目风险管理：
			>软件的运行和评价：
				>稳定性：一定周期、一定压力，出错的概率。应用和数据库服务器的稳定性。
				>可靠性：用户角度出现了系统故障、系统反应速度慢 就是系统的可靠性问题。	
		>企业资源规划：ERP  企业所有经营和管理的活动的描述和抽象。并进行计算和优化决策。不仅仅是模拟行动，记录行动过程；而且指导行动过程；超越秘书的工作。
			>管理思想：企业内部 供应链 的管理思想。
				>企业的业务流程看作是一个紧密连接的供应链，将企业内部划分成几个相互协同作业的支持子系统；
				>目标：在正确的时间制造和销售正确的产品。
			>软件产品：
			>管理系统：集成的信息系统。包括：人力资源、财务、销售、制造、任务分派和企业供应链。
				>经营系统：
				>市场营销系统：
				>开发管理系统：
				>后勤管理系统：
			--ERP主要功能：
				>支持决策的功能：
				>通用需求：采购、库存、计划、生产、质检、人事、财务。
				>行业特殊需求：电力：输配电-电表的抄费计价；零售：补货、变价、促销；
			--供应链：业务关系紧密、经济利益相连的行业上下游企业。而不止是企业内部业务流程。
				>管理范围：整个行业原材料供应、生产加工、配送环节、流通环节和最终消费者。
				>主要功能模块：物流、资金流、信息流进行全面一体化管理的管理信息系统。
					>生产控制：计划、制造 
					>物流管理：分销、采购、库存管理。
					>财务管理：会计核算、财务管理。
				>客户关系管理：CRM
					>目标：改善企业与客户之间关系的新型管理机制；提供更快捷、更周到的优质的服务。
					>市场营销：商机的产生、获取和管理。
					>客户服务：客服中心。收集客户建议、要求，通过数据分析和挖掘，提供完善的个性化服务。	
						>触发中心：
						>挖掘中心：
				>产品数据管理：PDM
					>企业需求：从工程设计到制造控制系统 缺乏产品数据的统一管理；。项目管理、工程更改、供应商和零部件管理。	
				>供应链管理：从源头供应商到最终消费者的集成业务流程。SCM.从原材料到用户的网络，网络上是信息流、物流、现金流。规划这三大流，并进行计划、组织、协调和控制。	
					>需求管理：预测和协作工具
					>供应链计划；多工厂计划 
					>生产计划：
					>生产调度：
					>配送计划：
					>运输计划：
					--产生原因：信息传递太慢或者错误误导了生产和存货计划。
					--管理的对象：物流。
						>采购物流：
						>生产物流：
						>销售物流：
					--功能：协调供应商、分销商、零售商	
					--运作模式：
						>需求信息流：客户订单、生产计划、采购合同。流向供应方，引发物流。
						>供应信息流：入库单、完工报告单、库存记录、可供销售量、提货发运单；
		>商业智能：企业对商业数据的搜集、管理和分析的系统过程。数据仓库、联机分析处理、数据挖掘。
			>阶段：
				>数据预处理：数据抽取、转换、装载。
				>建立数据仓库：
				>数据分析：联机分析OLAP和数据挖掘。
					>联机分析：数据聚集/汇总，切片、切块、下钻、上卷、旋转。对海量数据进行多维度分析。
				>数据展现：
		>基于中间件的开发：
			>中间件：新层次的基础软件。
				>通信处理中间件：消息中间件。
				>事务处理中间件：OLTP，分布式事务中间件。
				>数据存取管理中间件：
				>web服务器中间件：应用服务器。
					>应用服务器：开发、部署、运行和维护的平台。集群功能。
						>weblogic: 基于Java， 性能和可靠性高。
						>webshpere:	集成DB2,MQSeries
						>sybase: 
					>j2ee规范：
						>定义范围：应用客户端构件、EJB构件、Servlets\jsp\applet构件。多层分布式应用模型。
					>.net规范：制造服务而不是软件。
						>服务以web服务的形式出现：
						>描述和发布web服务：WSDL 。XML定义
						>查找相关服务：DISCO。。XML定义
						>简单对象的传递和调用：SOAP。。XML定义
					>EAI: 企业应用集成。将业务流程、应用软件、硬件和各种标准联合起来，对企业中完成不同业务功能的应用系统进行无缝集成。	
				>安全中间件：
				>跨平台和架构的中间件：
				>专用平台中间件：
				>网络中间件：
		>安全性和保密性设计：信息的保密性、完整性。
			>保密性：不能被无授权访问。
			>完整性：不能被非法改动或者删除。
			>真实性：信息发送者的确认。
			>占有性：存储的节点不被占用。
			>密码学：
				>信息传输过程：明文-->密文-->明文 
				>加密：加密算法+加密密钥。明文-->密文 
				>解密：解密算法+解密密钥。密文-->明文
				--加密密钥=解密密钥： 对称密钥 密码体制。
					>不一定相同：简单关系也是。3DES,IDEA,RC5,AES
					>加密过程：加密密钥生成52子密钥，初始置换52-->迭代16-->逆初始置换52
					>缺点：系统中每两个用户之间就必须要有一个通信密钥。
				--加密密钥!=解密密钥： 公开密钥 密码体制。
					>一定不同：很难计算另一个。RSA，背包密码，Diffe-Hellman,零知识证明算法、椭圆曲线
					>RSA加密解密过程：两个大素数乘积好算，乘积分解为两个大素数不好算；证明一个数是素数好算。分段log2N位，分段加密，分段解密。
					>发送者身份确认：用私钥加密明文(结果为数字签名)发送给对方。保障真实性。
				>散列函数：单向性---；唯一性；可以用来检测报文的可靠性。MD5,SHA,HMAC. MD5---得出的是一个128位的消息摘要。
				>数字签名：签名算法---证明真实性，验证算法---证明有效性；
					>只用 RSA 公私钥 实现计算量太大。所以不能对消息直接私钥加密，而是先MD5生成消息的消息摘要-简短的128位指纹。
					>发送方的数字签名：发送方对 信息 散列运算 得到 散列码/消息摘要，然后用私钥 对 消息摘要 加密 形成。
					>发送方发送：信息+信息的发送方数字签名。		
					>接收方接收：信息+信息的发送方数字签名。然后用公钥 解密 数字签名 得到 消息的散列码/消息摘要； 然后对消息 进行相同的 散列运算 得到 散列码；对比一致，说明信息没有被篡改；具有完整性；一定来自发送方，具有真实性。。缺点：消息明文发送，没有保密性。
				---发送方最好发送什么：自己的私钥加密 后 用对方的公钥加密。保证保密性、真实性。(附带数字签名 则完整性)。。。一定没有被改过，因为只有我能解开看。一定来自它，因为只有它能加密成这样。
				---接收方最好的解密方式： 用自己的私钥解密 后 用 对方的公钥继续解密：得到明文。
				>数字信封：
					>发送方发送：信息对称密钥加密A + 对称加密密钥的接收方公钥加密B
					>接收方接收： 用自己的私钥解密B 得到 对称加密密钥，然后 解密 A 就得到 了原信息。这样保证了信息的加密性 和密钥的安全性。算法不保密，密钥保密。
				>密钥分配中心：KDC
					>系统中每个用户保存：自己的私钥+KDC的公钥PKKDC,  而从KDC获取其他用户的公钥PK, 或者某一次通信可以使用的对称加密密钥。
					>密钥分配过程：
						>A向KDC请求和B通信：这个请求只需要证明是自己发送的即可：即SKA(A,B)
						>KDC响应A的请求：这个请求只能被A查看即可,同时包含用来和B通信的对称密钥 + 发送给B的只有B能看到的(A+K)：即PKA(K,PKB(K,A))
						>A向B发送从KDC收到的PKB(K,A)：
						>B收到后解开：得到K. 从而和A可以通信了。
				>公钥加密体制中：
					>公钥发布方法：必须保证公开密钥的持有者是真实的--而不是谁伪造的。公开密钥如何产生、分发和管理。
						>数字证书：收到解密，发送加密+签名
							>是每个用户身份确认的证据：验证对方的数字证书来确认对方身份的真实性和有效性。解决相互信任的问题。
							>包含： 
								>所有者的：名称+公开密钥 
								>签发者的：名称+数字签名
								>证书本身的：有效期+序列号
						>PKI: 提供公开密钥管理服务。是一套系统：数字证书+证书颁发机构CA	+ 合法性检查验证机构
							>结构模型：
								>管理实体: 服务提供者
									>CA: 发布和撤销证书
									>RA: 处理用户请求
								>端实体：用户 
									>持有者：
									>验证者：
								>证书库：证书+CRL的检索和存放。
									>X.509数字证书：
										>支持多种算法：证书的签名算法RSA/DSA、摘要算法MD5/SHA1；端实体拥有密钥对的类型-RSA密钥/DSA签名密钥/D-H密钥交换密钥、KEA密钥/ECDSA密钥。
										>命名机制：标识持有者和验证者。
										>限制证书使用范围：签名？不可否认？密钥加密？数据加密？密钥协商？证书签发？CRL签发？
										>数据项：
											>版本号：X.509的版本
											>序列号：证书序列号
											>签名算法识别符：指定CA签发 证书使用的公开密钥算法 +HASH算法。(数字签名+散列)
											>发行者名称：CA名称
											>主体名称：证书持有人。
											>主体公开密钥信息：主体的公开密钥+对应算法的标识符+算法相关的参数
											>签名：CA用自己的私钥对上述各个数据项的散列值 进行加密生成的数字签名。
				>网络上安全传输数据的方法：
					>TCP/IP协议没有做安全保护：
						>导致攻击者可以做：网络嗅探、IP欺骗、连接截获。
						>通信危险：数据并非来自合法的发送者、数据传输中被非法篡改、信息内容已经被人窃取。丢失---篡改---非人。
					>网络安全协议：IPSec 
						>网络层的密码技术：向发送者和接收者提供：源地址验证、数据传输的完整性、存取控制、保密性。
						>意义：保护通信免遭窃听、抵御网络攻击。
						>加密：对数据包加密。不改变HTTP等上层协议，而直接对数据包的数据加密，而不对头尾--源地址目的地址端口号CRC校验值等 加密。
						>基本原理：加密后传输，收到后解密。	
						>一套协议：
							>认证头部协议AH: 提供数据的完整性和认证。
								>先将数据校验+加密：后封装为ip包。实现：无连接通信的数据完整性、数据源认证、防止重放攻击。
								>需要改变数据包：IP头和 被保护的数据之间：加一个 AH头。使用MD5迭代型消息摘要算法，防止篡改。。。单向递增的序列号-->确定数据包的合法性-防止重放攻击。
							>封装安全负载协议ESP: 提供保密性。
								>需要改变数据包：IP头和 被保护的数据之间：加一个 ESP头,被保护的数据尾部添加 ESP尾。头内容：SPI+序列号+有效载荷数据。
								>默认加密算法：DES,64位密钥。此外：3DES,AES,RCS,RC6,Blowfish
							>密钥交换协议IKE: 加密算法和密钥等的协商。和用于网络认证及加密的算法等。
								>内容：安全管理和密钥管理协议ISAKMP、密钥确定协议Oakley、快速密钥刷新的密钥交换协议SKEME
						>安全关联：SA,用32位安全参数索引SPI唯一标识	。单向关系。A->B 就需要一个。
							>内容：IP数据包是否加密、认证，采用什么算法，密钥是什么；
							>安全关联 数据库：
						>安全策略：SP. 记录安全通信特征。		
							>安全策略数据库：
						>工作模式：
							>传输模式：IP头和被保护的数据之间增加IPSec头，解密者就是目的地址端的接收者。
							>隧道模式：IP数据包全部加密，然后头部加一个ESP Header, 然后再当作数据再前面加一个新的IP头，形成新的IP数据包。
								>两个终端之间建立一个隧道：安全性较高。
					>SSL：安全传输数据的通信协议。公钥加密体制+对称加密体制，保护信息的机密性和完整性。但不保证信息传输的不可否认性。
						>方面：服务端认证、客户认证。传输层之上，应用层之下，所以HTTP可以透明的建立在SSL基础上。
						>阶段：
							>握手确定密钥：(证书的解密过程 可以形象化为 红框包住 数据项，数据项中的数字签名又等于红框包住的散列值/指纹)。则双方可以对称加密解密通信了。
								>完成加密算法和密钥的协商、服务器认证。
								>服务器认证必须：客户端可以选择认证。客户端也认证 就是双向认证。会话的确认性。
								>通道的可靠性：用MAC对传送的消息进行完整性检查，保证通道上数据的完整性。
						>协议集合：
							>SSL记录协议：所有要传输的数据都封装在记录里；记录头+记录数据；因此 所有的 SSL通信：握手信息-安全空白记录-应用数据 都需要使用SSL记录。
								>记录头格式：记录头长度、记录数据长度。
									>记录头最高位1：不含有粘贴数据。记录头长度为2；记录数据最大长度为32767字节。
									>记录头最高位0：又粘贴数据；记录头长度为3；最大数据长度16383字节；
										>次高位1：所传输的记录是普通记录；
										>次高位0：传输的记录是安全空白记录。
								>记录数据格式：MAC数据+实际数据+粘贴数据。
									>MAC数据：=HASH(密钥、实际数据、粘贴数据、序号)；散列函数：握手协议的消息确定；MD5.。。用于数据完整性检查。序号=每个通信方的自增数。
									>客户端发送数据：密钥=客户的写密钥；自然的，服务端用读密钥验证MAC
									>客户端接收数据：密钥=客户的读密钥；自然的，服务端用写密钥验证MAC
							>SSL握手协议：建立在记录协议之上；用于实际的数据传输之前：双方进行身份认证、协商加密算法、交换加密密钥等；
								>握手过程：
									>建立秘密的通信信道：
									>客户验证：公钥加密算法 来 使得 服务器端身份在客户端得到验证；同时用来传递 会话通信用的对称加密密钥。这样，用公钥加密来保证 对称密钥的保密性，而用对称密钥加密来保证快速的加密减少开销；
										>公开密钥系统选择：RSA
										>密钥交换后密码的选择：RC2/RC4/IDEA/DES/3DES/ 。。消息摘要MD5
							>SSL密码变更说明协议：
							>SSL警告协议：
					>PGP协议：电子邮件加密方案。对邮件加密+增加发送方的数字签名	。扩展为 数据加密程序。
						>邮件内容加密算法：IDEA
						>对称密钥的加密传输：RSA公钥加密算法。
						>加密前：对邮件压缩；
						>数字签名和密钥认证管理机制：
						>加密过程：非常经典；就是一次次 数据包处理+在前面增加处理相关的信息；
							>发送方：
								>第一层处理：M= 邮件+邮件的散列的pka私钥加密即数字签名
								>第二层处理：Q=对M进行zip压缩后IDEA对称加密+ IDEA对称密钥的公钥pkb加密。。。。IDEA密钥随机生成；可以加密后再zip压缩一次？n多次？
								>第三层处理：S=对Q进行BASE编码
						>成熟的加密体系+成熟的密钥管理机制：
							>密钥管理体制：分配使用管理的方案。	
								>公钥：解决了密钥保密问题。但是篡改问题没有。
		>计算机病毒检测清除和防治
		>身份认证和访问控制：
			>对资源的访问操作中 加入拦截：拦截里包含 身份认证和访问控制的逻辑代码：来剔除非法访问、非法操作。
			>用户认证：PIN码，口令，密钥；。。关心：你是谁，你是否拥有你所声明的身份。
				>身份认证方式：
					>口令认证：用户的ID+口令； 先建立安全通道，后发送；看数据库里是否有这个ID+口令；有则通过。
					>基于公钥签名：每次请求都要发送：身份信息+请求信息。用户有：私钥。验证者：有用户的公钥。公钥分发：公钥数据库方式 或者 使用认证机构签发数字证书。公钥数据库：存储用户ID-->用户公钥
					>持卡认证：磁卡-IC卡。存储用户身份。分 不加密的公共区+加密的数据区。
					>基于人体生物特征：广泛-唯一-可采集-稳定。。模式识别。指纹+视网膜
					>动态口令：口令+动态因子 散列函数后生成的动态口令。
					>PPP中的认证：点到点链路上封装网络层协议信息。LCP+NCP
						>验证协议：PAP+CHAP+EAP
						>PPP链路的建立：
							>创建阶段：通过LCP向对方发送配置信息，建立链路。
							>认证阶段：客户端将身份发送给服务端；认证成功转到网络层协商。PAP+CHAP+EAP
							>网络层协商阶段：调用在创建阶段选定的各种NCP 协商 高层协议问题。如向拨入用户分配动态地址。
					>RADIUS协议：
						>UDP传输：1812端口，支持PAP,CHAP,Unix login 认证方法。
			>逻辑访问控制：关心：你能做什么，不能做什么。
				>用户组：每个组有相应的权限；
				>资源组：每个组有一批资源。
				>访问控制体系：
					>主体和客体：主体 是 发出请求的方；客体 是 被访问的对象；
					>访问规则：主体和客体的关系：某个主体对哪些客体 有怎样的访问能力和权限 的 规则配置。
				>访问控制策略：
					>自主访问控制DAC： 某种权限的主体还可以把权限授予其他主体。某个主体名下有资源。安全性不足。
					>强访问控制MAC: 资源机密登记；主体 岗位和可信的程度。。系统统一采用某种访问权限的授予和撤销的策略。
					>基于角色的访问控制RBAC：用户不是资源的拥有者。基于用户的职务 进行访问权限的设置和分配。
				>访问许可的授权：
					>等级型：树型；按职级权限越来越少。
					>拥有型：每个客体有拥有者---对所拥有的客体有全部的控制权。访问控制表。
					>自由型：拥有者可以授权，但是分配出去很难控制。
			>审计和跟踪：跟踪系统的一个或多个运行记录；
			>公共访问控制：避免匿名攻击；采取访问控制措施。	
		>网络安全体系：
			>OSI安全架构：安全应用 --->安全服务--->安全机制
				>5类安全服务：
					>对象认证服务：识别信源的身份。对身份的真实性和有效性进行证实。
					>访问控制服务：访问控制方法前述已毕。
					>数据保密性服务：信息保密、选择段保密、业务流程保密。
					>数据完整性服务：
					>禁止否认服务：
				>8种安全机制：
					>加密机制： 信息加密 
					>数字签名机制： 附带发送数字签名，让接收方确认发送方。
					>访问控制机制：访问规则 来判定 主体 对客体 访问是否合法
					>数据完整性机制：
					>鉴别交换机制：交换信息确认实体的身份。口令、加密、生物特征。
					>流量填充机制：流量中填充混肴随机序列。
					>路由验证机制：安全的路由路径.
					>公正机制：公正机构\权威机构,交换信息.进行仲裁.
				>安全服务和安全机制的联系:
					>二维表格映射对应相关的关系.
			>VPN在网络安全中的应用: 虚拟专用网.
				>端到端的连接服务: 通过 安全隧道技术;通信时, 在internet上传输的信息都是经过RSA不对称加密算法处理后的;密钥则是通过Diffe-Hellman 算法计算得出的.可以充分确保数据通信的安全.
				>异地人员的远程接入:扩充网络方便,配置几个节点,不需要对已经建好的网络 做工程调整.
				>方便的管理:VPN组网, ISP重.
				>支撑技术:
					>安全隧道技术:STF 安全隧道代理+管理中心=安全传输平面STP
					>用户认证: UAF 用户认证管理中心+密钥分配中心=公共功能平面CFP
					>访问控制: ACF
				>建立过程:
					>VPN用户向 向安全隧道代理 请求建立安全 隧道,接受后,在管理中心的控制和管理下 在internet上建立安全隧道
		>系统的安全性设计:	物理安全\防火墙\入侵检测			
			>物理安全问题与设计:
				>网络分隔手段: 防火墙 :
					>包过滤: 网络层和传输层设置规则:控制数据包的进出;从源地址目标地址端口号等方面限制.
					>状态检测: 连接状态表
					>应用网关: 应用层信息包的检测.
				>入侵检测系统: 防止和避免入侵,找出不安全的配置和漏洞,报警拦截和响应.检测攻击前的探测行为和攻击信息.	
		>系统的可靠性分析和设计:		
			>可靠性设计:
			>系统的故障模型:
				>逻辑级别: 电路元器件输入输出有关.如短路开路桥接故障.
				>数据结构级别: 二进制位发生改变
				>软件故障: 只跟设计有关. 如死循环\空间溢出
				>系统故障:输出和设计不一致
			>系统的可靠性模型:
				>时间模型:
				>故障植入模型:
				>数据模型:
			>组合模型可靠性计算: 两个状态
			>马尔可夫模型可靠性计算: 状态和状态转移 .状态转移方程, 来确定 t时候系统处于 x状态的概率.
			>防止故障造成失效:
				>故障掩蔽:
				>系统重组:
				--基础: 资源冗余
					>硬件冗余: 三模冗余 TMR
					>时间冗余:
					>信息冗余: 数据中附加冗余的信息.
						>海明校验码: 增加几个校验位, 就可以检测出 二位同时出错\一位出错并恢复的手段
						>奇偶校验码: CRC循环校验码
					>软件冗余:
			---系统配置方法:
				>容错技术: 系统部分故障差错时仍能工作
					>单机容错技术: 
						>自检技术: 自动发现故障\自动更换和隔离故障部件(到冗余部件)
						>冗余技术: 硬件冗余\软件冗余\时间冗余\信息冗余
							>多元件并联: 但实时只有一个在工作状态;
					>双机热备: 两台服务器系统+外接共享磁盘阵列(或者服务器自带RAID)+双机热备软件....计算和存储分离;程序和数据分离.
						>主备联系: 心跳. 主机系统的心跳
						>工作方式: 
							>双机热备模式: active/standby 前者工作, 后者监控准备;..关键业务,极高稳定性和可用性;7*24小时不间断服务,使用双机热备
							>双机互备模式: 彼此均设置位备机.
							>双机双工模式: 负载均衡和互备;
					>服务器集群:
			>备份与恢复: 从错误状态恢复到某种逻辑一致的状态
				>数据备份: 数据转储 和 建立日志文件..静态转储 和动态转储 
					>脱机备份: 冷备.	
					>连接备份: 热备
		>应用数学:
			>运筹方法:
				>决策论: 管理 就是决策 
					>不确定型决策: 悲观minmax\乐观maxmax\折中\等可能\后悔值maxmin
				>风险决策:	
					>最大期望收益决策准则:
					>最小机会损失决策准则:
				>博弈论:	
			>数据建模: