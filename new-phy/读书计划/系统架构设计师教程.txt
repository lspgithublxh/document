---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>举动-痛点：
	>解法/解决方案：
		>计算机组成与体系结构：
			>总线：分时共享。一个时刻只能一个部件发送指令/数据；地址、控制、数据总线三种；
			>BIOS:基本输入输出程序；
			>磁盘：盘片、盘面、磁头(每个盘面一个，径向运动，且每个磁头一致运动)、磁道(每个面n圈)、柱面(每个盘面的同一个磁道号的磁道；大文件信息优先存同一个柱面的不同磁道，后才是相邻柱面)、扇区(磁道分段,一个扇区存一个定长信息块)、定长信息块(512B)、寻道+旋转盘片
			>Cache: 内存地址-->值   这种映射的存储。存一个区的大小；
			>主存：分区(128)、分页(16)、页内地址(512KB)
			>加速比：就是任务的阶段数。
			>操作系统：5大管理功能。计算机和用户之间的接口。
				>管理计算机各类资源：软硬件资源。
					>进程管理：组织和协调用户程序对cpu的争夺使用；进行分配调度进程到cpu、管理控制进程；最大限度发挥cpu的作用。
						>存在资源共享和并发：就需要调度。
						>进程状态：就绪、运行、阻塞。另外一种：挂起(被交换到了磁盘)
						>互斥与同步：资源对进程互斥--只能同时被一个进程访问；进程同步执行--按顺序执行--一个在执行一个就不在执行；进程同步就可以实现资源对进程的互斥。
							>临界资源：只能同时被一个进程访问的资源。
							>临界区：临界资源如果是一块代码。
							--进程进入临界区的协调规则：没有可进；忙则等待；等待时必须释放cpu资源;多个都想进入必须可以快速决策出；
							--信号量：实现进程同步和互斥。java semphere的实现为对的。对资源加信号量包围:进入资源前执行p操作,退出资源后执行v操作
								>pv操作：p对信号量-1，v对信号量+1(同时唤醒阻塞队列中的一个进程); 信号量>0可以进入临界区，否则必须进入信号量的阻塞队列等待；
							--前驱图: 动作的先后执行和并行执行关系的表达; 谁在谁前面,后面;并行;父在子前,兄弟并行;	
							--调度:调度的是就绪队列里的进程 给 cpu资源;
								>进程调度的触发: 执行完毕;进程阻塞;进程主动唤醒就绪队列中进程;用完时间片;就绪队列某个进程优先级变高;
								>进程调度的算法: 就是选择下一个放到cpu上运行的就绪进程的算法: FIFO,优先级,轮转;
							--死锁的预防和检测: 降低并行程度;事前检测出资源依赖关系--将获取的资源是否被占用的记录图 查看; 银行家算法--但是检测会消耗cpu和时间;检测和处理更好;	
					>存储管理：影响系统性能;对内存的分配和回收;提高内存使用效率;(分区管理-->段页式管理)
						>内存划分:系统空间\用户空间
							>页式管理: 程序的逻辑空间和内存的物理空间按同样大小划分为若干页;以页为单位分配;
								>进程的逻辑页号和内存的物理页号:  系统为每个进程建立 一个页表, 来存储这个 页号映射关系(和状态:是否调入内存);
								>虚拟地址: 页号+位移;(p,d)
								>指令访问虚拟地址(p,d): 即先查p页是否在内存中,在则直接访问页中d位移的内容即可; 没有在内存则产生页中断,装入所需要的页;...... 即虚拟页号-->物理页号-->+偏移量 就找到了物理地址了, 否则页中断,加载页进来;
								--实现虚拟存储器: 作业信息分页存储在磁盘;执行时,加载部分页 进来,如果执行的指令的虚拟地址通过映射表找到的物理页在内存中,则找到偏移处 继续,否则 产生页中断,加载所需页面进来;...映射表就是:页表:存映射\状态(是否在内存/磁盘位置)
									>页面交换: 当需要的页不在内存,而内存无空闲空间,则选择一个页面交换到磁盘,如果这个页面被修改过,那么重新写回磁盘;
										>选择调出的页的算法: 最优算法---将来才使用的页, 随机算法, FIFO--驻留时间最长的; 最近最少使用--LRU
							>段式存储管理: 用户作业逻辑上有意义的划分出的各部分为段; 主程序\子程序\数据段;
								>段表:类似页表.	但段 单位更大;
							>段页式管理: 虚地址形式(s,p,d) ;每个进程一个段表,每个段一个页表;
								>段式分配\页式使用: 便于动态连接 和存储的动态分配;
								>页面交换: 段中部分页面加入内存或者交换出内存;	
						>内存分配算法: 取下一个可用内存小空间的算法:
						>内存的保护和扩充:
					>设备管理：
					>文件管理：
					>作业管理：
				>控制程序的执行：有效地利用资源。
				--为用户提供：命令、菜单、窗口。
				--为应用程序提供：API