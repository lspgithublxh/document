---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	

	
>举动-痛点：
	>解法/解决方案：
		>计算机组成与体系结构：
			>总线：分时共享。一个时刻只能一个部件发送指令/数据；地址、控制、数据总线三种；
			>BIOS:基本输入输出程序；
			>磁盘：盘片、盘面、磁头(每个盘面一个，径向运动，且每个磁头一致运动)、磁道(每个面n圈)、柱面(每个盘面的同一个磁道号的磁道；大文件信息优先存同一个柱面的不同磁道，后才是相邻柱面)、扇区(磁道分段,一个扇区存一个定长信息块)、定长信息块(512B)、寻道+旋转盘片
			>Cache: 内存地址-->值   这种映射的存储。存一个区的大小；
			>主存：分区(128)、分页(16)、页内地址(512KB)
			>加速比：就是任务的阶段数。
			>操作系统：5大管理功能。计算机和用户之间的接口。
				>管理计算机各类资源：软硬件资源。
					>进程管理：组织和协调用户程序对cpu的争夺使用；进行分配调度进程到cpu、管理控制进程；最大限度发挥cpu的作用。
						>存在资源共享和并发：就需要调度。
						>进程状态：就绪、运行、阻塞。另外一种：挂起(被交换到了磁盘)
						>互斥与同步：资源对进程互斥--只能同时被一个进程访问；进程同步执行--按顺序执行--一个在执行一个就不在执行；进程同步就可以实现资源对进程的互斥。
							>临界资源：只能同时被一个进程访问的资源。
							>临界区：临界资源如果是一块代码。
							--进程进入临界区的协调规则：没有可进；忙则等待；等待时必须释放cpu资源;多个都想进入必须可以快速决策出；
							--信号量：实现进程同步和互斥。java semphere的实现为对的。对资源加信号量包围:进入资源前执行p操作,退出资源后执行v操作
								>pv操作：p对信号量-1，v对信号量+1(同时唤醒阻塞队列中的一个进程); 信号量>0可以进入临界区，否则必须进入信号量的阻塞队列等待；
							--前驱图: 动作的先后执行和并行执行关系的表达; 谁在谁前面,后面;并行;父在子前,兄弟并行;	
							--调度:调度的是就绪队列里的进程 给 cpu资源;
								>进程调度的触发: 执行完毕;进程阻塞;进程主动唤醒就绪队列中进程;用完时间片;就绪队列某个进程优先级变高;
								>进程调度的算法: 就是选择下一个放到cpu上运行的就绪进程的算法: FIFO,优先级,轮转;
							--死锁的预防和检测: 降低并行程度;事前检测出资源依赖关系--将获取的资源是否被占用的记录图 查看; 银行家算法--但是检测会消耗cpu和时间;检测和处理更好;	
					>存储管理：影响系统性能;对内存的分配和回收;提高内存使用效率;(分区管理-->段页式管理)
						>内存划分:系统空间\用户空间
							>页式管理: 程序的逻辑空间和内存的物理空间按同样大小划分为若干页;以页为单位分配;
								>进程的逻辑页号和内存的物理页号:  系统为每个进程建立 一个页表, 来存储这个 页号映射关系(和状态:是否调入内存);
								>虚拟地址: 页号+位移;(p,d)
								>指令访问虚拟地址(p,d): 即先查p页是否在内存中,在则直接访问页中d位移的内容即可; 没有在内存则产生页中断,装入所需要的页;...... 即虚拟页号-->物理页号-->+偏移量 就找到了物理地址了, 否则页中断,加载页进来;
								--实现虚拟存储器: 作业信息分页存储在磁盘;执行时,加载部分页 进来,如果执行的指令的虚拟地址通过映射表找到的物理页在内存中,则找到偏移处 继续,否则 产生页中断,加载所需页面进来;...映射表就是:页表:存映射\状态(是否在内存/磁盘位置)
									>页面交换: 当需要的页不在内存,而内存无空闲空间,则选择一个页面交换到磁盘,如果这个页面被修改过,那么重新写回磁盘;
										>选择调出的页的算法: 最优算法---将来才使用的页, 随机算法, FIFO--驻留时间最长的; 最近最少使用--LRU
							>段式存储管理: 用户作业逻辑上有意义的划分出的各部分为段; 主程序\子程序\数据段;
								>段表:类似页表.	但段 单位更大;
							>段页式管理: 虚地址形式(s,p,d) ;每个进程一个段表,每个段一个页表;
								>段式分配\页式使用: 便于动态连接 和存储的动态分配;
								>页面交换: 段中部分页面加入内存或者交换出内存;
								--有查找段表页表的开销;
						>内存分配算法: 取下一个可用内存小空间的算法:
						>内存的保护和扩充:
					>设备管理：除磁盘/mem外的设备,输入输出\终端设备等;外围设备;
						>设备和cpu/mem之间数据传输方式: 速度高\开销小\充分发挥硬件资源能力
							>程序控制方式: 处理器启动 数据传输, 等待 传输完成;
							>中断方式: 进程 启动数据传输, 放弃cpu;传输完成,设备产生中断,中断处理程序 对数据处理后 唤醒相关进程为就绪状态;
							>DMA方式:DMA控制器 窃取 处理器的工作周期和控制总线, +总线浮起, 实现 外设和内存直接数据交换;(外设,一旦上电,就可以输入输出数据了--类似逻辑控制电路+存储的程序)
							>通道方式: IOP, 输入输出处理器, 执行自身的输入输出专用程序 进行 内存和外设的数据传输;
						>虚设备和SPOOLING技术: 假脱机技术,将低速独占设备--->可共享的设备; 一台物理设备 可以 对应 为 多台 虚拟的同类设备;		
					>文件管理：组织\存储\保护数据和程序; 数据和程序以文件形式存储;
						>建立修改删除文件:
						>按文件名访问文件\存放位置\存放形式\存取权限:  保护--避免被破坏;保密--避免未经授权的访问;
						>文件的逻辑结构:
							>无结构的字符流文件;
							>有结构的记录文件: 索引文件\直接文件;
						>文件的物理结构: 提高存储器的利用效率和降低存取时间;
							>分配和传输信息的基本单位: 物理块;按物理块 划分; 文件存储设备的组块策略和文件分配策略;
								>文件分配策略: 
									>顺序分配: 申请连续物理块, 按序存储; 创建即指定长度,不能动态增长;
									>链接分配: 每个物理块有后向指针,指向下一个物理块的地址;形成链接队列; 可以动态增长; 删除其中一个物理块只需要调整前后的指针; 提高存储利用率,但随机访问效率不高;
									>索引分配: 索引表. 文件的逻辑块号和物理块号的映射; 动态增长可以,随机访问也快;  .. 三级索引;  索引表先调入内存,后再根据索引的块号访问物理块;访问磁盘;
							>文件存储设备的管理: 对空闲块的组织和管理
								>空闲块的组织\分配\回收: 管理方法: 索引法\链接法\位示图法 
									>索引法: 空闲块的索引. 空闲区块的索引.
									>链接法: 分配从头取,回收从尾取;
									>位示图法: bitmap 记录文件存储器的使用情况, 每位对应文件存储器上的一个物理块;0/1为空闲和占用;
					>作业管理：
						>作业状态: 提交--作业从输入设备到外存; 后备状态--系统进行作业控制块的创建;执行状态---被作业调度程序选中而分配一定内存,建立进程,变为执行状态;  完成状态--完成;
						>用户接口: os提供给编程人员:API, 设备管理\文件管理\进程控制\进程通信\存储管理;	
				>控制程序的执行：有效地利用资源。
				--为用户提供：命令、菜单、窗口。
				--为应用程序提供：API
		>数据库系统:
			>模式和范式:
				>概念模式: 定义记录\数据项\数据的完整性约束条件,以及记录之间的联系; 全体数据的逻辑结构和特征的描述;
				>外模式: 用户可以看到的那部分数据的逻辑结构;
				>内模式: 定义存储记录的类型,存储域的表示以及存储记录的物理顺序,指引元\索引\存储路径等数据的存储组织;
			>两级独立性:物理独立性和逻辑独立性;
			>数据模型:
				>概念数据模型: ER图
				>基本数据模型: 数据结构\数据操作\完整性约束;
					>层次模型: 树形结构表示	实体类型和实体间的联系;
					>网状模型: 有向图表示实体类型和实体间的关系;
					>关系模型: 表格结构表达实体集; 外键表示实体间的联系;    -- 结构简单清晰; 有数学理论基础; 存取路径好;
					>面向对象模型:
			>关系代数:
				>并\交\差\笛卡尔积\选择\投影\连接\除法:  集合运算;
					>并:结果相并 ,显然要求记录是相同字段和类型的; union
					>交: 记录有主键,有各列值,求列值相同的行分别连接起来,形成新的集合;inner join 
					>差: A记录集合中有的某列的值,B记录集合中某列的值,取只在A中出现的记录;
					>笛卡尔积: A记录集合中每个记录都和B记录集合的每个记录相连接;形成的新的记录的集合;
					>选择: 筛选出记录,条件是 列值满足某种特征,列值和列值满足某种关系的记录,筛选出来;
			>关系模型满足的约束条件: 范式 
				>第一范式:最低的规范化要求. 要求简单域, 属性项不可再分; .. 使得 可以精细查询
				>第二范式: 所有非主属性 都直接只依赖主属性,而不是其他非主属性;..有 那么 会导致数据冗余\更新关系要全部涉及记录都更新\不能独立存储.  ... 比如:人-证书-发证部门;  办法:拆分非依赖主的字段;
				>第三范式: 即便依赖主属性,但是如不是只,即尽管主属性就可以确定B,C列的值,但是B-C自身相关,一对多/多对一, 则也要拆分;...非主属性的列列不能相关;
				---范式可以增强:增删改的速度. 减少了存储;  但是对查询,则需要更多的连接;
				--反范式设计:方便读,如增加冗余列;派生列;
			>数据库设计:
				>需求分析:
				>概念结构设计: ER图
				>逻辑结构设计:
				>物理结构设计:
			>事务管理:
				>并发控制: 并发操作带来的问题:丢失更新\不一致数据\读脏数据;
					>解法: 访问带上两种锁
				>封锁协议: 
					>一级封锁协议: 修改数据前必须带上X锁; 防止丢失更改;
					>二级封锁协议: 读取数据前必须带上S锁--读完就释放; +防止读脏数据;
					>三级封锁协议: 读取数据前必须带上S锁--事务结束前才释放: +防止重复读;	
				>两段锁协议:
					>读写数据之前: 获取封锁;
					>释放一个封锁后: 事务不能再申请和获得任何其他封锁;
				>封锁粒度:
					>属性值:
					>元组:
					>关系:
					>索引项:
					>整个关系数据库:
					>物理页:
					--问题:死锁 
						>死锁避免: 
							>预防法: 一次获取全部的封锁后才开始;或者:封锁对象按序编号-然后必须从小号开始申请(可能会串行等待一定时间);	
							>解除法: 死锁检测程序--检测死锁是否发生; 解锁程序--发现死锁了则开启解锁程序;
				>故障与恢复:
					>事务故障: 未运行至终点 就被撤销;
					>系统故障: 停电\硬件错误\操作系统错误; 事务非正常终止;
					>介质故障: 强磁场干扰;外存数据丢失; 碰撞;
					>计算机病毒: 
					--
					>故障恢复: 转储,登记日志文件;
						>事务故障的恢复: 恢复子系统应该对此事务做撤销处理
							>利用事务日志:进行反向处理.
						>系统故障的恢复: 正向扫描日志,找出故障发生前已经提交的事务, 将事务标记 放到 重做redo队列里; 同时找出 故障发生时 尚未完成的事务,放入撤销undo队列.
							>撤销队列的事务: 撤销处理:反向扫描日志, 对Undo事务的每个操作执行逆操作;
							>对重做队列的各个事务进行重做处理: 正向扫描日志,对每个re'do事务重新执行日志文件登记的操作;
						>介质故障和电脑病毒破坏的修复: 装入数据库后备副本; 使数据库恢复到最近一次转储时的一致性状态; 
							>从故障点开始反向读取日志文件: 找出其中已提交的事务,加入重做队列; 重做事务;
						>具有检查点的恢复技术： 也是从检查点 找到 此时 正在执行的事务，放入撤销undo队列， 再往回找，找到已经提交的事务，放到重做队列；然后分别先后撤销事务的做和重做事务的做；	
				>备份与恢复：
					>数据丢失尽可能少、备份时间和恢复时间尽可能短：
					>物理备份和逻辑备份：
						>物理备份：对数据库数据文件进行备份；
							>冷备份：先停数据库，后cp数据文件到新地方； 当数据库故障时，则将备份的数据复制回来；备份模式
							>热备：一种：不关闭数据库--数据文件备份状态后备份下来；二种--利用备份软件；
							--完全备份：全部备份
							--增量备份：上次完全备份以来的所有修改；
						>逻辑备份：数据库自身的备份工具进行 逻辑概念上的备份--如表、库；
				>分布式数据库：
					>坚固性好： 容忍网络分区；冗余技术；可靠性和可用性；
					>可扩展性： 增减节点；伸缩能力；
					>可改善性能： 就近访问：。减少系统响应时间；
					>自治性好： 分散管理，统一协调；
			>数据仓库：面向主题的操作型数据库，而不是面向事务处理；关注问题和关注对象的区别；
				>大量查询：修改删除少；
				>存储时间长：数年数十年；而不是一般，就几个月十几个月；
				>非实时：但是某个时刻的快照；
				>响应时间慢：秒，分钟，小时；分析很久 而不是实时简单查询；
				>OLAP: 就是数据仓库应用工具；但不是数据仓库；
			>数据挖掘：海量数据收集存储、多处理器并行计算、数据挖掘算法；
				>关联分析：同时出现的不同事情、对象；
				>序列分析：
				>分类分析：用户画像分类。利用神经网络、决策树，数理统计 建立 知识的模型；
		>计算机网络：
			>网络架构：
				>按照信息的传输过程：将网络的整体功能分解为一个个的功能层；
					>同一机器：相邻层通过接口进行信息传递；
					>不同节气：同层之间采用相同的协议；
				>OSI各层：开放系统互连参考模型。低三层--网络通信--为通信子网；高三层--信息处理--为资源子网；
					>物理层：不关心比特的含义，而只关心相邻节点0,1如何发送，接收端如何识别；正确传输和接收0或1(每次都要成功)---但是自身没有重试(0传输失败了不会重试/验证的消耗太大)。是系统和通信介质的接口；系统将信号发送到介质上；或者系统从介质上接收信号--感受介质上的信号(感受信号不断的变化)；
					>数据链路层：关心相邻节点如何无差错传输帧为单位大小的比特流；即有重试；某次某个帧传输失败了，那么重试；而物理层没有重试；其他手段：流量控制和差错控制；从而将不可靠的物理层连接 变成更加可靠的成功率更高的/无差错的数据通道(一次可能会内部重试好几次，所以正确率高)；从而对网络层显现一条可靠的链路；
					>网络层：实现整个通信子网内的连接，(不再仅仅相邻节点),将网络服务数据单元(更长的数据流)从子网的一点到另一点的正确传输；因为会跨多个节点，所以要解决路由转发；拥塞控制；多个网络互联等问题。从而产生了要对节点编号---ip的需求，负责路由的中间节点需要建立路由表的需求；。最开始：是一个编号1，2，3，4；5；如1号要连10号；发现中间隔着4号和5号；10个节点形成了一个图结构；则发现中间节点需要记录其出口线指向的数据范围；。。。。总之，建立了一条跨越多个节点的通信链路---使得数据包可以源源不断从一个节点跨越多个节点而到达另一个节点；这就是网络层的最大作用；
					>传输层：实现可靠的端到端的连接；即有重试；而网络层只专注实现路由功能，并不进行端到端的重试---所以并不可靠；另外，端上可能有多个应用要发送数据，所以还要对应用编号--端口；这样，一个计算机网络端：接收的数据分别放到对应的端口上--让对应的应用程序读取各自的数据---实现并发网络连接的功能；。。从而为高层提供了传输数据的通信端口；从而高层之间传输数据不用考虑和其他应用数据冲突的问题(指定ip对方，port自己的接收槽位即可)；
					>会话层：真正根据应用要发送的数据，而去打开传输通路--开启会话，调用传输层将数据写入进行传输；接收数据，释放连接；。。真正的通信服务代理者--更上层的视角来看这一层；
					>表示层：实现用户信息的格式化表示；传输数据，首先数据要格式化表示--才能被正确识别认识，数据的格式、编码、压缩的具体采取方案，是这一层考虑的方面；实现的是传输的数据的格式映射/信息映射/格式统一映射。。是协议的语法方面；使得被交换的数据在网络上是统一格式的；即便它在不同的端计算机上是各种不同的格式表示；但在传输过程中是共同格式的；
					>应用层：实现对格式化数据的解读(含义)展示问题(应用的事，非操作系统)(实现收集解读零散数据形成应用处理要求具有的表示格式的过程)；实现采集用户输入信息并初步表示 和 收到另一端来的数据并在表示层格式化后得到真正的数据后最终展示在进程里--用户空间里--UI控件里--可视化展示；不同格式的数据有不同的可视化展示：如邮件的展示、聊天消息的展示。
				>TCP/IP结构模型：
					>网络接口层：数据链路层+物理层的对应：基本相邻节点的通信的所有程序的集合
					>网络互联层：将数据报从信源传送到信宿；功能实现；(数据包/只是实现了传输功能)
					>网络传输层：将完整的信息集合从信源传送到信宿；这就是一个数据传输服务了(大文件)；
					>网络应用层：应用层实现的各种数据协议和通信模式，提供各种应用功能；
			>协议：
				>应用层协议：DNS,http。数据格式，含义，通信流程(功能实现的多轮通信过程)。
					>FTP: 客户机和服务器之间建立2条连接；一条传输控制信息，一条传输文件信息；
					>TFTP: 简单文件传输，提供不复杂、开销不大的文件传输服务；不提供存取授权和认证机制；
					>HTTP: 数据格式：页面等, 含义：浏览器可以识别解释；服务实现的多轮通信过程(收-解释-发流程)；请求-响应。浏览器：对页面解释和可视化；而数据-->页面 还需要一个处理过程---这个被称为可视化插件；
					>SMTP: 特定格式邮件数据的解释和可视化程序；	
					>DHCP: ip网络设定数据 由 DHCP服务器集中管理；客户端使用从服务器分配下来的ip环境数据；租约和续约；DHCP分配ip地址的方式：固定分配、动态分配、自动分配。	
					>telnet: 远程登陆一台计算机，并将响应返回。显然，服务端返回的是文件目录，和命令执行的结果。
					>DNS： 和DNS服务器交互的协议，发送域名，响应的是ip;
					>SNMP: 网络管理协议；解决Internet上路由器管理问题；
				>传输层协议：点到点的数据传输，所以需要负责 流量控制、错误校验、排序服务。
					>TCP: 利用ip层的数据包传输功能+重发 而提供一个可靠的、持续连接的全双工的数据传输服务；(功能与服务，就像我会开车和我提供客运服务 的区别一样)
						>场景使用：数据量少，可靠性要求高。
					>UDP: 不可靠无连接，错误检测少, 重试少，因此不可靠，但减少了消耗而速度快；用于传输数据量大，但可靠性要求不高的场景；即尽管传输n次，c次都失败了；
				>网络层协议：处理信息的路由和主机地址的解析。
					>IP: 网际协议。尽力传送。--可能丢失、重复、延迟、乱序。
						>数据分块和重组：来传给物理链路层--一个个帧传输；从而很大的ip数据包可以以较小的分组在网络上传输。而差错检测和流量控制没实现；
						--这一层也可以当作包切割(传输层也有包切割)。如包切割为帧--是ip层做的；而数据链路层：从上层推入的“帧队列”里取出帧(调用发送程序)发送到网络；物理层则是硬件，是一种因果响应--只要一端放上什么信号，另一端就可以接收到什么信号。
						>增加了ip号信息到帧里，才真正使得接收端接收到帧以后，决定从其他端口转发出去并知道这个帧转发到哪个端口。而做了转发这个动作才是ip层真正超越链路层的更高级的新增的独特的功能。
					>ICMP: 网际控制报文协议
						>对ip层传输的数据 进行 避免差错和差错时报告：机制的实现。
					>IGMP: 网际组管理协议
						>向相邻 多目路由器 报告多目组成员的协议。多目路由器会将组播数据发送给 组播成员---即用IGMP协议响应了多目路由器进行报告了的计算机。
					>ARP: 地址解析协议
						>动态的将ip地址转为物理地址：网卡地址。
					>RARP: 反向地址解析协议
						>动态的将网卡地址MAC转换为ip地址；
					--ipv4的主要问题：地址空间耗尽、路由表急剧膨胀、缺乏对Qos的支持、本身并不提供任何安全机制、移动性差。引入改进技术：DHCP\NAT\CIDR...所以95年ipv6设计文档已经开发出来。
						>ipv6: 地址空间更大；路由器中一条记录表示一个子网-路由表长度大大减少；组播支持和对流支持，多媒体应用更方便；自动配置--网络管理更方便；安全性更高---网络层数据进行加密；ip报文校验；
							>地址空间：128位。16*8, 8段，每段4个16进制数，冒号分割。压缩表示:: 表示连续的是0，
								>ipv6内嵌ipv4地址：在最后2段，直接用ipv4点分格式表示；
							>地址类型：
								>单播：一对一。目标地址为唯一的ipv6
								>多播：多播组的所有成员都可以接收到，每个成员唯一的ipv6地址；
								>泛播：多个节点同一个泛播地址，发送给一个泛播地址的数据包只会被其中一个收到---类似负载均衡。
						>ipv4/ipv6过渡技术：
							>双协议栈技术：节点对ipv4/ipv6都支持。
							>隧道技术：ipv4网络中部署通道，实现Ipv4网络对ipv6业务的承载；ISATAP隧道；
							>NAT-PT技术：NAT-PT网关实现两种协议的转换翻译和地址的映射；连接ipv4网络和ipv6网络；
					--局域网：
						>数据传输速率高：1000Mbps普遍。
						>误码率低：短距离基带传输；高质量传输媒体；
						>pC为主题：不设主骨干网系统。
						>网络拓扑结构：
							>星型结构：中心是网络交换设备；办公室局域网；
							>总线结构：共享通信线路--如同轴电缆；将节点连接起来；
					--无线局域网：WLAN
						>射频技术取代传输介质如同轴电缆/双绞线：来完成数据传输；网络节点从而任意分布可以；
						>拓扑结构：
							>接入点模式：整个网络使用无线通信，但系统中存在接入点AP；一个接入点覆盖一个业务域；
							>无接入点模式：整个网络无线通信，点对点无线网卡通信；无AP设备。路由和协调控制比较复杂；
						>协议标准：802.11
							>媒体访问控制层：MAC层。采用载波侦听多路访问/冲突避免 协议CSMA/CA 主动避免碰撞的方式解决冲突问题；
							>物理层：2.4GHz ISM频段上的扩频通信方式；2Mbps总传输速率；
					--3G通信：WCDMA...
						>WCDMA: 能架设在GSM上。
						>CDMA 2000: CDMA one升级，建设成本低
						>TD-SCDMA: 频谱利用率、业务支持灵活
					--4G通信：3G+WLAN 传输高质量视频图像 且 图像传输质量 和高清电视不相上下；100Mbps下载；上传20Mbps.DSL和有线电视调制解调器没有覆盖的地方部署。
						>两大方向：
							>LTE: 编解码、帧格式、空口、信令、网络架构 都和以前不同；
								>TD-LTE: 时分双工； OFDM正交频分复用技术。
								>FDD-LTE: 频分双工；最广泛的4G标准；
							>WiMAX: 全球微波互联接入；802.16 
								>工作频段：无需授权的2GHz-66GHz.  
								>传输距离：50公里的无线信号传输距离；
								>覆盖范围：3G发射塔的10倍
								--移动性差：无法满足高速50km/h下的网络的无缝链接。
					--广域网：
						>考虑因素：线路的冗余、带宽的利用、差错处理。
					--网络接入技术：
						>PSTN: 利用电话线拨号接入；64kbps; 将电话线接入调制解调器，计算机也接入调制解调器。
						>ISDN: 电话网络基础上；144kbps;
						>ADSL: 普通电话线连接；下行大于上行速度；8Mbps下行+1.5Mbps上行；分离器额外；
						>FTTx+LAN: 光前通信；传输频带宽；通信容量大；传输损耗小；抗电磁干扰能力强；
							>高速以太网：千兆以太网技术为主干；宽带技术：FTTx+LAN。光纤到路边、小区、楼、楼层、户。
							>无源光纤网络：PON技术。在光分支点安装 简单的光分支器；
								>APON：ATM+PON作为网络协议和平台；上下行采用ATM传输；下行622Mbps,上行155Mbps;光节点到前端--20km可以；
									>拓扑结构：无源双星；时分复用；时分多址；
								>EPON: 下行可达1000Mbps, 上行100Mbps, 传送可变的数据包，最长65535个字节；
						>同轴+光纤：HFC;光纤到小区，光电转换，利用有线电视的总线式同轴电缆连接到用户；	
							>光纤干线网：星型结构。
							>同轴电缆分配网：树形结构。
							--架设：需要CableModerm 电缆调制解调器：无需拨号；随时在线；频分复用+64QAM调制；上行10Mbps
					>网络互联：一般不能直接互联。
						>网络互联设备：为中间设备；实现不同网络之间的协议转换功能；
							>中继器：实现物理层协议转换、电缆之间转换二进制信号；
								>功能：将收到的信号加强后原封不同发送出去；只起到扩展传输距离的作用。只物理层。
							>网桥：实现物理层和数据链路层协议的转换；
								>功能：根据帧物理地址进行网络之间的信息转发(使用相同mac层协议)。只通过mac层的识别而转发。只数据链路层。
							>路由器： 实现网络层和以下各层协议转换；
								>功能：根据包的ip地址进行转发；只网络层工作；且子网使用的相同网络层协议；
							>网关：实现从最底层到传输层或以上各层的协议转换；
								>功能：根据甚至应用层的协议来解析数据拆分包来发送和接收数据组合包反解析为实际数据。此时即便底层跨了异构网络、网络层实现的是不同的协议都可以(可以协议转换)。
							>交换机：
								>2层交换机：多端口的网桥。
								>三层交换机：带路由功能+二层交换机。
								>多层交换机：带协议转换(如网络层协议/传输层协议)的交换机。
							>集线器：多端口的中继器。
							--基于无限网络：
								>无线网卡：
								>无线AP： 接入点。
								>无线网桥：
								>无线路由器：
							--交换技术：相距很远不采用直接点对点连，而是中间节点增加--以便共用，则采用交换技术可以找到终点。
								>电路交换：线路释放前，一对用户占用。
								>报文交换：报文从源点到终点，经过中间节点，中间节点存储转发报文；在转发节点/交换节点：需要缓冲存储、报文排队；因此报文交换不能满足实时通信的需求。
									>不适合交互式通信：较轻和间歇式负载，电路交换是合适的。电话拨号线路承载。
								>分组交换：在交换节点，报文分组发送；
									>虚电路分组交换：传送前设置虚电路。
							--路由技术：
								>内部网关协议：自治系统(同构型网关连接)内的路由选择协议；通常是由一个网络管理中心控制。
									>RIP: 路由信息协议
									>OSPF: 开放式最短路径优先
									>IGRP: 内部网关路由协议
									>EIGRP: 增强型IGRP
								>外部网关协议：两个AS自治系统之间的路由选择协议。选择下一跳的协议。
									>BGP: 边界网关协议：控制路由策略。
								>核心网关协议：AS都连接到主干网络，主干网络中的网关为核心网关---核心网关之间交换路由信息使用的是GGP
									>GGP: 核心网关之间。
								--路由协议算法分类：
									>距离向量协议：计算 网络中所有链路的距离和矢量，来确定最佳路径。协议规定 定期向相邻的路由器发送全部或者部分路由表；
									>链路状态协议：使用 每个路由器的拓扑数据库来创建 路由表--计算最短路径。协议规定 定期向相邻路由器发送网络链路状态信息。
									>平衡型协议：以上二者。
								--网络工程：通过调研 确定 网络建设方案。
									>网络规划：上网人数；地理布局；通信类型；网络容量；性能；
										>服务器数量和位置:
										>客户机的数量和位置：
										>同时访问的数量：
										>每天的用户数：同时访问的数量。
										...
									>网络设计：总体目标、设计原则；
										>网络逻辑结构：
										>网络物理结构：
									>网络实施：
			>网络存储技术：
				>直接附加存储：DAS 不带存储操作系统，通过电缆直接连接到服务器而已。是一种硬件的扩展。
					>影响服务器、数据处理处理和传输能力双双大大降低。宕机时：也会波及存储数据。
				>网络附加存储：NAS 通过网络接口访问存储系统。类似专用的文件服务器。几乎仅仅提供文件系统功能。
					>存储设备与服务器分离；访问协议：NFS/CIFS..容量足但是性能不足。
					>允许客户机与存储设备之间进行直接的数据访问：响应速度快，传输速率高。
				>存储区域网络：SAN
					>通过交换机将多个网络存储设备和服务器相连：将存储设备从以太网中分离出来。
					>访问过程：客户机-->服务器-->交换机-->网络存储设备。
					>访问协议：IP SAN ; FC SAN; IB SAN ; 
						>光纤通道：热插拔性、高速带宽、远程连接、连接设备数量大；昂贵复杂。 接口+连接设备(交换机)+协议。+存储设备+服务器。
			>系统评估：
				>性能指标：
				>指标计算：指标的计算办法
				>性能设计：性能优化
				>性能评估：评价和改进。
				--计算机：
					>主频: hz
					>高速缓存: 级数+容量
					>运算速度: MIPS (主频+核数)、
					>运算精度：直接处理的二进制位数：64位
					>内存：8G
					>存储器的存取周期；完成一次读或者写 所需的时间。连续两次读所需的最短时间 为存储周期。几十ns
					>响应时间：0.1s感觉不到延迟。1s愿意接受。
					...
				--网络：
					>设备级别：吞吐量、延迟、丢包率、转发速度
					>网络级别：船速速率、带宽利用率、平均传输延迟
					>应用级别：QOS\
					>用户级别：可靠性和可用性。吞吐量：100Mbps。网络负载。
				--操作系统： 
					>
				--数据库管理系统：
					>最大事务并发能力：
					>负载均衡能力：
					>最大连接数：
				--web服务器：
					>性能：
					>安全性：
					>最大并发连接数：
				-----指标计算： 
					>MIPS: = Fz*CPI ： Fz主频，CPI=每个时钟周期平均执行的指令条数。
			>负载均衡：
				>DNS负载均衡： 一个名字多个ip，选择一个ip返回；
					>缺点：更改配置后不能立即生效；无法感知服务器状态---负载均衡算法单一；
				>反向代理负载均衡：反向代理本身可能称为瓶颈。优点：可以和缓存结合。额外的安全性；可以采取更多的负载均衡策略。
					>安全性： 
					>缓存使用：
					>负载均衡算法：
				>基于NAT的负载均衡： 基于网络地址转换，---内网地址和外部地址之间的转换：
					>NAT: 可以多个ip外部地址：可以一一映射为内部地址；
						>硬件方式：称为交换。第四层交换机：支持负载均衡的网络地址转换。
						>软件方式：LVS免费软件。其中的NAT实现；中心负载均衡器存在带宽限制；	
				>扩展的负载均衡技术：		
		>软件开发方法：
			>软件生命周期：
				>可行性研究与计划：
					--研究：讨论、抛出、商讨、明确
					>目标: 
					>范围: 
					>风险: 
					>开发成本: 
					--得出：
						>可行性研究报告：
						>软件开发计划：
				>需求分析：软件做成什么样子：第一版
					>
				>概要设计：需求分析的结果：转换 为 技术设计方案。
					--确定：
					>系统架构：架构明细讨论会。抽象到具体的明细过程图。
					>各子系统间的关系：
					>接口规约：
					>数据库模型：
					>编码规范：
				>详细设计：更加具体的情况的明确过程。直接和开发有关了。
				>实现：编码+单元测试。
				>集成测试：集成在一起后测试：流程测试。
				>确认测试：
				>使用和维护：开发新功能也是。
			>软件开发模型：
				>瀑布模型：一个阶段往一个阶段走，阶段之间有明显的界限；
					>面向文档的开发模型：每个阶段，必须产出明确的文档，该阶段的成果文档/分析文档/设计文档/编码。
				>瀑布V模型：改进版本。更强调验证工作。
				--缺点：单向；时间顺序；后面未到的阶段只能等待。慢。文档对客户，大部分文档没意义。
				>演化模型：多次V模型。
					>螺旋模型：需求定义-->风险分析-->工程实现-->评审；；需求评审？
					>增量模型：增量发布；版本迭代。降低了风险，一个个版本的扩充起来。
					>原型法：
				>构建组装模型：	通过接口协作的构件的集合。构件可以新开发，可以利用老的。
					>软件重用的思想：粒度小；但是性能会损失。
				>统一过程：二维：横轴时间：纵轴 各个活动：
					>各个活动分四个阶段：初始、细化、构建、交付。是一种进度把控。项目管理。
					>活动包括：业务建模、需求、分析设计、实施、测试、部署、配置与变更管理：：：进入项目时间---和退出时间。
					>生命周期：
						>目标里程碑：确定目标
						>架构里程碑：确定架构
						>能力里程碑：确定系统稳定和成熟,alpha测试。
						>发布里程碑：完成系统测试。
				>敏捷方法：经常交付可工作的软件。
					>XP方法：持续集成，小步快走。
					>特征驱动开发：FDD方法。不断交付可运行的软件。
						>核心过程：
							>开发整体对象模型：面向对象业务建模。整体对象模型。领域对象建模。
							>构造特征列表：特征：小的对客户有用的功能；用-动作-结果-目标 来描述；
							>计划特征开发：根据特征的依赖关系，计划安排任务。
							>特征设计：主程 带领特征小组 对特征详细设计；为后面的构建做准备。
							>特征构建：特征实现，反复迭代；完成全部特征的开发。
						>开发和维护复杂产品的框架：Scrum
							>整个开发过程：若干个短的迭代周期组成。称为一个sprint,2-4周。
							>产品backlog: 管理产品的需求。按照商业需求价值排序的需求列表。先开发对客户具有较高价值的。
								>挑选需求：
								>会议讨论、分析估算得到相应的任务列表：sprint backlog
								--开发，交付：产品增量。
								>5个活动：
									>产品待办事项列表：事项级别和升降；事项分解合并；	
									>Sprint计划会议：团队共同理解和选择即将到来的Sprint中要完成的工作；
									>每日Srum会议：上一日Scrum会议到现在，完成了什么，计划完成什么，什么阻碍？，完成Sprint目标；
									>Sprint评审会议：评审sprint的产出；展示当前产品增量情况；以便调整产品待办事项列表。
									>Sprint回顾会议：流程人际关系和工具方面。
					>水晶方法：Cystal Clear 透明水晶方法；小团队，<6人
						>七大体系特征：
							>经常交付：
							>任务依赖：
					>开放式源码：
					>ASD方法：
			>软件重用技术：中间件、应用服务器。
				>利用已有软件元素：建立新系统。
					>源代码重用：
					>架构重用：软件架构风格、设计模式的推广和应用；
					>应用框架的重用：如Spring , 	
					>业务建模的重用：领域建模方法 ；降低领域知识不足的需求风险；
				>构建技术：CORBA,Javabean/ejb/com/DCOM
			>基于架构的软件设计：架构驱动方法.ABSD方法
				>方法的输入：
					>抽象功能需求： 功能需求的抽象描述。公共需求和需求相关的粗略变化的描述。
					>用例：用例分组
					...
				>基于架构的软件开发模型：
					>架构需求：用户对目标系统在指标、功能、设计约束上的期望。获取需求，标识构件。
						>需求获取：系统质量目标；必须的软件功能；
						>生成类图：Rational Rose 自动生成类图。
						>对类进行分组：与其他类隔离的类形成一个组；
						>把类打包成构件：
						>需求评审：
					>架构设计：
						>提出架构模型：
						>映射构件：
						>分析构件相互作用：
						>产生架构：
						>设计评审：
					>架构文档化：架构需求规格说明+测试架构的质量设计说明
					>架构复审：
					>架构实现：
					>架构演化：
			>逆向工程及形式化开发方法：
		>系统规划：描述从项目提出、选择到确定的过程。
			>系统项目的提出和可行性分析：产品开发方向。可行性：技术、经济、成本、环境、收益、政策。
			>系统方案的制定、评价和改进：
				>确定软件架构：
			>新旧系统的分析和比较：
		>系统分析与设计方法：
			>理解问题的本质：
				>因果鱼骨图：类似自顶向下的架构分析/问题分析过程图
				>帕累托图：结果为纵轴，原因为横轴；值为影响度。
			>定义系统的边界：系统和外界的接口。
				>结构化分析：上下文范围图
				>面向对象分析：用例模型。
					>根据每个参与者的功能需求：识别出代表系统功能的用例，从而界定系统的边界。
			>确定系统实现的约束：
				>约束源：进度、投资收益、预算、技术问题
				>需求分析与软件设计：明确用户需求，形成完整清晰的需求说明。
			>系统设计方法：在各个系统目标之间找到一个平衡点。
				>系统目标：功能、性能、健壮性、开发周期、交付日期。
				>平时了解了大量的系统：各种设计的优缺点、局限性了解。
				>好的系统设计: 
					>组件的独立性：高内聚、低耦合。---面向对象设计。
					>例外的识别和处理：使用者不按说明书操作。
					>防错和容错：网络中断、数据库崩溃灾难事件发生时；系统会不会崩溃？。
					--改进：降低复杂性、通过合约进行设计、原型化设计、错误树分析。
					>结构化分析和设计：自顶向下逐层分解；。数据流图--->建立系统逻辑模型(逻辑流程)--->划清人机界限(交互接口/系统边缘)
						>数据流图：输入--处理---存储--输出。
							>最顶层：context图
							>DFD0层：逐层细化；子流程和子流程的边界/IO, 相互关系交界；
						>数据字典：
						>结构化语言：
						>判定表：
						>判定树：
						--软件设计原则：
							>信息屏蔽：内部封闭，暴露使用的接口而已。
							>模块独立性：是否高内聚和低耦合；
					>面向对象的分析与设计：
						>类: 属性-服务方法的抽象封装。实体类、边界类、控制类；
							>实体类：无方法；对数据库表的映射；
							>控制类：对对象的控制行为建模出的类；提供一系列操作实体类的方法；相当于一个面板；
							>边界类：参与者和系统交互的类；窗口、通信协议、打印机接口；
						>继承与泛化：继承与抽象。
						>多态与重载：多态变量、泛型；让类/实例 表现出多态行为；
						>模板类：
						>消息与消息通信：
						--面向对象的分析：OOA/OOD方法
							>标识对象类：
							>标识结构与关联：
							>划分主题：
							>定义属性：
							>定义服务：
							--Booch方法：对象图、状态图、数据流图 
						>统一建模语言：UML
							>文档化语言：
							>构造块：
								>结构事物：
								>行为事物：
								>分组事物：
								>注释事物：
								>关系：
								>图：
									>系统静态结构的静态模型：类图、对象图、包图、构件图、部署图、制品图；
									>系统动态结构的动态模型：对象图、用例图、顺序图、通信图、定时图、状态图、活动图、交互概览图
							>公共机制：逻辑视图、进程视图、实现视图、部署视图、用例视图；
								>时序图：表达行为过程
								>状态图：表达数据变化规则
								>泳道活动图：表达交互过程。对象互动过程。
								>拓扑图：计算节点的拓扑结构和通信路径。
							>架构：
		>软件架构设计：
			>软件抽象层次和表达工具：子程序-->模块化-->面向对象-->框架(黑箱对象，相互嵌入)-->中间件/购买可复用元素
			>时间：需求分析之后，概要设计之前。
			>过程：
				>架构需求：
				>设计：
				>文档化：
				>评审：
				>实现:
				>演化：
			>软件架构5种模型：
				>结构模型：通过结构反映系统重要的语义内容；系统配置、约束、隐含的假设条件、风格、性质；
				>动态模型：
				>过程模型：
				>功能模型：功能组件层次组成，下层向上层提供服务。
				>框架模型：
				--视图模型：
					>逻辑视图：来自问题领域的功能抽象；。通过抽象、封装、继承，用对象模型来表达逻辑视图。类图描述逻辑视图。
					>开发视图：软件的重用性和软件的通用性。
					>进程视图：活动 
					>物理视图：系统拓扑结构；
					>场景：重要系统活动的抽象；
				--软件指标：
					>可靠性：一定时间内无故障运行；可用性：也是。
					>鲁棒性：故障了仍然运行；健壮性和容错性；
					>可伸缩性：扩容能力。
					>可用性：错误避免成为故障措施。
						>错误检测：心跳、消息；网络超时；
						>错误恢复：表决、冗余-切换
						>错误预防：
					>可修改性：运行时注册、配置文件、多态、构件更换	
					>抵抗攻击：动态密码、一次性密码、数字证书-生物识别；
						>用户授权：
						>数据机密性：加密数据和通信链路
						>数据完整性：数据添加校验-哈希值。
			>软件架构风格：架构级别的重用。
				>讨论的问题：
					>设计词汇表是什么？
					>构件和连接件类型是什么?
					>可容许的结构模式是什么？
					>基本的计算模型是什么？
					>风格的基本不变性是什么？
					>其使用的常见例子是什么？
					>使用此风格的优缺点是什么？
					>其常见的特例是什么？
				>风格分类：
					>数据流风格：批处理序列，管道/过滤器。加工过程。从A功能到Z功能-独立平级串联的关系；
						>批处理序列：一批程序；先后顺序一步步执行；
						>管道：一个阶段的输出是另一个阶段的输入；典型的：编译器设计风格；
						>特点：高内聚、低耦合；构架简单，顺序串联；软件重用；软件替换扩展方便；任务并行；
						>缺点：性能下降；
					>调用/返回风格：请求/响应风格；主/子程序；面向对象风格；层次结构；。抽象过程；从基础功能到高级功能；
						>分而治之的策略：复杂大系统分解为提供接口可调用的子系统；
						>面向对象风格：隐藏实现，暴露接口；
						>层次结构：下一层为上一层提供接口调用服务；隐藏实现；不断向上抽象实现；同一个系统的增量层；。。分层通信协议；从底层交互到高层交互；
							>支持基于抽象层次递增的系统设计；把复杂系统按照递增的步骤进行分解；支持功能增强、重用；。。(底层和高层的功能混在一起则不是)
					>独立构件风格：进程通信，事件系统；
						>特征： 每个构件相对独立，互相不直接通信；降低耦合度，灵活性高；
						>进程通信架构风格：构件是独立的进程，连接件是消息传递：点到点-异步同步远程调用；
						>事件系统风格：构件不直接调用一个过程，而是触发一个事件广播一个事件，系统自动调用注册了监听这个事件的所有过程；
							>支持基于事件的隐式调用：编程环境的各种集成工具；。事件注册登记系统；只负责触发，但不关心调用结果？
					>虚拟机风格：解释器，基于规则的系统；
						>构建运行环境、解析和运行自定义的一些语言：增加架构的灵活性；解释器：源代码--解释器-中间数据结构--解释的结果。。。专家系统；
					>仓库风格：数据库系统；超文本系统；黑板系统；
						>数据库系统：中央共享数据源；
						>黑板系统：使得问题的表达、组织和求解变得比较容易？语音和模式识别；
					--经典层次架构风格：
						>C/S架构：后台数据管理，前台用户交互；前后台数据请求和响应；
							>二层：安全性不高；
							>三层：表示层、功能层、数据层；只有表示层放在客户机中，后两层放在服务器中；浏览器--web服务器---数据库服务器；
						>MVC架构风格：基本思想是进行关注点分离；人机交互应用3个关注点：数据可视化、UI处理逻辑、业务逻辑。三者稳定性不同；依次升高；所以不要糅合在一起，而要分开。并采用合理的方式将依赖降到最低；
							>三部分的分工和协作：
								>Model: 应用状态和业务功能的封装：当作 数据和行为的领域模型；
								>View: 可视化界面呈现和捕捉用户的交互操作；
								>Controller: 接收View发送的用户交互操作，并响应；
						>MVP架构风格：MVC中view从model中读取数据；而MVP中从Controler;。。。类似直接请求返回json数据，前端直接负责渲染；
							>使得视图更加清晰：而不是和数据结构耦合，混乱一团。
							>使得controller可以负责更多的视图：因为只负责吐出数据；复用性更高；
					--面向服务的架构：SOA; 封装好可调用接口的服务的集合。
						>独立的各个服务之间：通过总线来交互.
						>服务设计原则:
							>明确定义的接口:长时间稳定的接口
							>自包含和模块化: 封装在业务上稳定\重复出现的活动和构件,独立进行部署\版本控制\自我管理和恢复
							>粗粒度: 依靠消息交互而不是远程过程调用;
							>松耦合: 服务请求者可见的是服务的接口,其当前状态和私有数据对请求者不可见;
						>关键技术:
							>UDDI: 服务发布和查找规范; 数据模型+API+注册服务
							>WSDL: 服务描述语言; 服务接口定义规范;抽象可重用的接口的定义;
							>SOAP: 服务提供者和调用者之间的消息传输规范;XML格式化消息,HTTP承载消息; 应用程序通过网络进行数据交换和远程过程调用;
								>消息应该包含什么内容: 封装+soap头+SOAP体
								>序列化机制:
								>RPC应答协议:
								>底层传输协议:交换SOAP封装的约定;
							>REST: 设计概念和准则. .将网络上的事物当作资源;资源有资源标识;对资源的操作通用4种;操作不改变资源标识;操作是无状态的;	
						>实现: CORBA, DCOM, EJB	
						>实现方式: 
							>web service: 
								>服务提供者:描述和注册服务
								>服务调用者: 发现和调用服务;
								>服务注册中心: 服务提供者发布的地方;服务调用者查找的地方;
								--发布/查找/绑定:	
									>绑定:就是 调用者 发现之后 定位\联系并调用服务;
							>服务注册表:
								>服务注册:
								>服务位置:
								>服务绑定:
							>企业服务总线:消除服务请求者和服务实现者之间的直接连接,从而进一步解耦.
								>
							>微服务: 类似活字印刷术; 每个服务是一个组件,通过编排组合的方式 来使用, 实现 独立\解耦\组件化\以维护\可复用\可替换\高可用\,最终提高交付质量,缩短交付周期.
								>服务专一:
								>通信机制轻量级:
								>松耦合\独立部署:
								--优势:
									>技术异构性: 每个服务可以选择适合自身的技术来实现;
									>弹性: 系统中一部分出故障 会引起多大的问题; ..微服务每个服务内部有内置可用性的解决方案和功能降级方案
									>扩展: 对单个服务进行扩展,而不是整个服务;
									>简化部署: 每个服务独立部署,所以升级迭代更快,更快部署;专门部署;而不是全部都得停下来部署;
									>与组织结构匹配: 避免出现太大的代码库;
									>可组合性: 接口更细化,对外的接口可以更细化;
									>对可替代性的优化: 重写服务很安全,而大系统则很麻烦;
								--劣势:
									>性能\可靠性\数据一致性\成本:
									>运维成本: 部署\配置\日志\监控 都需要独立做;
									>部署自动化: 因为部署更加频繁,则构件自动化部署流水线\降低部署成本\提高部署频率, 是一个挑战;
									>Devops和组织结构: 传递 Devops文化的价值;开发和运维,开发者也要部署和监控,责任更多;
									>服务间依赖测试: 有效的正常工作; 异常检测;
									>服务间依赖管理: 清晰展示服务之间的依赖关系;
				>架构设计: 架构模式
					>演变交付生命周期: 需求--架构-->骨架迭代
					>属性驱动设计法: ADD 	
						>输入: 功能需求\限制条件\质量需求
					>架构文档:
						>视图\元素目录\上下文图\可变性指南\架构背景\术语表\其他信息
					--反向工程:
						>软件架构重构:
				>软件架构评估:	
					>软件对场景的支持程度:
					>ATAM方法: 架构设计满足	系统质量需求的结果 
						>架构表述:从架构文档中提炼 ,简洁可理解的.
						>业务目标的表述: 
						>场景集合捕获质量需求:
						>正面影响和负面影响的各个动作的取舍权衡:
						--步骤:
							>生成质量属性效用树:
					>CBAM: 投资效益评估法
		>设计模式: 提高系统复用性的额外的设计; 更好的复用\移植\维护;..形成的某一类问题的解决方案.GOF..1.创建对象的问题/挑战/困难; 2.使用对象的问题/挑战/困难 (使用单个的挑战:适配/装饰/代理;使用多个的挑战:门面/桥接/组合/享元)
			>问题1:创建型:实例的生成: 工厂\单例\建造\原型
			>问题2:结构型:让已经生成的实例满足客户需要/方便使用而新增的工具/中间服务/中间工具:实例的服务: 新增一种结构服务来满足客户需求
						客户需要:															新增中间工具:
				#功能相同但另一种接口方法描述:   					 						适配器 
				#相同方法名但功能仅抽象或简单的方法(需要增强/动态增强?访问控制):  			动态代理器/静态代理器
				#相同方法名增加更多的有用的附加的功能										装饰器
				#多个维度抽象接口纵横组合简单实现各种类实现的组合生成						桥接器
				#门面器
				#组合器:
				#享元器:
			>问题3:行为型:给用户提供框架-半成品-统一功能-固定部分(设计有可以扩展的部分)(方便用户二次开发-继续开发)/组织型/指挥对象怎样行为产生一种新的服务的一种组织方法/特殊结构形态的调用链路&调用过程/设计的流程/设计的活动(活动体验),用户直接使用的是这个整体服务--并非为了使用其中某个目标对象;
						  (编码中发现的痛点/编码某个流程/某种功能,发现的重复/不便/冗余/规律/不通用/不够简洁)目标为:实现 流程的简化\代写和构造共同的流程(而不必次次专门去实现)\代码的简化
						客户需要:																										设计的组织方法/新增中间工具:
				#想一个方法内实现卅/U型调用n个有一个相同方法的k个对象(实现层层过滤效果)														责任链(用户想自己新增的过滤器都能被使用到;用户作为开发者--他在开发过滤器--想直接使用厂商提供的责任链服务)
					(或者说厂商提供了这样一种服务: 可以让用户提供的过滤方法加入到对指定对象的调用拦截之中,即调用前后被执行到--还可以决定调用不调用)		 AOP方法拦截器链/servlet的过滤器链/controller拦截器链
				#客户希望有这样一种服务,客户自己提供"事件"-"回调方法"给它,而服务负责在事件发生时捕捉到并调用客户的"回调方法"				观察者
					(或者说厂商实现了这种事件监听-回调服务: 只要客户注册自己感兴趣的平台能监听的事件+注册回调方法;则用户回调方法就能在事件发生后被调用--即用户被通知到)    订阅-通知/注册-间接&被动监听 
				#客户肯定不想反复实现相同的步骤但又想某些步骤做到灵活,所以厂商提供抽象模板类,固定某个流程,具体步骤的实现交给客户		    模板template
					(厂商提供一个固定模板, 用户只需要实现其中规定的某几个步骤即可使用完整流程的模板方法)
				# 客户原本需要复杂运算表达编码过程 才能解决一个问题, 看到其中的运算符其实是有限的且运算流程也有规律-语法规律,				解释器interpreter
					从而想到用户可不可以不用编写具体调用代码--而是按语法规则描述一下这个运算过程,根据这个描述,厂商就能理解解释并
					做这个描述句子表达的事情.    从而设计出: 提供 符号/变量 等+语法规则, 用户使用这个语法体系来描述运算过程,得到的
					描述结果,直接交给 解释器 即可; 解释器 通过自己的词法分析-语法分析 在上下文记录相关信息, 从而则解释 其含义,
					而执行指定的事情, 最后返回用户执行的结果. 		
				#命令command 
				#备忘录memento
				#迭代 iterator
				#中介mediator
				#状态state
				#策略strategy
				#访问者visitor
				