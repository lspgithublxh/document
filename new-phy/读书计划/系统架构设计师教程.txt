---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	

	
>举动-痛点：
	>解法/解决方案：
		>计算机组成与体系结构：
			>总线：分时共享。一个时刻只能一个部件发送指令/数据；地址、控制、数据总线三种；
			>BIOS:基本输入输出程序；
			>磁盘：盘片、盘面、磁头(每个盘面一个，径向运动，且每个磁头一致运动)、磁道(每个面n圈)、柱面(每个盘面的同一个磁道号的磁道；大文件信息优先存同一个柱面的不同磁道，后才是相邻柱面)、扇区(磁道分段,一个扇区存一个定长信息块)、定长信息块(512B)、寻道+旋转盘片
			>Cache: 内存地址-->值   这种映射的存储。存一个区的大小；
			>主存：分区(128)、分页(16)、页内地址(512KB)
			>加速比：就是任务的阶段数。
			>操作系统：5大管理功能。计算机和用户之间的接口。
				>管理计算机各类资源：软硬件资源。
					>进程管理：组织和协调用户程序对cpu的争夺使用；进行分配调度进程到cpu、管理控制进程；最大限度发挥cpu的作用。
						>存在资源共享和并发：就需要调度。
						>进程状态：就绪、运行、阻塞。另外一种：挂起(被交换到了磁盘)
						>互斥与同步：资源对进程互斥--只能同时被一个进程访问；进程同步执行--按顺序执行--一个在执行一个就不在执行；进程同步就可以实现资源对进程的互斥。
							>临界资源：只能同时被一个进程访问的资源。
							>临界区：临界资源如果是一块代码。
							--进程进入临界区的协调规则：没有可进；忙则等待；等待时必须释放cpu资源;多个都想进入必须可以快速决策出；
							--信号量：实现进程同步和互斥。java semphere的实现为对的。对资源加信号量包围:进入资源前执行p操作,退出资源后执行v操作
								>pv操作：p对信号量-1，v对信号量+1(同时唤醒阻塞队列中的一个进程); 信号量>0可以进入临界区，否则必须进入信号量的阻塞队列等待；
							--前驱图: 动作的先后执行和并行执行关系的表达; 谁在谁前面,后面;并行;父在子前,兄弟并行;	
							--调度:调度的是就绪队列里的进程 给 cpu资源;
								>进程调度的触发: 执行完毕;进程阻塞;进程主动唤醒就绪队列中进程;用完时间片;就绪队列某个进程优先级变高;
								>进程调度的算法: 就是选择下一个放到cpu上运行的就绪进程的算法: FIFO,优先级,轮转;
							--死锁的预防和检测: 降低并行程度;事前检测出资源依赖关系--将获取的资源是否被占用的记录图 查看; 银行家算法--但是检测会消耗cpu和时间;检测和处理更好;	
					>存储管理：影响系统性能;对内存的分配和回收;提高内存使用效率;(分区管理-->段页式管理)
						>内存划分:系统空间\用户空间
							>页式管理: 程序的逻辑空间和内存的物理空间按同样大小划分为若干页;以页为单位分配;
								>进程的逻辑页号和内存的物理页号:  系统为每个进程建立 一个页表, 来存储这个 页号映射关系(和状态:是否调入内存);
								>虚拟地址: 页号+位移;(p,d)
								>指令访问虚拟地址(p,d): 即先查p页是否在内存中,在则直接访问页中d位移的内容即可; 没有在内存则产生页中断,装入所需要的页;...... 即虚拟页号-->物理页号-->+偏移量 就找到了物理地址了, 否则页中断,加载页进来;
								--实现虚拟存储器: 作业信息分页存储在磁盘;执行时,加载部分页 进来,如果执行的指令的虚拟地址通过映射表找到的物理页在内存中,则找到偏移处 继续,否则 产生页中断,加载所需页面进来;...映射表就是:页表:存映射\状态(是否在内存/磁盘位置)
									>页面交换: 当需要的页不在内存,而内存无空闲空间,则选择一个页面交换到磁盘,如果这个页面被修改过,那么重新写回磁盘;
										>选择调出的页的算法: 最优算法---将来才使用的页, 随机算法, FIFO--驻留时间最长的; 最近最少使用--LRU
							>段式存储管理: 用户作业逻辑上有意义的划分出的各部分为段; 主程序\子程序\数据段;
								>段表:类似页表.	但段 单位更大;
							>段页式管理: 虚地址形式(s,p,d) ;每个进程一个段表,每个段一个页表;
								>段式分配\页式使用: 便于动态连接 和存储的动态分配;
								>页面交换: 段中部分页面加入内存或者交换出内存;
								--有查找段表页表的开销;
						>内存分配算法: 取下一个可用内存小空间的算法:
						>内存的保护和扩充:
					>设备管理：除磁盘/mem外的设备,输入输出\终端设备等;外围设备;
						>设备和cpu/mem之间数据传输方式: 速度高\开销小\充分发挥硬件资源能力
							>程序控制方式: 处理器启动 数据传输, 等待 传输完成;
							>中断方式: 进程 启动数据传输, 放弃cpu;传输完成,设备产生中断,中断处理程序 对数据处理后 唤醒相关进程为就绪状态;
							>DMA方式:DMA控制器 窃取 处理器的工作周期和控制总线, +总线浮起, 实现 外设和内存直接数据交换;(外设,一旦上电,就可以输入输出数据了--类似逻辑控制电路+存储的程序)
							>通道方式: IOP, 输入输出处理器, 执行自身的输入输出专用程序 进行 内存和外设的数据传输;
						>虚设备和SPOOLING技术: 假脱机技术,将低速独占设备--->可共享的设备; 一台物理设备 可以 对应 为 多台 虚拟的同类设备;		
					>文件管理：组织\存储\保护数据和程序; 数据和程序以文件形式存储;
						>建立修改删除文件:
						>按文件名访问文件\存放位置\存放形式\存取权限:  保护--避免被破坏;保密--避免未经授权的访问;
						>文件的逻辑结构:
							>无结构的字符流文件;
							>有结构的记录文件: 索引文件\直接文件;
						>文件的物理结构: 提高存储器的利用效率和降低存取时间;
							>分配和传输信息的基本单位: 物理块;按物理块 划分; 文件存储设备的组块策略和文件分配策略;
								>文件分配策略: 
									>顺序分配: 申请连续物理块, 按序存储; 创建即指定长度,不能动态增长;
									>链接分配: 每个物理块有后向指针,指向下一个物理块的地址;形成链接队列; 可以动态增长; 删除其中一个物理块只需要调整前后的指针; 提高存储利用率,但随机访问效率不高;
									>索引分配: 索引表. 文件的逻辑块号和物理块号的映射; 动态增长可以,随机访问也快;  .. 三级索引;  索引表先调入内存,后再根据索引的块号访问物理块;访问磁盘;
							>文件存储设备的管理: 对空闲块的组织和管理
								>空闲块的组织\分配\回收: 管理方法: 索引法\链接法\位示图法 
									>索引法: 空闲块的索引. 空闲区块的索引.
									>链接法: 分配从头取,回收从尾取;
									>位示图法: bitmap 记录文件存储器的使用情况, 每位对应文件存储器上的一个物理块;0/1为空闲和占用;
					>作业管理：
						>作业状态: 提交--作业从输入设备到外存; 后备状态--系统进行作业控制块的创建;执行状态---被作业调度程序选中而分配一定内存,建立进程,变为执行状态;  完成状态--完成;
						>用户接口: os提供给编程人员:API, 设备管理\文件管理\进程控制\进程通信\存储管理;	
				>控制程序的执行：有效地利用资源。
				--为用户提供：命令、菜单、窗口。
				--为应用程序提供：API
		>数据库系统:
			>模式和范式:
				>概念模式: 定义记录\数据项\数据的完整性约束条件,以及记录之间的联系; 全体数据的逻辑结构和特征的描述;
				>外模式: 用户可以看到的那部分数据的逻辑结构;
				>内模式: 定义存储记录的类型,存储域的表示以及存储记录的物理顺序,指引元\索引\存储路径等数据的存储组织;
			>两级独立性:物理独立性和逻辑独立性;
			>数据模型:
				>概念数据模型: ER图
				>基本数据模型: 数据结构\数据操作\完整性约束;
					>层次模型: 树形结构表示	实体类型和实体间的联系;
					>网状模型: 有向图表示实体类型和实体间的关系;
					>关系模型: 表格结构表达实体集; 外键表示实体间的联系;    -- 结构简单清晰; 有数学理论基础; 存取路径好;
					>面向对象模型:
			>关系代数:
				>并\交\差\笛卡尔积\选择\投影\连接\除法:  集合运算;
					>并:结果相并 ,显然要求记录是相同字段和类型的; union
					>交: 记录有主键,有各列值,求列值相同的行分别连接起来,形成新的集合;inner join 
					>差: A记录集合中有的某列的值,B记录集合中某列的值,取只在A中出现的记录;
					>笛卡尔积: A记录集合中每个记录都和B记录集合的每个记录相连接;形成的新的记录的集合;
					>选择: 筛选出记录,条件是 列值满足某种特征,列值和列值满足某种关系的记录,筛选出来;
			>关系模型满足的约束条件: 范式 
				>第一范式:最低的规范化要求. 要求简单域, 属性项不可再分; .. 使得 可以精细查询
				>第二范式: 所有非主属性 都直接只依赖主属性,而不是其他非主属性;..有 那么 会导致数据冗余\更新关系要全部涉及记录都更新\不能独立存储.  ... 比如:人-证书-发证部门;  办法:拆分非依赖主的字段;
				>第三范式: 即便依赖主属性,但是如不是只,即尽管主属性就可以确定B,C列的值,但是B-C自身相关,一对多/多对一, 则也要拆分;...非主属性的列列不能相关;
				---范式可以增强:增删改的速度. 减少了存储;  但是对查询,则需要更多的连接;
				--反范式设计:方便读,如增加冗余列;派生列;
			>数据库设计:
				>需求分析:
				>概念结构设计: ER图
				>逻辑结构设计:
				>物理结构设计:
			>事务管理:
				>并发控制: 并发操作带来的问题:丢失更新\不一致数据\读脏数据;
					>解法: 访问带上两种锁
				>封锁协议: 
					>一级封锁协议: 修改数据前必须带上X锁; 防止丢失更改;
					>二级封锁协议: 读取数据前必须带上S锁--读完就释放; +防止读脏数据;
					>三级封锁协议: 读取数据前必须带上S锁--事务结束前才释放: +防止重复读;	
				>两段锁协议:
					>读写数据之前: 获取封锁;
					>释放一个封锁后: 事务不能再申请和获得任何其他封锁;
				>封锁粒度:
					>属性值:
					>元组:
					>关系:
					>索引项:
					>整个关系数据库:
					>物理页:
					--问题:死锁 
						>死锁避免: 
							>预防法: 一次获取全部的封锁后才开始;或者:封锁对象按序编号-然后必须从小号开始申请(可能会串行等待一定时间);	
							>解除法: 死锁检测程序--检测死锁是否发生; 解锁程序--发现死锁了则开启解锁程序;
				>故障与恢复:
					>事务故障: 未运行至终点 就被撤销;
					>系统故障: 停电\硬件错误\操作系统错误; 事务非正常终止;
					>介质故障: 强磁场干扰;外存数据丢失; 碰撞;
					>计算机病毒: 
					--
					>故障恢复: 转储,登记日志文件;
						>事务故障的恢复: 恢复子系统应该对此事务做撤销处理
							>利用事务日志:进行反向处理.
						>系统故障的恢复: 正向扫描日志,找出故障发生前已经提交的事务, 将事务标记 放到 重做redo队列里; 同时找出 故障发生时 尚未完成的事务,放入撤销undo队列.
							>撤销队列的事务: 撤销处理:反向扫描日志, 对Undo事务的每个操作执行逆操作;
							>对重做队列的各个事务进行重做处理: 正向扫描日志,对每个re'do事务重新执行日志文件登记的操作;
						>介质故障和电脑病毒破坏的修复: 装入数据库后备副本; 使数据库恢复到最近一次转储时的一致性状态; 
							>从故障点开始反向读取日志文件: 找出其中已提交的事务,加入重做队列; 重做事务;
						>具有检查点的恢复技术： 也是从检查点 找到 此时 正在执行的事务，放入撤销undo队列， 再往回找，找到已经提交的事务，放到重做队列；然后分别先后撤销事务的做和重做事务的做；	
				>备份与恢复：
					>数据丢失尽可能少、备份时间和恢复时间尽可能短：
					>物理备份和逻辑备份：
						>物理备份：对数据库数据文件进行备份；
							>冷备份：先停数据库，后cp数据文件到新地方； 当数据库故障时，则将备份的数据复制回来；备份模式
							>热备：一种：不关闭数据库--数据文件备份状态后备份下来；二种--利用备份软件；
							--完全备份：全部备份
							--增量备份：上次完全备份以来的所有修改；
						>逻辑备份：数据库自身的备份工具进行 逻辑概念上的备份--如表、库；
				>分布式数据库：
					>坚固性好： 容忍网络分区；冗余技术；可靠性和可用性；
					>可扩展性： 增减节点；伸缩能力；
					>可改善性能： 就近访问：。减少系统响应时间；
					>自治性好： 分散管理，统一协调；
			>数据仓库：面向主题的操作型数据库，而不是面向事务处理；关注问题和关注对象的区别；
				>大量查询：修改删除少；
				>存储时间长：数年数十年；而不是一般，就几个月十几个月；
				>非实时：但是某个时刻的快照；
				>响应时间慢：秒，分钟，小时；分析很久 而不是实时简单查询；
				>OLAP: 就是数据仓库应用工具；但不是数据仓库；
			>数据挖掘：海量数据收集存储、多处理器并行计算、数据挖掘算法；
				>关联分析：同时出现的不同事情、对象；
				>序列分析：
				>分类分析：用户画像分类。利用神经网络、决策树，数理统计 建立 知识的模型；
		>计算机网络：
			>网络架构和协议：
				>按照信息的传输过程：将网络的整体功能分解为一个个的功能层；
					>同一机器：相邻层通过接口进行信息传递；
					>不同节气：同层之间采用相同的协议；
				>OSI各层：开放系统互连参考模型。低三层--网络通信--为通信子网；高三层--信息处理--为资源子网；
					>物理层：不关心比特的含义，而只关心相邻节点0,1如何发送，接收端如何识别；正确传输和接收0或1(每次都要成功)---但是自身没有重试(0传输失败了不会重试/验证的消耗太大)。是系统和通信介质的接口；系统将信号发送到介质上；或者系统从介质上接收信号--感受介质上的信号(感受信号不断的变化)；
					>数据链路层：关心相邻节点如何无差错传输帧为单位大小的比特流；即有重试；某次某个帧传输失败了，那么重试；而物理层没有重试；其他手段：流量控制和差错控制；从而将不可靠的物理层连接 变成更加可靠的成功率更高的/无差错的数据通道(一次可能会内部重试好几次，所以正确率高)；从而对网络层显现一条可靠的链路；
					>网络层：实现整个通信子网内的连接，(不再仅仅相邻节点),将网络服务数据单元(更长的数据流)从子网的一点到另一点的正确传输；因为会跨多个节点，所以要解决路由转发；拥塞控制；多个网络互联等问题。从而产生了要对节点编号---ip的需求，负责路由的中间节点需要建立路由表的需求；。最开始：是一个编号1，2，3，4；5；如1号要连10号；发现中间隔着4号和5号；10个节点形成了一个图结构；则发现中间节点需要记录其出口线指向的数据范围；。。。。总之，建立了一条跨越多个节点的通信链路---使得数据包可以源源不断从一个节点跨越多个节点而到达另一个节点；这就是网络层的最大作用；
					>传输层：实现可靠的端到端的连接；即有重试；而网络层只专注实现路由功能，并不进行端到端的重试---所以并不可靠；另外，端上可能有多个应用要发送数据，所以还要对应用编号--端口；这样，一个计算机网络端：接收的数据分别放到对应的端口上--让对应的应用程序读取各自的数据---实现并发网络连接的功能；。。从而为高层提供了传输数据的通信端口；从而高层之间传输数据不用考虑和其他应用数据冲突的问题(指定ip对方，port自己的接收槽位即可)；
					>会话层：真正根据应用要发送的数据，而去打开传输通路--开启会话，调用传输层将数据写入进行传输；接收数据，释放连接；。。真正的通信服务代理者--更上层的视角来看这一层；
					>表示层：实现用户信息的格式化表示；传输数据，首先数据要格式化表示--才能被正确识别认识，数据的格式、编码、压缩的具体采取方案，是这一层考虑的方面；实现的是传输的数据的格式映射/信息映射/格式统一映射。。是协议的语法方面；使得被交换的数据在网络上是统一格式的；即便它在不同的端计算机上是各种不同的格式表示；但在传输过程中是共同格式的；
					>应用层：实现对格式化数据的解读(含义)展示问题(应用的事，非操作系统)(实现收集解读零散数据形成应用处理要求具有的表示格式的过程)；实现采集用户输入信息并初步表示 和 收到另一端来的数据并在表示层格式化后得到真正的数据后最终展示在进程里--用户空间里--UI控件里--可视化展示；不同格式的数据有不同的可视化展示：如邮件的展示、聊天消息的展示。
					