---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。

  
>举动-痛点：对spring源码优化。开源项目二次开发。
 >解法/处理思想：官方网站模块架构图。设计的机制。
 ---各模块实现的功能：对应的现实实际需求。
  >spring-core: 核心工具。
  >spring-beans: 访问配置文件，创建和管理bean, 控制反转和依赖注入。BeanFactory
  >spring-context: 资源绑定、事件传播、资源加载、提供类似JNDI的框架式的对象访问方法。ApplicationContext
  >spring-expression-language: 提供表达式语言在运行时查询和操作对象。
  >spring-data access/Integretion: 对jdbc进一步的封装(比如数据库错误信息解析)。利用spring特性(如spring通用事务和DAO异常层次结构)的对象-关系映射的API如JPA，JDO。
  >spring-mvc: web模块
  >spring-AOP: 提供面向编程的实现，允许定义方法的拦截器(切面,纵向一圈)和切点(横向一线，一个连接点处多个切点)，从而将逻辑代码分开。
   >source-level元数据功能：
   
  >源码类：类的几个人功能、全部功能。
   >理论方法：
    >1.类图：关键是各个类的功能而不是名称本身；即这个功能树，抽象功能-具体功能树，基本功能。只有继承和实现的类图，有继承实现和依赖的类图。
    >2.事情逻辑线：事情分解为若干小事情、若干个基本问题，事情的内部结构，并且其中难易程度明确，事情解决的各个过程、各个环节，事情用基本功能来描述，即用基本功能来组合出来、逻辑组合、条件组合起来描述，事情分解出情况树，情况树下用基本功能来实现来完成来解决。
	 >一件事情的具体情况：有很多种。就像一个类有很多种实例。一件事情的解决方案，因具体情况的不同而不同，而具体情况也不是任意的----总是相似特征的但取值不同，所以方案必然也要根据取值的不同而有差异，所以方案树根据情况而取值具体方案，或者根据一个具体的情况而分析推导得出一个针对方案 是得出方案的两种好的方法。
   >XmlBeanFactory: 加载xml(得到Resource, 进一步document)并验证--->解析xml---->根据解析结果(BeanDefinition)执行实例化类(利用反射工具类)、将实例bean的引用存放到容器map里即注册，
    >ClassPathResource:
   >SingletonBeanRegistry: 对单例的注册和实现。
   >DefaultSingletonBeanRegistry: 对各函数的实现。
   >SimpleAliasRegistry: 使用map对alias缓存，对接口AliasRegistry实现。
   >资源操作方法：
    >Resource: 具体实现以加载具体各种形式(file,jar,array)的资源转换为InputStream，并且提供丰富的接口API。
	 >忽略给定接口的自动装配功能：实现了BeanNameAware.class的接口，BeanFactoryAware.class,ApplicationContextAware.class, BeanClassLoaderAware.class接口。有其他的注入方式。
	  >比如A-->B, 那么A在实例化时，如果B还没有实例化，但是如果B实现了上述接口，那么就不实例化B, 否则要实例化B，
	>Resource-->document: 获取对XML文件的验证模式(DTD/XSD)---->加载xml并验证(用DTD(.dtd)文件验证元素的定义规则，用XML schema(.xsd)文件验证文件内容)后最终parse生成document
	 >.dtd.xsd文件的加载：除了url方式，也可以直接从jar里加载，BeansDtdResolver从当前路径下寻找.dtd, 而PluggableSchemaResolver默认从/META-INF/Spring-schemas文件夹下寻找.xsd文件。
	>提取和注册bean: BeanDefinitionDocumentReader。解析根标签开始(先profile属性值，就是上下文参数spring.profiles.active的值)----> 再解析剩下的bean,分两大类bean,一种默认的普通的如<bean>，一种自定义的其他的如<tx:annotation-driven/>，来做分别的差别大的解析----->
	 >默认的标签的解析：默认标签4种：import, bean, alias, beans。bean解析过程：先解析获得BeanDefinitionHolder(获取beanName(id,name,classname)和alias和抽象定义就封装出来)----->BeanDefinitionReaderUtils注册--->发出bean加载完成的响应事件给监听器。
	  >抽象定义的获取：bean几乎所有的属性都先后被解析：因为<bean>标签对应的内存对象就是BeanDefinition, 属性是一一对应的。实现类RootBeanDefinition, GenericBeanDefinition等，BeanDefinition就注册到BeanDefinitionRegistry, 
	   >各种属性的设置：首先直接new  GenericBeanDefinition得到一个基本的，然后设置scope, parant, lazyInit,autowiremode,dependencycheck, depend-on,autowire-Candicate, initMethodName,destory-method, factory-method, factory-bean属性，
	   >解析子元素<meta>: 属性：key,value, 对应的实体BeanMetadataAttribute
	   >解析子元素lookup-method: 属性name, bean其中name是方法名,bean是方法的返回实例---已经是某个bean的它的名字。也就是说能够设置方法的返回值。用于给抽象类注入实现方法(返回bean的方法)，从而获取到这个抽喜类的实例----抽象方法返回的bean就是注入的实现bean。
	   >解析子元素replaced-method: 属性Name, replacer。name是方法名，replacer是新的替换类，而这个类实现MehtodReplacer接口，实现的方法就是替换的方法---方法参数不一致都没有任何问题。对应也是构造了一个MethodOverride对象，存放。
	   >解析子元素constructor-arg: 属性index,type,name. 构造方法可以并列多个。
	   >解析子元素property:属性name, 其中name是属性名，。对应的存放到内存实体是PropertyEntity和PropertyValue
	   >解析子元素qualifier:属性type, value。type为类名，value是值。
	  >抽象定义AbstractBeanDefinition的值：如lazyInit, abstractFlag, autowireMode
	  >默认标签下如果有自定义标签：寻找对应的命名空间处理器。
	 >注册：holder和registry已经得到。BeanDefinitionHolder和BeanDefinitionRegistry
	  >registry的方法：注册这个bean的name<-->beanDefinition。再注册所有的别名name<--->alias 
	  >