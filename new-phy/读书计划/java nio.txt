---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。

>举动-痛点：
	>解法/解决方案：
		>缓冲区操作：
			>数据移动：磁盘控制器-->内核内存临时缓冲区：DMA完成，无需CPU协助；
			>数据移动2：内核内存临时缓冲区-->进程执行read()调用时指定的缓冲区(用户空间)
			--内核再次复制的意义：数据的分解和再组合，形成用户需要的数据块的大小-一次复制过去；
			>发散/汇聚：系统调用时，提供多个缓冲区地址，则内核可以分别填满。发散，并行操作；
		>内核空间和用户空间：
		>虚拟内存：使用虚拟地址替换物理地址；在用户空间内存分配/内核空间内存分配，都可以直接分配虚拟地址 而不是物理内存地址；虚拟地址通过转换函数可以得到物理地址；
			>虚拟地址：多个虚拟内存地址可以映射为同一个物理内存地址；因此虚拟地址空间自然可以大于实例物理内存地址空间；
				>好处2： 用户空间缓冲地址 如果 是虚拟地址空间，内核空间缓冲地址也是虚拟地址空间，那么如果映射到同一个物理地址空间，那么数据就可以共享了。
					>条件：缓冲空间大小必须：磁盘扇区512字节的整数倍；内存核用户缓冲区必须使用相同的页对齐；内存页大小总是磁盘块大小的n倍，如4kB
		>分页技术：
			>虚拟内存分页：虚拟内存空间的页面可以继续存在于外部磁盘存储；物理内存充当分页区的高速缓存；
			>分页区：从物理内存中置换出来，存储在磁盘的内存页；
			--结果：进程A有5个虚拟内存页面，其中2个在物理内存，其余存储在磁盘；
			>页面加载过程：页面交换过程：
				>MMU: 内存管理单元，cpu和物理内存之间，该设备可以实现虚拟地址到物理地址的映射；虚拟页号转换为物理页号；如果没有找到对应的物理页号，则向CPU提交一个页错误；则产生一个系统调用，内核开始验证页的有效性，安排页面的调入；即页面调度；
		>面向文件I/O和流IO:
			>文件系统： 安排、解释磁盘数据的一种独特方式；有自己的一套概念体系：路径、文件名、文件属性、文件内容；
			>操作系统页：是基本内存页的倍数。
				>操作系统执行IO全过程：确定数据在哪些文件系统页-->在内核空间分配足够的内存页--->内存页和文件系统页建立映射-->为每一个内存页产生页错误-->虚拟内存捕获页错误，安排页面调入；-->调入完成，文件系统开始数据解析。
			>文件系统页：磁盘扇区组。空闲文件系统页。
			>内存映射文件：操作系统支持的 内核中的文件系统页和用户缓冲区映射到同一个物理地址空间
				>内存映射I/O: 使用文件系统建立从用户空间直到可用文件系统页的虚拟内存映射；用户碰触到映射内存空间，页错误自动产生，从而将文件数据从磁盘读到映射内存空间；用户修改之后，也会标记为脏，刷新到磁盘，文件得到更新；
			>文件锁定：允许一个进程阻止其他进程存取某文件；用于事务隔离；数据库应用严重依赖；
				>细微层面：可以是内容区段锁定；从而不同的进程访问不同的文件区段；
				>文件锁定两种方式: 多个共享锁可以 共享同一文件区域，但独占锁 要求锁定 的文件区域不能有其他锁；含义和数据库，java里的几乎一样；
					>建议使用：linux;强制使用：windows;;导致应用程序不可移植
			>流I/O: TTY和打印机端口、网络连接
				>传输：慢
				>就绪性选择：查看流是否就绪的任务交给了操作系统，操作系统提醒进程哪些流已经就绪，
					>意义： 应用程序根据操作系统返回的就绪信息，实现多活动流的多路传输；
					>意义2： 大容量缩放；
		>多工I/O: 
		>缓冲区： 
			>属性：0<=mark<=position<=limit<=capacity
				>容量：capacity缓冲区创建时初始化，不被改变；clear()->limit=capacity, position=0;
				>上界：limit; 缓冲区现存元素的计数,第一个不能被读和写的位置；flip() -->limit=position, position=0;  rewind()->position=0; 
				>位置：position下一个被读/写的索引。
				>标记：mark备忘位置；mark()-->mark=position ; reset()->position=mark; 初始值undefined;
				--只读的Buffer: MapperdByteBuffer
				--compact(): 将未释放的元素移动到0开始的位置
		>通道：缓冲区和套接字/文件之间有效地传输数据。
			>通道和文件描述符/文件句柄 一一对应：
			>通道只能在字节缓冲区上操作：
			>具体的通道实现：在java.nio.channels.spi下：如 AbstractInterruptibleChannel 和 AbstractSelectableChannel 
			>通道的创建：
				>文件通道：FileChannel, 只能RandomAccessFile, FileInputStream, FileOutputStream间接api:getChannel()创建;但可读可写权限是单一的；	
					>异步I/O: 
					>position属性：
					>force()方法：false参数则不同步文件元数据：最后修改时间、文件权限等；true则需要；
					>transferTo(): channel to channel 无需中间缓冲区来传输数据：
				>套接字通道：SocketChannel, ServerSocketChannel, DatagramChannel, 可以直接创建；**Channel.open();
					>特性：非阻塞、可选择(可伸缩性；异步)
					>好处：无需为每个Socket使用一个线程；
					>从通道上获取socket对象：socket()方法即可
					>非阻塞模式的关键：SelectableChannel。。更改阻塞模式，使用通道的阻塞锁来同步进行；
					>ServerSocketChannel:
						>创建后获取ServerSocket来配置socket选项：
						>accept()方法是非阻塞的：返回Null或者SocketChannel对象，从而实现可伸缩性并降低了复杂性；可选择性也因此得到实现；
						>注册到选择器实例：实现新连接到达时自动通知；
					>SocketChannel:
						>创建时即可配置Socket选项：
						>connect()内部：在循环里调用：sun.nio.ch.Net.connect()； 方法返回时，不一定建立好了连接，需要sc.finishConnect()完整性判断；---false返回则自旋
					>DatagramChannel:
						>创建后获取DatagramSocket绑定端口；
						>每个包：有目的地址；所以可以发送给多个服务端；接收也是，每个包也有各自的地址，可以多个不同的服务端；
						>使用的理由：可以承受数据丢失、吞吐量比可靠性更重要、同时发送数据给多个接收者
				>好处：读写文件更加高效；读是最新的，写也会脏页刷新回磁盘；
				>force(): 强制虚拟内存缓冲区刷新到磁盘；
				>通道的类型：
				>可读通道：ReadableByteChannel, 从通道读到ByteBuffer里； read(),flip()
				>可写通道：WritableByteChannel, 从ByteBuffer读出数据到通道 ; write(), compact();   退出之后，再次flip()--后hasRemaining()--write()
				--注意Channel的方法，含义都是对这个通道执行的动作：比如read()，对这个通道读，自然是读出来；write()，对这个通道写，自然就是写入这个通道；
			>通道的模式：
				>非阻塞模式：pipes, sockets面向流的通道才可以；
				>阻塞模式：文件通道总是阻塞的；
			>矢量I/O: Scatter/Gather 现代操作系统支持本地矢量I/O
			>文件锁：同一个jvm上的不同线程请求同一个文件的独占锁，不会互相阻塞，因为相当于重入；如果运行在不同jvm上，则会阻塞；因为锁最终是由操作系统或者文件系统来判优的；---且在进程级判而不是线程级判；
				>FileLock: 在文件内部区域上加锁：独占-可写方式打开文件；锁定范围可以超过size
			>建立虚拟内存映射区域：这个区域对用户空间，则为MappedByteBuffer视图， 对内核空间，则是文件系统页的虚拟地址映射到的物理地址区域；
				>这个建立由：map()方法调用内核完成；
					>可以映射文件的某个区域范围：position, size,映射模式-只读/读写/写时复制private
		>管道：Pipe:实体之间单向传递数据; jvm内部线程之间传递数据；
			>数据写入SinkChannel, 出现在SourceChannel:
		>选择器：单线程管理多个I/O通道成为可能；select(), poll()两个POSIX接口；
			>就绪通知的过程：操作系统处理I/O请求，并且通知对应的线程，它们的数据准备好了；。即操作系统提供就绪选择服务；Java中对应使用这个就绪选择服务的封装抽象出来的类就是Selector
				>多个通道共享/转交/委托同一个线程：来提供 通道的网络端口就绪选择的通知服务。
					>选择器就是：委托人，代理者。可以多个。操作系统处理I/O请求后，就会通知Selector. 而Selector就只需要select()等待即可---唤醒时候就是os通知时候
					>选择键：封装了通道、通道关心的事件类型集合、准备好的键的集合
			>select()返回之后，则selectedKey()返回的集合里的SelectionKey就是已经准备好的key;可以获取里面的channel
			>注册事件：一般服务端建立连接前：注册accept, 一旦连接建立获取了SocketChannel,则这个SocketChannel只需要注册read事件即可，write无需，因为直接写都可以。
			>选择键的移除：处理完成selectedKey()里的每个key，都需要移除。否则下次还会出现？
		>java正则表达式：
		>java字符集：
		>图形图像：GL4Java