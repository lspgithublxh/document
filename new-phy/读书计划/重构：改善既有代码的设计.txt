---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	>程序的执行要想象为人在执行；多线程则是交接执行权给其他人执行；
	>抽象编程与具体填充：假设编程和实现假设。面向对象中一个对象属性就假设已经填充好了，一个接口的实例就假设已经在容器中有了。代码编码层面和虚拟机执行层面，都规定/定义/设计为 将 接口和实例分开，系统启动时/甚至具体接口调用时才去容器里找接口的实例(启动时 一方面建立实例容器，另一方面 对接口寻找匹配的实例和链接到实例---进行连接和关联)。资源填充 和 接口调用(抽象调用)，资源--接口的映射对。领域抽象，资源抽象，功能抽象。
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点

--混乱的答案，宁可不说；只回答真正掌握的；。没有逻辑，因为没有进行抽象；没有找到所在的流程环节、模型中的位置
--系统、中间件的介绍，不是一来就是组成结构；这层次已经太细了太具体了太里面了，必须要从最简洁最抽象最上层开始；最表面最近开始；务实，不僵硬，不突然，要自然，不要忽视和没注意没意识和跳过很多步；而是从问题出发、从困难出发、从疑惑出发
	>从问题出发：先明确问题；先明确表达出问题、疑惑点、黑箱、痛点、矛盾点、难点，表述的范围可以很大(完全不知道是什么怎么办)后面逐渐具体问；无论多少问题，先明确下来；尤其要全部且完整的描述下来；
		>问题的提出：先明确背景，自然衍生、过渡、转折、演化，逻辑关系上，什么时候什么事情什么人，事情什么阶段遇到的什么问题、阻碍、阻挠、缺陷、瓶颈、不够简洁、不够简便、不够方便、不够优雅、离目标远、离理想情况远、离期望/极限效果远；不够抽象的地方；把它们充分描述完整叙述结构式组织起来。
			>问题抽象：归结为一类问题；去除具体和细节而明确问题模型；
		>问题产生原因：过程；条件；	
		>问题导致的恶果：阻碍、损失；
		>理想的方案特征/效果/必做必不做的动作&事情/应当改变的环节: 
			>这种特征/必做必不做的前提、必要条件、必然要求、必然说明、必然指示、必然可以确定的更多的事情/结论：
				>一系列结论、约束得到之后(结合条件/问题/情况本身)逐渐可以清晰看到/归结出该具体问题符合的/满足的通用/一般的/一类的问题模型/函数模型/服务模型/IO模型/请求响应模型的轮廓：若干个具体模型
					>方案的装饰/补充: 补充可靠性/稳定性/高性能(从而高可用/高并发)：因为暂时只是一个裸机、容易受到伤害、有功能但没有抵抗力(仅为打火机的火而不是熊熊大火)
							>方案的用法规则：在请求缓存前使用
		>能将具体方案进行分类的维度/情况/模型/环节/流程/抽象表述 的确定：然后使用 抽象-具体 的方法来得到新方案；					
		>普通的方案：已有的方案；方案的抽象，方案的取值选择评价；方案的表象缺陷、劣势；。。模型、数据结构和算法、协议约定分担 维度 上考虑；
	>任何事情/事物都有顺序/逻辑：且几乎都是几种常见逻辑中的一种: 时间先后、空间远近、因果环扣、程度递增
--大总结：含义包括：重新 深刻理解：
--通用的建模架构能力+Flink深度强化学习的推荐系统。。。。而不是做简单的业务逻辑开发；用深度强化学习来做应用/解决实际问题(用户的识别问题和抉择问题)；用抽象建模架构出逻辑完整的方案(工具方案/服务方案)；
--一体两翼的发展模型：底座：增强操作系统、网络、搜索、推荐能力； 两翼：普通项目：则架构建模；特殊项目：则深度强化学习；。。四大基础+两大实践(应用/使用)。。基础：是为了解决自己的问题；实践：为了解决别人的问题(用户的问题/大众)；
--一次彻底弄懂，而不是 反复低温加热。看架构书和源码书，不看使用书。
--对话中胜利：一个是提问，二个是不断的输出-高能输出。
--牢固的观念: 系统都是被使用的。
--任何一个系统、产品、服务、方案、东西、事情，它要解决的核心问题是什么？理想的形态效果影响应该是什么？市面上对应的哪些产品达到了或者没达到或者很难达到？没达到是为什么是否有我们的机会？是否还有我们可以满足的缺口。找市场缺口。
--从缝纫机原理看方案所属的分类和方案内的环节。抽象出分类和环节。
--把自己当做cpu,调/使用各个服务/接口/类/系统。
--全新学习掌握方法：先定问题体系，先提问，定逻辑路径，后开始找答案--推导和思考和查阅资料。
	>旧方法：还是盲目阅读，还是从头到尾的阅读一遍的阅读。
--所有系统和方案的理解/研究/制定的出发点：都是 出发顶点/问题顶点/概念顶点，找到了顶点才能出发，出发要从顶点出发，才顺畅，没有后顾之忧
--计算机解决问题的方法：采集，记录，计算，展示，通知，跟踪 数据/信息。

--商业经营才能：(全新的解决问题的方法：提出问题)
--什么问题 是可以用互联网来解决的？ 只要满足什么特征，该问题就可以用互联网方式来解决? 该问题的本质是什么问题(如是信息传递问题？)该问题抽象一般化后是什么问题(资管、记录、通知、计算、采集识别调动、代理/中介/数据中心/信息中心/信息模拟线下过程中心、信息传递)(信息展示/发布/搜索/推荐 平台；信息池；信息可以是映射描述的现实事物的信息(如商品/价值物/人)，也可以是纯虚拟信息(游戏/知识/新闻/视频))
	>能用信息发布展示/活动追踪-信息记录/通知/协作/推荐/搜索 解决的问题：信息可以是 编辑的信息/映射的信息/等价现实的信息/等价现实任何事任何物的信息。内涵BAT的老业务(电商/聊天/游戏/信息流/搜索)。
	>能用数据驱动决策抉择与调度分配/识别与推理/观测采集与调动机电-生物 而解决的问题：如alphazero/图像识别/语音识别/视频识别/云计算/智慧城市/自动驾驶。内涵BAT新业务(云计算/视频语音识别-下棋打游戏智慧体/智能音箱/自动驾驶)
--码农之家和脚本之家、异步社区。从 面向对象-->模式-->架构：由小到大。
--给其他非软件行业的工程师/人员开发软件。三高三可(高可用高并发高性能,可扩展性可维护性可重用性)。
--最佳：一边看书，一边独立思考；(比起纯看书和纯思考都好)。因为 看书 要有沉淀，积累，独立思考 结论，总结。而不是流经书，翻翻而已，左进右出。
--说话：社交场合，最重要的是：要有自己的认知、决策和行动；对形势的判断和分析和预测。而不是被别人牵着走，或者置身事外。
>举动-痛点：维护软件的概念完整性----人月神话。
	>解法/解决方案：不改变软件可观察行为的前提下改善其内部结构，提高可理解性、降低修改成本。高效受控的代码整理技术。整理收拾房间一样。
		>无需了解软件的行为：各种重构手法--坏味道  的映射。重构步骤。实用的代码，而不是过度工程。
		>重构：如何在代码写好之后 改进 它的设计。	
			>基本步骤：字段 在 类之间的移动；代码封装-提出函数；。。持续重构就是在对抗 慢慢腐烂。
		>坏味道：
			>1.不好修改(写新方法而旧代码没有可以复用的，改某个环节影响以前的功能/为了兼容从而变得臃肿)	
			>2.重复代码多，同一个功能代码多处有---导致一个改都得改--来保持一致性。
			>3.事先清楚哪些部分一定会经常修改：如策略。
			>4.代码只写固定不变的，会变的都要封装出去。方法里的 那些 会变化的部分/小段代码 都要封装出去。
				>重构后：使得添加变得容易，再添加特性。
				>重构前：建立测试机制。
		>重构手法：封装-转移-重命名，封装-转移-同名-冗余而压缩/化简
			>1.封装：将会改变的小块代码抽取封装起来，函数引用即可。
			>2.重命名：和方法功能相关。
			>3.方法迁移：如果方法本身没有使用 当前所在类的成员变量信息(属性/方法/常量)，则应该换个地方；换了之后---应该强制的引用了所在类的方法---即将代码提出为新方法(私有)---后引用它。
				>换的方式2：只将方法的全部内容封装到一个新类的新方法里，而被提走代码的方法 则 调用新类的新方法。进一步，调用原方法的方法里，可以替换为走新方法。
			>4.消除未使用变量：或只承接一次 和 被读取一次 就不再使用的 变量。	
			>5.去除临时变量：即便 增加时间复杂度？但可以封装出方法，这样就可能被复用---这个好处 即便用 时间复杂度来换 也是 值得的。
			>6.switch语句的重构：条件 应该 当前所在类的枚举，否则应该提出到所在类里，这样 当枚举的变更 后 直接在所在类就完成所有的变更处理。
			>7.消除if/switch: 将枚举和条件 封装 到 一个 入参 多态变量 里。即 将 不同 case 内的代码 封装 到 不同类的同名方法里，如果这些类实现相同的接口，那么 原 switch 下的每个case下的代码就可以重写为 Interface s = new 具体类(); s.method()，显然就就有具体类不同，显然可以统一以简化，即只要建立 case 的值 和 类的映射，则可以在外部 根据case值得到了 Interface 具体变量值，case里则统一只需要 s.method()就可以了，从而显然switch完全就可以压缩为 s.method(); 而且可以假设已经得到了Interface a, 即将它作为入参，假设编程，使得方法更为泛化；传参不传 case值，而是传Interface a的实例值。
				>用多态 来统一 case的处理：转为统一的接口调用/规范实体调用；从而 让 case 的处理都相同 而冗余，冗余而可以消除(if-else的处理都相同，则自然没必要if-else了)；
				>多态调用 就是 if/else switch-case 的压缩版本(描述量极少版本)：处理 在具体的实例里；不像if-else ，switch-case 处理就在分支里那么明显和过于具体(轮廓太具体、描述量太多)。描述量 多 则 多出好几倍，分支越多处理越复杂 倍数越大。
					>如果If-else过于复杂和用上了上下文中的多个方法内部局部动态生成的变量(非入参) 老构成的分支条件：则不改。
				>本质就是：用多态的跳转 来 代替 if-else 的跳转。多态的跳转，即接口的调用 具体实现类 可能 是多个--所以可能有多个实现类代码块 可以跳去/选择。多个分支 对应 多个实现类，走某个分支 代表 走某个实现类；异曲同工； 		
		>重构原则：	随时重构。多态 就是 压缩版本的 分支 (分支和多态可以类别)。		
			>重构原因：
				>难以阅读 则难以修改：
				>逻辑重复 难以修改：
				>添加新行为 出现 重复代码和要修改已有代码：难以修改：
				>带复杂条件逻辑的代码：难以修改
			>辅助工具：
				>性能度量工具：显示系统产生的对象数量+对象的诞生点；以便定位问题；
				>间接层：帮助 解释、共享、选择；
			>重构时机：
				>注释处：一行代码也抽取封装为函数。	
				>将总是一起变化的东西：封装在一起。
		>构筑测试体系：	
			>Junit: @Test + assert() 
				>单元测试：
				>功能测试：测试用例  +  测试套件 。TestRunner.run()  。  fail()	
		>重构列表：每个重构手法---动机/做法/范例		
			>Extract method: 函数名称和函数本体之间的语义距离；命名方式：意图；
			>Inline Method: 非必要的间接性 让人 不舒服；。。但是递归就不行；
			>Inline temp：对于赋值给一个临时变量，后这个变量只被读取一次，那么这个变量需要被消除。
			>Replace Temp with Query：一个函数里的业务规则应该尽可能少；如果太多，则每个规则提出为方法；这样一 可以共享，二方便对规则本身进行修改；三是方法调用会使得方便其他方法引用调用---即提出更多方法--提出包含原来提出的方法的方法；---从而将代码做到层层的简化---甚至入参不一定多--只要以查询方式反复获取一个计算的值--即便它被后面多次使用--但仍然是提出而可以反复无参调用。。。。只赋值一次的变量，可以定义为final.
				>不一定是按 函数体的分部分 而提取: 这不是真正的提取 , 应该是按照变量数据的获取/赋值 提取---提取计算它的过程;
			>Introduce Explaining Variable: 将 if里的判断表达式 分解 提出 单独定义为 boolean  变量;---自然声明为final .表达式的拆解也是这样,这样 可以 完全用 变量 的运算  来表达 表达式的含义--直观,而不是使用具体的数字;....当然用临时变量 还是 方法 看情况.	
			>Split Temporary Variable : 不是 循环变量和统计变量,那么  不要反复赋值---应该新定义变量.-----不要一个变量承担太多的责任;----令它的功能模糊含糊.
			>Remove Assignments to Parameters:  移除对入参的赋值. 如果需要用入参计算 并且 产生新的值,则赋值给新的变量.---即先将入参赋值给一个内部临时变量,然后后续修改这个临时变量;因为改变了入参的值---会产生歧义.不对入参赋值----所以可以入参被final修饰;
			>Replace method with Method Object: 将入参 封装 到 一个对象里,调这个对象的无参方法 来完成计算工作. ..这样 把入参 赋值给了属性,那么对 计算过程 进行extract method 会更加轻松;---参数传递也会大大减少;..相当于  一个 局域封装(局域计算封装).
			>Substitute Algorithm: 替换算法; 就是更简洁的算法;
		>在对象之间搬移特性:	
			>Move Method: 如果方法依赖原类的属性,那么新的类的方法需要引用这个属性,则可以:入参中\继承属性中\直接访问原类属性...如果还依赖原类的方法,那么就入参改为  原类 实例类型即可.
				>好的实现/理想的实现: 对外无参方法--- 调用本类的实例属性的某方法时,入参为本类实例属性;...... 对外有参方法----调用 入参实例的方法时,可以使用本类属性作为入参;
			>Move Field: 一个类中的字段 反而是其他某个类引用最多; 将一个类的简单属性 转放到它的某个实例类型的属性里;
				>Self-Encapsulation: 自我封装,即某个属性值 使用set/get方式访问,那么当这个属性被移除到其他类中时,只修改set/get方法本身就可以了.
			>Extract Class: 某个类做了应该由两个类做的事;.若干属性和若干函数提出 封装到新类;  比如几个属性和几个方法---那么原类只需要应用这个新类的实例就可以了.
				>类具体 则 功能要具体 从而责任单一:  类抽象一般化 则 只负责流程 应该 要主管 调用/流程实现 但不管具体环节的功能实现;..声明功能声明过程 而不实现功能;
			>Inline Class: 类合并.
			>Hide Delegate: 隐藏委托关系..即 一个类 不能提供 将自己的实例类型的属性 对外暴露 的方法---->这样 外部调用者就可以访问这个属性的方法, 破坏了封装的意义---让调用方知道数据依赖关系.同时也让客户端端耦合了自己的属性--->这样自己就不能轻易 修改自己的实例属性!!!!,为了解耦,如果客户需要知道 该类的实例属性的某个信息,那么应该由该类自己对外提供一个方法-->方法的实现则是调自己的属性的某个方法来完成.
				>实例属性不能直接被依赖
			>Remove Middle Man:  服务类 有委托的 功能,但是不能完全 所有功能都是委托---这样 那么就完全是一个委托人,反而不如让用户直接调用受委托类  来实现功能;
			>Introduce Foreign Method: 单行复杂赋值代码的封装.
			>Introduce Local Extension: 包装类实现 被包装类的所有方法;
		>重新组织数据:	
			>Self Encapsulate Field: 自封装字段...增加get/set
			>Replace Data Value with Object: 简单数据项  替换 为 对象类型;
			>Change Value to Reference : 工厂方法替代 new实例化方法;从而可以控制 是否进行真正的new对象;而 对象自己就可以 是工厂类,提供 getName(String)返回自己实例;而内部是一个dict:map结构;
			>Change Reference to Value: 引用对象改为值对象;
			>Replace Array with Object: 对象字段 和 数组元素对应. 类似map 也是这样; 元素信息以便明确;
			>Duplicate Observed Data: 领域类的设置函数 同时 是 观察者 模式的实现,即调用所有观察者/或者调用环境发送事件/生成改变事件并调通知函数;
			>单向关联改为双向关联: 当 一个类A 和 另一个类B 1对多的关系, 且现实上A中必须有B属性,而B只是有和A的对应关系,而现实场景中常常是B主动发起一个和A的某个实例的关联,那么添加这个关联的方法在B中,但方法的实现则是 调A的方法入参为B--因为A中才有B属性.
				>方法和映射关系: 存储在哪里 看现实情况;方法存于主动调用方;映射关系 存于宿主方;
			>双向关联改为 单向关联: 避免过度依赖;	
				--sprint-boot固定了哪些流程: 哪些环节的框架是可替换的
				--隐藏的投资机会
			>以字面量 取代 魔法数:  以便 不同处使用时  方便统一修改;	如果是个类型码,则替换为类
			>Encapsulate Field: 封装字段; 数据隐藏 于{}, 且private 不对外提供直接访问;而是提供 get/set方法;
			>Encapsulate Collection: 封装集合:  读取:返回不可变的只读副本(Collections.unmodifiableSet(set)); 添加修改 使用其他方法; 应该隐藏对象内和 用户无关的数据结构;	降低集合拥有者和用户之间的耦合度;
				>设置值: 例如设置set, 那么实现应该是遍历这个set,逐个加到内部的set中;
				>连续方法调用的合并到一个方法调用: .a().b() 替换为 .c()
				>array/list设置: 不是 getList().add() 而应该提供 set(index, value);这样的方法; 而返回的list/array应该是副本或者不可变的;
			>以数据类替代记录:  枚举替代基本类型;
			>以子类 取代类型码:
			>类状态/策略 取代 类型码: switch case应该尽可能简单,例如只有 new xxx()这样的语句. 或者 进一步将 每个case  都升级 为一个方法中: 无入参--方法名就反映条件--返回值就是new 对象;	
			>Replace Subclass with Fields: 仅仅是覆盖某个属性的子类; 那么可以删除, 将特征放入本类中;
		>简化条件表达式:  连招---:魔数替换-->分支合并-->条件表达式函数化-->多态替换分支
			>Decompose Conditional:  分解条件表达式:也是封装条件表达式; 来用方法名明确 条件判断的目的/含义;..或者每个条件单独封装到一个函数, 或者至少 封装到一个变量下;
				--好的代码结构: 1.控制结构 + 控制结构各位置都是函数调用(分支条件表达式位置+条件分支操作);  2. 无控制结构 下 则只有一句 条件表达式;(参数来自入参+属性) 3. 数据依次依赖的函数调用(入参如方法入参和属性)
			>Consolidate Conditional Expression: 合并条件表达式: 多个if, 尝试合并为一个if; 例如 如果 操作结果一样 则条件合并到一个函数中; 如果不一样 那么意图 不一样 则不合并;.使得代码可阅读性更强;	
				>并列if 或者 嵌套if 都可以: 只有if-else 甚至可以尝试 替换为 三元表达式.
			>Consolidate Duplicate Conditional Expression: 合并重复的条件片段: 如果 条件分支 操作 中有相同部分 /类似部分,则可以提出来放到 最后 共同使用/共享---来避免每个分支都写一个相同的操作;	
				>try-catch-finally: catch分支中相同的部分 也可以提出放到 finally 里.
			>Remove Control Flag: 移除控制标记. 使用break/return/continue  直接 退出; 一入口多出口.	
			>Replace Nested Conditional With Guard Clauses: 	嵌套if-else 语句 可以 将最外层到最里层全路径上表明的判断条件 按与的 关系 构成一个条件表达式 放到 一个if 中完成 嵌套条件 改 平行条件 ---或者嵌套条件 就等效于 平行条件;...且平行 + 每个if操作都return 就可以避免后面的if去判断一次----和return结合还会使得条件路径更短--因为有return而没有return说明当前条件已经是全新的环境了(直接将最里层的条件提出到最外层即可);
			>Replace Conditional with Polymorphism: 多态替换分支; 多态:隐式分支;分支隐式化...所有的具体化工作都逼退 到 配置里....从而降低系统各部分之间的依赖,使得系统升级更方便;
				>多态的实现:子类---代码开发早期; 代码开发后期:类已经 \状态模式\策略模式.
					>子类继承: 统一的接口的实现类,统一的方法-入参;..而接口 就是属于 原类----即便从实际含义上讲.
			>Introduce Null Object: 引入 Null对象; 从而不必再询问这个对象 是否是null再执行某个操作;而直接可以认为它是一个空对象而也可以调用它的方法---空对象也实现相同的方法---只是实现内容为专门为空时应该做的事情;		
				>任何函数都不返回null: 而是返回一个空对象类型的对象; 同理 任何入参也不在对象类型参数上传null而是传空对象类型的对象----提供一个isNull()方法--空对象类型返回true;
					>空对象类型 继承 该类型: 覆写所有的方法,并且提供对外的方法isNull()为true---从而不必使用类型判断来判空对象类型.
						>可以消除大量if判空语句;: 另外,空对象 可以有方法 返回另一种空对象类型 对象;
			>Introduce Assertion: 引入 断言.  事先 检查 约束条件  是否能够得到满足; 不满足直接抛出 参数检查异常;
		>简化函数调用:
			>Rename Method: 函数改名;新增方法;就方法Deprecated标记
			>Add Parameters: 参数提供足够的信息,或者通过其他函数提供信息; 也是使用新函数.
			>Remove Parameters: 声明新函数;
			>Separate Query from Modifier: 修改既有返回值 又有副作用的函数;..既修改又读取的函数  分开为 两个函数;读和写.
			>Parameterize Method: 令函数携带 参数. 让参数辅助描述,使得 描述更加广泛----而可以合并一些函数/合并一些相似片段代码.
			>Replace Parameter with Explicit methods: 函数里 按 参数的取值 分多种类型 分别处理, 可以 将分类值放到方法上 ,从而分解处多个方法---每个方法专门做相关的事情.  从而消除if;---让调用者判断该调用哪个函数---选择过程交给编程者/调用者----即最初的时候最初的方法的入参---就是调用某个具体含义的工厂方法(而不是直接数 或者带入参的工厂方法).
				>返回简单类型数值的方法 不如 返回接口/对象类型的方法: 方法的返回值 应该避免是 直接基本类型数值---因为这样 调用者 可能会直接利用数值进行判断---从而丧失了多态性---判断需要if;而用接口 则封装了隐藏了数值---从而具备多态性---无需if也可以做到;
			>Preserve Whole Object: 返回单参数的多个方法 封装为 返回一个接口对象的一个方法;; 或者 将 多个单参数的方法  改为 一个接口参数的方法; 同时传递对象 意味着传递了方法---可以方便函数回调 计算一些中间值;
			>Replace Parameter with Methods : 以函数取代参数... 参数值 如果不需要用传参的方式获取则无需这种方式. 例如 将入参计算过程 放到 入参所在的形参方法里;
			>Introduce Parameter Object: 入参封装到对象---且各个属性是不可变的; 同时引入对象方法----利用参数和新入参进行相关的计算----非常常见---封装属性并封装属性计算方法,
			>Remove Setting Method: 
			>Hide Method: 没有被其他类使用的方法,private化
			>Replace Constructor with Factory Method:  new 替换为有参工厂方法;如果参数只有一个 --且 入参分类几种,则 工厂提供参数方法名化的多个工厂方法. 避免显式的 创建对象;  Product Trader 模式
			>Encapsulate Downcast : 封装向下转型;
			>Replace Error code with Exception: 首先 方法返回直接数 已经不好---应该是对象, 而如果这个数是状态码,那么 甚至 不需要这个返回值---而改为  成功 则返回 失败则抛出异常;....好一点的则改错误码为成功失败 的布尔值?
				>抛出异常的检查语句:可以用断言 替换;
				>不能当作条件检查: 而只是特殊意外情况的处理.
			>Replace Exception with Test: 	操作之前先判断/提前测试; 而不是把 异常 当作是判断处理的分支.
				>抛出运行时异常: 如 catch分支里;
		>处理概括关系: 继承关系 
			>Pull up Field: 子类字段上移到超类,并声明为protected
			>Pull up method:  避免行为重复,子类方法上移... 超类 中 建立抽象函数也可以;
			>pull up Constructor Body: 
			>push down Method: 
			>Push down Field: 只有子类需要,则移动到 子类;
			>Extract Subclass: 类中的某些行为只有部分实例用到; 往往该类里有 类型码 字段; 则以某个类型码值为特征而建立子类, 把超类的构造函数protected化; 最后甚至可以把超类提炼为 抽象类 
			>Extract SuperClass:  建立 空超类, 将重复代码 提出 到 超类;
			>Extract Interface: 责任分离 出来 专门定义在 接口 中:为  方法;...从而方法中 也可以按 责任调用 / 按责任 接口类变量 来调用方法;
			>Collapse Hierarchy: 
			>Form TemPlate Method: 塑造模板函数..  两个子类 如果都有同一个实现方法, 但是内容流程很长,但是不断提取方法之后,可能可以流程上统一,而环节实现方法上不同;从而这样的方法可以提出到抽象类,而环节方法则是抽象方法;
			>Replace Inheritance with Delegation:  以委托取代继承; 子类继承了一堆 不需要的方法.....内部 新建  委托类字段---引用超类; 消除 继承 超类
			>Replace Delegation with Inheritance:  如果需要委托类的所有函数,那么继承 这个委托类;
		>大型重构:	
			>Tease Apart Inheritance: 梳理并分解继承体系.  识别继承体系 所承担的各项职责;; 分离职责到不同的接口,从而 类 继承接口 或者 引用接口;
			>Convert Procedural Design to Objects: 将过程化设计 转化为 对象设计  ... 封装 数据与方法 到专门的类中;
			>Separate Domain from Presentation:  分离展现逻辑和领域逻辑	
			>Extract Hierarchy: 提炼继承体系;
		>重构\复用和现实:
		>重构工具:	idea 工具.	