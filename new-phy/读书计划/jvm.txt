--------jvm的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。

1.举动-痛点：每个平台编译一次？经常内存泄漏指针越界？运行时间的增加性能越来越低？不够丰富的应用编程接口？
	>解法/处理思想：平台无关、相对安全的内存管理和访问机制、热点代码检测和运行时编译及优化、丰富第三方类库。
		>JDK内部的实现机制：尤其native的实现：编译一套自己的JDK最佳。用OpenJDK进行。JRE包含虚拟机+JDK部分api接口。
			>安装OpenJDK: cgwin + microsoft visual studio
		>自动内存管理机制：主要关注内存泄漏问题。
			>java运行时数据区：堆区、方法区、虚拟机栈、本地方法栈、程序计数器。数据区外是：执行引擎、本地库接口、本地方法库(windows/linux/...)。
			>程序计数器：一个线程有一个，记录字节码解释器的字节码位置。native方法执行时这个值就没有---是Undefined。
			>虚拟机栈：一个线程有一个。记录当前的方法调用链。栈里一个个栈帧，每个方法一个栈帧，每个栈帧--包含入参局部变量表+内部局部变量表+返回值变量、操作栈和动态链接。
				>编译期可知的所有基本数据类型：...+对象引用+returnAddress类型(指向一条字节码指令的地址)。。
				>局部变量表：在编译期所需要的内存空间已经确定：Long,double占用2字节，其他1字节。方法运行期间不会改变大小。
					>栈深太大：无动态扩展配置则stackoverflowError, 如果有扩展但是扩展需要的空间不够-垃圾回收仍然不够--还不能扩展/-自然就OutofmemoryError
			>本地方法栈：hotspot中合并到了虚拟机栈中。也会抛出上面2错误。
			>堆：线程共享。不是所有的对象都会分配在堆上。JIT和逃逸分析技术或许不会这么分配。栈上分配、标量替换。
				>分配缓存区TLAB：每个线程私有,每个线程有一个。
			>方法区：类字节码(父类、接口、内部静态变量、常量都会抽取出来专门存储)、常量、(静态变量)、JIT即时编译器编译后的代码。Hotspot中叫做永久代Permanent Generation, 会进行垃圾回收。这里也会OME
				>运行时常量池：编译期生成的字面量和符号引用。运行时常量也可以：比如String的intern()方法产生的。常量池无法再分配时也会抛出OutofmemoryError
				>直接内存：在NIO中引入的。可以使用native函数直接分配堆外内存，而在堆中用DirectByteBUffer对象来引用这块堆外内存。用户态和内核态共享数据区，避免数据在java堆和native堆中来回复制数据。
					>自然：这一块也会在动态扩展空间不够时OME
			>对象访问方式：
				>句柄：则会在堆中新增一个句柄池，对象引用存储句柄的地址，句柄池中的句柄存储各种地址---实例数据地址和类类型数据。这样实例移动后，只会改变句柄中的实例数据地址。
				>直接指针：对象引用直接存储实例数据的地址，而这个实例数据中有一个字段指向了类数据地址(方法区)。这样，访问对象会更快。Hotspot采用。
			>避免堆自动扩展：-Xmx 和-Xms设置为一样。
				>OOM时转储堆内存快照：配置-XX:+HeapDumpOnOutOfMemoryError 。则会OOM时生成堆转储快照文件。
				>分析堆转储快照文件：Eclipse Memory Analyzer..
					>内存泄漏：查看泄漏对象到GC Roots的引用链。实际上对象本身多，导致的问题情况不多。多是由于线程对象对应的OS线程占用空间太多导致的。
					>-XSS: 栈容量，是对每个线程的栈使用容量的限制。显然，如果堆内存太大，而-XSS又太大，那么OS能给的jvm进程(单个进程)的剩余空间就不多了----从而可能建立不了太多的线程----反而影响并发量。
						>报错：StackOverFlowError，也可以能OOM：unable to create new native thread 
					>内存溢出：OOM:Java heap space
					>常量池溢出：-XX:Permsize= -XXMaxPermSize=  最常见的是intern()方法，会将这个string对象包含的字符串放到常量池中，并且返回这个String对象的引用。OOM: PermGen space
					>方法区溢出：类字节码太多。OOM
					>直接内存溢出：DM设置-XX:MaxDirectMemorySize来指定。
					 >限制只能引导类加载器才会返回实例：则这个类设计时需要像Unsafe类一样。并且可以设计为只有rt.jar中的类才能使用----像Unsafe类一样。但是可以通过反射机制获取到Unsafe的实例。
						>DirectByteBuffer类：并不会直接申请内存，只是计算需要的内存大小。实际由unsafe.allocateMemory()实现----真正向OS申请分配直接内存。
			
举动-痛点2：垃圾收集和内存分配策略。哪些内存需要回收？何时回收？怎么回收？
	>解法/处理思想： 针对内存：方法区、堆区。(虚拟机栈、本地方法栈、程序计数器)都跟线程绑定，线程结束就被清理了。
		>回收步骤：
			>确定对象存活：
			 >引用计数算法：缺点--相互引用问题无法判断。
			 >根搜索算法：	GC Roots对象若干个---方法区中静态属性和常量引用的对象 + 虚拟机栈中引用的对象 + 本地方法栈中JNI引用的对象。。这些对象引用其他对象，层层向下引用更多的对象，如果有对象不在这些图下，则不可达，会被回收。
			>引用的扩展定义：需求来源：当内存紧张时，即使GC Roots可达的对象，如果它满足某种特征 或者事先给它一种标记，在此时也能被回收，那么就还可以省出空间。这种标记是引用标记，自然要从引用类型上来实现----即使用特定的类来标记。
			 >强引用：任何时候都不会被回收。--内存紧张时也不会。
			 >软引用：系统将要发生内存溢出异常之前，纳入回收范围。
			 >弱引用：下一次垃圾回收收集时，纳入回收范围。
			 >虚引用：为对象设置虚引用关联，希望能在对象被收集器回收时收到一个系统通知。唯一目的。
			>第一次标记：没有与GC Roots引用链相连接的对象，先判断有必要执行finalize()方法(如果执行过了(如上一次垃圾回收时)或者没有覆盖finalize()方法--则每必要)--然后加入到F-Queue队列中，稍后虚拟机自建的名为Finalizer的线程会来触发执行finalize()方法。如果finalize()执行中对象将自己又关联到了GC Roots引用链，那么接下来的第二次标记---即堆F-Queue队列中对象的标记就会把它移除出“即将回收”的集合，剩下的对象就会被回收了。
			>第二次标记：如上。finalize()方法不被建议使用。
		>永久代垃圾回收：废弃常量和无用类
			>常见：常量池中如果有个字符串，没有任何String对象的值是这个字符串，那么会被回收。
			>无用类的回收：无实例、类的类加载器已经被回收、反射有关的该类的java.lang.Class对象没有在任何地方被引用。//则可以卸载类。
		>垃圾收集算法：
			>标记清除：先标记，后清除。缺点：时间多、产生内存碎片。
			>复制：计算可达对象，复制到新空白区，移动堆顶指针。新生代采用。
				>IBM的研究表明：大量对象都是死的快的，所以新生代分为大块Eden + 小块2Survivor, HotSPot比例为：8：1：1， 每次回收将Eden+1Survivor的对象中幸存的---即认为是很少的复制到1Survivor里，然后Eden+1Survivor就清除空间。当然如果Survivor不够，会分配到老年代。
			>标记-整理：老年代采用。先标记可达，后统一移动到一端，将端边界以外的空间清理。因为存活率高，没有额外空间进行分配担保。
		>垃圾收集器：
			>Serial收集器：单线程工作方式。先STW方式复制算法 收集年轻代；再以STW方式标记-整理算法收集老年代。用途：虚拟机运行在client模式下。
			>ParNew收集器：多线程方式。过程和算法同上，仅仅在年轻代采用了多线程。而对于老年代，仍然是单线程。用途：Server模式下。新生代收集器。-XX:+UseConcurrentMarkSweepGC和-XX:+UseParNewGC时开启新生代采用的收集器。
			>Parallel Scavenge收集器：多线程方式。也是复制算法。目标：可控的吞吐量--即cpu利用率(垃圾回收使用cpu时间短则吞吐量高)。
				>停顿时间：指的是单次回收时的暂停时间。实际上频率可能在变，导致单次停顿时间短了但是总共的停止时间多了---即吞吐量低了。
				>自适应调节策略：给虚拟机一个参数目标：-XX:MaxGCPauseMills(单次停顿时间) -XX:GCTimeRadio(吞吐量), -Xmx最大堆。虚拟机自己动态调整新生代大小、Eden和Survivor的比例，新生代对象晋升到老年代的年龄。
			>Serial Old收集器：单线程，老年代。标记-整理算法。Client模式下。Parallel Scavenge配合使用。CMS的后备方案---CMS模式失败的时候。
			>Parallel Old收集器：多线程，老年代。标记-整理算法。在注重吞吐量+cpu多核利用的目标下，即吞吐量优先，那么常常组合Parallel Scavenge 配合使用。
			>CMS收集器：标记-清除算法。目标在缩短暂停时间(使用并发)(而不是注重吞吐量--即不是为了cpu利用率低)(并发时间不算在停顿时间内)。过程：三次标记一次清除。
				>初始标记：GC Roots直接关联到的对象。STW
				>并发标记：和用户线程同时运行。GC Tracing，引用链上的所有对象。
				>重新标记：并发标记期间用户新产生的垃圾。因为并发标记时间显著最长。STW
				>并发清除：和用户线程同时运行。标记清除。
			 ----缺点：并发启动的回收线程数=(cpu数 + 3)/4导致cpu<4个时用户吞吐量、执行速度还是有较大的降低。
						浮动垃圾。导致68%老年代利用就会触发垃圾回收，导致回收次数多。但可以配置调高。85%例如。
						标记-清除。产生内存碎片。可以各种配置来减少。会在Full GC后整理，或者压缩。
			>G1收集器：标记-整理算法。长时间运行的系统更适合。低停顿的垃圾回收--指定最大暂停时间--底层原因：不再是全区域的在整个年轻代或者老年代进行垃圾回收，而是新生代老年代都划分为2M为最小单位的区域region,并记录region里面垃圾的多少，按照多少排序优先收集垃圾多的。。
				>
		>常见垃圾收集器组合：总结：新生代3种：Serial --> ParNew --> Parallel Scavenge , 年老代3种：Serail Old --> Parallel Old --> CMS   最终的划分小区域垃圾优先并行回收的两代回收：G1
			>Serial + Serial Old: client模式下。 +UseSerailGC打开启用
			>ParNew + Serial Old: +UseParNewGC打开启用
			>ParNew + CMS + Serial Old: Serail Old是CMS的后备方案。在Concurrent Mode Failure之后启用。+UseConcMarkSweepGC启用。
				>CMS优化选项：CMSInitailingOccupancyFraction---老年代占用多少之后开始垃圾回收68%, UseCMSCompactAtFullCollections垃圾回收后是否要进行一次内存碎片整理，CMSFullGCsBeforeCompaction设置若干次垃圾收集后再进行一次内存碎片整理。
			>Parallel Scavenge + Serial Old: 虚拟机在Server模式下默认方案。+UseParallelGC后启用。
				>Parallel Scavenge 优化选项：GCTimeRadio---GC时间占用总时间的比率，默认99 ; MaxGCPauseMills--设置单次GC最大暂停时间。
			>Parallel Scavenge + Parallel Old:  。通过+UseParallelOldGC启用。ParallelGCThreads并行垃圾回收的线程数。
		>对象的内存分配：堆上分配(JIT之后在栈上分配。动态编译三个时机：编译时--cglib通过asm复制操作字节码产生(字节码增强)(对生成好的.class生成它的子类)(aspectJ通过JCC自己的语法编译工具：直接修改class文件，在调用的地方进行增强--前后增加Observer的方法)，类加载时期，运行时期(JDK动态代理其实也是，类似于动态编译--只是更简单的实现：))
			>堆区分配：Eden区--不足则发起一次MinorGC，TLAB上， 老年代。
			  >打印内存回收日志：在发生垃圾收集行为时进行。-XX:+PrintGCDetails
			  >分配担保机制：Eden中要转移的对象总量太大无法转移放到Survivor中时直接提前转移到老年代的机制(不会只转一部分或转一点到Survivor)。
				>大对象直接进入老年代：避免频繁MinorGC, 设置-XX:PretenureSizeThreshold参数。
			  >频繁MinorGC原因：有大对象要分配，导致eden空间剩余较多但不够就开始MinorGC来容纳这个大对象。
			  >暂停时长多的原因：Parallel Scavenge / G1 最大暂停时间设置的太小，是会导致这种现象的。频繁MinorGC导致。
			  >对象进入老年代：每个对象都有一个年龄计数器，先Minor到Survivor,增长1，然后每次Minor在S0,S1之间转移，每次增长1，直到默认15或者指定的-XX:MaxTenuringThreshold参数。
				>算法2：中位数法：占用空间一半的某个年龄的对象及其以上年龄的对象直接转移到老年代。
			    >空间分配担保：如果晋升到老年代的大小大于老年代剩余空间大小，大于，则直接进行一次FullGC, 小于则先查看是否允许担保失败----允许则只进行一次MinorGC, 否则也是FullGC
					(就是老年代担保有空间可以分配剩下的对象-XX:-HandlePromotionFailure=true)
		>虚拟机命令工具：jps, jstat, jinfo,jmap, jstack, jhat。。。jps -l
			>jmap: 内存转储快照的生成，堆内对象的查看。-heap查看垃圾回收器、参数配置等。 -histo:对象统计 。 -dump堆转储快照。
			>jstack: 显示虚拟机线程快照。查看各个线程的状态：wait ,wait for 等待中--执行中--/外部请求等待中，等待什么资源----阻塞中bloking。。查看线程长时间停顿的原因。堆栈信息，在哪个方法哪条代码上等待，是否占用了哪个对象的锁。
			  >死锁：
			  >死循环：
			  >请求外部资源：
			>jhat: 堆转储浏览器，分析heapdump文件，并启动一个http服务器可以可视化访问查看。一般不采用。而是导出来，在Eclipse Memory Analyzer 里进行分析。
			>jstat: 统计分析工具。类加载、垃圾收集、
			  >jstat -gc pid interval times 查看各代占用和垃圾回收情况，-gcutil -gccause 。。jit编译过的方法等。
			>jinfo: 虚拟机各项参数值：jinfo -flag 参数名 pid 
			----查看所有线程的堆栈信息：用Thread类提供的方法。火焰图。
		>虚拟机监控工具：visual vm 动态监控cpu/内存占用，堆内存对象占用，虚拟机栈中各线程的运行状态和调用链，Mbean的管理--远程查看值和调用方法。
			>独特的是可以安装插件：比如Visual GC 动态查看堆区各代占用比例，垃圾收集情况。
									比如Btrace ：场景：某方法报错，但是没打印入参和返回值。可以Btrace来查看。HotSwap技术---代码热替换技术---虚拟机运行不停止的情况下，替换已经加载的类的代码。定位连接泄漏、内存泄漏、解决多线程竞争问题等。
		>故障排查：
			>网站长时间没有响应：GC停顿--->Parallel Old这种吞吐量优先的收集器--->Full GC耗时14s--->文档序列化为大对象直接加到了老年代。：避免批量产生生存时间长的大对象。
				>不仅-Xms=-Xmx，而且-XX:PermSize=-XX:MaxPermSize。。对eclipse: 可以禁用代码验证-Xverify:none和禁止显式GC：System.gc()-XX:+DisableExplicitGC
			>逆向ajax技术：Comet, server side push .。。系统占用两种情形：java直接本地方法调用发起的系统调用，第二种是直接向系统申请共享内存/直接内存Unsafe.allocateMemory()--内核态和用户态都可以访问--避免态的来回切换和数据的来回复制NIO和零拷贝都基于这个原理。	但是Direct Memory的回收时间只能是某次Full GC之后垃圾收集器顺便进行回收废弃对象占用的空间。			
				>Comet: 基于http长连接的推技术。前端comet4j.js	后端comet4j-tomcat7.jar
			>JVM外会占用的空间：
				>Direct Memory: 通过-XX:MaxDirectMemorySize来调整大小。抛出的OOM：就会是Direct buffer memory
				>线程：系统的线程已满。unable to create new native thread//。。java虚拟机创建的线程，对应轻量级进程，对应linux的内核线程。
				>socket缓冲区：系统每个socket读写分别占用30KB左右的内存
				>JNI调用的本地库：也不在JVM中。
			>网站响应比较慢：CPU占用时间太多(查看Dtrace看是哪个系统调用占用)-->fork系统调用太多---->java调用Runtime运行命令/shell脚本---->jvm会克隆一个和当前虚拟机一样环境变量的进程，再在该进程里执行命令,然后退出进程--->是个消耗cpu和内存的事情。
				>linux和windows上线程的区别：windows上的线程由操作系统负责线程的调度。linux上的线程由创建线程的进程进行调度。windows上的线程在内核中也有。linux中在内核中只有进程，从而用户空间中的概念“线程”是用轻量级进程来表示的----共享一个代码上下文，内核中--进程是调度的最小单位。
				>web服务的同步调用和异步调用：同步调用就是通常的。异步调用就是回调，例如AIO, netty的回调。异步调用的服务方就压力大，建议改为消息发送方式：客户端接收；即交给第三方。
		>eclipse插件开发：比如eclipse启动时间统计。继承IStartUp类，并编写plugin.xml并打jar包放到plugins下即可。
			>启动时禁止字节码验证：-Xverify:none
		>JIT即时编译器：内嵌在JVM字节码执行引擎中。将字节码映射为本机机器码，由一个解释器完成。性能则不足，为此将部分频繁调用的方法先优化后直接编译为本机机器码，那么直接走系统调用，不用再次解释了，性能得到提高。由C1,C2两种编译器，后者优化程度更高。可以优化回退为解释执行，分层优化。而javac是静态编译。
			>优化地方：重复计算、方法内联(调用方法替换为方法的代码)、逃逸分析-栈上分配-标量替换(数据流分析机制，将对象放到线程栈里而不是堆里，且存对象的属性而不是对象本身，避免对象头和对齐填充空间的浪费)、逃逸分析-同步消除(锁没有逃逸仅仅线程私有，则JIT将同步锁去掉)
			>优化代价和结果：代价是运行时编译时间。结果是：热点方法不断出现而被编译，代码整体编译程度越来越高，性能越来越好。-server模式。
		>用户线程的安全点检测、挂起、恢复：在一次GC前。
		
举动-痛点3：虚拟机执行子系统
	>解法/处理思想：平台无关性、语言无关性。java语言规范、java虚拟机规范。
		>Class文件：8位字节位单位的二进制流。数据项>8位，高位在前的多个字节来存储。
		 >存储结构：无符号数、表。(另外有：容量计数器，前置在若干个连续的同类数据项之前，称这类数据的集合)
			>无符号数：4种。u1,u2,u3,u4 描述数字、索引引用、字符串。
			>表：复合数据结构。多个无符号数、其他表为数据项。以_info结尾为表的名称，所以有很多种。常量池是cp_info 
		 >头4个字节：魔数。标记是否能被虚拟机接受。0xCAFEBABE
		 >接着4个字节：文件次版本号(2字节,小数后面65535最大)+主版本号(2字节，45开始，1.7就是51)。45.65535为第一版的最大次版。JDK向下兼容。
		 >接着常量池入口：表类型。容量计数器(1字节,从1开始) + 常量 (字面量+符号引用)(都是表结构)
			>字面量：字符串、final常量值
			>符号引用：编译产生的：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
		  >常量池中常量所有的表结构：11种。
		   CONSTANT_Class_info表结构为例：
			>表结构开头：u1类型的标志位tag.1-12映射各种常量类型。7
			>表结构接着：u2类型的索引值name_index指向了一个CONSTANT_Utf8_info类型的常量，来描述这个类的全限定名。
		   CONSTANT_Utf8_info表结构：
			>u1标志位tag：1
			>u2字符串长度length:
			>u1字符byte：共有length个，缩略UTF-8编码方式：1-2-3个字节表示。
		   CONSTANT_Integer_info: u1tag + u4bytes
		   CONSTANT_String_info: u1tag + u2index(指向字符串字面量)
		   CONSTANT_Fieldref_info: u1tag + u2index(指向类描述符CONSTANT_Class_info) + u2index(指向字段描述符CONSTANT_NameAndType_info)
		   
		 >查看class文件种的常量池：javap -verbose A
		>接着2字节访问标志：类或者接口的前缀描述符，页描述是否是枚举等。共32个标志位。即32种是否判断。
		>接着u2类索引、u2父类索引、接口索引集合(u2容量计数器+接口索引)：
		>接着是字段表集合：u2容量计数器 + u2简单名称索引 + u2字段描述符索引 + u2属性表集合(额外信息，比如字段的初始化值)
		>接着是方法表集合：同上，其中u2属性表集合存储包括：Code为属性名的方法体编译后的指令集合。(养成先说原因后说结论的习惯，而不是反过来)。注意，存在类构造器方法。特征签名不包含返回值类型--所以仅仅返回值不同是同一个重载。
		 >用描述符来描述字段和方法：
		  >字段：u2标志位(字段前面的各种关键字修饰符) + u2简单名称索引 + 描述符(描述字段的数据类型，实现方式：大写字符如B-C-D-F-I-J-S-Z-V-L表示基本类型和对象类型,数组每个维度用[表示)
		  >方法：u2标志位 +  u2简单名称索引 + u2描述符(先参数列表，后返回值)索引 
		 --字段不能重载，所以字段名称需要不一样。
		 >属性表：u2属性名常量索引 + 具体而定属性值字节长度 + u1字节(长度n个) 
		  >Code属性: 方法体内字节码指令。-g:none禁用
			>属性值表结构：u2标记+u4属性值长度
			>栈帧中的操作数栈深度：max_stack
			>局部变量表所需的存储空间：max_locals  计算出来的，并且方法内一个变量作用域结束后它的slot可以释放而给其他变量使用。注意实例方法默认的入参this
			>字节码指令：u1code + u4code_length 每个u1长度的都是一个指令，java共有约200条指令。
			 >aload_0指令2A:将第0个slot中的为refrefence类型的局部变量 推送至栈顶。
			 >invokespecial指令B7：紧接着后面会跟着“方法”的符号引用u2。表示将栈顶对象来调用它的该方法来执行。
			 >return指令B1: 指令执行的时候，会把值设置到returnValue变量里去。实际赋值时：放到最后一个本地变量表的Slot中----ireturn时将这个Slot的数据读到操作数栈顶，作为方法返回值来使用。
		  >ConstantValue属性：常量值
			>异常表结构：
			 >start_pc: u2字节码行号
			 >end_pc:u2
			 >handler_pc:u2
			 >catch_type:u2
			>新的指令：
			 >iconst_1: 常量赋值1 iconst_3赋值3
			 >istore_1: 配合赋值之后使用
			 >iload_1: 从变量中赋值
			>最后出现的Exception table说明：有多行数据出现。如3条。
				>from列  to列 	target列 	type列
				  指令起始行号	结束行号	跳转行号	异常类型(起止中发生的异常)
		  >Exceptions属性：方法定义抛出的异常。内部try-catch-finally
			>u2属性名索引+u4属性长度 + u2异常类个数 + u2异常类常量索引
		
		  >LineNumberTable属性：行号和字节码指令行号的映射表。方便抛出异常时带上行号。用源码行号进行debug。
			>u2属性名索引+u4属性长度+u2行号表长度+line_number_info结构(start_pc u2 + line_number u2)的行号表若干个
		  >LocalVariableTable属性：方法的局部变量表描述和字节码指令中的变量名之间的映射。用于其他人引用之后可以看到源码中的名称。同时调试时可以根据参数名称获取到参数值。
			>u2属性名索引+u4属性长度+u2local_variable_info结构(start_pc起止偏移量+length作用域长度+名称索引+描述符索引+在栈帧局部变量表中Slot的位置index)
		  >LocalVariableTypeTable属性：局部变量类型中有泛型则用这个属性，差异在：描述符用特征签名替换---因为描述符中泛型类型被擦除了。
		  >SourceFile属性：源码文件名称。u2属性名索引+u4属性长度+u2源文件名常量索引。。方便抛出异常时显示所在源文件名
		  >ConstantValue属性：定长属性。u2属性名索引+u4属性长度+u2字面量常量值索引
		  >InnerClasses属性：内部类描述。u2属性名索引+u4属性长度+u2内部类个数+inner_classes_info类描述结构(内部类和宿主类的符号引用+内部类名称索引+内部类类访问标记位)
		  >Deprecated属性：标志类型布尔类型.u2属性名索引+u4属性长度
		  >Synthetic属性：标志类型布尔类型：内部类并非由用户代码产生：则为true..u2属性名索引+u4属性长度。。。扩展性就是：预留扩展点和预留空间。
		 
举动-痛点3：类加载机制
	>解法/处理思想：校验、转换解析、初始化
		>类生命周期：加载、验证、准备、解析、初始化、使用、卸载。解析可能发生在初始化之后。
		 >加载：类加载的一个阶段。1.通过类全限定名找到二进制字节流--->2.在方法区生成这个二进制字节流静态数据结构对应的运行时数据结构--->3.在堆中实例化生成一个java.lang.Class对象，指向方法区的这个运行时数据结构。
		  >类加载器的目标：获取字节流。
		 >验证：因为字节流不规定要从源码编译而来--可能修改字节码而来---可以十六进制编译器编写而来。所以要验证。
		  >文件格式验证：魔数、主版本次版本、常量类型tag、指向常量的索引值、CONSTANT_Utf8_info常量编码规范。决定能否放到方法区
		  >元数据验证：字节码信息的语义正确性分析。不符合java语法规范的那些错误--即本在编译阶段就不会通过的错误。
		  >字节码验证：方法体内的代码的校验：保证字节码指令是对对应的源码的正确实现。类型转换有效.
		  >符号引用验证：对类自身以外的信息(引用的其他类的信息)进行匹配校验。-Xverify:none不验证。
		 >准备：为类变量分配内存并设置零值。(并不是类变量的初始值-putstatic设置的值在初始化阶段开始执行)------但也看情况，看字段属性表里是否有ConstantValue属性，有则准备阶段就已经赋值了。
		 >解析：将常量池里的符号引用替换为直接引用(尤其是指向其他类的符号引用)。直接引用是直接指向目标的指针，跟虚拟机实现的内存布局相关--每次启动布局不同--因为内存地址不同。符号引用的值仅仅是符号--字面量，目标不一定加载到内存。(存在着 符号引用到直接引用的映射缓存表)
		  >D类的符号引用是其他类或者接口C：设这个符号引用的值是N,那么D类的类加载器会将N当作接口的全限定名去加载，即加载类C。如果C是数组，则C的数组元素类型也会从N(如[Ljava.lang.Integer)中解释出来(java.lang.Integer)而加载，然后虚拟机生成一个此数组对象。然后符号引用验证，C对D的访问权限验证--没有也会抛出错误java.lang.IllegalAccessError。
		  >字段解析：先解析字段表中的类或者接口的符号引用。然后是这个类的字段检查(因为可能引用了这个类的静态字段)，如果这个接口/类中没有，那么会到父类/父接口中找这个字段，层层向上，找到则返回它的符号引用--否则报错。如果自己有，父类也有，会编译无法通过的错。
		  >类方法解析：先解析方法表中的class_index索引项指向的类或接口C的符号引用，同上。如果解析发现C是个接口，抛出java.lang.IncompatibleClassChangeError异常，然后在C中查找是否有目标方法，且一致简单名称和描述符，然后到父类中找这个方法。然后到C实现的接口列表中找，如果找到了，那么C是一个抽象类，直接抛出错误：java.lang.AbastractMethodError。否则，抛出java.lang.NoSuchMethodError。然后检查是否有对这个方法的访问权限，如果没有也抛出java.lang.IllegalAccessError。
		  >接口方法解析：先解析接口方法表的class_info中索引的类或者接口C的符号引用。如果C是个类，抛出上述异常。然后到父类中找。然后结束，无此方法。
		 >初始化：执行static{}里的内容，static的属性也会初始化。执行类构造器方法<clinit>()的过程。这个方法是编译器收集静态属性赋值和静态块后合并在一起产生的, 收集顺序从上到下，上面的语句能赋值下面的语句但不能访问。
		  >父类的<clinit>()方法先执行。这个方法不是必须的，当有静态赋值或静态块时才会产生。
		  >接口的实现类不会先执行接口的<clinit>()方法，除非使用了接口中的静态量。
		  ><clinit>方法的执行时同步的。
		>对一个类主动引用：四种场景。包括：new getstatic putstatic invokestatic指令， 反射包，父类(接口除外)，主类初始化。
		>对一个类被动引用：访问一个类的父类的静态属性，则父类会初始化，但是子类没有初始化。
							new对象数组的时候--只指定个数，也不会对这个对象进行初始化。
							在一个主类里访问另一个类的静态常量，不会初始化另一个类。因为编译阶段替换为了常量---或者说主类中加载了另一个类的常量了。
		>类加载器：根据全限定名获取类的二进制字节流。热部署、代码加密是使用场景。
		 >类的唯一性：类加载器+类确定。类的唯一性判定场景：Class对象的equals()方法，instanceof关键字，isAssignableFrom()，isInstance()方法。自定义加载器加载的类C,和系统应用加载器加载的类C，可以共存于虚拟机。
		 >类别：c++实现的启动类加载器Bootstrap ClassLoader， 是虚拟机的一部分。其他都是继承java.lang.ClasLoader的独立于虚拟机的类加载器。
		  >启动类加载器Bootstrap ClassLoader:加载 JAVA_HOME/lib下的能被识别的jar到虚拟机内存，或者-Xbootclasspath下的。启动类加载器无法被java程序直接引用。
		  >扩展类加载器Extension ClasLoader: 加载JAVA_HOME/lib/ext下的，或者java.ext.dirs系统变量路径下的类库。开发者可使用。sun.misc.Launcher$ExtClassLoader。
		  >应用程序类加载器Application ClassLoder: 系统类加载器。加载用户类路径classpath下的类库.开发者可使用。sun.misc.Launcher$AppClassLoader。
		 >双亲委派模型：组合关系实现的对上级的引用。扩展类加载的parant属性则为null,加载方法里发现父类加载器为null就会用启动类加载器来加载。
		  >过程：接收到一个类的加载，先委派给父类加载器加载，所以每次加载都会传递到Bootstrap ClassLoader启动类加载器，只有父类无法加载---在它范围内没搜索到相应的类，才由它自己加载，自己不行交给子类。所以自己写的同名rt.jar中的类，可以编译通过，但是永远不会被加载。
		  >虚拟机类加载调用过程：调用加载器的loadClassInternal()---->loadClass()里面实现双亲委派，先检查类存在？不存在则父类加载器存在？存在则用父类加载器loadClass()否则调用启动类加载器；抛出了未发现类的异常；则自己加载---->findClass()
		 >破坏双亲委派模型：线程上下文加载器。放在线程的上下文里，那么上级类加载器就可以从线程上下文里获取到线程上下文加载器来加载应用级别的类，即启动类加载器可以加载classpath下的类库。比如JNDI在rt.jar中，但是SPI在classpath下，需要加载SPI，则只能用这个线程上下文来加载。JDBC也是这样。
							代码热替换、模块热部署：替换类代码，不需要重启虚拟机。OSGI：自定义的类加载器, 出现了：交给平级加载器加载。Bundle有自己的类加载器。import列表中的类交给export类所属的bundle的加载器加载。类在自己的fragment bundle中，则交给这个bundle来加载...
		  
举动-痛点4：执行引擎
	>解法/处理思想：虚拟机规范制定了虚拟机字节码执行引擎的概念模型
		>栈帧：局部变量表、操作数栈、动态连接、方法返回地址、附加信息。需要分配的内存在Class二进制字节流中的类方法表的Code属性中已经指定。
		>当前栈帧和当前方法：栈顶的栈帧及其关联的方法。
		 >局部变量表：容量：以变量槽Slot为最小单位(32位以内的类型)。returnAddress指向了一条字节码指令的地址。long,double用连续的两个Slot空间来表示。
			>第0位Slot：this， 接着Slot存的是方法参数列表，接着的Slot存的是方法体内部的局部变量，
			>控制变量回收时间：给变量手动编码设置作用域---即用{}包围，那么退出{}之后它的slot就可以被使用来给剩下的其他局部变量了，或者接着设置=null,两种情况下原变量都不会再GC Root可达，从而被回收。
		 >操作数栈：就是计算表达式的各个参数数值，而指令就是运算符。
		 >动态连接：指向方法区运行时常量池中的该栈帧所属方法的符号引用。
		 >方法返回地址：正常返回退出---有返回值。异常返回退出---没有返回值。方法退出之后，出栈，恢复调用者的局部变量表和操作数栈，如果有返回值，压入操作数栈；然后再调整PC计数器，指向下一条指令。
		 >其他信息：取决于具体虚拟机实现。
	    >方法调用：符号引用仅仅是字节码到字节码常量池的引用/偏移量，而不是到实际机器码的地址----直接引用。
		 >类加载的解析阶段将部分符号引用转换为直接引用：解析。静态方法和私有方法适合在此时解析。
		 >方法调用指令：invokestatic----调用静态方法, invokespecial---调用实例构造器方法、私有方法、父类方法，invokevitural---调用接口方法？实际为多个重载方法中的某个
		 >虚拟机和编译器确定(重载，同一个类中)方法版本的过程：调用者输入方法的各个参数类型和方法的入参类型一致的。即编译器根据静态类型一致而不是实际类型一致来定位方法执行版本(重载版本)，称为静态分派。
											对于字面量作为调用者输入方法的入参时，则是根据字面量的类型而定，如果输入'a',则按照：char --> int -->long-->float--->double不断数据类型转换，如果没匹配则自动装箱为Character, 再自动类型转换为Serializable--->Object，再到数组类型char...变长入参
		 >虚拟机和编译器确定(覆盖/重写，父类中有，自己中覆盖)方法版本的过程： 虚拟机运行期根据实际类型来分派方法的执行版本。astore_1将变量放到第1个slot中。astore_2将变量放到第2个slot中。
		  >invokevitural指令的多态查找：先找操作数栈顶的第一个元素的实际类型，实际类型中找目标方法，没有则从父类中找目标方法...方法找到了再确定访问权限。动态分派。
		  >类在方法区建立的虚方法表：方法--方法的实际入口地址。如果子类没有覆盖父类的方法，则方法的实际入口地址为父类的，否则为自己的。方法表的初始化：在准备阶段。
		>虚拟机的解释执行引擎：
			>程序源码-->词法分析、语法分析--->抽象语法树AST--->遍历生成字节码指令流：是javac的主要执行过程。输出的指令流就是指令集架构ISA。
			 >零地址指令：依赖操作数栈进行工作。iconst_1会将1入操作数栈 iadd指令会把栈里的两个元素弹出来执行相加，后放入栈顶。astore_1指令会将栈顶元素移入局部变量表。iload_1是复制局部变量表里的1号Slot里的元素到操作数栈里。imul 将弹出栈顶的两个元素相乘后入栈，ireturn 将栈顶的元素返回给调用者。
			 >基于寄存器的指令集：依赖pc寄存器。mov xx add yy
		  
		>web服务器相关：
			>部署的项目：
			 >各个项目有同一个jar的不同版本，可以共存的原因：提供好几个classpath供用户各个项目使用，lib/classes之类名称的路径，每个路径下有相应的自定义类加载器加载其中的类库。
				>Tomcat为例：/common/*下的类库，可以被所有的Web应用和Tocmat使用,CommonClassLoader加载；/server/*下仅仅tomcat可见,CatalinaClassLoader加载；/shared/*仅仅用户项目共同使用，SharedClassLoader；/webapp/WEB-INF/目录下仅仅该项目可见,WebAppClassLoader。JasperLoader是jsp的类加载器。		
						>新的加载器架构：合并了前三个目录到/lib下，从而只有一个CommonClassLoader加载。而其中的jar是CommonClassLoader加载的，如果jar中类比如spring的某个类要访问WebApp/WEB-INF下的jar,则用破坏双亲委派机制，使用线程上下文加载器就可以实现了。	
						>OSGI:更精确的模块划分和可见性控制。模块级的热插拨功能。
						  >灵活的Bundle类加载器：当Bundle A声明了一个它依赖的package时，如果OSGI发现有其他Bundle B声明发布了这个package，那么就会使用Bundle B的类加载器加载该package进来。。没有export的类不会被提供给其他Bundle使用。
			 >各个项目共享一个jar的原因：
			 >服务器本身依赖的类库和用户项目的类库隔离：
			 >JSP-->类：叫热替换HotSwap。。且修改JSP后无需重启服务器。
		>字节码生成技术：java自带的动态代理的错误观点:需要提供一个实现类---实现的仅仅是给实现类增强---尽管可以通过提供一个匿名实现来替换来达到RPC实现的效果。
			>java自带的动态代理：提供：类加载器+ 接口+ 回调handler即可。效果就是返回了接口的代理实现类$Proxy, 代理实现类的实现代码就是执行回调handler的invoke方法。ProxyGenerator实现方式是字节码拼装。变长参数编译之后变成了数组。
			>服务器端执行临时代码：jsp方式。不侵入原项目，不依赖第三方。
			 >动态编译：tools.jar里的com.sun.tools.javac.Main类可以实现编译java文件。
			 >jsp方式实现的例子：新建一个jsp，里面访问文件系统中的一个新编译后的的class文件---里面有main方法，且输出System.out了信息，然后jsp中的逻辑是读取class文件内容放到一个byte[]数组中，然后使用字节码替换类的方法替换字节码中的System.out的符号引用为自己的某个输出类，然后使用一个类加载器将新的字节码byte[]被加载到虚拟机，形成一个Class对象，再反射调用它的main方法即可，输出信息就到了我们自己的新输出类指定的输出里了。
			
			
			
			
			
参考资料：
1.逻辑设计：《java虚拟机规范》
2.https://www.cnblogs.com/jueyoq/p/7900232.html(即时编译)
3.《java与模式》
4.java程序社区：