--------jvm的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。

1.举动-痛点：每个平台编译一次？经常内存泄漏指针越界？运行时间的增加性能越来越低？不够丰富的应用编程接口？
	>解法/处理思想：平台无关、相对安全的内存管理和访问机制、热点代码检测和运行时编译及优化、丰富第三方类库。
		>JDK内部的实现机制：尤其native的实现：编译一套自己的JDK最佳。用OpenJDK进行。JRE包含虚拟机+JDK部分api接口。
			>安装OpenJDK: cgwin + microsoft visual studio
		>自动内存管理机制：主要关注内存泄漏问题。
			>java运行时数据区：堆区、方法区、虚拟机栈、本地方法栈、程序计数器。数据区外是：执行引擎、本地库接口、本地方法库(windows/linux/...)。
			>程序计数器：一个线程有一个，记录字节码解释器的字节码位置。native方法执行时这个值就没有---是Undefined。
			>虚拟机栈：一个线程有一个。记录当前的方法调用链。栈里一个个栈帧，每个方法一个栈帧，每个栈帧--包含入参局部变量表+内部局部变量表+返回值变量、操作栈和动态链接。
				>编译期可知的所有基本数据类型：...+对象引用+returnAddress类型(指向一条字节码指令的地址)。。
				>局部变量表：在编译期所需要的内存空间已经确定：Long,double占用2字节，其他1字节。方法运行期间不会改变大小。
					>栈深太大：无动态扩展配置则stackoverflowError, 如果有扩展但是扩展需要的空间不够-垃圾回收仍然不够--还不能扩展/-自然就OutofmemoryError
			>本地方法栈：hotspot中合并到了虚拟机栈中。也会抛出上面2错误。
			>堆：线程共享。不是所有的对象都会分配在堆上。JIT和逃逸分析技术或许不会这么分配。栈上分配、标量替换。
				>分配缓存区TLAB：每个线程私有,每个线程有一个。
			>方法区：类字节码(父类、接口、内部静态变量、常量都会抽取出来专门存储)、常量、(静态变量)、JIT即时编译器编译后的代码。Hotspot中叫做永久代Permanent Generation, 会进行垃圾回收。这里也会OME
				>运行时常量池：编译期生成的字面量和符号引用。运行时常量也可以：比如String的intern()方法产生的。常量池无法再分配时也会抛出OutofmemoryError
				>直接内存：在NIO中引入的。可以使用native函数直接分配堆外内存，而在堆中用DirectByteBUffer对象来引用这块堆外内存。用户态和内核态共享数据区，避免数据在java堆和native堆中来回复制数据。
					>自然：这一块也会在动态扩展空间不够时OME
			>对象访问方式：
				>句柄：则会在堆中新增一个句柄池，对象引用存储句柄的地址，句柄池中的句柄存储各种地址---实例数据地址和类类型数据。这样实例移动后，只会改变句柄中的实例数据地址。
				>直接指针：对象引用直接存储实例数据的地址，而这个实例数据中有一个字段指向了类数据地址(方法区)。这样，访问对象会更快。Hotspot采用。
			>避免堆自动扩展：-Xmx 和-Xms设置为一样。
				>OOM时转储堆内存快照：配置-XX:+HeapDumpOnOutOfMemoryError 。则会OOM时生成堆转储快照文件。
				>分析堆转储快照文件：Eclipse Memory Analyzer..
					>内存泄漏：查看泄漏对象到GC Roots的引用链。实际上对象本身多，导致的问题情况不多。多是由于线程对象对应的OS线程占用空间太多导致的。
					>-XSS: 栈容量，是对每个线程的栈使用容量的限制。显然，如果堆内存太大，而-XSS又太大，那么OS能给的jvm进程(单个进程)的剩余空间就不多了----从而可能建立不了太多的线程----反而影响并发量。
						>报错：StackOverFlowError，也可以能OOM：unable to create new native thread 
					>内存溢出：OOM:Java heap space
					>常量池溢出：-XX:Permsize= -XXMaxPermSize=  最常见的是intern()方法，会将这个string对象包含的字符串放到常量池中，并且返回这个String对象的引用。OOM: PermGen space
					>方法区溢出：类字节码太多。OOM
					>直接内存溢出：DM设置-XX:MaxDirectMemorySize来指定。
					 >限制只能引导类加载器才会返回实例：则这个类设计时需要像Unsafe类一样。并且可以设计为只有rt.jar中的类才能使用----像Unsafe类一样。但是可以通过反射机制获取到Unsafe的实例。
						>DirectByteBuffer类：并不会直接申请内存，只是计算需要的内存大小。实际由unsafe.allocateMemory()实现----真正向OS申请分配直接内存。
			
举动-痛点2：垃圾收集和内存分配策略。哪些内存需要回收？何时回收？怎么回收？
	>解法/处理思想： 针对内存：方法区、堆区。(虚拟机栈、本地方法栈、程序计数器)都跟线程绑定，线程结束就被清理了。
		>回收步骤：
			>确定对象存活：
			 >引用计数算法：缺点--相互引用问题无法判断。
			 >根搜索算法：	GC Roots对象若干个---方法区中静态属性和常量引用的对象 + 虚拟机栈中引用的对象 + 本地方法栈中JNI引用的对象。。这些对象引用其他对象，层层向下引用更多的对象，如果有对象不在这些图下，则不可达，会被回收。
			>引用的扩展定义：需求来源：当内存紧张时，即使GC Roots可达的对象，如果它满足某种特征 或者事先给它一种标记，在此时也能被回收，那么就还可以省出空间。这种标记是引用标记，自然要从引用类型上来实现----即使用特定的类来标记。
			 >强引用：任何时候都不会被回收。--内存紧张时也不会。
			 >软引用：系统将要发生内存溢出异常之前，纳入回收范围。
			 >弱引用：下一次垃圾回收收集时，纳入回收范围。
			 >虚引用：为对象设置虚引用关联，希望能在对象被收集器回收时收到一个系统通知。唯一目的。
			>第一次标记：没有与GC Roots引用链相连接的对象，先判断有必要执行finalize()方法(如果执行过了(如上一次垃圾回收时)或者没有覆盖finalize()方法--则每必要)--然后加入到F-Queue队列中，稍后虚拟机自建的名为Finalizer的线程会来触发执行finalize()方法。如果finalize()执行中对象将自己又关联到了GC Roots引用链，那么接下来的第二次标记---即堆F-Queue队列中对象的标记就会把它移除出“即将回收”的集合，剩下的对象就会被回收了。
			>第二次标记：如上。finalize()方法不被建议使用。
		>永久代垃圾回收：废弃常量和无用类
			>常见：常量池中如果有个字符串，没有任何String对象的值是这个字符串，那么会被回收。
			>无用类的回收：无实例、类的类加载器已经被回收、反射有关的该类的java.lang.Class对象没有在任何地方被引用。//则可以卸载类。
		>垃圾收集算法：
			>标记清除：先标记，后清除。缺点：时间多、产生内存碎片。
			>复制：计算可达对象，复制到新空白区，移动堆顶指针。新生代采用。
				>IBM的研究表明：大量对象都是死的快的，所以新生代分为大块Eden + 小块2Survivor, HotSPot比例为：8：1：1， 每次回收将Eden+1Survivor的对象中幸存的---即认为是很少的复制到1Survivor里，然后Eden+1Survivor就清除空间。当然如果Survivor不够，会分配到老年代。
			>标记-整理：老年代采用。先标记可达，后统一移动到一端，将端边界以外的空间清理。因为存活率高，没有额外空间进行分配担保。
		>垃圾收集器：
			>
			
			
参考资料：
1.逻辑设计：《java虚拟机规范》
		
