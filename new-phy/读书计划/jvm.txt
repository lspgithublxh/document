--------jvm的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。

1.举动-痛点：每个平台编译一次？经常内存泄漏指针越界？运行时间的增加性能越来越低？不够丰富的应用编程接口？
	>解法/处理思想：平台无关、相对安全的内存管理和访问机制、热点代码检测和运行时编译及优化、丰富第三方类库。
		>JDK内部的实现机制：尤其native的实现：编译一套自己的JDK最佳。用OpenJDK进行。JRE包含虚拟机+JDK部分api接口。
			>安装OpenJDK: cgwin + microsoft visual studio
		>自动内存管理机制：主要关注内存泄漏问题。
			>java运行时数据区：堆区、方法区、虚拟机栈、本地方法栈、程序计数器。数据区外是：执行引擎、本地库接口、本地方法库(windows/linux/...)。
			>程序计数器：一个线程有一个，记录字节码解释器的字节码位置。native方法执行时这个值就没有---是Undefined。
			>虚拟机栈：一个线程有一个。记录当前的方法调用链。栈里一个个栈帧，每个方法一个栈帧，每个栈帧--包含入参局部变量表+内部局部变量表+返回值变量、操作栈和动态链接。
				>编译期可知的所有基本数据类型：...+对象引用+returnAddress类型(指向一条字节码指令的地址)。。
				>局部变量表：在编译期所需要的内存空间已经确定：Long,double占用2字节，其他1字节。方法运行期间不会改变大小。
					>栈深太大：无动态扩展配置则stackoverflowError, 如果有扩展但是扩展需要的空间不够-垃圾回收仍然不够--还不能扩展/-自然就OutofmemoryError
			>本地方法栈：hotspot中合并到了虚拟机栈中。也会抛出上面2错误。
			>堆：线程共享。不是所有的对象都会分配在堆上。JIT和逃逸分析技术或许不会这么分配。栈上分配、标量替换。
				>分配缓存区TLAB：每个线程私有,每个线程有一个。
			>方法区：类字节码(父类、接口、内部静态变量、常量都会抽取出来专门存储)、常量、(静态变量)、JIT即时编译器编译后的代码。Hotspot中叫做永久代Permanent Generation, 会进行垃圾回收。这里也会OME
				>运行时常量池：编译期生成的字面量和符号引用。运行时常量也可以：比如String的intern()方法产生的。常量池无法再分配时也会抛出OutofmemoryError
				>直接内存：在NIO中引入的。可以使用native函数直接分配堆外内存，而在堆中用DirectByteBUffer对象来引用这块堆外内存。用户态和内核态共享数据区，避免数据在java堆和native堆中来回复制数据。
					>自然：这一块也会在动态扩展空间不够时OME
			>对象访问方式：
				>句柄：则会在堆中新增一个句柄池，对象引用存储句柄的地址，句柄池中的句柄存储各种地址---实例数据地址和类类型数据。这样实例移动后，只会改变句柄中的实例数据地址。
				>直接指针：对象引用直接存储实例数据的地址，而这个实例数据中有一个字段指向了类数据地址(方法区)。这样，访问对象会更快。Hotspot采用。
			>避免堆自动扩展：-Xmx 和-Xms设置为一样。
				>OOM时转储堆内存快照：配置-XX:+HeapDumpOnOutOfMemoryError 。则会OOM时生成堆转储快照文件。
				>分析堆转储快照文件：Eclipse Memory Analyzer..
					>内存泄漏：查看泄漏对象到GC Roots的引用链。实际上对象本身多，导致的问题情况不多。多是由于线程对象对应的OS线程占用空间太多导致的。
					>-XSS: 栈容量，是对每个线程的栈使用容量的限制。显然，如果堆内存太大，而-XSS又太大，那么OS能给的jvm进程(单个进程)的剩余空间就不多了----从而可能建立不了太多的线程----反而影响并发量。
						>报错：StackOverFlowError，也可以能OOM：unable to create new native thread 
					>内存溢出：OOM:Java heap space
					>常量池溢出：-XX:Permsize= -XXMaxPermSize=  最常见的是intern()方法，会将这个string对象包含的字符串放到常量池中，并且返回这个String对象的引用。OOM: PermGen space
					>方法区溢出：类字节码太多。OOM
					>直接内存溢出：DM设置-XX:MaxDirectMemorySize来指定。
					 >限制只能引导类加载器才会返回实例：则这个类设计时需要像Unsafe类一样。并且可以设计为只有rt.jar中的类才能使用----像Unsafe类一样。但是可以通过反射机制获取到Unsafe的实例。
						>DirectByteBuffer类：并不会直接申请内存，只是计算需要的内存大小。实际由unsafe.allocateMemory()实现----真正向OS申请分配直接内存。
			
举动-痛点2：垃圾收集和内存分配策略。哪些内存需要回收？何时回收？怎么回收？
	>解法/处理思想： 针对内存：方法区、堆区。(虚拟机栈、本地方法栈、程序计数器)都跟线程绑定，线程结束就被清理了。
		>回收步骤：
			>确定对象存活：
			 >引用计数算法：缺点--相互引用问题无法判断。
			 >根搜索算法：	GC Roots对象若干个---方法区中静态属性和常量引用的对象 + 虚拟机栈中引用的对象 + 本地方法栈中JNI引用的对象。。这些对象引用其他对象，层层向下引用更多的对象，如果有对象不在这些图下，则不可达，会被回收。
			>引用的扩展定义：需求来源：当内存紧张时，即使GC Roots可达的对象，如果它满足某种特征 或者事先给它一种标记，在此时也能被回收，那么就还可以省出空间。这种标记是引用标记，自然要从引用类型上来实现----即使用特定的类来标记。
			 >强引用：任何时候都不会被回收。--内存紧张时也不会。
			 >软引用：系统将要发生内存溢出异常之前，纳入回收范围。
			 >弱引用：下一次垃圾回收收集时，纳入回收范围。
			 >虚引用：为对象设置虚引用关联，希望能在对象被收集器回收时收到一个系统通知。唯一目的。
			>第一次标记：没有与GC Roots引用链相连接的对象，先判断有必要执行finalize()方法(如果执行过了(如上一次垃圾回收时)或者没有覆盖finalize()方法--则每必要)--然后加入到F-Queue队列中，稍后虚拟机自建的名为Finalizer的线程会来触发执行finalize()方法。如果finalize()执行中对象将自己又关联到了GC Roots引用链，那么接下来的第二次标记---即堆F-Queue队列中对象的标记就会把它移除出“即将回收”的集合，剩下的对象就会被回收了。
			>第二次标记：如上。finalize()方法不被建议使用。
		>永久代垃圾回收：废弃常量和无用类
			>常见：常量池中如果有个字符串，没有任何String对象的值是这个字符串，那么会被回收。
			>无用类的回收：无实例、类的类加载器已经被回收、反射有关的该类的java.lang.Class对象没有在任何地方被引用。//则可以卸载类。
		>垃圾收集算法：
			>标记清除：先标记，后清除。缺点：时间多、产生内存碎片。
			>复制：计算可达对象，复制到新空白区，移动堆顶指针。新生代采用。
				>IBM的研究表明：大量对象都是死的快的，所以新生代分为大块Eden + 小块2Survivor, HotSPot比例为：8：1：1， 每次回收将Eden+1Survivor的对象中幸存的---即认为是很少的复制到1Survivor里，然后Eden+1Survivor就清除空间。当然如果Survivor不够，会分配到老年代。
			>标记-整理：老年代采用。先标记可达，后统一移动到一端，将端边界以外的空间清理。因为存活率高，没有额外空间进行分配担保。
		>垃圾收集器：
			>Serial收集器：单线程工作方式。先STW方式复制算法 收集年轻代；再以STW方式标记-整理算法收集老年代。用途：虚拟机运行在client模式下。
			>ParNew收集器：多线程方式。过程和算法同上，仅仅在年轻代采用了多线程。而对于老年代，仍然是单线程。用途：Server模式下。新生代收集器。-XX:+UseConcurrentMarkSweepGC和-XX:+UseParNewGC时开启新生代采用的收集器。
			>Parallel Scavenge收集器：多线程方式。也是复制算法。目标：可控的吞吐量--即cpu利用率(垃圾回收使用cpu时间短则吞吐量高)。
				>停顿时间：指的是单次回收时的暂停时间。实际上频率可能在变，导致单次停顿时间短了但是总共的停止时间多了---即吞吐量低了。
				>自适应调节策略：给虚拟机一个参数目标：-XX:MaxGCPauseMills(单次停顿时间) -XX:GCTimeRadio(吞吐量), -Xmx最大堆。虚拟机自己动态调整新生代大小、Eden和Survivor的比例，新生代对象晋升到老年代的年龄。
			>Serial Old收集器：单线程，老年代。标记-整理算法。Client模式下。Parallel Scavenge配合使用。CMS的后备方案---CMS模式失败的时候。
			>Parallel Old收集器：多线程，老年代。标记-整理算法。在注重吞吐量+cpu多核利用的目标下，即吞吐量优先，那么常常组合Parallel Scavenge 配合使用。
			>CMS收集器：标记-清除算法。目标在缩短暂停时间(使用并发)(而不是注重吞吐量--即不是为了cpu利用率低)(并发时间不算在停顿时间内)。过程：三次标记一次清除。
				>初始标记：GC Roots直接关联到的对象。STW
				>并发标记：和用户线程同时运行。GC Tracing，引用链上的所有对象。
				>重新标记：并发标记期间用户新产生的垃圾。因为并发标记时间显著最长。STW
				>并发清除：和用户线程同时运行。标记清除。
			 ----缺点：并发启动的回收线程数=(cpu数 + 3)/4导致cpu<4个时用户吞吐量、执行速度还是有较大的降低。
						浮动垃圾。导致68%老年代利用就会触发垃圾回收，导致回收次数多。但可以配置调高。85%例如。
						标记-清除。产生内存碎片。可以各种配置来减少。会在Full GC后整理，或者压缩。
			>G1收集器：标记-整理算法。长时间运行的系统更适合。低停顿的垃圾回收--指定最大暂停时间--底层原因：不再是全区域的在整个年轻代或者老年代进行垃圾回收，而是新生代老年代都划分为2M为最小单位的区域region,并记录region里面垃圾的多少，按照多少排序优先收集垃圾多的。。
				>
		>常见垃圾收集器组合：总结：新生代3种：Serial --> ParNew --> Parallel Scavenge , 年老代3种：Serail Old --> Parallel Old --> CMS   最终的划分小区域垃圾优先并行回收的两代回收：G1
			>Serial + Serial Old: client模式下。 +UseSerailGC打开启用
			>ParNew + Serial Old: +UseParNewGC打开启用
			>ParNew + CMS + Serial Old: Serail Old是CMS的后备方案。在Concurrent Mode Failure之后启用。+UseConcMarkSweepGC启用。
				>CMS优化选项：CMSInitailingOccupancyFraction---老年代占用多少之后开始垃圾回收68%, UseCMSCompactAtFullCollections垃圾回收后是否要进行一次内存碎片整理，CMSFullGCsBeforeCompaction设置若干次垃圾收集后再进行一次内存碎片整理。
			>Parallel Scavenge + Serial Old: 虚拟机在Server模式下默认方案。+UseParallelGC后启用。
				>Parallel Scavenge 优化选项：GCTimeRadio---GC时间占用总时间的比率，默认99 ; MaxGCPauseMills--设置单次GC最大暂停时间。
			>Parallel Scavenge + Parallel Old:  。通过+UseParallelOldGC启用。ParallelGCThreads并行垃圾回收的线程数。
		>对象的内存分配：堆上分配(JIT之后在栈上分配。动态编译三个时机：编译时--cglib通过asm复制操作字节码产生(字节码增强)(对生成好的.class生成它的子类)(aspectJ通过JCC自己的语法编译工具：直接修改class文件，在调用的地方进行增强--前后增加Observer的方法)，类加载时期，运行时期(JDK动态代理其实也是，类似于动态编译--只是更简单的实现：))
			>堆区分配：Eden区--不足则发起一次MinorGC，TLAB上， 老年代。
			  >打印内存回收日志：在发生垃圾收集行为时进行。-XX:+PrintGCDetails
			  >分配担保机制：Eden中要转移的对象总量太大无法转移放到Survivor中时直接提前转移到老年代的机制(不会只转一部分或转一点到Survivor)。
				>大对象直接进入老年代：避免频繁MinorGC, 设置-XX:PretenureSizeThreshold参数。
			  >频繁MinorGC原因：有大对象要分配，导致eden空间剩余较多但不够就开始MinorGC来容纳这个大对象。
			  >暂停时长多的原因：Parallel Scavenge / G1 最大暂停时间设置的太小，是会导致这种现象的。频繁MinorGC导致。
			  >对象进入老年代：每个对象都有一个年龄计数器，先Minor到Survivor,增长1，然后每次Minor在S0,S1之间转移，每次增长1，直到默认15或者指定的-XX:MaxTenuringThreshold参数。
				>算法2：中位数法：占用空间一半的某个年龄的对象及其以上年龄的对象直接转移到老年代。
			    >空间分配担保：如果晋升到老年代的大小大于老年代剩余空间大小，大于，则直接进行一次FullGC, 小于则先查看是否允许担保失败----允许则只进行一次MinorGC, 否则也是FullGC
					(就是老年代担保有空间可以分配剩下的对象-XX:-HandlePromotionFailure=true)
		>虚拟机命令工具：jps, jstat, jinfo,jmap, jstack, jhat。。。jps -l
			>jmap: 内存转储快照的生成，堆内对象的查看。-heap查看垃圾回收器、参数配置等。 -histo:对象统计 。 -dump堆转储快照。
			>jstack: 显示虚拟机线程快照。查看各个线程的状态：wait ,wait for 等待中--执行中--/外部请求等待中，等待什么资源----阻塞中bloking。。查看线程长时间停顿的原因。堆栈信息，在哪个方法哪条代码上等待，是否占用了哪个对象的锁。
			  >死锁：
			  >死循环：
			  >请求外部资源：
			>jhat: 堆转储浏览器，分析heapdump文件，并启动一个http服务器可以可视化访问查看。一般不采用。而是导出来，在Eclipse Memory Analyzer 里进行分析。
			>jstat: 统计分析工具。类加载、垃圾收集、
			  >jstat -gc pid interval times 查看各代占用和垃圾回收情况，-gcutil -gccause 。。jit编译过的方法等。
			>jinfo: 虚拟机各项参数值：jinfo -flag 参数名 pid 
			----查看所有线程的堆栈信息：用Thread类提供的方法。火焰图。
		>虚拟机监控工具：visual vm 动态监控cpu/内存占用，堆内存对象占用，虚拟机栈中各线程的运行状态和调用链，Mbean的管理--远程查看值和调用方法。
			>独特的是可以安装插件：比如Visual GC 动态查看堆区各代占用比例，垃圾收集情况。
									比如Btrace ：场景：某方法报错，但是没打印入参和返回值。可以Btrace来查看。HotSwap技术---代码热替换技术---虚拟机运行不停止的情况下，替换已经加载的类的代码。定位连接泄漏、内存泄漏、解决多线程竞争问题等。
		>故障排查：
			>网站长时间没有响应：GC停顿--->Parallel Old这种吞吐量优先的收集器--->Full GC耗时14s--->文档序列化为大对象直接加到了老年代。：避免批量产生生存时间长的大对象。
				>不仅-Xms=-Xmx，而且-XX:PermSize=-XX:MaxPermSize。。对eclipse: 可以禁用代码验证-Xverify:none和禁止显式GC：System.gc()-XX:+DisableExplicitGC
			>逆向ajax技术：Comet, server side push .。。系统占用两种情形：java直接本地方法调用发起的系统调用，第二种是直接向系统申请共享内存/直接内存Unsafe.allocateMemory()--内核态和用户态都可以访问--避免态的来回切换和数据的来回复制NIO和零拷贝都基于这个原理。	但是Direct Memory的回收时间只能是某次Full GC之后垃圾收集器顺便进行回收废弃对象占用的空间。			
				>Comet: 基于http长连接的推技术。前端comet4j.js	后端comet4j-tomcat7.jar
			>JVM外会占用的空间：
				>Direct Memory: 通过-XX:MaxDirectMemorySize来调整大小。抛出的OOM：就会是Direct buffer memory
				>线程：系统的线程已满。unable to create new native thread//。。java虚拟机创建的线程，对应轻量级进程，对应linux的内核线程。
				>socket缓冲区：系统每个socket读写分别占用30KB左右的内存
				>JNI调用的本地库：也不在JVM中。
			>网站响应比较慢：CPU占用时间太多(查看Dtrace看是哪个系统调用占用)-->fork系统调用太多---->java调用Runtime运行命令/shell脚本---->jvm会克隆一个和当前虚拟机一样环境变量的进程，再在该进程里执行命令,然后退出进程--->是个消耗cpu和内存的事情。
				>linux和windows上线程的区别：windows上的线程由操作系统负责线程的调度。linux上的线程由创建线程的进程进行调度。windows上的线程在内核中也有。linux中在内核中只有进程，从而用户空间中的概念“线程”是用轻量级进程来表示的----共享一个代码上下文，内核中--进程是调度的最小单位。
				>web服务的同步调用和异步调用：同步调用就是通常的。异步调用就是回调，例如AIO, netty的回调。异步调用的服务方就压力大，建议改为消息发送方式：客户端接收；即交给第三方。
		>eclipse插件开发：比如eclipse启动时间统计。继承IStartUp类，并编写plugin.xml并打jar包放到plugins下即可。
			>启动时禁止字节码验证：-Xverify:none
		>JIT即时编译器：内嵌在JVM字节码执行引擎中。将字节码映射为本机机器码，由一个解释器完成。性能则不足，为此将部分频繁调用的方法先优化后直接编译为本机机器码，那么直接走系统调用，不用再次解释了，性能得到提高。由C1,C2两种编译器，后者优化程度更高。可以优化回退为解释执行，分层优化。而javac是静态编译。
			>优化地方：重复计算、方法内联(调用方法替换为方法的代码)、逃逸分析-栈上分配-标量替换(数据流分析机制，将对象放到线程栈里而不是堆里，且存对象的属性而不是对象本身，避免对象头和对齐填充空间的浪费)、逃逸分析-同步消除(锁没有逃逸仅仅线程私有，则JIT将同步锁去掉)
			>优化代价和结果：代价是运行时编译时间。结果是：热点方法不断出现而被编译，代码整体编译程度越来越高，性能越来越好。-server模式。
		>用户线程的安全点检测、挂起、恢复：在一次GC前。
		
举动-痛点3：虚拟机执行子系统
	>解法/处理思想：平台无关性、语言无关性。java语言规范、java虚拟机规范。
		>Class文件：8位字节位单位的二进制流。数据项>8位，高位在前的多个字节来存储。
		 >存储结构：无符号数、表。(另外有：容量计数器，前置在若干个连续的同类数据项之前，称这类数据的集合)
			>无符号数：4种。u1,u2,u3,u4 描述数字、索引引用、字符串。
			>表：复合数据结构。多个无符号数、其他表为数据项。以_info结尾为表的名称，所以有很多种。常量池是cp_info 
		 >头4个字节：魔数。标记是否能被虚拟机接受。0xCAFEBABE
		 >接着4个字节：文件次版本号(2字节,小数后面65535最大)+主版本号(2字节，45开始，1.7就是51)。45.65535为第一版的最大次版。JDK向下兼容。
		 >接着常量池入口：表类型。容量计数器(1字节,从1开始) + 常量 (字面量+符号引用)(都是表结构)
			>字面量：字符串、final常量值
			>符号引用：编译产生的：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
		  >常量池中常量所有的表结构：11种。
		   CONSTANT_Class_info表结构为例：
			>表结构开头：u1类型的标志位tag.1-12映射各种常量类型。7
			>表结构接着：u2类型的索引值name_index指向了一个CONSTANT_Utf8_info类型的常量，来描述这个类的全限定名。
		   CONSTANT_Utf8_info表结构：
			>u1标志位tag：1
			>u2字符串长度length:
			>u1字符byte：共有length个，缩略UTF-8编码方式：1-2-3个字节表示。
		   CONSTANT_Integer_info: u1tag + u4bytes
		   CONSTANT_String_info: u1tag + u2index(指向字符串字面量)
		   CONSTANT_Fieldref_info: u1tag + u2index(指向类描述符CONSTANT_Class_info) + u2index(指向字段描述符CONSTANT_NameAndType_info)
		   
		 >查看class文件种的常量池：javap -verbose A
		>接着2字节访问标志：类或者接口的前缀描述符，页描述是否是枚举等。共32个标志位。即32种是否判断。
		>接着u2类索引、u2父类索引、接口索引集合(u2容量计数器+接口索引)：
		>接着是字段表集合：u2容量计数器 + u2简单名称索引 + u2字段描述符索引 + u2属性表集合(额外信息，比如字段的初始化值)
		>接着是方法表集合：同上，其中u2属性表集合存储包括：Code为属性名的方法体编译后的指令集合。(养成先说原因后说结论的习惯，而不是反过来)。注意，存在类构造器方法。特征签名不包含返回值类型--所以仅仅返回值不同是同一个重载。
		 >用描述符来描述字段和方法：
		  >字段：u2标志位(字段前面的各种关键字修饰符) + u2简单名称索引 + 描述符(描述字段的数据类型，实现方式：大写字符如B-C-D-F-I-J-S-Z-V-L表示基本类型和对象类型,数组每个维度用[表示)
		  >方法：u2标志位 +  u2简单名称索引 + u2描述符(先参数列表，后返回值)索引 
		 --字段不能重载，所以字段名称需要不一样。
		 >属性表：u2属性名常量索引 + 具体而定属性值字节长度 + u1字节(长度n个) 
		  >Code属性: 方法体内字节码指令。-g:none禁用
			>属性值表结构：u2标记+u4属性值长度
			>栈帧中的操作数栈深度：max_stack
			>局部变量表所需的存储空间：max_locals  计算出来的，并且方法内一个变量作用域结束后它的slot可以释放而给其他变量使用。注意实例方法默认的入参this
			>字节码指令：u1code + u4code_length 每个u1长度的都是一个指令，java共有约200条指令。
			 >aload_0指令2A:将第0个slot中的为refrefence类型的局部变量 推送至栈顶。
			 >invokespecial指令B7：紧接着后面会跟着“方法”的符号引用u2。表示将栈顶对象来调用它的该方法来执行。
			 >return指令B1: 指令执行的时候，会把值设置到returnValue变量里去。实际赋值时：放到最后一个本地变量表的Slot中----ireturn时将这个Slot的数据读到操作数栈顶，作为方法返回值来使用。
		  >ConstantValue属性：常量值
			>异常表结构：
			 >start_pc: u2字节码行号
			 >end_pc:u2
			 >handler_pc:u2
			 >catch_type:u2
			>新的指令：
			 >iconst_1: 常量赋值1 iconst_3赋值3
			 >istore_1: 配合赋值之后使用
			 >iload_1: 从变量中赋值
			>最后出现的Exception table说明：有多行数据出现。如3条。
				>from列  to列 	target列 	type列
				  指令起始行号	结束行号	跳转行号	异常类型(起止中发生的异常)
		  >Exceptions属性：方法定义抛出的异常。内部try-catch-finally
			>u2属性名索引+u4属性长度 + u2异常类个数 + u2异常类常量索引
		
		  >LineNumberTable属性：行号和字节码指令行号的映射表。方便抛出异常时带上行号。用源码行号进行debug。
			>u2属性名索引+u4属性长度+u2行号表长度+line_number_info结构(start_pc u2 + line_number u2)的行号表若干个
		  >LocalVariableTable属性：方法的局部变量表描述和字节码指令中的变量名之间的映射。用于其他人引用之后可以看到源码中的名称。同时调试时可以根据参数名称获取到参数值。
			>u2属性名索引+u4属性长度+u2local_variable_info结构(start_pc起止偏移量+length作用域长度+名称索引+描述符索引+在栈帧局部变量表中Slot的位置index)
		  >LocalVariableTypeTable属性：局部变量类型中有泛型则用这个属性，差异在：描述符用特征签名替换---因为描述符中泛型类型被擦除了。
		  >SourceFile属性：源码文件名称。u2属性名索引+u4属性长度+u2源文件名常量索引。。方便抛出异常时显示所在源文件名
		  >ConstantValue属性：定长属性。u2属性名索引+u4属性长度+u2字面量常量值索引
		  >InnerClasses属性：内部类描述。u2属性名索引+u4属性长度+u2内部类个数+inner_classes_info类描述结构(内部类和宿主类的符号引用+内部类名称索引+内部类类访问标记位)
		  >Deprecated属性：标志类型布尔类型.u2属性名索引+u4属性长度
		  >Synthetic属性：标志类型布尔类型：内部类并非由用户代码产生：则为true..u2属性名索引+u4属性长度。。。扩展性就是：预留扩展点和预留空间。
		 
举动-痛点3：类加载机制
	>解法/处理思想：校验、转换解析、初始化
		>类生命周期：加载、验证、准备、解析、初始化、使用、卸载。解析可能发生在初始化之后。
		 >加载：类加载的一个阶段。1.通过类全限定名找到二进制字节流--->2.在方法区生成这个二进制字节流静态数据结构对应的运行时数据结构--->3.在堆中实例化生成一个java.lang.Class对象，指向方法区的这个运行时数据结构。
		  >类加载器的目标：获取字节流。
		 >验证：因为字节流不规定要从源码编译而来--可能修改字节码而来---可以十六进制编译器编写而来。所以要验证。
		  >文件格式验证：魔数、主版本次版本、常量类型tag、指向常量的索引值、CONSTANT_Utf8_info常量编码规范。决定能否放到方法区
		  >元数据验证：字节码信息的语义正确性分析。不符合java语法规范的那些错误--即本在编译阶段就不会通过的错误。
		  >字节码验证：方法体内的代码的校验：保证字节码指令是对对应的源码的正确实现。类型转换有效.
		  >符号引用验证：对类自身以外的信息(引用的其他类的信息)进行匹配校验。-Xverify:none不验证。
		 >准备：为类变量分配内存并设置零值。(并不是类变量的初始值-putstatic设置的值在初始化阶段开始执行)------但也看情况，看字段属性表里是否有ConstantValue属性，有则准备阶段就已经赋值了。
		 >解析：将常量池里的符号引用替换为直接引用(尤其是指向其他类的符号引用)。直接引用是直接指向目标的指针，跟虚拟机实现的内存布局相关--每次启动布局不同--因为内存地址不同。符号引用的值仅仅是符号--字面量，目标不一定加载到内存。(存在着 符号引用到直接引用的映射缓存表)
		  >D类的符号引用是其他类或者接口C：设这个符号引用的值是N,那么D类的类加载器会将N当作接口的全限定名去加载，即加载类C。如果C是数组，则C的数组元素类型也会从N(如[Ljava.lang.Integer)中解释出来(java.lang.Integer)而加载，然后虚拟机生成一个此数组对象。然后符号引用验证，C对D的访问权限验证--没有也会抛出错误java.lang.IllegalAccessError。
		  >字段解析：先解析字段表中的类或者接口的符号引用。然后是这个类的字段检查(因为可能引用了这个类的静态字段)，如果这个接口/类中没有，那么会到父类/父接口中找这个字段，层层向上，找到则返回它的符号引用--否则报错。如果自己有，父类也有，会编译无法通过的错。
		  >类方法解析：先解析方法表中的class_index索引项指向的类或接口C的符号引用，同上。如果解析发现C是个接口，抛出java.lang.IncompatibleClassChangeError异常，然后在C中查找是否有目标方法，且一致简单名称和描述符，然后到父类中找这个方法。然后到C实现的接口列表中找，如果找到了，那么C是一个抽象类，直接抛出错误：java.lang.AbastractMethodError。否则，抛出java.lang.NoSuchMethodError。然后检查是否有对这个方法的访问权限，如果没有也抛出java.lang.IllegalAccessError。
		  >接口方法解析：先解析接口方法表的class_info中索引的类或者接口C的符号引用。如果C是个类，抛出上述异常。然后到父类中找。然后结束，无此方法。
		 >初始化：执行static{}里的内容，static的属性也会初始化。执行类构造器方法<clinit>()的过程。这个方法是编译器收集静态属性赋值和静态块后合并在一起产生的, 收集顺序从上到下，上面的语句能赋值下面的语句但不能访问。
		  >父类的<clinit>()方法先执行。这个方法不是必须的，当有静态赋值或静态块时才会产生。
		  >接口的实现类不会先执行接口的<clinit>()方法，除非使用了接口中的静态量。
		  ><clinit>方法的执行时同步的。
		>对一个类主动引用：四种场景。包括：new getstatic putstatic invokestatic指令， 反射包，父类(接口除外)，主类初始化。
		>对一个类被动引用：访问一个类的父类的静态属性，则父类会初始化，但是子类没有初始化。
							new对象数组的时候--只指定个数，也不会对这个对象进行初始化。
							在一个主类里访问另一个类的静态常量，不会初始化另一个类。因为编译阶段替换为了常量---或者说主类中加载了另一个类的常量了。
		>类加载器：根据全限定名获取类的二进制字节流。热部署、代码加密是使用场景。
		 >类的唯一性：类加载器+类确定。类的唯一性判定场景：Class对象的equals()方法，instanceof关键字，isAssignableFrom()，isInstance()方法。自定义加载器加载的类C,和系统应用加载器加载的类C，可以共存于虚拟机。
		 >类别：c++实现的启动类加载器Bootstrap ClassLoader， 是虚拟机的一部分。其他都是继承java.lang.ClasLoader的独立于虚拟机的类加载器。
		  >启动类加载器Bootstrap ClassLoader:加载 JAVA_HOME/lib下的能被识别的jar到虚拟机内存，或者-Xbootclasspath下的。启动类加载器无法被java程序直接引用。
		  >扩展类加载器Extension ClasLoader: 加载JAVA_HOME/lib/ext下的，或者java.ext.dirs系统变量路径下的类库。开发者可使用。sun.misc.Launcher$ExtClassLoader。
		  >应用程序类加载器Application ClassLoder: 系统类加载器。加载用户类路径classpath下的类库.开发者可使用。sun.misc.Launcher$AppClassLoader。
		 >双亲委派模型：组合关系实现的对上级的引用。扩展类加载的parant属性则为null,加载方法里发现父类加载器为null就会用启动类加载器来加载。
		  >过程：接收到一个类的加载，先委派给父类加载器加载，所以每次加载都会传递到Bootstrap ClassLoader启动类加载器，只有父类无法加载---在它范围内没搜索到相应的类，才由它自己加载，自己不行交给子类。所以自己写的同名rt.jar中的类，可以编译通过，但是永远不会被加载。
		  >虚拟机类加载调用过程：调用加载器的loadClassInternal()---->loadClass()里面实现双亲委派，先检查类存在？不存在则父类加载器存在？存在则用父类加载器loadClass()否则调用启动类加载器；抛出了未发现类的异常；则自己加载---->findClass()
		 >破坏双亲委派模型：线程上下文加载器。放在线程的上下文里，那么上级类加载器就可以从线程上下文里获取到线程上下文加载器来加载应用级别的类，即启动类加载器可以加载classpath下的类库。比如JNDI在rt.jar中，但是SPI在classpath下，需要加载SPI，则只能用这个线程上下文来加载。JDBC也是这样。
							代码热替换、模块热部署：替换类代码，不需要重启虚拟机。OSGI：自定义的类加载器, 出现了：交给平级加载器加载。Bundle有自己的类加载器。import列表中的类交给export类所属的bundle的加载器加载。类在自己的fragment bundle中，则交给这个bundle来加载...
		  
举动-痛点4：执行引擎
	>解法/处理思想：虚拟机规范制定了虚拟机字节码执行引擎的概念模型
		>栈帧：局部变量表、操作数栈、动态连接、方法返回地址、附加信息。需要分配的内存在Class二进制字节流中的类方法表的Code属性中已经指定。
		>当前栈帧和当前方法：栈顶的栈帧及其关联的方法。
		 >局部变量表：容量：以变量槽Slot为最小单位(32位以内的类型)。returnAddress指向了一条字节码指令的地址。long,double用连续的两个Slot空间来表示。
			>第0位Slot：this， 接着Slot存的是方法参数列表，接着的Slot存的是方法体内部的局部变量，
			>控制变量回收时间：给变量手动编码设置作用域---即用{}包围，那么退出{}之后它的slot就可以被使用来给剩下的其他局部变量了，或者接着设置=null,两种情况下原变量都不会再GC Root可达，从而被回收。
		 >操作数栈：就是计算表达式的各个参数数值，而指令就是运算符。
		 >动态连接：指向方法区运行时常量池中的该栈帧所属方法的符号引用。
		 >方法返回地址：正常返回退出---有返回值。异常返回退出---没有返回值。方法退出之后，出栈，恢复调用者的局部变量表和操作数栈，如果有返回值，压入操作数栈；然后再调整PC计数器，指向下一条指令。
		 >其他信息：取决于具体虚拟机实现。
	    >方法调用：符号引用仅仅是字节码到字节码常量池的引用/偏移量，而不是到实际机器码的地址----直接引用。
		 >类加载的解析阶段将部分符号引用转换为直接引用：解析。静态方法和私有方法适合在此时解析。
		 >方法调用指令：invokestatic----调用静态方法, invokespecial---调用实例构造器方法、私有方法、父类方法，invokevitural---调用接口方法？实际为多个重载方法中的某个
		 >虚拟机和编译器确定(重载，同一个类中)方法版本的过程：调用者输入方法的各个参数类型和方法的入参类型一致的。即编译器根据静态类型一致而不是实际类型一致来定位方法执行版本(重载版本)，称为静态分派。
											对于字面量作为调用者输入方法的入参时，则是根据字面量的类型而定，如果输入'a',则按照：char --> int -->long-->float--->double不断数据类型转换，如果没匹配则自动装箱为Character, 再自动类型转换为Serializable--->Object，再到数组类型char...变长入参
		 >虚拟机和编译器确定(覆盖/重写，父类中有，自己中覆盖)方法版本的过程： 虚拟机运行期根据实际类型来分派方法的执行版本。astore_1将变量放到第1个slot中。astore_2将变量放到第2个slot中。
		  >invokevitural指令的多态查找：先找操作数栈顶的第一个元素的实际类型，实际类型中找目标方法，没有则从父类中找目标方法...方法找到了再确定访问权限。动态分派。
		  >类在方法区建立的虚方法表：方法--方法的实际入口地址。如果子类没有覆盖父类的方法，则方法的实际入口地址为父类的，否则为自己的。方法表的初始化：在准备阶段。
		>虚拟机的解释执行引擎：
			>程序源码-->词法分析、语法分析--->抽象语法树AST--->遍历生成字节码指令流：是javac的主要执行过程。输出的指令流就是指令集架构ISA。
			 >零地址指令：依赖操作数栈进行工作。iconst_1会将1入操作数栈 iadd指令会把栈里的两个元素弹出来执行相加，后放入栈顶。astore_1指令会将栈顶元素移入局部变量表。iload_1是复制局部变量表里的1号Slot里的元素到操作数栈里。imul 将弹出栈顶的两个元素相乘后入栈，ireturn 将栈顶的元素返回给调用者。
			 >基于寄存器的指令集：依赖pc寄存器。mov xx add yy
		  
		>web服务器相关：
			>部署的项目：
			 >各个项目有同一个jar的不同版本，可以共存的原因：提供好几个classpath供用户各个项目使用，lib/classes之类名称的路径，每个路径下有相应的自定义类加载器加载其中的类库。
				>Tomcat为例：/common/*下的类库，可以被所有的Web应用和Tocmat使用,CommonClassLoader加载；/server/*下仅仅tomcat可见,CatalinaClassLoader加载；/shared/*仅仅用户项目共同使用，SharedClassLoader；/webapp/WEB-INF/目录下仅仅该项目可见,WebAppClassLoader。JasperLoader是jsp的类加载器。		
						>新的加载器架构：合并了前三个目录到/lib下，从而只有一个CommonClassLoader加载。而其中的jar是CommonClassLoader加载的，如果jar中类比如spring的某个类要访问WebApp/WEB-INF下的jar,则用破坏双亲委派机制，使用线程上下文加载器就可以实现了。	
						>OSGI:更精确的模块划分和可见性控制。模块级的热插拨功能。
						  >灵活的Bundle类加载器：当Bundle A声明了一个它依赖的package时，如果OSGI发现有其他Bundle B声明发布了这个package，那么就会使用Bundle B的类加载器加载该package进来。。没有export的类不会被提供给其他Bundle使用。
			 >各个项目共享一个jar的原因：
			 >服务器本身依赖的类库和用户项目的类库隔离：
			 >JSP-->类：叫热替换HotSwap。。且修改JSP后无需重启服务器。
		>字节码生成技术：java自带的动态代理的错误观点:需要提供一个实现类---实现的仅仅是给实现类增强---尽管可以通过提供一个匿名实现来替换来达到RPC实现的效果。
			>java自带的动态代理：提供：类加载器+ 接口+ 回调handler即可。效果就是返回了接口的代理实现类$Proxy, 代理实现类的实现代码就是执行回调handler的invoke方法。ProxyGenerator实现方式是字节码拼装。变长参数编译之后变成了数组。
			>服务器端执行临时代码：jsp方式。不侵入原项目，不依赖第三方。
			 >动态编译：tools.jar里的com.sun.tools.javac.Main类可以实现编译java文件。
			 >jsp方式实现的例子：新建一个jsp，里面访问文件系统中的一个新编译后的的class文件---里面有main方法，且输出System.out了信息，然后jsp中的逻辑是读取class文件内容放到一个byte[]数组中，然后使用字节码替换类的方法替换字节码中的System.out的符号引用为自己的某个输出类，然后使用一个类加载器将新的字节码byte[]被加载到虚拟机，形成一个Class对象，再反射调用它的main方法即可，输出信息就到了我们自己的新输出类指定的输出里了。
			
		>前端编译过程：.java -->.class的javac的原理	。查看javac源码
			>解析与填充符号表：
			 >词法分析:将字符流转变为 标记集合。com.sun.tools.javac.parser.Scanner类来实现。本质和split差别不大。就是切分为一个个合理的最小的元素部分
			 >语法分析：根据标记Token序列构造抽象语法树。每个节点是一个语法结构。Eclise AST View有说明。com.sun.tools.javac.parser.Parser类来实现。com.sun.tools.javac.tree.JCTree类来描述抽象语法树。
			 >输入到符号表：符号地址和符号信息构成的表格。用于：语义检查(名字的使用是否和说明一致)、产生中间代码、对符号名地址分配的依据。com.sun.tools.javac.comp.Enter类来实现。
			>注解处理：插入时注解处理器的标准API--->可以对抽象语法树进行读取修改添加元素；修改之后重新回到解析与填充符号表的过程。实现如编码风格校验工具的功能。
			>分析与字节码生成：语义分析和字节码生成。语义分析：源程序是否符合逻辑---进行上下文有关性质的审查如类型审查。
			 >标注：变量是否声明、变量与赋值的数据类型之间是否匹配。常量折叠：将int a =1 + 2折叠为int a=3;com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类实现。
			 >数据流分析：程序局部变量使用前是否赋值、方法的每条路径是否有返回值、是否所有的受查异常都被正确处理。。注意局部变量没有访问标志---比如方法的入参就是没有的---所以加final和不加编译的结果是一样的。实现类com.sun.tools.javac.comp.Flow类。
			 >解语法糖：语法糖是一种写法，可以方便程序员使用，对语言的功能没有影响，增加程序的可读性--减少程序出错的机会。如泛型、变长参数、自动装箱拆箱。但是需要在编译时还原为基础语法结构，这个过程就是解语法糖。com.sun.tools.javac.comp.TransTypes类和com.sun.tools.javac.comp.com.sun.tools.javac.comp.Lower类中完成。
			   >泛型：只在源码中存在。字节码中被替换为了原生类型Raw Type。实现方式称为泛型擦除。仅仅是Code属性中的字节码泛型擦除，元数据中保留了泛型信息----所以反射可以获取到。
			   >自动装箱：for快速循环会编译为迭代器实现。字面量整数之类会被编译为包装类。包装类的== 无运算时不会拆箱和 equals()方法不会类型转换。
			 >生成字节码：com.sun.tools.javac.jvm.Gen类来实现。将语法树、符号表转换为字节码写到磁盘中，同时也进行少量的代码添加和转换工作----如类实例构造器<clinit>(),如将字符串相加操作替换为StringBuilder的append()等。完成对语法树的遍历和调整之后，把填充了所有所需信息的符号表提交到com.sun.tools.javac.jvm.ClassWriter类上---输出字节码--生成最终的Class文件。
		>条件编译：编译时就去掉永远不会到达的代码。在解语法糖的阶段完成。
		>插入时注解处理器：
		 >校验程序写得好不好：FindBug, CheckStyle;扫描字节码或者源码来实现。
		  >编写一个驼峰命名法的代码风格校验工具：
		    >自定义的注解处理器：实现javax.annotation.processing.AbstractProcesser, 覆盖process()方法，这个方法会被编译器调用，这个方法提供注解集合+语法树节点Element+处理器环境上下文processingEnv。。这个实现类有两个类上注解可以使用：@SupportedAnnotationTypes表示对哪些注解感兴趣和@SupportedSourceVersion支持哪些java版本代码。process()方法返回false表示没有对语法树进行修改。可以借助javax.lang.model.util.ElementScanner6.NameCheckScanner类。Lombok则在编译时候修改语法树。Hibernate Validator检查类似。
			>打印编译信息：-XprintRounds和-XprintProcessorInfo
		>即时编译器：编译性能和代码优化程度是关键指标。	
		 >解释器和编译器并存的原因：
		  >解释执行的好处：快速启动来执行，节约内存，编译器激进优化时的一个逃生门---通过逆优化退回到解释状态(c1也是c2的逃生门)。
		  >编译执行的好处：编译为本地代码后，有更好的执行效率。编译耗时，优化程度越高编译越耗时。
		   >分层编译：动机---启动相应速度和运行效率。第0层：解释执行，不开启性能监控，可触发第1层编译。第1层：C1编译，字节码编译为本地代码，并进行简单可靠的优化，可能进行性能监控profiling,.第2层：C2编译，字节码编译为本地代码，并进行耗时较长的优化，甚至根据性能监控信息进行一些激进的优化。
		 >两个编译器的原因：虚拟机所在的机器硬件性能有差异。-client -server强行指定使用哪个编译器。-Xint强行只用解释器。-Xcomp强行只用编译器，但是会保留解释器作为逃生门。java -version会输出在哪种模式下。最常见是混合模式。
		 >何时解释何时编译：
		 >哪些编译何时编译：
		   >多次调用的方法和体内有多次执行的循环的方法：都会认为是热点代码而触发编译为本地代码。后一种编译方式称为：栈上替换OSR。
			>热点探测：基于采样：周期性的检查各个线程的栈顶，统计栈顶方法出现的次数---但是受线程阻塞的影响。另一种：基于计数器：为每个方法建立计数器，记录执行次数，HotSpot虚拟机采用这种---准备了两个计数器：方法调用计数器和回边计数器。client模式下1500，server模式下10000。累次调用累次增加1，直到和超过阈值而提交请求给编译器，编译完成后才会从编译后的本地代码开始执行。当在一定的时间之内方法仍然没有被触发编译，那么调用次数会被减半，称为热度衰减导致的半衰周期，-XX:CounterHalfLifeTime设置。回边计数器：方法体内循环返回指令的执行次数，累计和过阈值也会触发编译请求，-XX:OnStackReplacePercentage。
		 >编译过程：
		   >c1: (方法内联、常量传播)字节码--->高级中间代码HIR表示(静态单分配SSA代表代码值)(平台无关) ----> (空值检查消除，范围检查消除)低级中间代码LIR表示(平台相关)---->(窥孔优化)使用线性扫描算法在LIR上分配寄存器----> 机器码生成、本地代码
		   >c2:充分优化过的高级编译器，执行所有的高级优化动作：无用代码消除、循环展开、循环表达式外提、公共子表达式消除、常量传播、基本块重排序；java特性相关：范围检查消除，控制检查消除；根据profiling进行的激进优化：守护内联、分支频率预测。
		 >查看编译过的方法：-XX:+PrintCompilation。。方法内联信息：-XX:+PrintInlining  
		 >查看反汇编后的指令：虚拟机的反汇编接口提供。安装反汇编适配器。-XX:+PrintAssembly要求虚拟机打印编译方法的汇编代码。
		 >跟踪本地代码的具体生成过程：-XX:+PrintCFGToFile 或-XX:PrintIdealGraphFile将数据输出到文件。使用Java Hotspot Client Compiler Visualizer 来查看。  
		 >采用的代码优化技术: 编译器策略类、基于性能监控的优化技术类、基于证据的优化技术、数据流敏感重写、语言相关的优化技术(锁消除、锁膨胀)、内存及代码位置变换、循环变换、全局代码调整、控制流图变换、
		   >例子：先方法内联-->冗余访问消除(公共子表达式消除y.v会被当作是表达式来优化)---> 复写传播(消除y=z这种冗余)---->无用代码消除。。总是需求理解容易，实现比价麻烦。
		    >公共子表达式消除：语言无关经典。根据：公共子表达式不必再重复计算，直接赋值即可。
			>数组范围检查消除：语言无关经典。执行数组操作的时候默认带着上下界的范围检查，这个是负担---循环中多次判断可以根据数据流分析循环变量取值范围 正常则可以把数组上下界检查消除。自动装箱消除、安全点消除、消除反射等。
			>方法内联：重要。本身消除方法调用的成本，另外方便其他的优化---进一步上下文的优化。但是内联的条件是方法不是多态的--不是invokevirtural指令调用的，是能够在编译期间就能确定调用对象的；通过CHA类型继承关系分析可以得出是否方法有多版本---即重载或者重写的其他版本：：这种CHA分析后的优化是激进优化。
			>逃逸分析：前沿。本身不优化代码，为其他优化方法提供依据。分析对象动态作用域。
			 >方法逃逸：方法A里定义的对象传递给A中调用的方法B.
			 >线程逃逸：方法A里定义的对象赋值给类变量，从而可以被其他线程看到。
			 ---如果一个对象被证明不会发生上述两种逃逸，那么可以进行一些优化：栈上分配(对象直接在栈上分配内存来存储，随着栈帧出栈而销毁；会减轻垃圾回收系统压力)、同步消除(对这个对象的同步可以取消)、标量替换(不创建对象，而是创建它的被方法使用到的成员变量--即标量来替换；从而栈上分配的是成员变量/标量---这些标量大概率被虚拟机分配到物理机器的高速寄存器中)。。但是逃逸分析的消耗或许比收益更大。Hotspot上没有栈上分配。-XX:+DoEscapeAnalysis来手动开启逃逸分析。
		 >JAVA即时编译器和C++静态编译器比较：  占用程序运行时间的代价--卡顿。动态安全检查--消耗运行时间。多态太多内联可能性更小---优化不足。运行时加载新的类---改变程序类型继承关系---使得全局优化难以进行--只能激进优化。栈上分配和用户直接回收而不后续检查式回收----节省时间--节省精力。提高了开发效率，牺牲了运行效率。


举动-痛点5：Java内存模型和线程。内存模型不是内存区域划分、运行时数据区。
	>解法/处理思想：多线程
		>处理器和主存储器之间通过高速缓冲进行交互：解决了速度差别大/不匹配的问题，但是也带来新的问题：缓存一致性。
		 >缓存一致性：各个处理器有自己的高速缓存，又共享一个主存。当运算涉及同一块主存区域时，有可能导致高速缓存之间不一致。所以：要求处理器访问主存要遵守一些协议如MESI。
		 >乱序执行：处理器为了充分利用内部运算单元，使得输入代码执行顺序可能不一致，但是结果和顺序执行一致。是一种优化。java即时编译器也有指令重排序。
		>java内存模型：java虚拟机规范中定义。不像c++直接访问的是硬件。目标是：定义程序中变量(实例字段，静态字段，数组字段等共享字段)的访问规则。---存到内存和读出内存的规则。
		 >规定1：所有变量存储在主存中。
		 >工作内存：每个线程独有的，处理变量使用，处理变量需要先将变量赋值到工作内存中，在高速缓存/寄存器中，拷贝了主存中变量的一个副本。其他线程无法访问到，工作内存之间的值交换需要通过主内存来实现。
		 >交互协议：主内存和工作内存之间变量值交互。下面8个操作在规范里都规定有原子性。
		  >锁定lock：锁定主存中的一个变量。只能被一个线程操作。(类似于下，lock一个变量之前，也必须先执行load-read操作？)
		  >解锁unlock：解锁后，其他线程才能访问该变量。且执行unlock一个变量之前，必须先执行store-write操作。
		  >读取read：从主存到工作内存。
		  >载入load：将读取的数据放到工作内存的变量副本中。
		  >使用use：当虚拟机遇到需要用到该变量的指令时，会将工作内存中的该变量传递给执行引擎。
		  >赋值assign：将执行引擎返回的值赋给工作内存的变量，变量赋值的字节码指令时会执行这个操作。
		  >存储store：将工作内存中的变量取出，传送到主内存。
		  >写入write：将存储操作传来的值放入主存的变量中。
		  ----可以看作工作内存、主存两者的入口处都有一个执行器，不能越过，而是将指令交给它，由它转入内部。
		 >规定2：读取和载入有顺序，存储和写入有顺序，但是可以不连续。不可以单独一个出现。
		 >规定3：工作内存中变量变化之后--赋值之后，必须同步回主存。没有赋值，不能同步回主存。不允许在工作内存使用use或者存储store一个未初始化的变量。
		 >规定4：一个时刻只允许一个线程对一个变量lock,且可以被同一个线程lock多次，且unlock要相同多次。lock之后，会清空工作内存中此变量的值。不能unlock未Lock的变量，也不能unlock不是自己lock的变量。unlock之前，必须将变量同步回主存中。
		 >volatile的语义：使变量具有可见性：一个线程修改之后，其他线程立刻感知。即执行引擎看不到差异---因为其他工作线程会认为失效而使用在时重新read-load该变量(实现方式：MESI缓存行失效通知机制)。第二，禁止指令重排序优化：保证变量之前的代码先执行，而后面的代码后执行；实现方式是在本地代码中插入许多内存屏障指令。
		   >但是运算在并发下不安全：因为java运算不是原子性的。一条字节码指令的语义实现也可能需要多条本地机器码指令。
		   >DCL双锁检测来实现单例模式：
		   >具体的语义：load --use 必须一同出现；想要use必须Load, load之后必然use。同样，assign -- store也必须一同连续出现：想要store必须先load,一旦load之后必然会store。。最后一条是：对两个变量V，W， 先用use先加载load, 先赋值assign先存储store；即两个volatile变量操作顺序不会被编译器指令重排序的。
		 >java内存模型的特征：并发过程中的 原子性(单个操作)、可见性(共享变量)、顺序性(两组操作)
		  >原子性：6个原子性操作，保证了基本类型变量的读写是原子性的。lock和unlock则提供更大范围的原子性保证；尽管没开发给用户使用；但是提供的字节码指令monitorenter , monitorexit隐式的使用了这两个操作；在语言级别，则就是提供synchronized实现--即内部的代码是可以有被同步执行的能力的。
		  >可见性：一个线程修改了一个变量的值，其他线程能在使用时感知到这个变量的改变而重新从主存中获取。volatile的使用-赋值语义保证了提供了变量可见性。 lock-unlock的语义实现也提供了变量的可见性。this不逃逸那么实例变量final化就可以被共享而具有可见性---赋值一次--其他线程可见(比如在赋值之前等3s,但是之后都可见的)。
		  >有序性：语义串行，操作无序。AB先后开始，CD先后开始。且A先于C，B先于D。AC是对变量V的操作，BD是对变量W的操作，且在两个不同的线程里；V前后和W前后还有很多操作--无序的。
		   >线程内表现为串行的语义：
		   >指令重排序：
		   >工作内存和主内存同步延迟：
		   >有序性的其他实现：除了volatile和synchronized之外。“先行发生”原则：判断数据是否存在竞争、线程是否安全的主要依据。虚拟机按照这个原则对一些操作做了一些实现。
			>先行发生原则：A操作先行于B操作，那么A的影响能被操作B观察到。如何知道A先行于B?。如果CB没有先行关系，那么即使C发生在操作A之后B之前，C的影响B也可能没有观察到，导致B读了过期数据---不具备多线程安全性。
		    >指令之间天然的先行发生关系：虚拟机已经实现，无需任何同步手段。不在此列则可能会对这些指令进行指令重排序。
			 >程序次序规则：一个线程内的代码顺序/控制流顺序。编译器虚拟机保证结果正确--但是可能指令重排序--只要结果一样。
			 >管理锁定规则：unlock先行发生于后面对同一个锁的lock操作。即说的是同步块synchronized{}
			 >volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。但是读与读则没有。即B写完之后A再读就必然会从主存中读(而不是高速缓存中，可能延迟好几秒?)。所以对volatile变的直接赋值(不依赖原值)是线程安全的。
			 >线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
			 >线程终止规则：线程的所有操作都先行发生于对此线程的终止检测如Thread.join()。isActive()---只有所有操作都结束后才会false
			 >线程中断规则：线程的中断操作先行于线程的中断检测操作。即Thread.interrupt()先行发生于Thread.interrupted()
			 >对象终结规则：对象的初始化构造函数的执行完成先行发生于它的finalize()
			 >传递性：A先行B,B先行C，则A先行C
		    >判断操作之间是否具备顺序性：如果操作是读写共享变量，就是线程是否安全---(代码上)时间上先调用但影响不一定被看到(没有刷入主存)。
		 >Java线程在虚拟机中的实现：线程共享进程资源，又独立调度。
		  >线程实现方式：内核线程、用户线程、用户线程+轻量级进程。
		   >内核线程KLT：内核完成线程切换，通过操纵调度器对线程调度，并将线程任务映射到各个处理器上。(对线程解决三个问题：切换、调度、任务映射)多线程内核支持。
		    >内核线程的高级接口：轻量级进程LWP。程序使用的，就是LWP，用户看到的线程。LWP和KLT一对一，称为一对一线程模型。
			 >轻量级进程的缺点：创建、析构、同步都需要进行系统调用--因为基于KLT实现。。系统调用的代价：用户态和内核态来回切换。LWP也消耗内核资源---内核线程的栈空间。因此LWP数量是有限的。
		   >用户线程：建立、调度、销毁、同步都是在用户态完成--无需内核帮助---快而低消耗(有些高性能数据库中的线程就是用户线程)。这种进程P和用户线程一对多的关系，称为一对多线程模型。但是对像“多线程如何映射到其他处理器上”这类问题解决起来比较复杂。很少语言实现。
		   >混合实现：用户线程和LWP都存在，创建、析构、切换在用户空间，线程调度和处理器映射交给LWP完成。用户线程--LWP之间多对多的实现，称为M:N多对多的线程模型。Unix系列提供。
		  >java线程模型：基于操作系统的原生线程模型。影响并发规模和操作成本。Windows版本和Linux版本都是一对一线程模型。因为Linux和Windows提供的主流使用的就是一对一线程模型。
		  >线程调度：系统为线程分配处理器使用权的过程。
		   >调度方式：协同式调度方式、抢占式调度方式。
		    >协同式：线程自己控制执行时间，做完自己的事情通知系统切换到另一个线程。没有线程同步的问题？缺点：一个进程不让出CPU会导致系统崩溃。
			>抢占式：系统分配线程执行时间，线程切换不由线程本身决定。线程的执行时间可控。Windwos中，一个线程有问题，可以任务管理器来杀死。java的线程调度方式就是抢占式的。且线程cpu占用时间长短相对可以设置线程的优先级。
		  >线程状态：5种：
		   >新建：New创建而未启动
		   >运行: Runnable等待cpu分配时间或者正在执行。
		   >无限期等待：Waiting需要等其他线程唤醒。即自己Object.wait()了。调用子线程Thread.join()了。LockSupport.park(); Unsafe.park()
		   >限期等待：Timed Waiting在一段时间之后还在等待则系统会唤醒。带时间参数的上述wait(),join(), 和sleep(), .parkNanos(), parkUntil()
		   >阻塞：Blocked等待其他线程释放某个资源/锁。
		   >结束：已终止线程的线程状态。
		   
举动-痛点6：线程安全与锁优化
	>解法/处理思想：正确并发、高效并发
		>线程安全：多线程访问一个对象时，调用方不用做额外的同步和协调，调用这个对象的行为都能获得正确的结果，那么这个对象就是线程安全的。
		>共享数据的安全级别：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。
		 >不可变：不可变的对象。比如基本类型，和String类型。比如对象类型，如果调用对象的行为不影响对象的状态则也认为不可变----一种方法是内部的状态量都用final修饰--比如Integer对象。String和枚举类也是。但是AtomicInteger对象不是不可变的。
		 >绝对线程安全：所有方法都synchronized标注的类。但是：如果多次调用/交替调用带同步关键字的对象的方法，则可能会发生线程不安全事件。如Vector，HashTable, Collections.synchronizedCollection()集合
		 >相对线程安全：单独的操作是线程安全的。
		 >线程兼容：调用端正确使用同步手段可以保证对象在并发环境中安全的调用。ArrayList, HashMap
		 >线程对立：避免使用。
		>实现线程安全：代码实现线程安全，虚拟机实现同步和锁。
		 >互斥来实现同步：
		  >临界区、互斥量、信号量来实现互斥：
		  >synchronized实现互斥同步：编译之后，synchronized同步块前后有monitorenter和monitorexit字节码指令，且这两个指令都需要一个入参：reference类型，来指明要锁定和解锁的对象(应该是lock的对象/变量/主存变量)；如果在实例方法上，是这个实例对象，如果在类方法上，是类的Class对象来作为锁对象。
			>根据java虚拟机规范规定：monitorenter执行时，尝试获取对象的锁，如若没有被锁定或者已经获得，那么锁的计数器+1， monitorexit时锁计数器-1， 锁计数器=0时锁就被释放了。如果获取锁失败，那么线程阻塞等待，直到另一个线程释放继续竞争锁。
			 >阻塞或者唤醒一个线程：需要切换到内核态通知操作系统这么做。而这样切换代价高。所以虚拟机做的优化：在通知阻塞和唤醒之前先自旋一段时间(这里的通知应该是自己通知--线程代码自己)。
		  >ReentryLock实现互斥同步：同样可以线程重入。高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。
		   >等待可中断：等待锁的线程可以超时退出。可以try直接失败退出。
		   >公平锁：按照申请锁的时间顺序依次获得锁，MCH锁类似,而不是一个线程释放之后开始随机的竞争锁----这种是非公平锁---这是synchronized锁。ReentryLock带上参数的构造函数可以实现公平锁。
		   >绑定多个条件：一般synchronized的锁对象可以.wait()和notify()；但是在同步块里，也只能使用锁对象，其他对象的.wait()必须要用加新的同步块。而ReentryLock方式就仅仅只需要newCondition()得到一个对象---就是锁对象，就可以当作锁对象来使用。
		   >性能：和synchronized相差无几，但后面可能会更差。
		  ----互斥同步的问题：线程阻塞和唤醒带来的系统调用消耗。阻塞同步。悲观的并发策略。检查锁是否被占用、用户态内核态切换、维护锁计数器、检查是否有被阻塞的线程需要被唤醒(在占有锁的线程执行完毕之后会调用一个唤醒操作)。 
	     >非阻塞同步：基于冲突检测的乐观并发策略：需要“操作和冲突检测”具有原子性----且靠硬件来实现而不是用互斥同步。原理过程：先操作，共享数据争用了冲突了进行补偿(重试)。乐观策略不需要线程挂起。
		  >硬件提供的原子性的多步操作：硬件保证看起来只用一条指令就完成。
		   >测试并设置：Test-and-Set
		   >获取并增加：Fetch-and-Increment
		   >交换：Swap .。
		   >比较并交换：Compare-and-Swap  称为CAS   现代处理器新增 cmpxchg指令 。三个操作数：内存地址V、旧期望值A、新值B；一个返回值：V旧值；处理过程是A==V ? V=B : 不处理，返回旧值V。
			>java提供的：Unsafe.compareAndSwapInt()等方法，编译后就是平台相关的CAS指令，没有方法调用过程---无条件内联进去了。默认限制只有启动类加载器才能创建Unsafe的实例，但是可以反射实现。
			>ABA问题：会有但是不影响并发的正确性。即便直到了修改了多次到了原值---还是要赋值(除非关心谁改过、改过多少次；变量值版本AtomicStampedReference)。如果关心---那么换为用互斥同步更好。
		   >加载链接/条件存储：Load-Linked/Store-Conditional 称为LL/SC  现代处理器新增  Idrex/strex指令
		 >无同步方案：代码天生就是线程安全的。
		  >可重入代码：可重入性是基本特性之一，可以保证线程安全。即任意时刻都可以中断它而去执行其他代码而返回后原来的程序没有问题。特征：不依赖堆上资源和系统资源。例子：输入相同的数据，返回相同的结果这样的方法比如计算输入的两个整数的和。
		  >线程本地存储：将需要在当前线程中共享数据时，可以把数据存储到当前线程的ThreadLocalMap中---通过ThreadLocal访问。在一个线程中处理完。比如Web交互模型中一个请求对应一个服务器线程。即一个请求中的涉及的变量不会被多个线程写(只涉及读)。
		>锁优化：适应性自旋、锁消除、锁粗化、轻量级锁、偏向锁
		 >自旋锁：避免了线程切换的开销，但占用cpu时间。所以设置自旋的次数：10次。-XX:PreBLockSpin
		 >自适应自旋锁：自旋时间由前一次的自旋时间和结果决定，如果结果为获得锁，那么这次自旋时间设置得更长一点；如果结果为没有获得锁，那么下次忽略自旋。
		 >锁消除：不可能发生数据竞争的锁进行消除。字符串的连续相加----实际优化为StringBuilder.append()--但是这个方法有实例同步---但是显然一个线程中是不会有竞争的---所以即时编译后消除了同步而直接执行。
		 >锁粗化：如果发现有一系列的加锁解锁操作，那么去除中间的，而保留两端的。
		>轻量级锁：相对于传统的用操作系统互斥量来实现的锁而言。减少性能消耗。
		 >对象头的内存布局：
		  >运行时数据: hashcode,GC分代年龄等。共64bits。是实现轻量级锁和偏向锁的关键。称为Mark Word
		  >指向方法区对象类型数据的指针：
		  >如果对象是数组: 存储数组长度
		  -----根据对象的状态的不同：Mark Word存储的值是不同的。
		  >MarkWord: 标记位2bit + ...
		   >标志位01: 未锁定状态， 其他部分存储：对象hashcode  + 对象分代年龄
		   >标志位00: 轻量级锁定，其他部分存储：指向锁记录Lock Record的指针。
		   >标志位10: 膨胀(重量级s锁定)，其他部分存储：指向重量级锁的指针。
		   >标志位11：GC标记，其他部分存储：空，不需要记录信息
		   >标志位01: 可偏向，其他部分存储：偏向线程ID，偏向时间戳，对象分代年龄
		 >轻量级锁的执行过程：
		  >进入同步块：如果同步对象的锁标志位为01未锁定，则在当前栈帧中新建一个名为锁记录Lock Record的空间----放置对象头MarkWord的拷贝。然后CAS尝试更新锁对象的Mark Word 指向这个栈帧里的这个LockRecord, 如果成功则将对象的MarkWord的标记为更新为00---表示轻量级锁定。。如果失败了，虚拟机检查MarkWord是否指向当前栈帧，如果是则进入代码块执行，否则被其他线程抢占了。如果有两个以上的线程争用，那么MarkWord的标记位锁状态直接变为10--膨胀为重量级锁，且其他部分存储指向重量级锁/互斥量的指针.后面等待锁的线程进入阻塞状态。
		  >退出同步看：解锁过程。如果对象的MarkWord指向栈帧中的LockRecord，那么将MarkWord CAS方式替换为空，状态为01--如果替换失败--将阻塞的线程唤醒。。
		  ----优势场景：绝大部分的锁，整个周期内都是不存在竞争的，没有竞争---从时间序列上看，那么轻量级锁CAS操作避免了使用互斥量的开销。但是如果有竞争，则CAS开销+互斥量开销，会比重量级锁开销更大。
        >偏向锁：消除数据在无竞争情况下的同步原语。无竞争的情况下，连CAS也不要了，同步都不要了。偏向于第一个获取它的线程。-XX:+UseBiasedLocking
		 >执行过程：锁对象第一次被线程获取的时候，锁状态更新为01偏向模式，并且CAS将当前线程ID更新到锁对象的MarkWord中，如果CAS成功，那么以后线程进入这个锁对象的代码块时都不需任何同步操作---Locking/unlocking/MarkWord的Update等。如果另一个线程尝试获取这个锁时，如果前一个线程已经释放锁，那么撤销偏向为01未被锁定的不可偏向的，如果前一个还在锁定，则更新状态为轻量级锁定00
		  >高伸缩性的并发程序：
		 
---附录：
·	>字节码指令分类： 
		>将常量池中值推送到栈顶：ldc   iconst_1
		>将局部变量表slot号上变量推送到栈顶：iload
		>将栈顶元素存入slot号上：istore
		>将栈顶元素相加压入栈顶：iadd
		>从当前方法返回void: return 
		>获取类属性-实例属性压入栈顶：getstatic , getfield
		>调用实例/静态方法：invokevitural invokestatic 
		>将栈顶的异常抛出：athrow
		>获取/释放对象的锁：monitorenter monitorexit
		>跳转到指定offset位置并加载下一条指令地址压入栈顶：jsr_w
		
		
		
参考资料：
1.逻辑设计：《java虚拟机规范》
2.https://www.cnblogs.com/jueyoq/p/7900232.html(即时编译)
3.《java与模式》
4.java程序社区：
5.https://max.book118.com/html/2019/0624/8140101113002031.shtm(tcp/ip详解)
6.<<java concurrency in practice>>
7.<java核心技术--卷1卷2卷3><java编程思想>
8.