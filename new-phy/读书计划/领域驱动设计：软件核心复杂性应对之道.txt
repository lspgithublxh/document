---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	>程序的执行要想象为人在执行；多线程则是交接执行权给其他人执行；
	>抽象编程与具体填充：假设编程和实现假设。面向对象中一个对象属性就假设已经填充好了，一个接口的实例就假设已经在容器中有了。代码编码层面和虚拟机执行层面，都规定/定义/设计为 将 接口和实例分开，系统启动时/甚至具体接口调用时才去容器里找接口的实例(启动时 一方面建立实例容器，另一方面 对接口寻找匹配的实例和链接到实例---进行连接和关联)。资源填充 和 接口调用(抽象调用)，资源--接口的映射对。领域抽象，资源抽象，功能抽象。
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点

--混乱的答案，宁可不说；只回答真正掌握的；。没有逻辑，因为没有进行抽象；没有找到所在的流程环节、模型中的位置
--系统、中间件的介绍，不是一来就是组成结构；这层次已经太细了太具体了太里面了，必须要从最简洁最抽象最上层开始；最表面最近开始；务实，不僵硬，不突然，要自然，不要忽视和没注意没意识和跳过很多步；而是从问题出发、从困难出发、从疑惑出发
	>从问题出发：先明确问题；先明确表达出问题、疑惑点、黑箱、痛点、矛盾点、难点，表述的范围可以很大(完全不知道是什么怎么办)后面逐渐具体问；无论多少问题，先明确下来；尤其要全部且完整的描述下来；
		>问题的提出：先明确背景，自然衍生、过渡、转折、演化，逻辑关系上，什么时候什么事情什么人，事情什么阶段遇到的什么问题、阻碍、阻挠、缺陷、瓶颈、不够简洁、不够简便、不够方便、不够优雅、离目标远、离理想情况远、离期望/极限效果远；不够抽象的地方；把它们充分描述完整叙述结构式组织起来。
			>问题抽象：归结为一类问题；去除具体和细节而明确问题模型；
		>问题产生原因：过程；条件；	
		>问题导致的恶果：阻碍、损失；
		>理想的方案特征/效果/必做必不做的动作&事情/应当改变的环节: 
			>这种特征/必做必不做的前提、必要条件、必然要求、必然说明、必然指示、必然可以确定的更多的事情/结论：
				>一系列结论、约束得到之后(结合条件/问题/情况本身)逐渐可以清晰看到/归结出该具体问题符合的/满足的通用/一般的/一类的问题模型/函数模型/服务模型/IO模型/请求响应模型的轮廓：若干个具体模型
					>方案的装饰/补充: 补充可靠性/稳定性/高性能(从而高可用/高并发)：因为暂时只是一个裸机、容易受到伤害、有功能但没有抵抗力(仅为打火机的火而不是熊熊大火)
							>方案的用法规则：在请求缓存前使用
		>能将具体方案进行分类的维度/情况/模型/环节/流程/抽象表述 的确定：然后使用 抽象-具体 的方法来得到新方案；					
		>普通的方案：已有的方案；方案的抽象，方案的取值选择评价；方案的表象缺陷、劣势；。。模型、数据结构和算法、协议约定分担 维度 上考虑；
	>任何事情/事物都有顺序/逻辑：且几乎都是几种常见逻辑中的一种: 时间先后、空间远近、因果环扣、程度递增
--大总结：含义包括：重新 深刻理解：
--通用的建模架构能力+Flink深度强化学习的推荐系统。。。。而不是做简单的业务逻辑开发；用深度强化学习来做应用/解决实际问题(用户的识别问题和抉择问题)；用抽象建模架构出逻辑完整的方案(工具方案/服务方案)；
--一体两翼的发展模型：底座：增强操作系统、网络、搜索、推荐能力； 两翼：普通项目：则架构建模；特殊项目：则深度强化学习；。。四大基础+两大实践(应用/使用)。。基础：是为了解决自己的问题；实践：为了解决别人的问题(用户的问题/大众)；
--一次彻底弄懂，而不是 反复低温加热。看架构书和源码书，不看使用书。
--对话中胜利：一个是提问，二个是不断的输出-高能输出。
--牢固的观念: 系统都是被使用的。
--任何一个系统、产品、服务、方案、东西、事情，它要解决的核心问题是什么？理想的形态效果影响应该是什么？市面上对应的哪些产品达到了或者没达到或者很难达到？没达到是为什么是否有我们的机会？是否还有我们可以满足的缺口。找市场缺口。
--从缝纫机原理看方案所属的分类和方案内的环节。抽象出分类和环节。
--把自己当做cpu,调/使用各个服务/接口/类/系统。
--全新学习掌握方法：先定问题体系，先提问，定逻辑路径，后开始找答案--推导和思考和查阅资料。
	>旧方法：还是盲目阅读，还是从头到尾的阅读一遍的阅读。
--所有系统和方案的理解/研究/制定的出发点：都是 出发顶点/问题顶点/概念顶点，找到了顶点才能出发，出发要从顶点出发，才顺畅，没有后顾之忧
--计算机解决问题的方法：采集，记录，计算，展示，通知，跟踪 数据/信息。

--商业经营才能：(全新的解决问题的方法：提出问题)
--什么问题 是可以用互联网来解决的？ 只要满足什么特征，该问题就可以用互联网方式来解决? 该问题的本质是什么问题(如是信息传递问题？)该问题抽象一般化后是什么问题(资管、记录、通知、计算、采集识别调动、代理/中介/数据中心/信息中心/信息模拟线下过程中心、信息传递)(信息展示/发布/搜索/推荐 平台；信息池；信息可以是映射描述的现实事物的信息(如商品/价值物/人)，也可以是纯虚拟信息(游戏/知识/新闻/视频))
	>能用信息发布展示/活动追踪-信息记录/通知/协作/推荐/搜索 解决的问题：信息可以是 编辑的信息/映射的信息/等价现实的信息/等价现实任何事任何物的信息。内涵BAT的老业务(电商/聊天/游戏/信息流/搜索)。
	>能用数据驱动决策抉择与调度分配/识别与推理/观测采集与调动机电-生物 而解决的问题：如alphazero/图像识别/语音识别/视频识别/云计算/智慧城市/自动驾驶。内涵BAT新业务(云计算/视频语音识别-下棋打游戏智慧体/智能音箱/自动驾驶)
--码农之家和脚本之家、异步社区。从 面向对象-->模式-->架构：由小到大。
--给其他非软件行业的工程师/人员开发软件。三高三可(高可用高并发高性能,可扩展性可维护性可重用性)。
--最佳：一边看书，一边独立思考；(比起纯看书和纯思考都好)。因为 看书 要有沉淀，积累，独立思考 结论，总结。而不是流经书，翻翻而已，左进右出。
--说话：社交场合，最重要的是：要有自己的认知、决策和行动；对形势的判断和分析和预测。而不是被别人牵着走，或者置身事外。
>举动-痛点：维护软件的概念完整性----人月神话。
	>解法/解决方案：领域分层；接口/类分域分模块。
		>定义领域：寻找领域。定义属性和方法/服务。
			>领域的层次结构：抽象过程。层层抽象。
		>领域交互：事件通知、消息通知、服务调用。
		>使用领域的领域：使用各个领域的领域/第三方领域/更抽象的领域。组合调用，形成复合功能/复合服务。
		>领域分层/分模块：按环节/角色/功能类型
		>数据回路：驱动回路/调用回路。分层领域形成的多叉树，从根节点开始的调用--调用回路形成树叶的轮廓。
		>敏捷开发过程：
			>简单且管用：然后不断重构。
		>领域模型：
			>领域：系统性的思考方法来理解。
				>元素：对领域的知识体系/活动的逐渐理解中， 发现经常出现的经常使用的/有作用/有功能的元件|概念 逐渐 沉淀/积累/记录 下来。形成类图。
				>结构：类图
				>商务活动：和用户达成协议，交换价值。互相服务。提供服务/消费服务。
					>服务分为几步：每步 用户需要做什么。服务方需要做什么。服务的开始，服务的结束。服务计费：方式/总额/款项交接。
						>每步：谁是网站/app使用者，发送什么样的请求(操作填写点击)到后端。后端将有序解析请求并做存储到对应表 之类的处理 后给与正确的响应。
							>一半是业务流程：用户+操作 实际事物 来描述 构成的活动(自然语言描述)。这个要确定。上半图
							>一半是请求：用户 + 发送怎样的请求到后端 + 后端反馈什么信息(信息请求互联网技术语言描述)。这个也要确定。下半图
						>请求审核和资源分配：业务规则就是 根据，判断对错/执行不执行/执行什么的根据、决策根据、行动根据、选择根据。显然，审核通不通过 这个 判断	需要一个根据，这个根据就是业务规则。
							>服务流程是否走下去、走什么路径：判断/选择/决策/开关 的 根据依据 就叫 业务规则(确定转向 方向和幅度的逻辑运算表达式 是业务规则，表达式的计算结果是 方向和幅度，表达式的变量的值是条件的值/情况的值)。 而服务流程/步骤/转向动作(原地不动的转向) 是业务流程； 而 服务动作 就是 业务内容。用户评价感受体验 就是 业务效果。对社会产生了影响-好的进步的改变/服务了用户/帮助了用户的点/解决的问题/解决的需求 就是 业务价值。
								>例如预定系统中：客户进行预定时，是否接受预定 这个 变量的值 的计算 过程/可以得出变量值的 逻辑运算表达式 就是：请求量 -  配额量 >= 0
								>规则：规则 是 如果xxx那么xxx,  。如果 规  那么 则 。如果 情况 取值 那么 动作取值(如果天气好我去旅游)。如果 动作取值 那么 情况 取值(如果我洗澡那么地面变湿)。
									>业务规则集合：就是 若干个、几十几百个 如果..那么..句子构成的 集合。
									>定义：计算表达式 的 值域 到 行动域的映射 。意味着 动作 可以反查 (已知)表达式的取值(方便调查取证)。也要求 表达式的每个取值 都要有 对应的动作，否则就是逻辑漏洞，大问题(设计业务规则时的要求)。
										>一个公司的所有动作/行为/决策 都有 其所属于的 业务规则： 找到这些业务规则/明确这些业务规则/所有业务规则 是了解一个公司业务的重点---这就是公司业务的全部。
										>一个服务/服务者/系统进行的每个转向动作/服务动作 都有其所属于的 业务规则：没有 业务规则的服务动作/转向动作 是不合理的/不安全的/不稳定的/未验证的/草率的。
									>业务规则在代码中的体现/实现：编码时：计算过程要封装(如为策略)、行动具体过程要封装，控制结构则保留。
									>若干个业务规则封装在一起 构成一个服务方法：一个服务方法的实现 就是 制定 若干个业务规则的过程。一个服务方法 由 若干个 业务规则来实现。
									>按时间先后的依次调用 是一个业务过程：基本的业务过程。但 先后也是规则，数据依赖是规则，数据来源也是业务规则---隐形的业务规则。需要规定的地方/确定的地方 都是业务规则体现的地方。
									--以上是服务方法 和业务规则的构成关系：
								>判断： 判断 是 xxx是xxx, 因为xxxx
								>描述： 描述 是 xxx具备xxx
								>推理： 推理 是 假设xxx那么xxx,现在xxx,所以xxx。 假设 判断为真/模型取值为x/上一个假设为真，可以递归，引用，所以会比较复杂。 
								>方案：方案 是 已知 目标... 和 起点..., 而计算推导出来的 路径...。 目标 是 描述 ， 起点 是 已有条件/当前情况/当前条件。
					>服务系统要做的事：1.服务实现/上线后，对外：展示服务信息/吸引用户；2.用户提交申请服务信息/系统审核通过，系统提供本次服务标准和计费相关说明，用户同意；3.开始服务：4.服务过程跟踪/状态跟踪/体验跟踪；5.服务结束，用户评价，评价信息反馈到系统；。。其他分支情况：A. 用户提交申请后，开始服务前后悔了，停止服务，取消服务。
						>逻辑复杂的地方/点(业务规则多的地方/判断-行动分支多的地方)：1.根据系统当前资源情况，决定是否要接受服务；这个决策过程/判断过程 规则会比较复杂和长(每个判断-行动 都是 一条规则)。
							>业务规则：放到哪里---领域对象里(否则，就要通过阅读代码来检验规则，这要避免)(同时也方便 将 业务规则/需求文本/代码 联系起来)。
								>业务规则类型：1.看作策略Policy(因为业务规则可能会在以后被修改/替换/废弃，所以必须将规则封装到一个策略领域对象里--而只对外暴露这个规则所在的方法-以供使用/调用)(规则要封装，只是封装后的所在的类的类型取名叫 策略，即不同的业务规则 封装 到 类后就可能取 不同类类型 名 如 状态)
									>封装：本质含义/真正含义：将一串代码/业务代码/业务规则代码 封装 抽取 放到一个专门的方法/类中，只对外暴露使用接口，让领域边界更清晰，领域对象更明确。packaging --就像名字一样，对外码的封装，非常形象。不愧是 面向对象思想 对代码的三大操作：封装(提取)/多态(路由)/继承(获取)。领域提取，动态路由，声明获取。
										>封装的粒度：是否每个判断表达式都要封装?每个分支流程都要封装？。。各种各样的封装(大大小小逻辑块的封装到方法/类)、继承(层层定义类/接口而层层继承的使用)和多态(接口编程/接口变量大量使用)。
										>封装的好处：如封装为策略。拥有更好的可扩展性(替换/增加新策略方便--只需要策略实例替换即可--实例替换很方便)(而策略为@Autowired绑定，或者启动时注解指示注入)
											>可扩展性：增加/修改 更方便的举措 都增加 可扩展性。例如实例替换 比代码替换/修改更方便。配置内容替换 比 配置在类中写死更 方便 替换/修改。时间上更方便 往往意味着 空间上需要多，以后修改方便 意味着 现在就要 在资源上多做准备(多份实现/接口-实现模式实现)---以后直接使用即可。
											>可维度性：不属于某类的属性/方法 都不放在该类里。提出放到专门的类里。
											>可重用性：共享。代码共享/功能共享，多处可能都需要调用，以后新增的业务/代码可能需要调用。
										>封装的意义：封装是一种简化/一种共享。亲自写业务逻辑规则计算处理结果 简化为 调用，即调用的方法可以不是自己写--可以是其他人已经写好的，将要写的。继承也是一种共享/一种简化(编码层面)。多态 则方便了 动态替换，多态是一种抽象描述/统一描述(前后统一/四处统一/当前与未来统一)/不可变描述/不需变描述(是持久一劳永逸的编程，稳定的代码，稳定的编程，长久的编程/活得久的编程/长远的编程)，(代码)只进行抽象描述 以获得(这块代码,大结构/整体结构/整体逻辑/结构逻辑)永久统一永久不变的好处。
									>多态：实现不同的接口，类对象在不同接口下就表现不同的行为。	(接口)变量多态；类实例多态。使用接口变量且不初始化-而是靠方法注入/反射注入/动态注入 或者调用时 赋值/注入实例，类实现接口，，都会使得软件/程序具有多态。一定要初始化，那么则使用工厂方法来初始化！！！即：保证显式构造对象/出现new 的地方只能在 专门的类里/ 工厂类里/Factory结尾的类里。
										>重要思想：非工厂类的变量应该都是接口/基本数据类型。非工厂类不出现显式构造对象的代码。非工厂类的变量都不初始化/显式赋值--除了用工厂来初始化/赋值；变量赋值 通过 外部/调用者 调set方法注入/形参注入/反射注入。
											>效果：让类/程序/方法/软件 具有多态性；不同入参下有不同的行为表现--且无需修改类代码/代价小，使得程序稳定性高-抗需求扩展能力强-不崩溃/不大改/不难改。
									>继承：概念对象 领域对象 所在层次 ，动作是它的还是它上层、父类的? 类的兄弟类、父类。职责明确划分，才能明确哪些方法/属性要继承哪些重写 哪些 要 重载。也可以为了共享和提供默认实现。	
			>模型：是对现实活动/虚拟活动/设想活动/思想实验 中 复杂精细的完整的知识体系 的 抽象而简练扼要的 结构化描述，使得理解信息的含义，并专注于问题。
			>模型语言：
			>领域相关的问题：解决它是 软件开发的目的。
		>有效建模的经验：
			>模型和具体实物/实在的绑定：一一对应，维护映射关系/对应关系。
			>建立了基于模型的语言：UML类图。并随着进展 模型不断的丰富。
			>让模型蕴含丰富知识：对象的行为/规则/属性。
		>知识消化：
			>领域知识来源：领域专家头脑/系统使用/用户。对知识的抽象建立起知识体系。
				>概念严谨：抽象整洁。模型必须有概念。程序对应有对象。
		>交流与语言的使用：协作
			>公共语言：业务专家和开发人员都懂。领域模型 是 核心。非代码形式呈现的设计载体，把整个系统组织在一起的大尺度结构，定义了不同系统和模型之间关系的界限上下文，在模型和设计中使用的其他模式。
				>软件的业务功能：
				>软件的工作机理：
			>简化的图：俯视视角 下的 向下逐层 展示 的 分层视角 对象图。	
				>从设计文档中抽象总结出 模型：
		>领域抽象：模型 反应领域概念  +  软件设计原则/实用的软件实现
			>领域模型 与 软件 各部分 的对应：类是对领域的封装，方法是对操作/运算的封装。
			>模型驱动设计：建模范式。模型是一组逻辑规则+规则操作的事实。。。
				>抽象出关键的领域知识：
				>模型要支持有效的实现：
				>例子：PCB是net集合。最省的不交叉的布线 图 是布线的目标；。一个net用一对 组件-引脚 描述。
					>布线规则：对每个net: 最小线宽：5，最大延迟：15 。一条net所属的组 用 它的名称 来约定。
				>模型组织：概念分类。(模型不是单纯的数据结构)	
					>领域：现实对象/概念的映射，一组属性的封装，对属性的访问，使用属性实现的简单的/基本的方法。也封装复杂方法：利用本身属性 + 方法入参属性。
					>服务：调用各个领域对象，实现领域间协作。也有领域对象构造/初始化。使用业务规则。对象命名规则/
					>仓库：领域对象的管理：添加/删除/更新。
		>模型驱动设计的构造块：建模和设计的最佳实践。
			>职责驱动设计：
				>Entry: 由标识 定义的对象，附加唯一键ID。确保连续性，使得行为更清除且可预测。
				>Factory: 目的在于 对 对象创建过程的 封装，隐藏创建的细节。对象不负责自身的创建--避免职责过重(即避免自己构造自己--又不是生物)。
					>装配过程：必须满足一定的规则：业务规则的一种。也创建Aggregate
					>适合：多态/临时/配置 主依赖 的对象 的创建。重建对象Factory.
				>Repository: 存储和访问对象的机制，搜索替换遍历方式。对象与存储之间的相互转换。
					>不参与事务控制：
				>Service: 是对无状态活动的建模对象。任务的制定，动作和操作 对象。某些领域操作无法放到任何entity中。
					>多领域对象的协调：构成的综合方法。避免扰乱模型对象 而专门放到的一个类。Manager结尾之类。不适合建模为对象。仅是接口，没有封装的状态，没有自己的属性。
					>组织实体的行为 而不是替代 实体的行为：在领域里 但不属于 实体的行为/操作。无状态。
					>领域层/应用层/基础设施层：都有Service。领域层Service: 业务规则的service；基础设施层Service: 工具类Service；应用层Service: 用户响应相关/组织协调领域层Service相关/调用发送命令。
					>控制领域层接口的粒度：避免客户端和Entity耦合。领域知识不蔓延到应用层。应用层不用细粒度的交互。
					>实现关注点的分离：
				>Layered Architecture: 分层架构。A层的领域只和本层+下层中的领域通信。领域分层，内聚性更好。
					>界面层：用户交互
					>应用层：指挥表达领域概念的	对象 来解决问题。不包含业务规则。管理应用任务。
						>发起事务请求到事务控制(提交/回滚)：		
						>负责提问 不负责回答：
					>领域层：负责表达业务状态、业务概念、业务规则。
						>业务规则：1.是判断是否要服务该用户的条件(有前提条件服务)。2.是服务该用户的过程的各个环节和过程整体的度量的约束/限制/要求(有限服务)(对用户的要求，对服务者的要求(如必须记录什么/怎么记录/记录之间什么关系/关系也要记录)，对可重用资源/不可重用资源的使用过程记录/状态跟踪记录)。3.是服务结算的规定/规则/活动规则(有偿服务)
							>转账业务：规则：每笔贷款必须有与其数目相等的借款。因为每个人既可能是借款者也可能是贷款者。
						>对象的方法：都是被动的，都需要调用才生效；至少需要输入调用；都是 功能方法/功能型方法。动作属于谁。有时动作属于操作者，但是操作者并不知道这个操作会导致对象内部发生怎样的改变/变化---而这个变化必须人工完成--此时就只能对象自己去完成；；例如 写到缓冲区，缓冲区自己实现了写入这个方法---所以不是意味着对象有这个动作 而是 对象知道这个动作对自己有什么影响/只有对象自己应该知道这个动作会对自己的各个属性有什么变化影响---所以要自己去实现这个影响过程/自己描述自己属性的变化过程。所以对象要提供一个 假设别人怎么操作我 我会怎么变化 这样一个方法定义和实现。即承受的动作。对象的方法是对象承受的动作。
							>对象的方法：是对象的承受动作。对象方法：就是 对象可以承受的动作。对象方法实现：就是  对象承受了动作之后的变化描述。
							>调用：别人的请求。调用者代码里的请求服务(并给出形参/参数)/方法调用。调用指令
							>实现：自己的行动。执行者服务方法的实现代码过程。服务过程的描述。实现指令集
					>基础设施层：为领域层提供持久化机制。保存业务状态。为应用层传递消息；为界面层绘制屏幕组件。
						>不关心领域对象的具体内容：Service
					--联系各层：调用/回调，观察者模式/事件监听通知
						>MVC 模式：MVC框架。
				>Aggregate: 顶级领域对象也可以划分，按相关性划分组，暴露一个Root/访问入口类，而这个Root就需要Repository存储--其他的不需要存储--它们关联了Root/this且是Root的一个属性。
					>重构的目的：用新的知识来改进模型的设计。
					>根据对象的意义来划分：而不是是否存储。
				>Value Object: 描述领域的某个方面 而本身没有概念标识。属性，也可以是Entity类型。
				>Module: 更大的角度描述了领域。之间是低耦合的，内部高内聚的。代码的划分/概念的划分。 一组：Entity/Service/Repository的封装。分包分jar
					>关注点的逻辑划分：不同bean做不同的工作；
		>软件中所表示的模型：省事的设计。6,1,0,0,0,0,0 代价分布；而不是3，3，3，3，3，3，3	
			>关联：对象间。
			>建模范式：面向对象
		>对象生命周期：状态在变化。维护对象的完整性。
			>聚合模式：定义清晰的所属关系和边界，避免错综复杂的对象关系网 来实现 模型的内聚。可以维护对象的生命周期各个阶段的完整性。
				>根：特定Entity，外部可访问。
				>边界：内部都有什么。外部不可访问。
				>固定规则：一致性规则。请求通过根之后来满足。
		>模型和设计的精化过程：阻力和解决的模式。
			>货物运输系统：用户怎么操作，要发送什么请求，后端要记录和采集什么信息。活动过程的各个角色和行为和过程。
			>如何确定领域对象：找全？属性确定、找全？
		>找到深层次的模型：驱动切实可行的设计。捕捉领域深层含义。抽象。	
			>设计模式重构：
			>代码细节重构：
			>初始模型：浅显认知，名词和动词。
				>例子：信贷
					>贷款股份：Loan 各个出借方 占总出借的比例。每轮出借后 贷款股份可能变化。
					>信贷股份：只跟出借方能力极限有关。是能力极限的比例。
					>借款方还款和利息：出借方 按贷款股份 分配。合理。
					>借款方为享有信贷权而支付：出借方 按 信贷股份 分配。合理。
		>隐式概念的明确：实现模型的精化。			
			>参考书：一整套明确定义的概念体系 .
			>新类别的概念:	
				>显式的约束: 值域. 约束规则封装到方法里---策略对象中/. . 
				>过程建模为对象:过程的建模:则是模板类
					>业务规则: 不是Entity/Value Object的职责.  谓词 是一种可分离可组合的规则对象。
						>规格：输入对象，返回布尔，内部封装 满足逻辑/满足为结果的业务规则。规格 也是一种业务规则的封装，就像将业务规则封装为 策略 一样。
							>规格概念结构：不同子规格 有不同的 业务规则。
							>规格的应用：1.验证(对象的取值)。2.过滤/筛选(合规的对象)。3.创建复杂对象所需的规格参数的封装(对象的规格属性，不一定是它自身属性值域的约束，而更常见是 某场景/活动中使用对象的业务规则/使用约束/活动特征环境特征场景特征的规格要求)。
					>业务规则的目的：功能、解决问题、合规合法合理、安全要求、生存要求、销售策略、管理要求。达到某个效果、目标、指标。保证形态、保证情况在控制之下、任何意外/突发不利事件情况都可以控制。			
		>柔性设计：设计要让人们乐于使用，并且易于修改。在挖掘出隐式概念之后。反复重构。
			>为了使用一个组件而必须看它的实现：则失去了封装的价值。即还要看实现来推测其用途。需要把 概念 显式 建模 为 类或者方法。
				>接口：只表明意图。来命名。
				>操作封装到函数中：减少副作用。
				>断言：Assertion, 明确的把副作用表达出来。
				>抽象：抽象的目的：高层看流程，具有更短的流程，因为基本概念是比较高层的。
			>简单业务规则的如果部分 封装到 lamda表达式里：那么 部分 也封装到 一个 无参的lamda表达式里： 数据结构.if(()->{}).then(()->{})
				>数据集合常见处理：过滤、映射、每个处理、分组、排序。
				>数据常见处理：非空则、转换
		>设计模式应用到领域模型：分析模式和设计模式。
		>通过重构得到更深层的理解：	
		>精炼：把混杂在一起的组件分开的过程。
			>模型真正的核心：能够表示业务领域并解决业务问题的模型部分。
			>模型导航图：显示核心和它支持的特性的关系。
		>大型结构：
			>决策层：
			>策略层：
			>作业层：
			>潜能层：
			---接口的含义：
				>现实中：通道实体 + 数据规范 。(连接两个世界的通道实体和数据规范)
				>代码中：(编程序/写代码) 编码后(接口类代码就是规范实体)(假定/命名一个符合/引用/满足规范实体的变量a/实体A)-->编译后(虚拟机能看懂的假定陈述)-->加载后(和运行无关/运行不变的代码的正确放置并索引位置确定，即元数据的位置确定)-->调用过程(利用当前变量实体 内存区域中的 元数据地址 找到 元数据空间 中 对当前 规范方法的 实现实体位置，找到后设置this的内存地址，后开始执行这里的代码)
					>接口就像规范实体索引键：可以用来 从 框架 和的项目代码 共享的实例池 bf 里找到 索引键对应的实例索引；框架甚至可以自己扫而自己注入/设置到自己的某些类的实例空间上的属性位置上。本层视角上看 要实现的一般功能编程，利用/使用/指挥 索引到下层实现的键/规范实体键 编程；让 规范实体的实现 交给 其他模块/底层模块，让规范实体键 和 它的实体的映射索引关联 交给系统；
						>代码编程：代数编程；指代编程。
						>Spring的起源：面向对象语言思想下： 由于 代码的封装，产生了引用和实现；由于引用本身完全看不出实现的过程，从而 引用可以单独存在 ，进而 可以对 引用 进行 单独定义和先于实现定义，从而 引用和 实现 的关联放到编译之后加载之时--更高层的抽象可以延迟在运行时，规范和实现的分离(规范索引到实现)，规范和实现的静态连接和动态连接(关联/映射)，规范的实现都是动态确定(不在运行时，几乎不知道是哪个/其实调用者也不关心是哪个,但肯定都是实现了 指定规范的功能的对象)，从而需要运行时：各个框架 去 寻找 各自各个领域对象的接口属性的实现类的 并 实例化 (后引用它)，尤其是项目中编写的对框架规范接口的实现类，过程太相似，如果都去实现一遍--都去扫包寻找和实例化(包含属性依赖注入、初始化)，就是重复代码了，这是一般功能/普遍功能/通用功能，所以可以构建一个专门做这件事(扫包寻找和实例化 并 内部存储和维护)的工具/模块/容器，然后对外提供一个查询(某规范实体的实现类)实例的方法。从而产生了Spring。对于新场景，很多个规范接口 其实 都希望 是 同一个实现类，但是直接写每个实现类，或者写死继承规范接口 都 做不到运行时/不修改框架代码 而 简便的得到/动态得到 一个新的接口的实现类，最好的自然是 框架自己运行时/加载时生产出每个接口的实现类--且转发给 共同处理类，从而对外提供一个 生产 一个 实现 指定接口且转发给 共同处理类的 类的实例 的这样的方法，内部也维护这个接口-动态代理类 映射关系。
							>自然不是所有框架都依赖Spring去找类并实例化(包含属性注入、初始化) 或者生产动态代理实例 而直接从Spring中获取指定接口规范的实例/动态代理实例：而可能还是自己亲自去找 和去实例化/构造动态代理实例。例如Mybatis框架,自己去扫Mapper/xml所在包并解析，但是虽然寻找和实例化这两步没依赖Spring, 但是存放管理 还是交给了Spring, 即把实例 交递 给了 Spring。
							>spring-boot下 Tomcat 框架启动时 执行的StandardContext.startInternal() 就注入了 从 Spring.bf里取得的 ServletContainerInitializer ： 从而 间接的 将servletClass=DispatcherServlet 赋值到了Tomcat
							