---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	>程序的执行要想象为人在执行；多线程则是交接执行权给其他人执行；
	>抽象编程与具体填充：假设编程和实现假设。面向对象中一个对象属性就假设已经填充好了，一个接口的实例就假设已经在容器中有了。代码编码层面和虚拟机执行层面，都规定/定义/设计为 将 接口和实例分开，系统启动时/甚至具体接口调用时才去容器里找接口的实例(启动时 一方面建立实例容器，另一方面 对接口寻找匹配的实例和链接到实例---进行连接和关联)。资源填充 和 接口调用(抽象调用)，资源--接口的映射对。领域抽象，资源抽象，功能抽象。
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点

--混乱的答案，宁可不说；只回答真正掌握的；。没有逻辑，因为没有进行抽象；没有找到所在的流程环节、模型中的位置
--系统、中间件的介绍，不是一来就是组成结构；这层次已经太细了太具体了太里面了，必须要从最简洁最抽象最上层开始；最表面最近开始；务实，不僵硬，不突然，要自然，不要忽视和没注意没意识和跳过很多步；而是从问题出发、从困难出发、从疑惑出发
	>从问题出发：先明确问题；先明确表达出问题、疑惑点、黑箱、痛点、矛盾点、难点，表述的范围可以很大(完全不知道是什么怎么办)后面逐渐具体问；无论多少问题，先明确下来；尤其要全部且完整的描述下来；
		>问题的提出：先明确背景，自然衍生、过渡、转折、演化，逻辑关系上，什么时候什么事情什么人，事情什么阶段遇到的什么问题、阻碍、阻挠、缺陷、瓶颈、不够简洁、不够简便、不够方便、不够优雅、离目标远、离理想情况远、离期望/极限效果远；不够抽象的地方；把它们充分描述完整叙述结构式组织起来。
			>问题抽象：归结为一类问题；去除具体和细节而明确问题模型；
		>问题产生原因：过程；条件；	
		>问题导致的恶果：阻碍、损失；
		>理想的方案特征/效果/必做必不做的动作&事情/应当改变的环节: 
			>这种特征/必做必不做的前提、必要条件、必然要求、必然说明、必然指示、必然可以确定的更多的事情/结论：
				>一系列结论、约束得到之后(结合条件/问题/情况本身)逐渐可以清晰看到/归结出该具体问题符合的/满足的通用/一般的/一类的问题模型/函数模型/服务模型/IO模型/请求响应模型的轮廓：若干个具体模型
					>方案的装饰/补充: 补充可靠性/稳定性/高性能(从而高可用/高并发)：因为暂时只是一个裸机、容易受到伤害、有功能但没有抵抗力(仅为打火机的火而不是熊熊大火)
							>方案的用法规则：在请求缓存前使用
		>能将具体方案进行分类的维度/情况/模型/环节/流程/抽象表述 的确定：然后使用 抽象-具体 的方法来得到新方案；					
		>普通的方案：已有的方案；方案的抽象，方案的取值选择评价；方案的表象缺陷、劣势；。。模型、数据结构和算法、协议约定分担 维度 上考虑；
	>任何事情/事物都有顺序/逻辑：且几乎都是几种常见逻辑中的一种: 时间先后、空间远近、因果环扣、程度递增
--大总结：含义包括：重新 深刻理解：
--通用的建模架构能力+Flink深度强化学习的推荐系统。。。。而不是做简单的业务逻辑开发；用深度强化学习来做应用/解决实际问题(用户的识别问题和抉择问题)；用抽象建模架构出逻辑完整的方案(工具方案/服务方案)；
--一体两翼的发展模型：底座：增强操作系统、网络、搜索、推荐能力； 两翼：普通项目：则架构建模；特殊项目：则深度强化学习；。。四大基础+两大实践(应用/使用)。。基础：是为了解决自己的问题；实践：为了解决别人的问题(用户的问题/大众)；
--一次彻底弄懂，而不是 反复低温加热。看架构书和源码书，不看使用书。
--对话中胜利：一个是提问，二个是不断的输出-高能输出。
--牢固的观念: 系统都是被使用的。
--任何一个系统、产品、服务、方案、东西、事情，它要解决的核心问题是什么？理想的形态效果影响应该是什么？市面上对应的哪些产品达到了或者没达到或者很难达到？没达到是为什么是否有我们的机会？是否还有我们可以满足的缺口。找市场缺口。
--从缝纫机原理看方案所属的分类和方案内的环节。抽象出分类和环节。
--把自己当做cpu,调/使用各个服务/接口/类/系统。
--全新学习掌握方法：先定问题体系，先提问，定逻辑路径，后开始找答案--推导和思考和查阅资料。
	>旧方法：还是盲目阅读，还是从头到尾的阅读一遍的阅读。
--所有系统和方案的理解/研究/制定的出发点：都是 出发顶点/问题顶点/概念顶点，找到了顶点才能出发，出发要从顶点出发，才顺畅，没有后顾之忧
--计算机解决问题的方法：采集，记录，计算，展示，通知，跟踪 数据/信息。

--商业经营才能：(全新的解决问题的方法：提出问题)
--什么问题 是可以用互联网来解决的？ 只要满足什么特征，该问题就可以用互联网方式来解决? 该问题的本质是什么问题(如是信息传递问题？)该问题抽象一般化后是什么问题(资管、记录、通知、计算、采集识别调动、代理/中介/数据中心/信息中心/信息模拟线下过程中心、信息传递)(信息展示/发布/搜索/推荐 平台；信息池；信息可以是映射描述的现实事物的信息(如商品/价值物/人)，也可以是纯虚拟信息(游戏/知识/新闻/视频))
	>能用信息发布展示/活动追踪-信息记录/通知/协作/推荐/搜索 解决的问题：信息可以是 编辑的信息/映射的信息/等价现实的信息/等价现实任何事任何物的信息。内涵BAT的老业务(电商/聊天/游戏/信息流/搜索)。
	>能用数据驱动决策抉择与调度分配/识别与推理/观测采集与调动机电-生物 而解决的问题：如alphazero/图像识别/语音识别/视频识别/云计算/智慧城市/自动驾驶。内涵BAT新业务(云计算/视频语音识别-下棋打游戏智慧体/智能音箱/自动驾驶)
--码农之家和脚本之家、异步社区。从 面向对象-->模式-->架构：由小到大。
--给其他非软件行业的工程师/人员开发软件。三高三可(高可用高并发高性能,可扩展性可维护性可重用性)。
--最佳：一边看书，一边独立思考；(比起纯看书和纯思考都好)。因为 看书 要有沉淀，积累，独立思考 结论，总结。而不是流经书，翻翻而已，左进右出。
--说话：社交场合，最重要的是：要有自己的认知、决策和行动；对形势的判断和分析和预测。而不是被别人牵着走，或者置身事外。
--什么是最重要的? 就是你想做出一个什么东西...  这是最有价值的事情,是最重要的目标(比起学位和金钱和看多少书都重要);
	>不讲在公司的项目: 只讲自己 业余时间 做出的东西; ..  和 理解的东西... 总结起来 就是 四个方面: 架构 + 源码 + 算法 + 产品/作品
--不必指责和愤怒: 只需 战胜 和提防.
--莫忘理性决策：详细的明确和计算，一点也不能含糊。看看这次搬家时机的决策失误和搬家房间选择的失误，造成了金钱和时间上的巨大浪费。又比如以前自大没有投资股市---导致损失很大！！	拒绝感情用事和感动别人。
	>不能武断：不能一厢情愿。不能只见树木不见森林。
	
>举动-痛点：微服务下 服务节点数的增长 带来的资源消耗 等 运维问题 产生了 云计算的需求;
	>解法/解决方案：云原生应用架构
		>云原生: 微服务 + 敏捷基础设施 + 持续交付 + DevOps
			>敏捷基础设施: 随时拉取一套 基础设施 来服务 于 开发\测试\联调\灰度上线;....资源随时拉起 随时释放;
				>部署服务器\管理服务器模板\更新服务器 和 定义基础设施的模式 都是通过代码来完成的;
			>持续交付: 产品随时发布;持续集成\持续部署\持续发布;
				>一次改动\立刻构建\自动化测试\安全的部署到产品环境;: 自动持续增量的交付产品;
			>DevOps: 团队之间通过  自动化工具协作和沟通 来 完成 软件的生命周期管理; 从而更快更频繁的交付 更稳定的软件;...
			>微服务: 基于云 进行 服务化 架构改造;
				>是一种架构风格: 每种服务只做一件事; 独立开发部署的无状态化服务(独立扩展\升级\可替换)
				>引入的问题: 性能延迟\分布式事务\集成测试\故障诊断
			>12要素:	
				>基准代码: 一份 基准代码, 多份部署 . 基础设施都是代码配置的;
				>依赖: 显式声明依赖关系 ....不对部署环境产生依赖;
				>配置: 在环境中存储配置 
				>后端服务: 把后端服务当作 附加资源 ...数据库\网络\计算\存储资源 都当作服务 来对待和使用;
				>构建\发布\运行: 严格分离 构建和运行 ...基于容器的Build\Ship\Run
				>进程: 以一个或者多个无状态进程运行应用 ...无状态无共享;
				>端口绑定: 通过端口绑定提供服务 
				>并发: 通过进程模型进行扩展 
				>易处理: 快速启动和优雅终止 可最大化 健壮性;
				>环境等价: 尽可能 保持开发\预发布线上环境相同;
				>日志: 日志当作事件流
				>管理进程: 后台管理 任务 当作 一次性 进程 运行;
		>云原生应用的特点:
			>高可用设计: 不同级别:区域/机房/机架/进程 的 高可用;
			>可扩展设计: 无状态的设计;业务天生扩展性;
			>快速失败设计: 系统间 依赖 的调用 失败\硬件基础设施服务 宕机\后端有状态服务的系统能力 可能有瓶颈; 发送异常 时 应该能 快速失败\快速恢复, 保证业务永远在线;
		>工具: 
			>maven: 
				>profile: 配置用来访问不同的数据库; . mvn package -Ponline  这里的 online就是<profile>.<id>
			>git: 
				>rebase: 
				>cherry-pick: 
				>打tag: 仙人掌模型;
			>docker:
				>镜像的版本化: 可移植,启动快;....包装了环境,让环境都可以移植,并且迅速恢复; 且一个节点上可以运行/容纳多套环境.
				>镜像-容器-仓库:镜像 就像 封装的搭建好的封装好的配套的机器,容器 就是提供了电源/风扇/监控的环境/空间/厂房, 仓库 就是存放配套机器组合的 仓库;
					>镜像: 就是 对机器的 一层一层的封装 物 本身.
					>容器: 创建并启动一个容器; 所以容器 就是一个独立的运行环境;
						>进入容器 并启动bash 会话: docker exec -it ubuntu_bash bash 
				>工程化: 批量 \精细 构建 和管理/监控  各种各样 内容/镜像 的 容器.		
					>linux下创建一个spring-boot单体应用: 
						>1.最简单 时 只需要 pom.xml + src/main/java/xxx/Application.java 两个文件即可,然后 在 根目录下执行 mvn package 就可以 在 根目录下生成 target 文件夹,里面包含一个jar包;  而 spring-boot的配置的pom.xml 打出来的jar 是可以独立执行的:java -jar xxx.jar 就可以运行了.
						>2. 根目录下创建 dockerfile文件: 里面的内容依次 为: 下载 并安装 git , 拉取代码并打包, 复制 jar包到当前目录 并改名为app.jar, ENTRYPOINT ["java", "-jar", "/app.jar"]
						>3. 构建镜像: 在根目录下 执行: docker build -t spring-boot-docker-cloudcomb:0.1.0.
							>运行容器: docker run -p 8080:8080 -t spring-boot-docker-cloudcomb:0.1.0 
							>推送镜像到网易云: docker login hub.c.163.com 
							>统一标记本地镜像: docker tag spring-boot-docker-cloudcomb:0.1.0 hub.c.163.com/test/spring-boot-docker-cloudcomb:0.1.0
							>推送镜像到云基础服务镜像仓库: docker push hub.c.163.com/test/spring-boot-docker-cloudcomb:0.1.0
							>在网易云上创建服务:
		>初创期 应用架构: 
			>基于长连接的实时服务: 使用 纯异步的 Node.js 
			>技术选型:选型因素: 文档/扩展性 
			>Tomcat启动: 使用 JAVA_OPTS 来实现 jvm配置的注入.
			>数据库选型: mysql
			>业务框架选型: spring-mvc
			>缓存选型:
				>mem:
				>redis: 支持的值类型\值运算\客户端通信协议\支持主从部署\自带高可用组件\数据持久化
				>对比方面: 
					>性能: 不分伯仲
					>\内存利用率: 50MB的理论数据, redis 实际使用 68M内存, mem使用58M内存;
					>\监控信息: redis: info 命名; mem: stats 命令 ; 都提供了丰富的监控信息;
					>\功能对比: redis支持更多于string的数据结构和数据操作;
					>\扩展性: redis 集群功能/动态增加节点/配置的自动修改;可以动态增加单个节点的内存容量; mem无法做到 纵向和横向扩容.
			>静态资源存储:
				>nginx 静态托管: 配置 location ~ .*\.(html|gif|jpg|png|js|css)${ root /故障some/resources/path;}
				>独立存储方案: NAS SAN,
			>架构实践:
				>快速搭建开发环境:
					>基于docker 镜像的方式,进行开发环境搭建.
				>容器编排: k8s ...  k8s这种产品 这种方案 出现的原因 ,也可以 解释 为 docker容器 出现后遇到的新的问题(新的问题/尚未解决的问题)---容器的维持 . 
					>Pod: 一个逻辑主机.包含多个容器,  每个容器共享 网络命名空间/持久化的卷存储, Pod和Pod资源互相隔离;   维持 和管理 容器, 调度容器;
					>Replication Controller: Pod复制和调度,保证所有时间内 都有特定数量的Pod副本在运行.
				>cpu负载监控: vmstat 		
				>磁盘使用情况: df -lah 
				>网络信息: ethtool eth0
					>网上流量统计信息: sar -n DEV 1
					>服务端tcp 连接 状态: ss -s 
		>快速成长期 应用架构实践: 
			>用redis 来实现基本的统计功能:
				>秒杀: 四大阶段:
					>用户: redis扣减 阶段, 抢到.                 用户支付
					>服务端: 					 异步下单并管理            支付款收到更新订单状态, 唤起下一个阶段 如 通知商家 物流开始
			>搜索: 
				>单词在哪些章节: 单词本身 由 k个 字母组成, 每个字母1-26, 如果最长100个字母,那么可以对所有单词建立一颗 100为高度的 26叉树, 从而一个单词直接算k次, 就知道在哪个 叶子节点上,然后叶子节点上存储的是 该单词出现 的 所有章节, 这样 如果 多个单词联合搜索 则可以 汇总 叶子节点的 各个章节 求交 得到的就是综合匹配的.
					>进一步的: 可以 在叶子末端 建立 单词 的 左相邻 单词列表, 右相邻 单词列表.
			>数据收集服务:
				>rsylog: 占用资源少,性能高; 专注安全性和稳定性; 100w+/s日志条数 到本地;
				>logstash:  es作为目的地;
			>无状态服务: 无需上下文,无需上次的状态;.不把数据 保存在本地;	
			>后端系统水平扩展:
				>redis服务水平扩展: Redis Cluster; Twemproxy, 豌豆荚的 Codis; 
					>Twemproxy+sentinel 方案: 前者hash分发,后者 监控选举
					>Redis Cluster: crc16取得slot, 	slot所在区间映射到节点;
						>缺点: 客户端实现复杂; 没有中心管理节点,节点故障通过 gossip 协议传递，有时延；	
				>数据库水平扩展： 分发请求、生成执行计划、下发sql、汇总结果		
					>分布式事务：
					>Mysql数据库自动宕机检测和切换： MMM,MHA,
				>消息系统：
					>rabbitmq: 吞吐量的影响因素： 生产者 确认：20%， 消息中心持久化 机制：40%， 消息中心 高可用： 30%, 消费者确认机制： 10%
					>投递模型：最多1次，最少1次，刚好1次；
				>应用诊断：进程监控/tcp健康检查；	
					>top -H -p pid 
					>pidstat -u -p xxx 1
					>磁盘： pidstat -d -p xxx 1
					>进程突然消失： dmesg | tail 
					>btrace: 
				>缓存引进的 必要原因：  A单次耗时短,且连续，即高频，作为生产者，但是单行； B单次耗时长，且连续，但是多个实例并行；从而在大的单位上看，A和B的吞吐量是一样的；但是小的单位上看，B在它的单次操作期间A已经产生了很多次， 这些结果要在下次输入B 则必须要先保存起来---保存在缓存/队列里！！	
					>但 分发速度： 至少要相等于 生产速度；。
					>iostat: iftop: 
				>DevOps: jenkins + k8s: 	 解决大型产品测试的效率和环境隔离问题；	
					>持续集成： 增量代码、打包为镜像、拉起一个容器运行镜像、切换配置流量转发到新容器；
					>持久交付： 开发、镜像上传、测试、AB测试(属于一种灰度发布，不同灰度发布的方式有不同的回滚策略)、
			>安全设计：
				>基于网络的入侵检测系统：Snor, 对网络数据包进行嗅探和实时分析，进行规则的匹配和处理。
				>基于主机的入侵检测系统：
					>流量劫持： DNS劫持：链路劫持(侦听数据包；解法：https)；。。劫持域名解析的回包，对服务器返回的数据包内容进行篡改
						>HTTPDNS: 	用http协议请求的方式来获取一个host的ip地址列表。
		>稳定期服务化应用架构实践：
			>业务拆分：边界与通信方式；
				>边界确定：服务建模。数据库独立，代码独立。
			>统一配置中心：	
			>任务调度： 数据库里存放整体任务，缓存里存放当前节点正在处理的任务---如果当前调度节点调度失败---那么重启后可以继续加载任务而调度执行。缓存redis存放的key有过期时间--如果崩溃了就会被其他节点抢过去--重新调度任务。
				>重要：解决任务失败、调度失败 后 的重试问题。
			>分布式锁：
				>基于n个独立redis节点的分布式锁Redlock： 
			>分布式协调服务： etcd, zk 前者k8s使用。http协议方式进行提交配置和获取配置。
				>consul: go语言实现，raft协议。提供：服务发现、健康检查、kv存储、多数据中心
			>服务治理：
				>服务发现和配置管理：
				>服务依赖关系图：
				>服务监控、健康检查、统计：
				>服务扩容：弹性扩缩容。k8s HPA 出发副本控制器，修改副本数量 保证 Pod 的负载回归到正常的范围之内。
				>流量控制-服务降级：调的A服务连续失败则转调fallback方法。
				>容量规划:
				>权限控制：
			>微服务架构测试：不需要把所有的微服务都部署好就可以测试了。
				>Mock: 实现MockServer: EasyMock, GMock, 
			>数据一致性实践：
				>AP系统：Casandra、Dynamo
				>CP系统： HBase、MongoDB
				>分布式事务：事务保证数据一致性。
					>2pc：
					>BASE: 定义更新成功、更新失败(查询成功/查询失败)的三套标准。
						>强一致性 模式： 全部副本都更新为最新 才更新成功，期间数据锁定不可读。
						>弱一致性 模式： 更新成功部分副本 就更新成功，然后就放开读，所以可能读取到不一致的数据。且如果后面更新失败，可能不会纠正。
						>最终一致性 模式： 更新成功部分副本 就更新成功，然后就放开读，所以可能读取到不一致的数据，但是接着会不断尝试/继续更新其他副本，直到所有副本都更新为上次更新的值。
							>可能引进：消息队列、日志-定时任务。
					>保证分布式系统一致性的算法：
						>Quorum NRW: N总的副本，R读的副本数，W写的副本数；设定三个值，来调节 一致性、可用性、总体性能。
				>强一致性解决方案：
					>分布式事务方案：2pc\3pc\paxos\raft
				>最终一致性解决方案：
					>eBay事件队列方案：消息队列、日志-定时任务  来 异步执行两个服务。即一个服务执行后，写消息到队列 或者 写日志到数据库，然后消息队列/定时任务发送 消息请求/日志请求 给第二个服务。‘
						>类似 本地消息事务表：定时任务/消息队列 要能重试和  服务要支持 幂等。重试 是补偿，TCC也是一种补偿。
					>TCC补偿：
						>失败原因：
							>网络故障：网络超时、网络中断---不用回滚服务。
							>拒绝服务：服务内部错误。调用失败，需要回滚。
				>缓存数据一致性方案：
					>
			>同城多活：应用集群 同城多活；负载均衡器 同城多活。AZ--之间通过高速光纤相连。	
					>同城灾备机房：核心业务同城多活。
						>减少同城机房间的距离、减少数据传输量：提升数据同步的实时性。跨AZ高可用、两地三中心。
					>跨AZ负载均衡：解决了多AZ流量入口的问题；。还有跨AZ的通信、数据同步、计算资源分配等问题。
						>AZ容量冗余：来在一个AZ异常时能接手异常AZ转移过来的流量。
			>故障诊断：日志收集系统 -- 如 ELK，把机器的日志收集起来，通过统一的接口向外提供查询。
				>全链路跟踪系统：把一个请求从进入系统到返回过程中的相关数据，包含函数 调用性能、错误日志、异常堆栈、访问缓存、数据库的性能等数据，以及跟应用进程和机器相关的数据都关联起来，形成一个诊断的闭环；
					>顶层思路：一个请求一个ID, 微服务调用时 透传 ID, 从而方便 统计服务之间的 负载、响应时间、错误率等数据。
					>功能：
						>基于服务之间的调用、自动的发现拓扑图：并能够把拓扑图中每个服务的性能数据关联起来。请求调用链、请求快照。