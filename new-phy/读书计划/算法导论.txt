---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
 
>举动-痛点：分治法、动态规划、贪心算法、摊还分析、NP完全性和近似算法
  >解法/处理思想：归并排序：采用了分治法。渐进表示 来表达算法运行时间
   >一类算法问题的共同特征：很多候选集，其中只有一个或部分是最优的。有效算法。NP完全。
   >算法分析出来的过程/框架/步骤：科学推导过程。每个步骤上的方法集合。
    >框架模式1：将文字描述的问题用基本数据结构来重新表达，即
	 >1.要将问题的条件-用数据结构表达，
	 >2.然后对期望的结果-用数据结构+标志变量来描述， 
	 >3.接着就是寻找结果数据结构如何通过条件数据结构一步步得到
	  >路径1：结果的上一步一定是什么样子可否一定可以确定范围, 可以则继续上上一步什么样子，直到条件数据结构；溯源法。如美团的矩阵路径。
	  >路径2：分析得到结果的必要条件，先知条件。转为计算先知条件。层层递归。
	  >路径3：从条件数据结构场景开始，能做的动作有哪些，做完动作后的新数据结构场景是否是相似的，或者出现的新数据结构场景是固定有限个类型的，只是规模不同，那么可以以相同处理序列/函数处理计算子数据结构场景，得出子结果按实际关系局部和整体的得出关系来表达出表示出父结果；。如二查树的三种遍历：仅仅打印位置在代码不同位置。如归并排序算法，复杂度仅仅为n*log(n) + n/2
	  >路径4：已知条件的等价含义。
	  
	 >框架模式2：明确问题，用数据结构和操作表达初始、过程、结束，明确计算目标。
	  >达到计算目标的计算过程：
	   >计算方法1：问题规模缩小到最小：从1从2开始计算，总结规律。
	   >逻辑语言表达和逻辑语言推理：找出事件和事件之间的固有逻辑关系、逻辑运算组合出整体情况整体事件；找到度量和度量之间的固有数量关系；找出两个事件的各自的两个度量之间如果是某种数量关系的概率是多大(可以根据什么推出计算出)，如果是某种数量关系时：(可以根据什么推出/计算出)会推出什么新的数量关系。
	    >逻辑线梳理：
		
   >算法的验证和效率估计：
    >效率下界：Ω(n) 效率上界：O(n) 都可以相等；而o(n)不可以相等，是上界。指数的简化计算(1+x/n)^n极限方式。多项式的计算，分解计算。lgn对数2为底。多重函数，多重对数--重数在自然界不超过5
    >空间原址性：任何时刻都只需要常数个额外的元素空间。
   >软件工程的问题范围包括：数据抽象、模块性、异常处理、日志。
   >常见算法：
    >归并排序算法：
	>插入排序算法：
	>堆排序算法：
	 >堆：元素之间有关系的数组。利用了二叉树第k层的元素的个数：刚好是2^k - 2^(k-1), 而2^k这个值画到数轴上，那么两点之间就刚好可以放第k层的所有元素，数轴当作数组，因此一个数组可以放下一颗完全二叉树(仅最底层不是慢的树)。这里得出了左节点l和节点j的序号之间的关系:l=2j, 也容易得出节点和右节点i的关系：i=2j + 1。好处在于：2倍关系通过左右位移可以实现。
      >最大堆：父节点的值大于等于子节点。右节点的父节点计算只需要/2向下取整。最大元素根节点。
	  >最小堆：最小元素根节点。
	  >大值下降--时间复杂度递归表达式：T(n) <= T(2n/3) + O(1) 。。根据主定理可以得出：O(lgn)。。堆的平衡和建造。
	  >堆排序算法：巧妙在根节点末节点交换，堆长度-1.
	>快速排序：找到一个元素位置，2个元素位置，4个元素位置,...直到找完。
	 >为了性能提高：先对数组进行随机化：按照之前的数组随机化重排的方式先shuffle处理。
	>比较排序的决策树模型：每个节点就是一个排列。根节点是1:2，第一个元素和第二个元素的比较，以此类推，比较直到可以确定所有元素的先后顺序从而到叶子节点，因为确定过程的路径根据元素真实顺序的不同而不同，导致叶子节点的高度也不一定相等，叶子节点到根节点确定的元素大小顺序可以看作是一个组合，那么n个元素最多n!个组合，而整颗树假设h层，那么总共最多2^h个节点，显然n个节点的决策树：有2^h > n! 所以  h > n*lgn
	>计数排序：(已有一个排好序的架子容器)对整数的排序。将整数当作一个数组的下标来看存储到对应下标的位置，一个计1，两个相同则累加，这样n次就排序好了；所以叫计数排序；最后的整理，需要知道小于一个整数的元素个数，也累加而求解。
	>基数排序：对整数的排序，整数统一补齐为一样的长度，从低到高位依次根据n个数相同位上的数值对应放到一个0-9的线上，相同的挂在上一个数后面，一轮挂完之后，从左到右读取构成一个新的排序，这样挂了最大整数位数轮次，产生了对应次数个排序，最后的排序就是最终的排序。复杂度：位数*n ..实际中，这个进制选择2^8进制，申请256长度的数组，来对超大的整数进行排序，效果还可以；最多只需要排4*n---因为当作了4位数。
	>桶排序：hashmap的方式，先映射到/按概率映射到0-n-1个桶位置上，然后在相同位置上进行元素的排序。
	>中位数和顺序统计量：
	 >找出第二大的数的我的算法：首先，在一次遍历中找最大值和最小值都是直接比较的。而如果在遍历中，当判断出当前为止的最大值后，将当前值和另一个存储值比较:如果它比最大值小而比之前的第二大的值大，那么更新第二大的值为新的值。即变量引入：最大值、最小值、第二大值。。同理，可以引入第三大，第四大，同样，倒数第二小，倒数第三小等。第二大：要比较(1+2)*n次，第三大：比较(1+2+3)*n次，因为每次都需要比较。；；
	  >算法二：值分布，分布图-分布数组，就根计数排序一样。
	  >算法3：k个值堆排序，不断插入一个新的值而删除旧的值。
	  >算法4：利用快速排序每次可以确定一个值的位置的性质，如果这个位置比k大，那么再从位置k后面的元素开始找，否则从k前面的元素开始找，这样，总共需要n + n/2 + n/4 + ....+1 = n * 2 *( - (1/2)^m + 1) 其中有2^m=n,从而lgn=m所以总共需要n*2*(1 - 1/n)=2n - 2次,为O(n)。
	  >算法5：上述的改进。上述的优点在找中位数，而缺点在一半区域内每个元素都找，如果可以堆一半区域划分为若干个小区域，然后确定小区域的中位数，那么从这若干个中位数中，又可以找到一个中位数，这个中位数所在的小区域旧把整个大区域划分为了两半，且可以确定中位数的中位数所在小区域左边的小区域的元素总数，同理右边，就可以和i比较，来确定下一步从左边还是右边找；到此为止，没有一个元素一个元素去找，而是对一个小组一个小组找出特征--中位数，就可以找到小组中的中位小组了----这个是根本真正目标，因为这样就可以去掉一半的不必要的比较，而用小组的方式找中位小组则加倍找出中位数。
	>基本数据结构：  
	 >栈：一个数组一个指针可以实现：
	 >队列：一个数组两个指针可以实现：指向首a尾b元素。当a=b则为空，a=b+1则为满;尾部加元素，头部移除。
	 >双向链表：首尾元素要有指向对方。加入哨兵next头元素。
	 >多数组表示多个同类对象：
	 >散列表：利用数组的直接寻址优势，和链表的方便扩展元素的优势；合并起来，将数组一个元素当作是链表的头元素，形成的一个链表数组。
	  >关键字计算出整数：取模来得到数组的下标。	
	  >完全散列：关键字集合固定。
	  >散列函数：除法散列(就是取模)：其中的被除数不应该是2^p，因为这样产生的除法，二进制数后面p位相同的都会相同，大大加大了重复的概率？接近n的大于的最小质数可以？
	   >乘法散列：k乘以一个小数的值的小数部分，作为k之间的区分，乘以m取整则得到槽位。具体实现时：根据计算机的字位数如64,确定2^64这个值范围，k在这个范围内；再确定一个分数A/2^64 = 0.618033...而确定A, 即A也在2^64这个范围内，则k*A在2^128范围内，二进制表示上划分为两半，则两半r0,r1都在2^64范围内，取低位r0的最高位开始的p位数的值就是散列值。
	   >全域散列：即便是输入相同的n个值，都会被散列到不同的位置？
	   >二级散列表：就是一次hash得到一个槽位值，然后再次第二个hash函数得到另一个槽位值，即第一个槽位下的对应的那个数组的槽位值。hash函数形如((ak+b)mod p )mod m 这样的两个参数a,b控制的hash映射。
	 >直接寻址表：一个数组。
	 >二叉搜索树：既作为一个字典又作为一个优先队列：即如果给树规定，节点的值大于左节点的，小于右节点的。
	  >后继和前驱：刚好比某个值大或者比某个值小的节点：右节点的最小值和左节点的最大值。
	 >红黑树：性质定义。伸展树。跳表属于平衡二叉树。
	  >修改树：保持性质而旋转和变色。
	  >删除：关键归结就是删除黑色节点的平衡操作，归结到删除红色节点好处理。
	 >对搜索二叉树：
	  >找某个元素的秩：不使用额外的数据结构，那么需要遍历。如果采用二进制映射，树的每层的每个元素都可以赋予一个二进制的值，根据这个值转换为lro字符形式再转换为一个三进制的数，给定一个字符串表示的节点，可以知道它前面排满时又多少个元素。
	  >顺序统计树：红黑树基础上，节点加一个属性size：即该节点为根节点的树的大小。使得找到一个数的秩，只需要lgn次查找。同样的复杂度找第i个元素。
	  >区间统计树：同理，红黑树的基础上，节点增加区间属性low, high: 即该节点为根节点的key的取值区间。
	 >动态规划：区别于基本的分治、随机化、递归。n个正数和一定，每个正数的权重一定，则n个正数的权重和取极值时的n个正数的取值是什么？可以递归的方式计算出来，但是代价很高。组合的角度进行递归，排列的角度进行递归。从排列角度，发现fun(n,p)对一组相同的(n,p)其实被调用了多次--尤其是底层的：但其实只需要执行n次即可----所以需要将中间参数映射的值保存到一个表中，这样调用层次降低为3层，复杂度变为1+2+3+...+n只有n^2层次(复杂度就从指数降低为了多项式)。而如果把r[]中间结果当作最终结果的生产容器，那么不需要递归，只需要循环。
	  >计算公共子子问题：
	  >子问题图：自底向上逆拓扑序来处理子问题图中的顶点。深度优先搜索描述自顶向下动态规划。
	  >递归表达式的特征：划分为下一级子规模的问题组时，有若干种划分方法，从中取最佳的那种，因此表达式中有划分遍历来获取最佳的循环过程。最优解是划分子问题产生的。一个问题的最优解=划分的几个子问题的最优解的运算组合的多种划分中的最优划分。每种划分都有最优解，找出最优解集合中的最优解。最优是遍历出来的。
	  >最优子结构：子结构一定也是最优的，否则可以用最优来替换。这个性质必须有，否则不是动态规划能处理的问题。只是划分是多种的，但存在最优的。
	 >贪心算法：动态规划的简化版本。从局部最优来看全局最优。步步最优来力求全局最优。
	  >贪心策略：	
	  >最优子结构： 
	  >贪心选择后的唯一子问题的最优解组合上贪心选择为整体最优解：
	  >拟阵：	
	 >摊还分析：操作序列的总代价和平均代价。
	  >聚合分析：n个序列的对空栈的push,pop,multi-pop代价：推出为O(n)
	  >核算法：
	   >摊还代价：计算摊还代价的方式来计算实际总代价的上界。
	   >摊还时间：
	   >信用：
	  >势能法：	
	>高级数据结构：
	 >B树：为磁盘存储(辅助存储)设计的平衡搜索树(硅存储代价高，磁存储代价低且容量大)。
	  >磁盘结构：磁臂-磁头-磁道-盘片-主轴；同时，磁臂也能围绕自己的轴旋转---从而磁头转移到不同的磁道上。每个盘片都有专门的磁臂，所以磁盘只存在两种机械运动：磁臂旋转和盘片旋转(5000-15000圈/min)。
	   >磁盘平均存取：8-11ms, 所以为了提高性能，摊还机械运动所花费的等待时间，磁盘会一次读取多个数据项
	   >页：在柱面内连续出现的数据：2kB-16kB。(柱面就是各个磁头定位到同一角度然后盘片旋转而从各个盘片上读出的总数据--视觉上看是一个柱面。)
	   >B树在主存中的页数：只是B树总页数的一部分。即当前查询的部分，更新后的部分回写到磁盘相应页位置。
	   >B树查找效率和读的中间节点个数相关：让读取中间节点更少的磁盘IO,则至少一个节点仅仅1次page IO,而一次page IO尽可能多的数据，所以一个节点应包含一页能容纳的数据。
	  >中间节点：关键字个数+1=孩子数
	   >关键字容量和孩子指针容量：一个中间节点大小固定为一磁盘页16kB, 关键字为整数bigint则8B,指针6B。
	   >每个关键字的卫星数据和指向卫星数据的指针：随着关键字的移动而移动。B+树则卫星数据都在叶子节点，因此最大化了中间节点的孩子总数。
	  >定义：有限树。
	   >每个节点信息：关键字总数、关键字本身、孩子指针
	   >每个叶子节点高度相同：
	   >每个中间节点关键字有序：
	   >内部节点孩子个数区间：半满到满。2-3-4树。中间节点孩子个数[2,4][t,2t]
	  >搜索：采用递归的方式，先从x中查询，找到则返回，x是叶子节点也没找到则返回没找到，否则先磁盘读x的对应的那个孩子节点，然后递归搜索这个节点下是否有k
	  >创建：根节点可以持久化到磁盘；新的节点创建时内存中。
	  >分裂：中间节点个数满而分裂，居中关键字上移，其孩子指针指向新的节点，而其原来的孩子由其原来的右边的节点作为新的起始关键字的左孩子。因为改变了2个节点，新增了一个节点，所以需要持久化写磁盘这三个节点
	  >删除：删除上级：同级合并与向上突出。删除本级：先向上合并再同级合并再向上突出。
	 >可合并堆：斐波拉契堆:图问题算法， 基于有限树。
	  >可合并堆：支持5种操作如最小元素查看和删除、用两个堆合并为一个新的堆
	  >斐波那契堆：一系列最小堆序的有限树的集合。
	   >孩子链表：双向链表
	   >最小节点：树的最小关键字的根节点
	   >根链表：
	   >势函数：t(H) +2m(H)总的摊还代价的上界就是总的实际代价的上界。
	   >最大度数：度数可以认为是根节点的child个数。根链表上的各个根节点的度数需要是不同的。D(n) = O(lgn) 从下述名字的由来中可以证明此结论。
	   >创建一个斐波那契堆：
	   >插入一个节点：
	   >合并根链表：相同度数的根节点，key大的移除加到key小的节点的直接子节点位置上
	   >某个节点减少键值：新键值比父节点的值小，那么这个节点移动到根节点链表；如果父节点false那么改为true即可，如果为true那么父节点也移动到根链表，同时递归将切信息传递到cut父节点的父节点。
	   >删除一个节点：先设置这个节点值减为负无穷，然后移除堆的最小元素。
	   >名字的由来：一个节点的孩子节点的从左到右，度数必然越来越高的，从而x的节点个数本身会出现斐波那契数一样的增长，增长到的量值就和x节点的度数有关，由此决定。并且得出附属结论：最大度数<=lgn
	 >有限整数的lgn时间查询数据结构：van Emde Boas树的递归结构。比计数排序O(n)还短时间复杂度。
	  >条件：关键字0~u-1且不重复：且u=2^k
	  >位向量方法：A[x]=1存在，0不存在。
	  >位向量上方叠加二叉树：左分支表0，右分支表1，值表是否有，则查找下一个元素、上一个元素更方便，边回溯边判断即可，从而最多2lgn实现；最小最大元素更是lgn即可。增加则路径节点的值设置位1，删除则从叶子节点向上节点的值为孩子节点的逻辑或
	  >位向量上方叠加多叉树：sqrt(u)个分支，那么树总共2层固定了，这是优势。但是查找后继、前驱、最大、最小等需要O(sqrt(u))次查找。
	  >位向量上方自顶向下每个节点分出u^(1/2^h)的分支直到分支数为2： 最顶层节点一个，分出u^1/2^1个分支，一个值属于哪个分支可以计算出来，找到对应分支后，用余数/下一级的分支数的商继续指出属于的下一级分支是哪个，余数保存下来，一直算下去得到具体的位置A[]。那么计算的次数可以用前面的哪个递减公式u^(1/2^h)=2 来得出h=lglgn, 从而是这个时间复杂度，对查询、插入、最小、最大、上一个下一个都是。V.cluster存节点,V.summary存是否存在，high(x)为商，low(x)为余数，index(x,y)为商*除数+余数。前述需要存位信息。如果veb树，存。veb树：每个节点还有min,max两个量。不存储位信息，而要求u也不一定那么2^2^k;比如2^3也可以：分解为4个cluster每个2个元素。
	   >重要认识1: 最小元素不出现在叶子节点即某个veb(2)中。
	   >重要认识2：如果一个veb(2)中只有一个元素，那么min=max=x, 不需要额外的A数组。如果veb(2^i)只有一个元素，那么也不需要簇。或者说，向一个空veb树插入一个元素，只需要修改min=max=x即可。目的都是为了缩短递归调用链。
	   >重要认识3：sumary存储的是cluster中有值的下标，存储方式同cluster。
	   ---推论：在书本例子中，按照先后对一颗空veb树插入2,3,4,5,7,14,15;第一次2，还是空树，所以只改变了min=max=2 ，第二次3,求得商为0，余数为1，而cluster[0]指向的树还是一颗空树，因此也只改变该子树的min=max=3，第三次4,商=1，余数=0，同理cluster[1]为空树所以min=max=4, 第四次5则第一层商1余1，第二层则商=1/2=0余数1，所以子子veb(2)中min=max=1, 同理第五次7在第二次商1余2从而min=max=1，第六次14商1余0于是min=max=0,.....
	  >简单有限树：大集合划分出的若干个不相交的子集合构成。
	   >不相交集合数据结构：
	   >加权合并启发式策略：合并时假设为两两合并，那么两个两个合并共有n/2组，四个四个共有n/4组，所以总的合并组数n/2+n/4+...+1则项数:n/2^k=1从而k=lgn, 每次需要操作的次数，第一轮n/2次(min(1,1)),第二轮也是总元素个数少一半n/2,同理最后一轮也是min=n/2总元素个数/2，因此总共的合并代价=n/2*lgn, 又make-set m次代价
	   >按秩合并和路径压缩：秩就是树的高
	    >两趟方法：路径压缩的Find-Set。使得第一遍耗时，但第二遍开始就直接找到根节点了。
	   >证明：m个操作,O(m*alpha(n))
	 >动态树：不相交的有限树的森林。渐进最快的网络流算法中常使用。
	  >流网络问题：G(V,E) 线性规划问题的特例。
	   >源节点到汇节点的最大速率：问题归结：假设s->t共有n条不完全重合路径，每条路径的流量为xi, 各条路径经过的管道按照管道排列：则c1管道有：∑xi, 那么要求∑xi<c1，同理k个管道都要有这个要求。在这k个线性要求条件下，∑xi 其中xi为1<=i<=n所有值 ，求这个和的最大值--所以是一个线性规划问题。可以通过广度优先遍历找出所有的可达路径。
	    >经典方法:
		>推送-重贴标签方法：
		>残存网络：残存流量大于0的边-残存边构成Gf。残存网络中依然存在的s->t的路径p为增广路径，其上的最小值为可续加容量，续加之后形成的新的残存网络，再次寻找增广路径，然后续加...直至没有增广路径。
		>增广路径：
		>切割：网络切割为S和T。 单个点具有流量守恒：对于某个节点u: ∑f(u,v) - ∑f(v,u) = 0 流入减流出=0 显然 对所有除了s-t之外的点都满足这个关系。
		 >想象一幅网络流图：定义|f|=s点的所有流出和-s点的所有流入和。上面那条和这一条是最重要的性质。而f(S, T) = S中所有的点流出到T中的流出 - T中所有的点到S的流出。。而从定义出发，从形式上的相似，和没有新概念，所以认为f(S,T) 和|f|之间有关系，并且轻易推得|f| = f(S,T)。。同样可以定义 切割的容量c(S,T)=∑∑c(u,v)。而c(u,v)>=f(u,v); f(S,T)=∑∑f(u,v) - ∑∑f(v,u)<=c(S,T)相等的条件在于特殊的切割：假设G被处理后没有了增广路径，那么说明流量路径p上至少有一环/一边的流量=容量--且这个就是流量的值|f|：即f(m,l)=c(m,l)=|f|---否则还可以继续加流量；同时如果有返回的，那么返回一定为0或者使得同路径上某条边满了--否则还可以继续加流量；如果只有单条流量从s->t，那么对这条边进行切割，形成S，T，且分割方法为S只有这条边的起点a, 剩下的点包括st都在T内，那么S->T就只有一条边，那么|f|=f(S,T)=c(m,l)=c(S,T) ；如果是有多条边从s->t即从不相交/也可以相交：那么每条都必然有一条容量满的边--否则可以继续加流量：从而以这几条满边切割，将边的起点构成一个集合S,剩下的点包括st都在T集合里，那么S->T就只有那些满容量的边，又可以得出|f|=∑c(mi,li)=c(S,T)
	 >伸展树：二叉搜索树的一种形式，为了简化动态树。
	 >持久数据结构：
	 >聚合树：
	 >指数搜索树：
	 >动态图数据结构：顶点连通性、边连通性、最小生成树、双连通性、传递闭包。
	  >无向图的最小生成树：最小权重之和连接所有的节点。图的森林集合形成一个图拟阵。
	   >图的生成树：暴力方法：利用E的按起点分组先后排序，从各组里选择所有可能的0-k的个，接着从下一组顶点开始，要求，后一组的两个点不能选择已经出现在已有点的集合里，最后将各组对应的点集合一个一个合并，不能合并为一个则不行，节点数少也不行。
	    >我的动态规划方法：想象将节点排序一条线，去掉第一个点，剩下的点能够进行的最小代价树得到了，它和被去掉的这个点之间的最短连接必然可以算出来(如果有连接的话)，从而得出总代价；也可以去掉第2个，...k个，都做一遍，分别也得出总代价，然后选择代价最小的 那个去掉，必然就是最小生成树的模式；即存在最优子结构--可以用动态规划方法解决。 W(V<k+1>) = min{min{wk} + W(Vk)} , |V<k+1>| >= 2 , 一个点时权重为0；如果两个点之间无连接，则保持为2个集合。
		 >从边的角度：想象将边排序，选择一条边，剩下的边构成了最小代价树，那么这条新的边加进去看能否：新增节点、或者简化已有路径、或者连接两个点集合/树；能，则保留，不能则无用而不加进去。递归到一条边开始，然后新来一条边；一种简化已有路径比如三个点三条边而去掉代价最高的一条，又比如新增一条边而成环了就删除环中最长的那条边。方案：条件：边集合；中间数据结构：树集合。非常好的方法，一次遍历就可以搞定！！！
		>kruskal算法：将上述从边的角度的算法中，将边按照权重排序从低到高，那么回环出现的时候，新加的这条边不加就可以了---一定是回环中最大的。 
		>prime算法：每个节点有条件地更新parent指向---根据权重。所以每个节点一定有一个parent,因此除了r根节点，其他节点都有parant,末级节点没有child,;另外一个重要条件是，节点必须要按照权重排序而在Q中，每次弹出最小权重的节点(可以用三个节点构成三角形的场景来解释：不从最小的开始弹--就要双向更新；三角形去除最长边道理---只要走最小边---那么不需要双向更新就一定把更长边排除了)。。初始连接、更新连接，最小的开始下一个初始/更新。。已弹出结构、已连接结构；下一次弹出必然从已连接结构中弹；可以把已弹出结构收缩当作一个点---从而又是最开始的三角形情形(需要证明：最小边一定会得到保留：假设除了最小边的两个点之外的其他点构成了一个最优树，那么最小边的两个点接入最优树的方式只有3种，想象最优树为一个点，或者说，最小边的第二点到最优树的距离为s1, 最小边的第一点到最优树的距离为s2, 而最小边两个点之间的距离即最小边的长度为s3, 那么首先就有s3<=s2肯定成立，所以s3肯定不是最长边，所以无论如何将最小边的两个点接入最优树，最小边都会得到保留，才能保证总代价最低，得证！)。已经证明最小边会得到保留，那么将第二点弹出，先给它的连接点初始化权重--意义仅仅为初始化了一批：相当于最开始对第一个点初始化一批一样--目的为对弹出结构的每个点都要初始化连接的点，但此时弹出的点不一定是第二点连接的--可能也是第一点连接到的---因为是已经初始化的所有点的最小权重点；那么假设除了这两点之外的点构成了一颗最优树，那么这两个点接入最优树的方式必然只有走找到的最小权重那一条，即这一条会得到保留，因此这一条的另一个端点可以弹出了---并进行初始化连接点了；接着又寻找这三个已经相连的点对外的所有连接中最短的那一条边---同理推断肯定会走这一条，如此根据必然会保留的一条一条找下去，递归下去，而连接起所有的点。
	  >节点对之间的最短路径：单源最短路径
	   >我的几种方法：从目的节点开始：找与它相邻的所有节点，更新这些节点到它的最短距离；再下一层，对第二层的每个节点，都找出所有每个节点能够到达的所有未到达的节点，更新最短距离，直到全部节点展示完；形成一颗就像河流分细支一样的图，目标节点此时的值就是最短的路径。但找出的是所有的节点到目标节点的最短路径--代价高。
	    >动态规划方法：Vij = min{ vik + Vkj}, 当白色节点集合中i节点可达的节点中无i节点时，更新代价和到达路径；当白集中有j节点时，更新j的代价和路径；。这种方式，广度优先或者深度优先都可以，可以借助一个队列；从起点开始，将可达节点更新代价和路径后入队，然后弹出一个节点，取它可达节点，如果更新成功则入队，失败不入队。也可以最终实现----这种方式则广度优先遍历更好---每次更新后深度更新。而且遍历，显然可以从最短距离的点开始遍历。
	   >松弛技术：节点增加最短路径权重的上限属性。
	   >Bellman-Ford算法：对上述动态规划算法处理，不用队列，直接遍历第一遍，则s到t的一条边达到的最短路径找到了，对于2条边到达的路径，则可能因为边的先后问题，而先m->t(不会使用到mt权重),后s->m从而没连接上这2边到达的路径--仅仅使用了sm更新了m的权重，则第二遍更新一定可以使用到所有的2次到达的路径---并自然的存在2次最短的路径：如果和一次到达相比代价更低则会更新为2次到达的路径，同理3次到达最多只需要遍历3次就可以找到3次及其以内到达的最优路径，一般的，最多V个节点，最多V-1条边，所以最多遍历V-1次，就能把V-1次到达的最优也找出来更新下来，这样就找到了s->t的所有k次到达中的最小代价的路径。甚至连指定次数到达的最优路径也能找到。一条边到达的最短值是所有一条边的最短值；两条边到达的最短值，其中起点到路径上的每个点都是起点到该点的最短路径；三条边到达的最短路径，就是前两条边最短路径+最后一条边的和能够到达的所有情形里面，最小的哪个来更新；因为s开始的前两条边构成的最短路径的所有情形都在前两次遍历完成了，所以第三次遍历能够筛选出全部2+1次组合中的最短路径--即s->t三步到达的最短路径。t是任意的，而轮次也可以递增类推，从而V-1次内到达的最短路径对任意t也都可以推出来了。
	    >最优权重的典型特征就是：每个节点都满足：v.d<=u.d+w(u,v) 且反过来也成立。即两个是充要条件。
		>对边进行排序：这样来避免出现上述的先某些边而导致更新无效--无穷的值；原因在于太底层--上层的边还没有更新；所以一轮更新过程中，如果严格按照先高层后底层的更新顺序，则不会出现无效更新的情形，从而甚至一轮更新就能先找出一步最优、二步最优\...直到V-1步最优的路径；而这个顺序就是拓扑排序---广度优先生成的树的层次序：：自顶向下进行松弛/更新权重路径。
		 >应用：PERT图分析。
	   >Dijkstra算法：把上述队列方法中，队列加入的元素改为全部顶点，同时取元素改为取当前权重最小的那个节点。无放回。第一次只有一个节点，先更新它的所有直接相连的顶点的权重，然后找其中最小路径的节点弹出---也是Q中的节点，因为这个点的权重不会再更新了---假设会--还有s开始的更短路径---那么就会和前面最小路径矛盾，因此这第二个节点的权重一定不用更新了。然后这第二个节点相连的节点的权重也可以更新了，如果包含第一轮初始化的节点，自然也可能被更新。每次都走最短路径线的端点，即弹出的点到起点的距离一定是还没走过的最短的线的端点--因为如果还存在更短的线则会走那条了，第二，它的权值不会再被更新--因为假设未来某一次找到了一条指向它的线-那么那条线到它的距离一定长于目前的权值---因为还没指向它时这条线的长度已经就超过目前的权值了---因为在它后面执行；因此它的权值不会再被更新。从而出现弹出一个确定一个，弹出一个又确定一个，从而弹出V-1次，而总的更新次数为边数E次，从而复杂度为O(V+E)--注意弹出最小的那个算法未考虑时，而且确定速度更快、每次都有确定的。
	   >差分约束和最短路径：条件为约束一个定义域，目标是再从定义域中找到映射到值域最大的定义域的集合。
	    >条件的可能情形：差额限制条件：两个量要满足一定的差额，比如事件顺序执行的先后的时间差。
		>差分约束系统Ax<=b的约束图：n+1个节点。
		 >与单源最短路径问题的关系：引入的额外节点v0, 则v0到所有节点的最短路径构成的最短路径树的各个节点的权重满足的关系和约束图一样；因此是约束图的一个解。如果环路的总值为负，那么表达出这个环路和总值，做一个数学运算，得出结果来解释。
	  >所有节点之间的最短路径：与矩阵乘法之间的关系。另外，最短路径树上的每条路径上，任意两点中的前节点到后节点之间也是最短路径。
	   >基于矩阵乘法的动态规划算法：动态规划：C(i,j)=min{w(paiij,j) + C(i, paiij)}当i!=j时，当i=j时C(i,j)=0;其中paiij可以从权重矩阵的j列中不为无穷的数对应的行来确定。
	   >矩阵序列L(m)方法：根本原理之前已经讨论过，就是一步到达，二步到达，....k步到达的最优。这里给出了这个过程的数学表达形式L。
	    >重复平方技巧：因为W^4=W^2 * W^2 非常巧妙地简化了矩阵相乘的代价----坦白的说，是矩阵的指数次方的代价。对上述算法中的计算有利：简化为n^2*lgn
	   >Floyc-Warshall算法和传递闭包：这种算法本质和1次到达、2次到达、...k次到达的方式一样。首先W矩阵的含义可以理解为i->j一步到达的路径值，那么2步到达就是：i能到达的所有点--同i行，这些点到j的距离--同j列一一求和比较，并和一步的路径值比较，确定一个最小的值更新到dij位置即可，n*n次可以确定所有二步及其以内到达的最小路径值；自然的，只需要继续在旧D的基础上计算一个新D,就可以得出3步以内、...n-1步以内的最小路径值D(n)。D(1)=W
	    >有向图的传递闭包：存在i->j的路径，的所有(i,j)的集合就是G的传递闭包。t(0)ij的值为0或者1，就足以表示情况。一步以内可连接，直接wij映射为0-1而来tij, 2步以内开始递归-依赖上一幅图/矩阵：t(k)ij= t(k-1)ij | (t(k-1)ik & t(k-1)kj)即这一幅图里tij的相连情况(路径上至多k个中间节点)=上一幅图(路径上至多k-1个节点，不经过k节点)里ij是否相连(已经相连则下一图相连) 或 上一幅图里过k节点时能否相连即i到k 与上 k到j。。。另一种解释:i,1,2,3,...k,j  则如果i不能达到j,那么1-k中一定有一个点m能直接达到j,同时也必然有一个点l能直接达到i,所以在遍历1...k时，首先，每次的更新会把该点能到达的点更新到i点能到达的点位置上，无论m,l在1..k序列中谁先谁后。
		 >数学化表达和证明：假设i,j外，遍历1...k个节点，那么1节点之后，1节点直接相邻的有(1,x11)(1,x12)...，形成一个球，1节点在中心，面上的节点互相直接连接， 遍历2节点之后，2直接相邻的(2,x21)(2,x22)...同理2也形成一个球-表面的点互相连接，如果2和1相连间隔1个点--那么1和2两个球上的点都互相连接了；如果2和1相间隔0个点，那么也是互相连接了。而k个点形成的球，因为k个点之间本身存在练成线的互相连接，所以相邻则合并，因为总共相邻k-1次，所以合并k-1次，并且合并为1个球，即内部的k个点互相连接起来了，而这个球中有m-l两个点必然连接着i,j,所以在m合并的时候，i和球上的点直接连接了，l合并的时候l和球上的点直接连接了。因此最终合并完成时，i和j就直接相连了。这就是i,j能相连则合并k次一定能直接相连的原因。
	   >Johnson算法：先额外取一个点s,对G图，得出s到G的最短距离树，记delta(s,u)=h(u) 那么h(u)-h(v)>=w(u,v) 记w(u,v) + h(u) - h(v) = w'(u,v)则 >= 0 从而可以在w'构成的G'上使用Dijkstra算法n次得出最短距离delta'(u,v) ;然后利用delta'(u,v)=求和w'(vi,v(i+1))其中1<=i<=k 假定时某条最短路径，那么可以进一步展开w', 得出delta'(p)=求和w(vi,v(i+1)) + h(v1) - h(vk)。其中求和这一项的含义推导：假设G图上u->v有n条路径，每条路径的路径和为：求和w(u,vi) = 求和w(u,vi) + h(u) - h(v) - (h(u) - h(v)) = 求和w'(u,vi) + h(v) - h(u) 而h()是固定的，所以用w'表达后路径长度仅仅固定增长和具体的路径无关，从而各个路径的长短排序顺序并没有改变，因此u->v的最短路径在w变为w'后仍然是u->v的最短路径；从而有前面的Dijkstra算法应用后得出的最短路径：求和w'(vi,v(i+1))=delta'(v1,vk)=求和w(vi,v(i+1)) + ..那么第二个求和也是最短路径的求和：即求和w(vi,v(i+1)) = delta(v1, vk) 从而就有：delta'(v1,vk)=delta(v1,vk) + h(v) - h(u) 从而delta(v1,vk) = delta'(v1, vk) + h(u) - h(v)而间接地计算出来了。
	    >重新赋予权重：根据三角不等式而来：最小路径图中h(v)-h(u)>= w(u,v) 从而w'(u,v) = w(u,v) + h(u) - h(v) >= 0即得到的新的边权重就是冗余路径差。
		>证明：如上。
	 >图的广度优先算法和深度优先算法：
	  >图的搜索技巧：图算法领域的核心。
	  >图的表示：邻接链表和邻接矩阵。
	  >深度优先搜索：有向无环图的拓扑排序。有向图中计算强连通分量。
	  >广度优先搜索：最小生成树算法+单源最短路径算法。电子线路板的排线问题。
	   >命名由来：由近及远地访问s的所有可达节点，距离从1到2到3...且近处访问完毕才更远1的节点。一直向外，一直向下。无回溯。灰色、白色、黑色的节点。从s开始，访问到的白色节点入队列。
	   >广度优先树：G(V,E)从s开始广度优先搜索BFS而产生的前驱子图 树Gpai(Vpai,Epai) 特征就是：|Epai|=|Vpai|-1
	  >深度优先搜索：DFS可以判断G是否是有向无环图：有无B边后向边
	   >深度优先森林：多棵深度优先树。结点：时间戳-开始-结束， 颜色：白-灰-黑，边类型：树边、B-C-F
	   >括号化结构：
	   >拓扑排序：有向无环图的。DFS中先退回到根节点，再将树的白色节点打印出来。
	   >强连通分量：有后向边特征。G的一个强连通分量就是含有后向边的一个环。将G中的环收缩为一个点，得到无环分量图G^SCC。G的转置的环还是一样同G。G^SCC
   >数学结论：
    >矩阵相乘的递归性质的推导(根源在于线性组合表达式具有递归特征)：C=A*B， 对于Cij的表达式表示如C11,如果将表达式截断为两半，分别用括号包括，那么第一个括号里的也可以看作是某个矩阵的一行乘以另一个矩阵的一列，第二个括号里的内容也是可以这样看， 那么C11就可以看作是两组两个矩阵的乘积的和的第一个位置的元素，其他元素也是，从展开表达式，和源C的对应位置上看，看每个C元素，从而发现C是A,B分别分割为4份后的8个子矩阵对应位置的乘积和---乘法法则同样满足矩阵的乘法；从而得出了一个重要结论：矩阵的乘法，对于矩阵的一个元素如果是还是一个矩阵，只要另一个因子矩阵同样元素规模，那么同样满足矩阵的乘法，可以直接相乘得出相应位置的结果。即矩阵的元素为矩阵时依然满足矩阵的乘法法则。从而可以递归地计算矩阵相乘的结果：直至2*2规模的矩阵。傅立叶变换也具有递归性。
    >同时发生事件的概率：如果A事件发生圈定的范围就是B事件发生的大前提/范围，那么同时发生就是一个条件概率：P(AB)=P(A)*P(B|A) 如果两个事件无关，那么P(B|A)=P(B)
    >布尔不等式：并集事件的概率和各个事件独立的概率和的关系。
    >指示器随机变量：分解为连续求和计算。
     >0-1随机变量表达的是个数的概念(只是这个次数、个数是分布的)：也是这样定义它的目的之一。因此可以用它来进行相加减来表达其他意思的个数。尤其期望计算中。
   >经典问题练习：
    >给定数组的随机排列：0-n先随机选后交换法。
    >一根绳子随机2刀，三段可以构成一个三角形的概率：三段的分布函数应该一样且均匀，所以可以转换为(0,n)之间随机三个数，则P(a+b-c>0)通过卷积计算得到分布，可知：P(a+b-c>0)=5/6 .分布是一个斜边二次内凹梯形分布。
	>矩阵相乘的动态规划问题：矩阵链乘法问题: 乘法的先后顺序不同则标量乘法量不同。
	 >如果假定m[i,j]表示Ai...Aj相乘矩阵的代价。中间有一次划分k,可以表示出m[i,j] = m[i,k] + m[k+1,j] + pi-1pkpj  从k的所有取值中选择一个使得代价最小的一个值，来作为m[i,j]的代价；显然，这个过程程序化，只需要3层循环，i,k,k 而考察其中的过程发现m[1,2]=m[1,1] + m[2,2]从矩阵角度可以看到规律，且m[1,3]也由m[1,1]m[1,2]m[1,3]m[2,3]m[3,3]等历史求出来的值决定；而m[k,k]=0所以对于m矩阵，计算结果会从对角线逐渐向右顶角移动，从而完整全部实现最终得到m[1,n]。
	>最长公共子序列：可不连续子串。我想到的方法：去除0,1,2,3,4,5,...n个元素，分为n轮。一轮去除一个元素，每轮去除一个元素后得到的多个可能结果，进行比较，看是否相同---即是否有交集；没有则，双层遍历本轮产生的两个结果集合，而递归调用本函数(去除-比较-再次递归函数removeOneAndCompare(arr1, arr2))。复杂度是n(n-1)...(n-i+1)而超过1轮，则每轮都有重复的，重复次数为Aii=i*(i-1)*1, 所以如果采用中间缓存表，结果一样，第二轮少2倍，第三轮少3倍，i轮少i倍，所以复杂度为n(n-1)...(n-i+1)/(i*(i-1)...1)=Cni<=Cn,n/2<n^(n/2), 而恰好产生的结果数也是Cni,因此概率=Cni/2^n, 因此期望个数为>2^n/n
	 >描述的问题最初规模的数据结构/表达式的目标结果的某个度量，并且将度量其中的参数n,m...替换为i,j..., 再替换为i-1, j-1, 之类，来寻找与相临近的递归关系。
	 >表达式按规模分解：分解为小规模的组合。最佳的那种分解就是目标。
	>最优二叉搜索树的构造：逼近方法：对权重key数组按权重从高到低排序，然后用红黑树方式进行构造。
	 >重要性质1：任何一个相同k集合构造出的子树，加到某一个树的某个节点下，所增加的搜索代价都是固定的n*(k1...ki), n为附着节点的高度。因此一个最优二叉搜索树的某个连续k集合子树必然也是k集合的最优二叉搜索树，如果不是则可以用这个最优搜索树替代---从而和它本身已经是最优二叉搜索树矛盾。
	 >重要性质2：根节点指定：k集合中，指定根节点kr分出左子树和右子树。两个子树都是最优子树。根节点的指定就是最优指定。
	 >重要性质3：构造最优二叉搜索树：e(i,j)，root(i,j)已知，定义函数Node buildTree(i,j) 里面只需要计算根节点位置、递归、父子节点指针连接即可。
	>欧几里得旅行商问题：从左到右如果双调巡游，那么从左到右，问题的最优子结构也是最优的，因此可以用动态规划。最优的证明：去除最左边的点，右边的所有点有一个最优构造，而左边的点连接进最优的最优构造，只有一种情形，从而增加的代价是确定的：双调巡游有，但是一般情况下则没有，因为此时右边的点的组合有很多种。左边的点接进来则总代价变化不同，所以不能确定--子结构的最优加一个节点后不一定是最优。
	>编辑距离问题：248页。DNA序列对齐问题
	>活动选择问题：性质1：活动按结束时间先后排序的序列中，最早结束的活动am一定在这个序列的最大兼容活动序列中，因为除去am之后的剩下序列中找出的最大兼容序列一定>=不是除去am而是其他更多的则剩下的序列，因为此序列只会更短；而剩下中找出的按定义一定和am兼容。因此只需要对排好序的序列遍历一遍，就可以找到最大兼容活动序列。
	>0-1背包问题：拿走平均价值最高的那些？非，剩下的磅重不一定价值高。动态规划算法，总价值为c[i,j] 则讨论i=j时的最大价值，j=i+1时的最大价值，那么就可以拓展到i<j任意的价值了。
	 >我的方案：按重量从大到小排序：从左到右递归式选择，直到选出重量<=W最接近时，看价值，选择出价值最大的。因为本问题看起来没有最优子结构-----但实际上，n个商品的最大价值方案确实和n-1个商品的最大价值方案差别可能大，但是如果加上了n-1个商品的最大价值方案中重量的限制刚好少wn, 那么就有了，当然，去掉的这一个，要从序列中每个都去掉试一遍--来找到最佳的去掉(就是目标元素)。
	>分数背包问题：如果分数是任意小数，那么只需要按qi/wi从高到低排序，含金量最高的排前面，再按重量大小为长度尺度紧紧放在坐标轴上，那么W处为切割点，左边的就是取的量。如果不能任意切割，而是一份一份的，那么就一份一份的去掉，剩下中取最优的，最终得出最佳的去除而得出各个货物的份数。
	>赫夫曼编码问题：性质1：不定长编码，4位前进，只会识别出一个字符，不断往后，唯一重现。
	 >赫夫曼编码树：不定长编码的得出：关键字-频率得出且排序好，然后从低位开始两两构造三叉节点并加入排序。不定长编码的每个编码都是树的叶子节点，所以一个编码不会由两个编码顺序拼凑出来，---否则就是中间节点--从而矛盾。保证了正确性即可唯一恢复性。又因为频率高的叶子节点高度低，从而整体编码量少。
	>单处理器上带截止时间和惩罚的单位时间 任务 调度问题：将单位时间任务按照截止时间从小到大排序，出现Nn()>n时，表明需要延迟Nn()-n个任务，则选择前面这么多个惩罚最低的任务放到最后面，然后继续往后，直到遍历完所有任务。 
	>缓存管理问题：缓存优先级：元素的磁盘查询代价*元素的在线查询频率。
	>套利交易问题：可以深度优先遍历，找到回向边，然后开始找所包围的所有环，看乘积总值是否大于1,是则存在套利交易链。可以找出全部。
	 
	 
	
	
	