---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 
>举动-痛点：分治法、动态规划、贪心算法、摊还分析、NP完全性和近似算法
  >解法/处理思想：归并排序：采用了分治法。渐进表示 来表达算法运行时间
   >一类算法问题的共同特征：很多候选集，其中只有一个或部分是最优的。有效算法。NP完全。
   >算法分析出来的过程/框架/步骤：科学推导过程。每个步骤上的方法集合。
    >框架模式1：将文字描述的问题用基本数据结构来重新表达，即
	 >1.要将问题的条件-用数据结构表达，
	 >2.然后对期望的结果-用数据结构+标志变量来描述， 
	 >3.接着就是寻找结果数据结构如何通过条件数据结构一步步得到
	  >路径1：结果的上一步一定是什么样子可否一定可以确定范围, 可以则继续上上一步什么样子，直到条件数据结构；溯源法。如美团的矩阵路径。
	  >路径2：分析得到结果的必要条件，先知条件。转为计算先知条件。层层递归。
	  >路径3：从条件数据结构场景开始，能做的动作有哪些，做完动作后的新数据结构场景是否是相似的，或者出现的新数据结构场景是固定有限个类型的，只是规模不同，那么可以以相同处理序列/函数处理计算子数据结构场景，得出子结果按实际关系局部和整体的得出关系来表达出表示出父结果；。如二查树的三种遍历：仅仅打印位置在代码不同位置。如归并排序算法，复杂度仅仅为n*log(n) + n/2
	  >路径4：已知条件的等价含义。
	  
	 >框架模式2：明确问题，用数据结构和操作表达初始、过程、结束，明确计算目标。
	  >达到计算目标的计算过程：
	   >计算方法1：问题规模缩小到最小：从1从2开始计算，总结规律。
	   >逻辑语言表达和逻辑语言推理：找出事件和事件之间的固有逻辑关系、逻辑运算组合出整体情况整体事件；找到度量和度量之间的固有数量关系；找出两个事件的各自的两个度量之间如果是某种数量关系的概率是多大(可以根据什么推出计算出)，如果是某种数量关系时：(可以根据什么推出/计算出)会推出什么新的数量关系。
	    >逻辑线梳理：
		
   >算法的验证和效率估计：
    >效率下界：Ω(n) 效率上界：O(n) 都可以相等；而o(n)不可以相等，是上界。指数的简化计算(1+x/n)^n极限方式。多项式的计算，分解计算。lgn对数2为底。多重函数，多重对数--重数在自然界不超过5
    >空间原址性：任何时刻都只需要常数个额外的元素空间。
   >软件工程的问题范围包括：数据抽象、模块性、异常处理、日志。
   >常见算法：
    >归并排序算法：
	>插入排序算法：
	>堆排序算法：
	 >堆：元素之间有关系的数组。利用了二叉树第k层的元素的个数：刚好是2^k - 2^(k-1), 而2^k这个值画到数轴上，那么两点之间就刚好可以放第k层的所有元素，数轴当作数组，因此一个数组可以放下一颗完全二叉树(仅最底层不是慢的树)。这里得出了左节点l和节点j的序号之间的关系:l=2j, 也容易得出节点和右节点i的关系：i=2j + 1。好处在于：2倍关系通过左右位移可以实现。
      >最大堆：父节点的值大于等于子节点。右节点的父节点计算只需要/2向下取整。最大元素根节点。
	  >最小堆：最小元素根节点。
	  >大值下降--时间复杂度递归表达式：T(n) <= T(2n/3) + O(1) 。。根据主定理可以得出：O(lgn)。。堆的平衡和建造。
	  >堆排序算法：巧妙在根节点末节点交换，堆长度-1.
	>快速排序：找到一个元素位置，2个元素位置，4个元素位置,...直到找完。
	 >为了性能提高：先对数组进行随机化：按照之前的数组随机化重排的方式先shuffle处理。
	>比较排序的决策树模型：每个节点就是一个排列。根节点是1:2，第一个元素和第二个元素的比较，以此类推，比较直到可以确定所有元素的先后顺序从而到叶子节点，因为确定过程的路径根据元素真实顺序的不同而不同，导致叶子节点的高度也不一定相等，叶子节点到根节点确定的元素大小顺序可以看作是一个组合，那么n个元素最多n!个组合，而整颗树假设h层，那么总共最多2^h个节点，显然n个节点的决策树：有2^h > n! 所以  h > n*lgn
	>计数排序：(已有一个排好序的架子容器)对整数的排序。将整数当作一个数组的下标来看存储到对应下标的位置，一个计1，两个相同则累加，这样n次就排序好了；所以叫计数排序；最后的整理，需要知道小于一个整数的元素个数，也累加而求解。
	>基数排序：对整数的排序，整数统一补齐为一样的长度，从低到高位依次根据n个数相同位上的数值对应放到一个0-9的线上，相同的挂在上一个数后面，一轮挂完之后，从左到右读取构成一个新的排序，这样挂了最大整数位数轮次，产生了对应次数个排序，最后的排序就是最终的排序。复杂度：位数*n ..实际中，这个进制选择2^8进制，申请256长度的数组，来对超大的整数进行排序，效果还可以；最多只需要排4*n---因为当作了4位数。
	>桶排序：hashmap的方式，先映射到/按概率映射到0-n-1个桶位置上，然后在相同位置上进行元素的排序。
	>中位数和顺序统计量：
	 >找出第二大的数的我的算法：首先，在一次遍历中找最大值和最小值都是直接比较的。而如果在遍历中，当判断出当前为止的最大值后，将当前值和另一个存储值比较:如果它比最大值小而比之前的第二大的值大，那么更新第二大的值为新的值。即变量引入：最大值、最小值、第二大值。。同理，可以引入第三大，第四大，同样，倒数第二小，倒数第三小等。第二大：要比较(1+2)*n次，第三大：比较(1+2+3)*n次，因为每次都需要比较。；；
	  >算法二：值分布，分布图-分布数组，就根计数排序一样。
	  >算法3：k个值堆排序，不断插入一个新的值而删除旧的值。
	  >算法4：利用快速排序每次可以确定一个值的位置的性质，如果这个位置比k大，那么再从位置k后面的元素开始找，否则从k前面的元素开始找，这样，总共需要n + n/2 + n/4 + ....+1 = n * 2 *( - (1/2)^m + 1) 其中有2^m=n,从而lgn=m所以总共需要n*2*(1 - 1/n)=2n - 2次,为O(n)。
	  >算法5：上述的改进。上述的优点在找中位数，而缺点在一半区域内每个元素都找，如果可以堆一半区域划分为若干个小区域，然后确定小区域的中位数，那么从这若干个中位数中，又可以找到一个中位数，这个中位数所在的小区域旧把整个大区域划分为了两半，且可以确定中位数的中位数所在小区域左边的小区域的元素总数，同理右边，就可以和i比较，来确定下一步从左边还是右边找；到此为止，没有一个元素一个元素去找，而是对一个小组一个小组找出特征--中位数，就可以找到小组中的中位小组了----这个是根本真正目标，因为这样就可以去掉一半的不必要的比较，而用小组的方式找中位小组则加倍找出中位数。
	>基本数据结构：  
	 >栈：一个数组一个指针可以实现：
	 >队列：一个数组两个指针可以实现：指向首a尾b元素。当a=b则为空，a=b+1则为满;尾部加元素，头部移除。
	 >双向链表：首尾元素要有指向对方。加入哨兵next头元素。
	 >多数组表示多个同类对象：
   >数学结论：
    >矩阵相乘的递归性质的推导(根源在于线性组合表达式具有递归特征)：C=A*B， 对于Cij的表达式表示如C11,如果将表达式截断为两半，分别用括号包括，那么第一个括号里的也可以看作是某个矩阵的一行乘以另一个矩阵的一列，第二个括号里的内容也是可以这样看， 那么C11就可以看作是两组两个矩阵的乘积的和的第一个位置的元素，其他元素也是，从展开表达式，和源C的对应位置上看，看每个C元素，从而发现C是A,B分别分割为4份后的8个子矩阵对应位置的乘积和---乘法法则同样满足矩阵的乘法；从而得出了一个重要结论：矩阵的乘法，对于矩阵的一个元素如果是还是一个矩阵，只要另一个因子矩阵同样元素规模，那么同样满足矩阵的乘法，可以直接相乘得出相应位置的结果。即矩阵的元素为矩阵时依然满足矩阵的乘法法则。从而可以递归地计算矩阵相乘的结果：直至2*2规模的矩阵。傅立叶变换也具有递归性。
    >同时发生事件的概率：如果A事件发生圈定的范围就是B事件发生的大前提/范围，那么同时发生就是一个条件概率：P(AB)=P(A)*P(B|A) 如果两个事件无关，那么P(B|A)=P(B)
    >布尔不等式：并集事件的概率和各个事件独立的概率和的关系。
    >指示器随机变量：分解为连续求和计算。
     >0-1随机变量表达的是个数的概念(只是这个次数、个数是分布的)：也是这样定义它的目的之一。因此可以用它来进行相加减来表达其他意思的个数。尤其期望计算中。
   >经典问题练习：
    >给定数组的随机排列：0-n先随机选后交换法。
    >一根绳子随机2刀，三段可以构成一个三角形的概率：三段的分布函数应该一样且均匀，所以可以转换为(0,n)之间随机三个数，则P(a+b-c>0)通过卷积计算得到分布，可知：P(a+b-c>0)=5/6 .分布是一个斜边二次内凹梯形分布。
	
	
	
	