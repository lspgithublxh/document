---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 
>举动-痛点：分治法、动态规划、贪心算法、摊还分析、NP完全性和近似算法
  >解法/处理思想：归并排序：采用了分治法。渐进表示 来表达算法运行时间
   >一类算法问题的共同特征：很多候选集，其中只有一个或部分是最优的。有效算法。NP完全。
   >算法分析出来的过程/框架/步骤：科学推导过程。每个步骤上的方法集合。
    >框架模式1：将文字描述的问题用基本数据结构来重新表达，即
	 >1.要将问题的条件-用数据结构表达，
	 >2.然后对期望的结果-用数据结构+标志变量来描述， 
	 >3.接着就是寻找结果数据结构如何通过条件数据结构一步步得到
	  >路径1：结果的上一步一定是什么样子可否一定可以确定范围, 可以则继续上上一步什么样子，直到条件数据结构；溯源法。如美团的矩阵路径。
	  >路径2：分析得到结果的必要条件，先知条件。转为计算先知条件。层层递归。
	  >路径3：从条件数据结构场景开始，能做的动作有哪些，做完动作后的新数据结构场景是否是相似的，或者出现的新数据结构场景是固定有限个类型的，只是规模不同，那么可以以相同处理序列/函数处理计算子数据结构场景，得出子结果按实际关系局部和整体的得出关系来表达出表示出父结果；。如二查树的三种遍历：仅仅打印位置在代码不同位置。如归并排序算法，复杂度仅仅为n*log(n) + n/2
	  >路径4：已知条件的等价含义。
	  
	 >框架模式2：明确问题，用数据结构和操作表达初始、过程、结束，明确计算目标。
	  >达到计算目标的计算过程：
	   >计算方法1：问题规模缩小到最小：从1从2开始计算，总结规律。
	   >逻辑语言表达和逻辑语言推理：找出事件和事件之间的固有逻辑关系、逻辑运算组合出整体情况整体事件；找到度量和度量之间的固有数量关系；找出两个事件的各自的两个度量之间如果是某种数量关系的概率是多大(可以根据什么推出计算出)，如果是某种数量关系时：(可以根据什么推出/计算出)会推出什么新的数量关系。
	    >逻辑线梳理：
		
   >算法的验证和效率估计：
    >效率下界：Ω(n) 效率上界：O(n) 都可以相等；而o(n)不可以相等，是上界。指数的简化计算(1+x/n)^n极限方式。多项式的计算，分解计算。lgn对数2为底。多重函数，多重对数--重数在自然界不超过5
    >空间原址性：任何时刻都只需要常数个额外的元素空间。
   >软件工程的问题范围包括：数据抽象、模块性、异常处理、日志。
   >常见算法：
    >归并排序算法：
	>插入排序算法：
	>堆排序算法：
	 >堆：元素之间有关系的数组。利用了二叉树第k层的元素的个数：刚好是2^k - 2^(k-1), 而2^k这个值画到数轴上，那么两点之间就刚好可以放第k层的所有元素，数轴当作数组，因此一个数组可以放下一颗完全二叉树(仅最底层不是慢的树)。这里得出了左节点l和节点j的序号之间的关系:l=2j, 也容易得出节点和右节点i的关系：i=2j + 1。好处在于：2倍关系通过左右位移可以实现。
      >最大堆：父节点的值大于等于子节点。右节点的父节点计算只需要/2向下取整。最大元素根节点。
	  >最小堆：最小元素根节点。
	  >大值下降--时间复杂度递归表达式：T(n) <= T(2n/3) + O(1) 。。根据主定理可以得出：O(lgn)。。堆的平衡和建造。
	  >堆排序算法：巧妙在根节点末节点交换，堆长度-1.
	>快速排序：找到一个元素位置，2个元素位置，4个元素位置,...直到找完。
	 >为了性能提高：先对数组进行随机化：按照之前的数组随机化重排的方式先shuffle处理。
	>比较排序的决策树模型：每个节点就是一个排列。根节点是1:2，第一个元素和第二个元素的比较，以此类推，比较直到可以确定所有元素的先后顺序从而到叶子节点，因为确定过程的路径根据元素真实顺序的不同而不同，导致叶子节点的高度也不一定相等，叶子节点到根节点确定的元素大小顺序可以看作是一个组合，那么n个元素最多n!个组合，而整颗树假设h层，那么总共最多2^h个节点，显然n个节点的决策树：有2^h > n! 所以  h > n*lgn
	>计数排序：对整数的排序。将整数当作一个数组的下标来看存储到对应下标的位置，一个计1，两个相同则累加，这样n次就排序好了；所以叫计数排序；最后的整理，需要知道小于一个整数的元素个数，也累加而求解。
	
   >数学结论：
    >矩阵相乘的递归性质的推导(根源在于线性组合表达式具有递归特征)：C=A*B， 对于Cij的表达式表示如C11,如果将表达式截断为两半，分别用括号包括，那么第一个括号里的也可以看作是某个矩阵的一行乘以另一个矩阵的一列，第二个括号里的内容也是可以这样看， 那么C11就可以看作是两组两个矩阵的乘积的和的第一个位置的元素，其他元素也是，从展开表达式，和源C的对应位置上看，看每个C元素，从而发现C是A,B分别分割为4份后的8个子矩阵对应位置的乘积和---乘法法则同样满足矩阵的乘法；从而得出了一个重要结论：矩阵的乘法，对于矩阵的一个元素如果是还是一个矩阵，只要另一个因子矩阵同样元素规模，那么同样满足矩阵的乘法，可以直接相乘得出相应位置的结果。即矩阵的元素为矩阵时依然满足矩阵的乘法法则。从而可以递归地计算矩阵相乘的结果：直至2*2规模的矩阵。傅立叶变换也具有递归性。
    >同时发生事件的概率：如果A事件发生圈定的范围就是B事件发生的大前提/范围，那么同时发生就是一个条件概率：P(AB)=P(A)*P(B|A) 如果两个事件无关，那么P(B|A)=P(B)
    >布尔不等式：并集事件的概率和各个事件独立的概率和的关系。
    >指示器随机变量：分解为连续求和计算。
   
   >经典问题练习：
    >给定数组的随机排列：0-n先随机选后交换法。
    >一根绳子随机2刀，三段可以构成一个三角形的概率：三段的分布函数应该一样且均匀，所以可以转换为(0,n)之间随机三个数，则P(a+b-c>0)通过卷积计算得到分布，可知：P(a+b-c>0)=5/6 .分布是一个斜边二次内凹梯形分布。