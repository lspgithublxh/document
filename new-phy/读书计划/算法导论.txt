---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
 
>举动-痛点：分治法、动态规划、贪心算法、摊还分析、NP完全性和近似算法
  >解法/处理思想：归并排序：采用了分治法。渐进表示 来表达算法运行时间
   >一类算法问题的共同特征：很多候选集，其中只有一个或部分是最优的。有效算法。NP完全。
   >算法分析出来的过程/框架/步骤：科学推导过程。每个步骤上的方法集合。
    >框架模式1：将文字描述的问题用基本数据结构来重新表达，即
	 >1.要将问题的条件-用数据结构表达，
	 >2.然后对期望的结果-用数据结构+标志变量来描述， 
	 >3.接着就是寻找结果数据结构如何通过条件数据结构一步步得到
	  >路径1：结果的上一步一定是什么样子可否一定可以确定范围, 可以则继续上上一步什么样子，直到条件数据结构；溯源法。如美团的矩阵路径。
	  >路径2：分析得到结果的必要条件，先知条件。转为计算先知条件。层层递归。
	  >路径3：从条件数据结构场景开始，能做的动作有哪些，做完动作后的新数据结构场景是否是相似的，或者出现的新数据结构场景是固定有限个类型的，只是规模不同，那么可以以相同处理序列/函数处理计算子数据结构场景，得出子结果按实际关系局部和整体的得出关系来表达出表示出父结果；。如二查树的三种遍历：仅仅打印位置在代码不同位置。如归并排序算法，复杂度仅仅为n*log(n) + n/2
	  >路径4：已知条件的等价含义。
	  
	 >框架模式2：明确问题，用数据结构和操作表达初始、过程、结束，明确计算目标。
	  >达到计算目标的计算过程：
	   >计算方法1：问题规模缩小到最小：从1从2开始计算，总结规律。
	   >逻辑语言表达和逻辑语言推理：找出事件和事件之间的固有逻辑关系、逻辑运算组合出整体情况整体事件；找到度量和度量之间的固有数量关系；找出两个事件的各自的两个度量之间如果是某种数量关系的概率是多大(可以根据什么推出计算出)，如果是某种数量关系时：(可以根据什么推出/计算出)会推出什么新的数量关系。
	    >逻辑线梳理：
		
   >算法的验证和效率估计：
    >效率下界：Ω(n) 效率上界：O(n) 都可以相等；而o(n)不可以相等，是上界。指数的简化计算(1+x/n)^n极限方式。多项式的计算，分解计算。lgn对数2为底。多重函数，多重对数--重数在自然界不超过5
    >空间原址性：任何时刻都只需要常数个额外的元素空间。
   >软件工程的问题范围包括：数据抽象、模块性、异常处理、日志。
   >常见算法：
    >归并排序算法：
	>插入排序算法：
	>堆排序算法：
	 >堆：元素之间有关系的数组。利用了二叉树第k层的元素的个数：刚好是2^k - 2^(k-1), 而2^k这个值画到数轴上，那么两点之间就刚好可以放第k层的所有元素，数轴当作数组，因此一个数组可以放下一颗完全二叉树(仅最底层不是慢的树)。这里得出了左节点l和节点j的序号之间的关系:l=2j, 也容易得出节点和右节点i的关系：i=2j + 1。好处在于：2倍关系通过左右位移可以实现。
      >最大堆：父节点的值大于等于子节点。右节点的父节点计算只需要/2向下取整。最大元素根节点。
	  >最小堆：最小元素根节点。
	  >大值下降--时间复杂度递归表达式：T(n) <= T(2n/3) + O(1) 。。根据主定理可以得出：O(lgn)。。堆的平衡和建造。
	  >堆排序算法：巧妙在根节点末节点交换，堆长度-1.
	>快速排序：找到一个元素位置，2个元素位置，4个元素位置,...直到找完。
	 >为了性能提高：先对数组进行随机化：按照之前的数组随机化重排的方式先shuffle处理。
	>比较排序的决策树模型：每个节点就是一个排列。根节点是1:2，第一个元素和第二个元素的比较，以此类推，比较直到可以确定所有元素的先后顺序从而到叶子节点，因为确定过程的路径根据元素真实顺序的不同而不同，导致叶子节点的高度也不一定相等，叶子节点到根节点确定的元素大小顺序可以看作是一个组合，那么n个元素最多n!个组合，而整颗树假设h层，那么总共最多2^h个节点，显然n个节点的决策树：有2^h > n! 所以  h > n*lgn
	>计数排序：(已有一个排好序的架子容器)对整数的排序。将整数当作一个数组的下标来看存储到对应下标的位置，一个计1，两个相同则累加，这样n次就排序好了；所以叫计数排序；最后的整理，需要知道小于一个整数的元素个数，也累加而求解。
	>基数排序：对整数的排序，整数统一补齐为一样的长度，从低到高位依次根据n个数相同位上的数值对应放到一个0-9的线上，相同的挂在上一个数后面，一轮挂完之后，从左到右读取构成一个新的排序，这样挂了最大整数位数轮次，产生了对应次数个排序，最后的排序就是最终的排序。复杂度：位数*n ..实际中，这个进制选择2^8进制，申请256长度的数组，来对超大的整数进行排序，效果还可以；最多只需要排4*n---因为当作了4位数。
	>桶排序：hashmap的方式，先映射到/按概率映射到0-n-1个桶位置上，然后在相同位置上进行元素的排序。
	>中位数和顺序统计量：
	 >找出第二大的数的我的算法：首先，在一次遍历中找最大值和最小值都是直接比较的。而如果在遍历中，当判断出当前为止的最大值后，将当前值和另一个存储值比较:如果它比最大值小而比之前的第二大的值大，那么更新第二大的值为新的值。即变量引入：最大值、最小值、第二大值。。同理，可以引入第三大，第四大，同样，倒数第二小，倒数第三小等。第二大：要比较(1+2)*n次，第三大：比较(1+2+3)*n次，因为每次都需要比较。；；
	  >算法二：值分布，分布图-分布数组，就根计数排序一样。
	  >算法3：k个值堆排序，不断插入一个新的值而删除旧的值。
	  >算法4：利用快速排序每次可以确定一个值的位置的性质，如果这个位置比k大，那么再从位置k后面的元素开始找，否则从k前面的元素开始找，这样，总共需要n + n/2 + n/4 + ....+1 = n * 2 *( - (1/2)^m + 1) 其中有2^m=n,从而lgn=m所以总共需要n*2*(1 - 1/n)=2n - 2次,为O(n)。
	  >算法5：上述的改进。上述的优点在找中位数，而缺点在一半区域内每个元素都找，如果可以堆一半区域划分为若干个小区域，然后确定小区域的中位数，那么从这若干个中位数中，又可以找到一个中位数，这个中位数所在的小区域旧把整个大区域划分为了两半，且可以确定中位数的中位数所在小区域左边的小区域的元素总数，同理右边，就可以和i比较，来确定下一步从左边还是右边找；到此为止，没有一个元素一个元素去找，而是对一个小组一个小组找出特征--中位数，就可以找到小组中的中位小组了----这个是根本真正目标，因为这样就可以去掉一半的不必要的比较，而用小组的方式找中位小组则加倍找出中位数。
	>基本数据结构：  
	 >栈：一个数组一个指针可以实现：
	 >队列：一个数组两个指针可以实现：指向首a尾b元素。当a=b则为空，a=b+1则为满;尾部加元素，头部移除。
	 >双向链表：首尾元素要有指向对方。加入哨兵next头元素。
	 >多数组表示多个同类对象：
	 >散列表：利用数组的直接寻址优势，和链表的方便扩展元素的优势；合并起来，将数组一个元素当作是链表的头元素，形成的一个链表数组。
	  >关键字计算出整数：取模来得到数组的下标。	
	  >完全散列：关键字集合固定。
	  >散列函数：除法散列(就是取模)：其中的被除数不应该是2^p，因为这样产生的除法，二进制数后面p位相同的都会相同，大大加大了重复的概率？接近n的大于的最小质数可以？
	   >乘法散列：k乘以一个小数的值的小数部分，作为k之间的区分，乘以m取整则得到槽位。具体实现时：根据计算机的字位数如64,确定2^64这个值范围，k在这个范围内；再确定一个分数A/2^64 = 0.618033...而确定A, 即A也在2^64这个范围内，则k*A在2^128范围内，二进制表示上划分为两半，则两半r0,r1都在2^64范围内，取低位r0的最高位开始的p位数的值就是散列值。
	   >全域散列：即便是输入相同的n个值，都会被散列到不同的位置？
	   >二级散列表：就是一次hash得到一个槽位值，然后再次第二个hash函数得到另一个槽位值，即第一个槽位下的对应的那个数组的槽位值。hash函数形如((ak+b)mod p )mod m 这样的两个参数a,b控制的hash映射。
	 >直接寻址表：一个数组。
	 >二叉搜索树：既作为一个字典又作为一个优先队列：即如果给树规定，节点的值大于左节点的，小于右节点的。
	  >后继和前驱：刚好比某个值大或者比某个值小的节点：右节点的最小值和左节点的最大值。
	 >红黑树：性质定义。伸展树。跳表属于平衡二叉树。
	  >修改树：保持性质而旋转和变色。
	  >删除：关键归结就是删除黑色节点的平衡操作，归结到删除红色节点好处理。
	 >对搜索二叉树：
	  >找某个元素的秩：不使用额外的数据结构，那么需要遍历。如果采用二进制映射，树的每层的每个元素都可以赋予一个二进制的值，根据这个值转换为lro字符形式再转换为一个三进制的数，给定一个字符串表示的节点，可以知道它前面排满时又多少个元素。
	  >顺序统计树：红黑树基础上，节点加一个属性size：即该节点为根节点的树的大小。使得找到一个数的秩，只需要lgn次查找。同样的复杂度找第i个元素。
	  >区间统计树：同理，红黑树的基础上，节点增加区间属性low, high: 即该节点为根节点的key的取值区间。
	 >动态规划：区别于基本的分治、随机化、递归。n个正数和一定，每个正数的权重一定，则n个正数的权重和取极值时的n个正数的取值是什么？可以递归的方式计算出来，但是代价很高。组合的角度进行递归，排列的角度进行递归。从排列角度，发现fun(n,p)对一组相同的(n,p)其实被调用了多次--尤其是底层的：但其实只需要执行n次即可----所以需要将中间参数映射的值保存到一个表中，这样调用层次降低为3层，复杂度变为1+2+3+...+n只有n^2层次(复杂度就从指数降低为了多项式)。而如果把r[]中间结果当作最终结果的生产容器，那么不需要递归，只需要循环。
	  >计算公共子子问题：
	  >子问题图：自底向上逆拓扑序来处理子问题图中的顶点。深度优先搜索描述自顶向下动态规划。
	  >递归表达式的特征：划分为下一级子规模的问题组时，有若干种划分方法，从中取最佳的那种，因此表达式中有划分遍历来获取最佳的循环过程。最优解是划分子问题产生的。一个问题的最优解=划分的几个子问题的最优解的运算组合的多种划分中的最优划分。每种划分都有最优解，找出最优解集合中的最优解。最优是遍历出来的。
	  >最优子结构：子结构一定也是最优的，否则可以用最优来替换。这个性质必须有，否则不是动态规划能处理的问题。只是划分是多种的，但存在最优的。
	 >贪心算法：动态规划的简化版本。从局部最优来看全局最优。步步最优来力求全局最优。
	  >贪心策略：	
	  >最优子结构： 
	  >贪心选择后的唯一子问题的最优解组合上贪心选择为整体最优解：
	  >拟阵：	
	 >摊还分析：操作序列的总代价和平均代价。
	  >聚合分析：n个序列的对空栈的push,pop,multi-pop代价：推出为O(n)
	  >核算法：
	   >摊还代价：计算摊还代价的方式来计算实际总代价的上界。
	   >摊还时间：
	   >信用：
	  >势能法：	
	>高级数据结构：
	 >B树：为磁盘存储(辅助存储)设计的平衡搜索树(硅存储代价高，磁存储代价低且容量大)。
	  >磁盘结构：磁臂-磁头-磁道-盘片-主轴；同时，磁臂也能围绕自己的轴旋转---从而磁头转移到不同的磁道上。每个盘片都有专门的磁臂，所以磁盘只存在两种机械运动：磁臂旋转和盘片旋转(5000-15000圈/min)。
	   >磁盘平均存取：8-11ms, 所以为了提高性能，摊还机械运动所花费的等待时间，磁盘会一次读取多个数据项
	   >页：在柱面内连续出现的数据：2kB-16kB。(柱面就是各个磁头定位到同一角度然后盘片旋转而从各个盘片上读出的总数据--视觉上看是一个柱面。)
	   >B树在主存中的页数：只是B树总页数的一部分。即当前查询的部分，更新后的部分回写到磁盘相应页位置。
	   >B树查找效率和读的中间节点个数相关：让读取中间节点更少的磁盘IO,则至少一个节点仅仅1次page IO,而一次page IO尽可能多的数据，所以一个节点应包含一页能容纳的数据。
	  >中间节点：关键字个数+1=孩子数
	   >关键字容量和孩子指针容量：一个中间节点大小固定为一磁盘页16kB, 关键字为整数bigint则8B,指针6B。
	   >每个关键字的卫星数据和指向卫星数据的指针：随着关键字的移动而移动。B+树则卫星数据都在叶子节点，因此最大化了中间节点的孩子总数。
	  >定义：有限树。
	   >每个节点信息：关键字总数、关键字本身、孩子指针
	   >每个叶子节点高度相同：
	   >每个中间节点关键字有序：
	   >内部节点孩子个数区间：半满到满。2-3-4树。中间节点孩子个数[2,4][t,2t]
	  >搜索：采用递归的方式，先从x中查询，找到则返回，x是叶子节点也没找到则返回没找到，否则先磁盘读x的对应的那个孩子节点，然后递归搜索这个节点下是否有k
	  >创建：根节点可以持久化到磁盘；新的节点创建时内存中。
	  >分裂：中间节点个数满而分裂，居中关键字上移，其孩子指针指向新的节点，而其原来的孩子由其原来的右边的节点作为新的起始关键字的左孩子。因为改变了2个节点，新增了一个节点，所以需要持久化写磁盘这三个节点
	  >删除：删除上级：同级合并与向上突出。删除本级：先向上合并再同级合并再向上突出。
	 >可合并堆：斐波拉契堆:图问题算法， 基于有限树。
	  >可合并堆：支持5种操作如最小元素查看和删除、用两个堆合并为一个新的堆
	  >斐波那契堆：一系列最小堆序的有限树的集合。
	   >孩子链表：双向链表
	   >最小节点：树的最小关键字的根节点
	   >根链表：
	   >势函数：t(H) +2m(H)总的摊还代价的上界就是总的实际代价的上界。
	   >最大度数：度数可以认为是根节点的child个数。根链表上的各个根节点的度数需要是不同的。D(n) = O(lgn) 从下述名字的由来中可以证明此结论。
	   >创建一个斐波那契堆：
	   >插入一个节点：
	   >合并根链表：相同度数的根节点，key大的移除加到key小的节点的直接子节点位置上
	   >某个节点减少键值：新键值比父节点的值小，那么这个节点移动到根节点链表；如果父节点false那么改为true即可，如果为true那么父节点也移动到根链表，同时递归将切信息传递到cut父节点的父节点。
	   >删除一个节点：先设置这个节点值减为负无穷，然后移除堆的最小元素。
	   >名字的由来：一个节点的孩子节点的从左到右，度数必然越来越高的，从而x的节点个数本身会出现斐波那契数一样的增长，增长到的量值就和x节点的度数有关，由此决定。并且得出附属结论：最大度数<=lgn
	 >有限整数的lgn时间查询数据结构：van Emde Boas树的递归结构。比计数排序O(n)还短时间复杂度。
	  >条件：关键字0~u-1且不重复：且u=2^k
	  >位向量方法：A[x]=1存在，0不存在。
	  >位向量上方叠加二叉树：左分支表0，右分支表1，值表是否有，则查找下一个元素、上一个元素更方便，边回溯边判断即可，从而最多2lgn实现；最小最大元素更是lgn即可。增加则路径节点的值设置位1，删除则从叶子节点向上节点的值为孩子节点的逻辑或
	  >位向量上方叠加多叉树：sqrt(u)个分支，那么树总共2层固定了，这是优势。但是查找后继、前驱、最大、最小等需要O(sqrt(u))次查找。
	  >位向量上方自顶向下每个节点分出u^(1/2^h)的分支直到分支数为2： 最顶层节点一个，分出u^1/2^1个分支，一个值属于哪个分支可以计算出来，找到对应分支后，用余数/下一级的分支数的商继续指出属于的下一级分支是哪个，余数保存下来，一直算下去得到具体的位置A[]。那么计算的次数可以用前面的哪个递减公式u^(1/2^h)=2 来得出h=lglgn, 从而是这个时间复杂度，对查询、插入、最小、最大、上一个下一个都是。V.cluster存节点,V.summary存是否存在，high(x)为商，low(x)为余数，index(x,y)为商*除数+余数。前述需要存位信息。如果veb树，存。veb树：每个节点还有min,max两个量。不存储位信息，而要求u也不一定那么2^2^k;比如2^3也可以：分解为4个cluster每个2个元素。
	   >重要认识1: 最小元素不出现在叶子节点即某个veb(2)中。
	   >重要认识2：如果一个veb(2)中只有一个元素，那么min=max=x, 不需要额外的A数组。如果veb(2^i)只有一个元素，那么也不需要簇。或者说，向一个空veb树插入一个元素，只需要修改min=max=x即可。目的都是为了缩短递归调用链。
	   >重要认识3：sumary存储的是cluster中有值的下标，存储方式同cluster。
	   ---推论：在书本例子中，按照先后对一颗空veb树插入2,3,4,5,7,14,15;第一次2，还是空树，所以只改变了min=max=2 ，第二次3,求得商为0，余数为1，而cluster[0]指向的树还是一颗空树，因此也只改变该子树的min=max=3，第三次4,商=1，余数=0，同理cluster[1]为空树所以min=max=4, 第四次5则第一层商1余1，第二层则商=1/2=0余数1，所以子子veb(2)中min=max=1, 同理第五次7在第二次商1余2从而min=max=1，第六次14商1余0于是min=max=0,.....
	  >简单有限树：大集合划分出的若干个不相交的子集合构成。
	   >不相交集合数据结构：
	   >加权合并启发式策略：合并时假设为两两合并，那么两个两个合并共有n/2组，四个四个共有n/4组，所以总的合并组数n/2+n/4+...+1则项数:n/2^k=1从而k=lgn, 每次需要操作的次数，第一轮n/2次(min(1,1)),第二轮也是总元素个数少一半n/2,同理最后一轮也是min=n/2总元素个数/2，因此总共的合并代价=n/2*lgn, 又make-set m次代价
	   >按秩合并和路径压缩：秩就是树的高
	    >两趟方法：路径压缩的Find-Set。使得第一遍耗时，但第二遍开始就直接找到根节点了。
	   >证明：m个操作,O(m*alpha(n))
	 >动态树：不相交的有限树的森林。渐进最快的网络流算法中常使用。
	  >流网络问题：G(V,E) 线性规划问题的特例。
	   >源节点到汇节点的最大速率：问题归结：假设s->t共有n条不完全重合路径，每条路径的流量为xi, 各条路径经过的管道按照管道排列：则c1管道有：∑xi, 那么要求∑xi<c1，同理k个管道都要有这个要求。在这k个线性要求条件下，∑xi 其中xi为1<=i<=n所有值 ，求这个和的最大值--所以是一个线性规划问题。可以通过广度优先遍历找出所有的可达路径。
	    >经典方法:
		>推送-重贴标签方法：是最快实现。推送目的：调低溢出点u的e(u)---要么最多可以少流入(cf(u,v)>0&(v,u)->E)要么最多可以多流出(cf(u,v)>0&(u,v)->E)(结果是：v->u无流入或者u->v流满同时e(u)>=0, 或者e(u)=0而没满或者没空);重贴标签目的：找到最佳推送目标--临近最少主动推送者
		 >过程：在残余网络Gf中寻找一个溢出节点：如果没有则e(u)=0对所有节点成立，那么已经是最大流了，退出。寻找临近中h最小的即溢出次数最少的且cf(u,v)>0即还有调节空间的节点来作为u的调节目的地--容纳u的减少量。一次次循环贴-推-找溢出节点中，因为每次Gf都不存在增广路径，而最后e(u)=0没有溢出流量，从而所有s流入的都流到了t处，那么预流f就是最大流。
		 >预流：非s节点的所有节点都满足，流入总和大于流出总和
		 >超额流：e(u)= ∑f(v,u) - ∑f(u,v) >= 0  而>0则成为溢出--u为溢出节点,溢出节点至少有一边满足cf(u,v)>0即残存边是u->v指向的，因为从溢出原因来看。注意残余量cf(u,v) + cf(v,u) = c恒成立，因为u->v在E中，则为c-f，而v->u时cf(u,v)=f。。总之，残余量cf(u,v)是会为0的---注意区分两个残余量。
		 >高度函数：对所有的残存边(u,v)->Ef：h(u)<=h(v)+1 严格的说h(u)>=h(v)
		  >重贴标签操作：对溢出节点u进行，只有当h(u)<=h(v)时才会进行，进行之后h(u)<=h(v)+1，此后下一次对u重贴标签，也会等到h(u)<=h(v)时，即所有相邻节点都不比h(u)低时才会，所以增加后未破坏性质，直到下次增加也不会破坏高度函数定义性质。
		 >饱和推送总次数：上界2|V||E| 
		 >独立最简单理解：可以看作推箱子-推货物模型。本质可以当作溢出效果，一步一步一节点一节点的溢出，只要存在路径那么总可以到达t；第二，如果出路径已经满了仍然溢出那么可以退货---到达流减少流入即可：因为∑f(v,u)-∑f(u,v)=e(u)所以一定可以通过减少流入来实现减少e(u)至0的程度；一直退到s，所以完全不担心某个路径上推多了之类的问题；---退回即可。前面解释了一定可达。第三，一定足够，因为最多不会超过s->s.adj全满的量，而最开始就给这么多的量--给了上限的量。第四，一定不会漏路径，假设还有一条路径还可以容纳，那么必然s.adj必然可以有还没有推送的或者退回的e(u),而可以从s.adj开始推送到该路径至该路径有一环满了<e(u)。可达，足够，不会漏路径，所以最后可以找出最大流。
		>前置重贴标签算法：在选择溢出节点和组织溢出节点方面给出的一个算法，结合推送-重贴标签构成的释放动作，实现推送重贴标签算法。
		 >许可边：许可网络
		 >释放过程：一次将一个溢出节点的额度e(u)释放完为止--向临近的节点推送。释放高度最大的溢出节点。
		 >遍历过程：一次取一个节点，如果该节点释放过程执行后，高度变化了，将它移动到链表首位置----是因为u在释放中可能升高h所以可能产生从u出发的许可边--因此要从头开始遍历--但u本身不必-所以将u移动到开头-而从u的下一个节点开始释放，还发现u没有超额流量,而继续下去，如果x的释放没有增加高度--则没有新增许可边-所以x及其前面的节点的超额流量都是0，再从下一个元素开始遍历释放---如果到达了末尾-说明所有节点超额流量已经为0--已经没有节点可以释放-需要释放，因此退出。
		>残存网络：残存流量大于0的边-残存边构成Gf。残存网络中依然存在的s->t的路径p为增广路径，其上的最小值为可续加容量，续加之后形成的新的残存网络，再次寻找增广路径，然后续加...直至没有增广路径。
		>增广路径：使用广度优先算法，先找到路径经过节点数最少的。
		>切割：网络切割为S和T。 单个点具有流量守恒：对于某个节点u: ∑f(u,v) - ∑f(v,u) = 0 流入减流出=0 显然 对所有除了s-t之外的点都满足这个关系。
		 >想象一幅网络流图：定义|f|=s点的所有流出和-s点的所有流入和。上面那条和这一条是最重要的性质。而f(S, T) = S中所有的点流出到T中的流出 - T中所有的点到S的流出。。而从定义出发，从形式上的相似，和没有新概念，所以认为f(S,T) 和|f|之间有关系，并且轻易推得|f| = f(S,T)。。同样可以定义 切割的容量c(S,T)=∑∑c(u,v)。而c(u,v)>=f(u,v); f(S,T)=∑∑f(u,v) - ∑∑f(v,u)<=c(S,T)相等的条件在于特殊的切割：假设G被处理后没有了增广路径，那么说明流量路径p上至少有一环/一边的流量=容量--且这个就是流量的值|f|：即f(m,l)=c(m,l)=|f|---否则还可以继续加流量；同时如果有返回的，那么返回一定为0或者使得同路径上某条边满了--否则还可以继续加流量；如果只有单条流量从s->t，那么对这条边进行切割，形成S，T，且分割方法为S只有这条边的起点a, 剩下的点包括st都在T内，那么S->T就只有一条边，那么|f|=f(S,T)=c(m,l)=c(S,T) ；如果是有多条边从s->t即从不相交/也可以相交：那么每条都必然有一条容量满的边--否则可以继续加流量：从而以这几条满边切割，将边的起点构成一个集合S,剩下的点包括st都在T集合里，那么S->T就只有那些满容量的边，又可以得出|f|=∑c(mi,li)=c(S,T)
		>Fold-Fulkerson算法；就是找出残余网络，不断地找到增广路径-增加增广路径中的最小边为量值的流量-更新cf(u,v)残余边值-从而消除增广路径。
		 >Edmonds-Karp算法：在残余网络中找增广路径的方法为广度优先的F-F算法。第一次找出来一条最短的路径，其中u->v是关键边，则δf(s,v)=δf(s,u)+1 更新后，显然δf'(s,u)=δf(s,u)是不会变的--因为s->u没有消失的边，而s不经过u到v的仍然>=δf(s,v)--因为后者是最短距离,经过u而不直接到达v的也>=δf(s,v)--理由一样，现在新的Gf'中(u,v)去除了，所以只有走剩下的路，剩下的路则必然>=δf(s,v);所以δf'(s,v)>=δf(s,v)下一次它不是增广路径。一条边成为关键边的次数最多：假设u->v相连是增广路径上的关键边，那么增量处理后，残存网络中v->u即指向变反,从而δf(s,u)=δf(s,v)+1 那么后面v->u假设成为关键边，那么增量后δf'(s,u) + 1 =δf'(s,v)>=δf(s,u)+1=δf(s,v)+1 + 1=δf(s,v)+2 从而在两次增广路径上时,s->v的距离已经增加了2，初始0，而最长距离不超过全部节点连起来的长度：V-2 则2m=V-2 从而最多增加m次=V/2-1 最多m次成为关键边；而总共E条边，所以最多E(V/2-1)=O(EV)个关键边次数。假设每次递增操作仅仅1个关键边更新，那么就也有O(EV)次流量更新。
	  >最大二分匹配：机器集合和任务集合的匹配。且一个任务最多只能和一台机器匹配，一台机器最多只能和一个任务匹配。V分为L U R ， 最多匹配就是寻找最多的L->R的满足前述一一对应要求的连接的最多个数；引进s,t在两边，s->L, R->t连接，G'全部边的权重为1，那么s->t的每条流都是1，且每条流必然不会相交--因为容量原因，所以最大流就是最大匹配数。
	 >伸展树：二叉搜索树的一种形式，为了简化动态树。
	 >持久数据结构：
	 >聚合树：
	 >指数搜索树：
	 >动态图数据结构：顶点连通性、边连通性、最小生成树、双连通性、传递闭包。
	  >无向图的最小生成树：最小权重之和连接所有的节点。图的森林集合形成一个图拟阵。
	   >图的生成树：暴力方法：利用E的按起点分组先后排序，从各组里选择所有可能的0-k的个，接着从下一组顶点开始，要求，后一组的两个点不能选择已经出现在已有点的集合里，最后将各组对应的点集合一个一个合并，不能合并为一个则不行，节点数少也不行。
	    >我的动态规划方法：想象将节点排序一条线，去掉第一个点，剩下的点能够进行的最小代价树得到了，它和被去掉的这个点之间的最短连接必然可以算出来(如果有连接的话)，从而得出总代价；也可以去掉第2个，...k个，都做一遍，分别也得出总代价，然后选择代价最小的 那个去掉，必然就是最小生成树的模式；即存在最优子结构--可以用动态规划方法解决。 W(V<k+1>) = min{min{wk} + W(Vk)} , |V<k+1>| >= 2 , 一个点时权重为0；如果两个点之间无连接，则保持为2个集合。
		 >从边的角度：想象将边排序，选择一条边，剩下的边构成了最小代价树，那么这条新的边加进去看能否：新增节点、或者简化已有路径、或者连接两个点集合/树；能，则保留，不能则无用而不加进去。递归到一条边开始，然后新来一条边；一种简化已有路径比如三个点三条边而去掉代价最高的一条，又比如新增一条边而成环了就删除环中最长的那条边。方案：条件：边集合；中间数据结构：树集合。非常好的方法，一次遍历就可以搞定！！！
		>kruskal算法：将上述从边的角度的算法中，将边按照权重排序从低到高，那么回环出现的时候，新加的这条边不加就可以了---一定是回环中最大的。 
		>prime算法：每个节点有条件地更新parent指向---根据权重。所以每个节点一定有一个parent,因此除了r根节点，其他节点都有parant,末级节点没有child,;另外一个重要条件是，节点必须要按照权重排序而在Q中，每次弹出最小权重的节点(可以用三个节点构成三角形的场景来解释：不从最小的开始弹--就要双向更新；三角形去除最长边道理---只要走最小边---那么不需要双向更新就一定把更长边排除了)。。初始连接、更新连接，最小的开始下一个初始/更新。。已弹出结构、已连接结构；下一次弹出必然从已连接结构中弹；可以把已弹出结构收缩当作一个点---从而又是最开始的三角形情形(需要证明：最小边一定会得到保留：假设除了最小边的两个点之外的其他点构成了一个最优树，那么最小边的两个点接入最优树的方式只有3种，想象最优树为一个点，或者说，最小边的第二点到最优树的距离为s1, 最小边的第一点到最优树的距离为s2, 而最小边两个点之间的距离即最小边的长度为s3, 那么首先就有s3<=s2肯定成立，所以s3肯定不是最长边，所以无论如何将最小边的两个点接入最优树，最小边都会得到保留，才能保证总代价最低，得证！)。已经证明最小边会得到保留，那么将第二点弹出，先给它的连接点初始化权重--意义仅仅为初始化了一批：相当于最开始对第一个点初始化一批一样--目的为对弹出结构的每个点都要初始化连接的点，但此时弹出的点不一定是第二点连接的--可能也是第一点连接到的---因为是已经初始化的所有点的最小权重点；那么假设除了这两点之外的点构成了一颗最优树，那么这两个点接入最优树的方式必然只有走找到的最小权重那一条，即这一条会得到保留，因此这一条的另一个端点可以弹出了---并进行初始化连接点了；接着又寻找这三个已经相连的点对外的所有连接中最短的那一条边---同理推断肯定会走这一条，如此根据必然会保留的一条一条找下去，递归下去，而连接起所有的点。
	  >节点对之间的最短路径：单源最短路径
	   >我的几种方法：从目的节点开始：找与它相邻的所有节点，更新这些节点到它的最短距离；再下一层，对第二层的每个节点，都找出所有每个节点能够到达的所有未到达的节点，更新最短距离，直到全部节点展示完；形成一颗就像河流分细支一样的图，目标节点此时的值就是最短的路径。但找出的是所有的节点到目标节点的最短路径--代价高。
	    >动态规划方法：Vij = min{ vik + Vkj}, 当白色节点集合中i节点可达的节点中无i节点时，更新代价和到达路径；当白集中有j节点时，更新j的代价和路径；。这种方式，广度优先或者深度优先都可以，可以借助一个队列；从起点开始，将可达节点更新代价和路径后入队，然后弹出一个节点，取它可达节点，如果更新成功则入队，失败不入队。也可以最终实现----这种方式则广度优先遍历更好---每次更新后深度更新。而且遍历，显然可以从最短距离的点开始遍历。
	   >松弛技术：节点增加最短路径权重的上限属性。
	   >Bellman-Ford算法：对上述动态规划算法处理，不用队列，直接遍历第一遍，则s到t的一条边达到的最短路径找到了，对于2条边到达的路径，则可能因为边的先后问题，而先m->t(不会使用到mt权重),后s->m从而没连接上这2边到达的路径--仅仅使用了sm更新了m的权重，则第二遍更新一定可以使用到所有的2次到达的路径---并自然的存在2次最短的路径：如果和一次到达相比代价更低则会更新为2次到达的路径，同理3次到达最多只需要遍历3次就可以找到3次及其以内到达的最优路径，一般的，最多V个节点，最多V-1条边，所以最多遍历V-1次，就能把V-1次到达的最优也找出来更新下来，这样就找到了s->t的所有k次到达中的最小代价的路径。甚至连指定次数到达的最优路径也能找到。一条边到达的最短值是所有一条边的最短值；两条边到达的最短值，其中起点到路径上的每个点都是起点到该点的最短路径；三条边到达的最短路径，就是前两条边最短路径+最后一条边的和能够到达的所有情形里面，最小的哪个来更新；因为s开始的前两条边构成的最短路径的所有情形都在前两次遍历完成了，所以第三次遍历能够筛选出全部2+1次组合中的最短路径--即s->t三步到达的最短路径。t是任意的，而轮次也可以递增类推，从而V-1次内到达的最短路径对任意t也都可以推出来了。
	    >最优权重的典型特征就是：每个节点都满足：v.d<=u.d+w(u,v) 且反过来也成立。即两个是充要条件。
		>对边进行排序：这样来避免出现上述的先某些边而导致更新无效--无穷的值；原因在于太底层--上层的边还没有更新；所以一轮更新过程中，如果严格按照先高层后底层的更新顺序，则不会出现无效更新的情形，从而甚至一轮更新就能先找出一步最优、二步最优\...直到V-1步最优的路径；而这个顺序就是拓扑排序---广度优先生成的树的层次序：：自顶向下进行松弛/更新权重路径。
		 >应用：PERT图分析。
	   >Dijkstra算法：把上述队列方法中，队列加入的元素改为全部顶点，同时取元素改为取当前权重最小的那个节点。无放回。第一次只有一个节点，先更新它的所有直接相连的顶点的权重，然后找其中最小路径的节点弹出---也是Q中的节点，因为这个点的权重不会再更新了---假设会--还有s开始的更短路径---那么就会和前面最小路径矛盾，因此这第二个节点的权重一定不用更新了。然后这第二个节点相连的节点的权重也可以更新了，如果包含第一轮初始化的节点，自然也可能被更新。每次都走最短路径线的端点，即弹出的点到起点的距离一定是还没走过的最短的线的端点--因为如果还存在更短的线则会走那条了，第二，它的权值不会再被更新--因为假设未来某一次找到了一条指向它的线-那么那条线到它的距离一定长于目前的权值---因为还没指向它时这条线的长度已经就超过目前的权值了---因为在它后面执行；因此它的权值不会再被更新。从而出现弹出一个确定一个，弹出一个又确定一个，从而弹出V-1次，而总的更新次数为边数E次，从而复杂度为O(V+E)--注意弹出最小的那个算法未考虑时，而且确定速度更快、每次都有确定的。
	   >差分约束和最短路径：条件为约束一个定义域，目标是再从定义域中找到映射到值域最大的定义域的集合。
	    >条件的可能情形：差额限制条件：两个量要满足一定的差额，比如事件顺序执行的先后的时间差。
		>差分约束系统Ax<=b的约束图：n+1个节点。
		 >与单源最短路径问题的关系：引入的额外节点v0, 则v0到所有节点的最短路径构成的最短路径树的各个节点的权重满足的关系和约束图一样；因此是约束图的一个解。如果环路的总值为负，那么表达出这个环路和总值，做一个数学运算，得出结果来解释。
	  >所有节点之间的最短路径：与矩阵乘法之间的关系。另外，最短路径树上的每条路径上，任意两点中的前节点到后节点之间也是最短路径。
	   >基于矩阵乘法的动态规划算法：动态规划：C(i,j)=min{w(paiij,j) + C(i, paiij)}当i!=j时，当i=j时C(i,j)=0;其中paiij可以从权重矩阵的j列中不为无穷的数对应的行来确定。
	   >矩阵序列L(m)方法：根本原理之前已经讨论过，就是一步到达，二步到达，....k步到达的最优。这里给出了这个过程的数学表达形式L。
	    >重复平方技巧：因为W^4=W^2 * W^2 非常巧妙地简化了矩阵相乘的代价----坦白的说，是矩阵的指数次方的代价。对上述算法中的计算有利：简化为n^2*lgn
	   >Floyc-Warshall算法和传递闭包：这种算法本质和1次到达、2次到达、...k次到达的方式一样。首先W矩阵的含义可以理解为i->j一步到达的路径值，那么2步到达就是：i能到达的所有点--同i行，这些点到j的距离--同j列一一求和比较，并和一步的路径值比较，确定一个最小的值更新到dij位置即可，n*n次可以确定所有二步及其以内到达的最小路径值；自然的，只需要继续在旧D的基础上计算一个新D,就可以得出3步以内、...n-1步以内的最小路径值D(n)。D(1)=W
	    >有向图的传递闭包：存在i->j的路径，的所有(i,j)的集合就是G的传递闭包。t(0)ij的值为0或者1，就足以表示情况。一步以内可连接，直接wij映射为0-1而来tij, 2步以内开始递归-依赖上一幅图/矩阵：t(k)ij= t(k-1)ij | (t(k-1)ik & t(k-1)kj)即这一幅图里tij的相连情况(路径上至多k个中间节点)=上一幅图(路径上至多k-1个节点，不经过k节点)里ij是否相连(已经相连则下一图相连) 或 上一幅图里过k节点时能否相连即i到k 与上 k到j。。。另一种解释:i,1,2,3,...k,j  则如果i不能达到j,那么1-k中一定有一个点m能直接达到j,同时也必然有一个点l能直接达到i,所以在遍历1...k时，首先，每次的更新会把该点能到达的点更新到i点能到达的点位置上，无论m,l在1..k序列中谁先谁后。
		 >数学化表达和证明：假设i,j外，遍历1...k个节点，那么1节点之后，1节点直接相邻的有(1,x11)(1,x12)...，形成一个球，1节点在中心，面上的节点互相直接连接， 遍历2节点之后，2直接相邻的(2,x21)(2,x22)...同理2也形成一个球-表面的点互相连接，如果2和1相连间隔1个点--那么1和2两个球上的点都互相连接了；如果2和1相间隔0个点，那么也是互相连接了。而k个点形成的球，因为k个点之间本身存在练成线的互相连接，所以相邻则合并，因为总共相邻k-1次，所以合并k-1次，并且合并为1个球，即内部的k个点互相连接起来了，而这个球中有m-l两个点必然连接着i,j,所以在m合并的时候，i和球上的点直接连接了，l合并的时候l和球上的点直接连接了。因此最终合并完成时，i和j就直接相连了。这就是i,j能相连则合并k次一定能直接相连的原因。
	   >Johnson算法：先额外取一个点s,对G图，得出s到G的最短距离树，记delta(s,u)=h(u) 那么h(u)-h(v)>=w(u,v) 记w(u,v) + h(u) - h(v) = w'(u,v)则 >= 0 从而可以在w'构成的G'上使用Dijkstra算法n次得出最短距离delta'(u,v) ;然后利用delta'(u,v)=求和w'(vi,v(i+1))其中1<=i<=k 假定时某条最短路径，那么可以进一步展开w', 得出delta'(p)=求和w(vi,v(i+1)) + h(v1) - h(vk)。其中求和这一项的含义推导：假设G图上u->v有n条路径，每条路径的路径和为：求和w(u,vi) = 求和w(u,vi) + h(u) - h(v) - (h(u) - h(v)) = 求和w'(u,vi) + h(v) - h(u) 而h()是固定的，所以用w'表达后路径长度仅仅固定增长和具体的路径无关，从而各个路径的长短排序顺序并没有改变，因此u->v的最短路径在w变为w'后仍然是u->v的最短路径；从而有前面的Dijkstra算法应用后得出的最短路径：求和w'(vi,v(i+1))=delta'(v1,vk)=求和w(vi,v(i+1)) + ..那么第二个求和也是最短路径的求和：即求和w(vi,v(i+1)) = delta(v1, vk) 从而就有：delta'(v1,vk)=delta(v1,vk) + h(v) - h(u) 从而delta(v1,vk) = delta'(v1, vk) + h(u) - h(v)而间接地计算出来了。
	    >重新赋予权重：根据三角不等式而来：最小路径图中h(v)-h(u)>= w(u,v) 从而w'(u,v) = w(u,v) + h(u) - h(v) >= 0即得到的新的边权重就是冗余路径差。
		>证明：如上。
	 >图的广度优先算法和深度优先算法：
	  >图的搜索技巧：图算法领域的核心。
	  >图的表示：邻接链表和邻接矩阵。
	  >深度优先搜索：有向无环图的拓扑排序。有向图中计算强连通分量。
	  >广度优先搜索：最小生成树算法+单源最短路径算法。电子线路板的排线问题。
	   >命名由来：由近及远地访问s的所有可达节点，距离从1到2到3...且近处访问完毕才更远1的节点。一直向外，一直向下。无回溯。灰色、白色、黑色的节点。从s开始，访问到的白色节点入队列。
	   >广度优先树：G(V,E)从s开始广度优先搜索BFS而产生的前驱子图 树Gpai(Vpai,Epai) 特征就是：|Epai|=|Vpai|-1
	  >深度优先搜索：DFS可以判断G是否是有向无环图：有无B边后向边
	   >深度优先森林：多棵深度优先树。结点：时间戳-开始-结束， 颜色：白-灰-黑，边类型：树边、B-C-F
	   >括号化结构：
	   >拓扑排序：有向无环图的。DFS中先退回到根节点，再将树的白色节点打印出来。
	   >强连通分量：有后向边特征。G的一个强连通分量就是含有后向边的一个环。将G中的环收缩为一个点，得到无环分量图G^SCC。G的转置的环还是一样同G。G^SCC
   >基于动态多线程的并行计算模型：
    >并行算法：动态多线程算法的完美模型。
	>分布式存储：每个处理器的存储器是私有的。
	>共享存储：每个处理器都可以访问处理器的任何位置。
	 >静态线程：os加载线程运行，交换出来为其他线程来运行
	 >并发平台：抽象出来的专门处理任务的负载平衡调度。支持：嵌套并行和循环并行。
	>动态多线程模型：可单线程化、基于信号量和持续时间、-嵌套并行-自然分治
	 >逻辑并行：spawn并行和sync同步。多子并行,又在调用者指定处同步。
	 >调度器：处理器数和对链进行处理器分配。
	 >计算的有向无环图：圆圈为指令，方框为一次调用，边线为指出执行顺序。
	 >工作量：所有处理器算起来总共多少个单位时间。任务的总的运行时间。
	 >持续时间：沿着一条路径的最长执行时间。最长路径时间。
	 >加速比：T1/Tp<=P 持续时间T∞。并行度T1/T∞
	 >运行时间估计：Tp>=T1/P工作量定律。Tp>=T∞为持续时间定律。而在T∞时间内最多的工作量是：T∞<=T2<=T∞P,所以剩余工作量假设可以均摊到各个处理器(假设均摊后几乎一样高-虽然实际上参差不齐)那么也有：<=(T1-T2)/P, 那么承担T∞的处理器再次承接，那么耗时总共：Tp=T∞+(T1-T2)/P<T∞+T1/P
	 >松弛度：T1/(P*T∞) 如果=1说明核数=任务量按处理时间均摊-即并行度；或者说=1说明每个核上的任务量=持续时间。松弛度高：Tp<2(T1/P),松弛度低：Tp<2T∞ 。所以max{T1/p,T∞} <= Tp <= 2max{T1/p,T∞}
	 >链: 就是节点。关键路径：有向边构成的最长路径；其上的节点数为持续时间。总节点数就是运行时间。
	 >确定性竞争：读取同一个主存值并至少一个写。
	  >矩阵乘法的并行化：并行循环parallel for 工作量O(n^3)/持续时间O(lgn)  。。嵌套/派生循环spawn-sync
	 >多线程归并排序：数组分割为两半，两半派生调用并行排序，最后同步，merge合并两半排序的结果。我的merge并行化方案：两个数组都中间分割q,p, 计算max{p,q}得出真正的分割，对两个数组生效，然后并行低位和低位，高位和高位合并，结果直接拼接。
   >矩阵上操作的高效算法：求解一组线性方程组
    >超定线性方程组的最小二乘解：欠定线性方程组可能有无数个解。
	>LUP分解：比A^(-1)b效果好。每个非奇异矩阵A都有。
	 >采用原因：发现解线性方程组，除了求逆，最好的就是特殊的线性方程组--上/下三角阵形式的参数Ux=b, 因为这样可以自底向上一次一个变量的计算出来，又因为任何一个矩阵其实可以通过变换而分解为两个三角阵的乘积：PA=LU, 那么转换为这个形式后，就可以间接利用LU计算了：PAx=b, 则 LUx=b, 即L(Ux)=b, 那么可以先计算出Ux=y, y计算出来后，可以直接计算出x。
	>LU分解：用高斯消元法，i行处理j行，可以很方便的将Ax=b 化为Ux=y ；或者只看矩阵：则A->U，而对一个矩阵A的高斯消元动作可以等价为对这个矩阵左乘以一个下三角矩阵C，最终就是∏CiA=U 而下三角阵互乘也是下三角阵，所以也可以表达为LA=U，其中L和U都经过这个高斯消元过程计算出来了，那么此时其实可以计算出x了。LAx=Ux=Lb, 从而可以直接计算出x来。但是计算比较麻烦。
     >经典的递归分解：A可以表示为4部分，按照a11为第一块的划分，A=[a11 w;v A'] 四块又可以分解为两个四块相乘：A=[1 0;v/a11 In-1]*[a11 wT;0 A'-vwT/a11]而A'-vwT/a11又可以同理表达为两块相乘=L'U'从而再定两个子矩阵的一行一列，从而用来表示A=[1 0;v/a11 L']*[a11 wT;0 U']就定了2行2列，一直递归下去就定了n行n列。实质上就是LU=[1 0;v/a11 L'][a11 wT;0 U']的递归；每次只需要知道L*U的第一行和第一列，就可以计算出分解中的主要元素，而知道L*U的每个元素则可以知道L'*U'的每一个元素，从而知道L和U的每一行每一列，递归下去，L和U就会变成上三角和下三角矩阵。
	 >LUP分解：A的LU分解中有要求的，因为出现了除以a11。假设A非奇异，经过一个Q的行变换，那么可以使得第一个元素非0--比如取第一列所有行中的最大绝对值的那一项，从而变换之后就可以分解了，数学表达为：QA=LU=[1 0;v/a11 In-1]*[a11 wT;0 A'-vwT/a11], 这里Q是可以知道的计算出来的；同理Q'(A'-vwT/a11)=L'U'其中Q'也是可以计算出来的；但是LU表示里还没出现Q'乘以这样的计算情形，需要出现则左右同时再乘以一个矩阵W，即WQA=W[1 0;v/a11 In-1][a11 wT;0 A'-vwT/a11]，W为4块，则为结果中出现Q'(A'-vwT/a11)而其他项目变化最小--尽可能不变，那么一种方案是W=[1 0;0 Q'] 结果WQA=[1 0;Q'v/a11 Q'][a11 wT;0 A'-vwT/a11]=[1 0;Q'v/a11 L'][a11 wT;0 U']=LU 从而形式上LU和L'U'之间又建立了一个递推关系；令WQ=P=[1 0;0 Q’]Q再令Q'=P'那么可以得到另一种形式PA=LU=[1 0;P'v/a11 L'][a11 wT;0 U']
	>逆矩阵的计算：问题表达为:如果AA^(-1)=I 则 ni(A) 为A的逆矩阵。LUP分解中，有PA=LU 可以计算出P和L和U，然后 ni(U)*ni(L)*P*A=E 那么ni(A)=ni(U)*ni(L)*P但是工作量重复，逻辑不自然。第二种方法：AX=I, 将X看作n个x向量，I也可以，那么就有Axi=ei从而一个一个计算，计算n次LUP分解方法计算出来的x，拼接即可。
	 >Strassen算法：
	 >通过逆矩阵方式计算两个矩阵的乘积：是因为发现了一个特殊的矩阵的逆：D=[I A 0; 0 I B;0 0 I]而D^(-1)=[I -A AB;0 I -B;0 0 I]
	 >通过低阶的逆矩阵来计算高阶的逆矩阵：对于对称正定矩阵A,则A=[B C^T; C D] 那么A的逆矩阵借助关于B的舒尔补S=D - CB^(-1)C^T 可以方便的表达为：[B^(-1) + B^(-1)C^TS^(-1)CB^(-1) -B^(-1)CTS^(-1); -S^(-1)CB^(-1) S^(-1)] 即需要求逆的只有B和S，而可以对B做1维，所以逆就是它的倒数，S可以直接算，S的逆则可以递归---因为形式上已经出现了，S也是对称正定的，所以S可以做类似A的分解，一直递归到一阶，而1阶的S的逆就是它的倒数，从而知道2阶的，进一步...直到n阶的。而对于任意的非奇异矩阵A，都有A^TA是一个对称矩阵。而A^(-1)=(A^TA)^(-1)*AT
	 >正定矩阵：x^TAx>0恒成立的矩阵。可以通过A=[B C^T; C D] 来证明这种性质的含义。
	 >S是正定的的证明：利用A的分解和定义。
	 >最小二乘逼近：对称正定矩阵的应用。
	  >问题：给定一组点(xi,yi), 假定拟合函数为f(x)= ∑cix^(i-1)的n项多项式, 那么误差的范数||e||=平方和的二次开方，然后求误差的最小，即平方和的最小值，求导得对某一个系数ck求导=0的条件：∑(∑aij*cj-yi)*aik=0 而外面aik相乘，n个方程，则发现变量是k是列，那么这个等式应该是A^T的一行*一个向量所得，假定这个向量为b, 每一项元素为bi=(∑aij*cj-yi) 这个可以看作是A的一行乘以c向量-y向量的一个元素，所以b=Ac-y, 从而n个求导等式变为A^T*(Ac-y)=0, 进一步得A^TAc=A^Ty  那么形式上就是Px=b,P为正定矩阵这样的计算求解模型，可以用LUP分解自然计算c了。Aij就是第i组(xi,yi)的xi的第j-1次方的值。
	 >矩阵按奇异值分解：SVD.。A=Q1∑Q2^T , 其中∑是一个对矩阵整行加倍的转换矩阵：即只有对角线上的元素可能不为0， Q1,Q2^T都是标准的列互相标准正交的矩阵。
	  >正交矩阵：两个向量标准正交：内积为0，各自范数为1. 
   >线性规划：单纯形算法
    >规划：规划就是分配。线性规划问题就是一个有约束的分配问题。
    >约束不等式组：标准形的线性规划(A,b,c)
	>目标表达式：目标函数。
	>最优目标值在可行区域的顶点上：因为目标函数是线性函数。
	>单纯形算法：找可行区域的顶点和临近顶点的目标函数值，直到一个顶点的值是局部最大为止。
	 >不等式上的高斯消元法：令非基本变量为(0,0,0...)得到非基本变量的值 和目标值。从目标函数中找一个系数为正的非基本变量，从约束等式中找出它的增加使得基本变量==0的最小增加值--为最紧的--如果始终为正则为无穷, 取最值的对应的那个等式约束的非基本变量和这个变量交换位置：即代数移动，这个变量移动到非基本变量的位置，非基本变量移到右边，然后两边同时除以非基本变量的系数，得到新的形式，然后带入剩下的方程，从而得到新的等式约束关系组。非基本变量和基本变量的交换位置叫做一次转动。继续寻找目标函数中的系数为正的非基本变量来进行转动，直到目标函数的变量的系数都是负数为止。
	 >是否可行、基本解可行、有边界：目标函数有正系数变量，从约束等式中使得基本变量为0的最小化该变量不是无穷；则有界有解，可以计算初始解而返回。
	  >每次的转动：bi的变化：因为每次选择都是取非基本变量最小值,即ble/ale<=bi/aie，因此bi'=bi - aie*ble/ale>=0恒成立。从而转动之后，依然保持bi>=0
	   >目标值的变化：不会减小。如果不变，则称为退化。z=v+ce*xe' , xe'=bl/ale 所以当bl=0时发生退化。如果两次迭代后松弛型一样则称为循环.
	  >A-b-c相同则松弛型必然等同:可以定义两个,得出一样的结论.
	  >迭代中松驰形的总个数:C(m)(m+n) 或者说(n+m  m)种,迭代次数超过这个次数,则必然循环.
	  >避免循环:Bland规则:采取具有最小下标的变量来打破目标值不变的局面.
	 >线性规划对偶性: 证明实际上找到的解是最优解.
	  >寻找对偶线性规划: A横向约束变为A纵向约束(这个关系就含有两个目标函数之间的关系),最大化变为最小化,目标函数变为系数为bj的集合; 且可以用定义的约束关系证明的性质是:对偶线性规划的目标值>=原始线性规划的目标值, 而对偶线性规划是找最小值,原始是找最大值,那么说明当原始目标值=对偶目标值时,对偶不能再小了,否则违反前述不等式,原始也不能再大了,否则同理也违反不等式,那么就停止迭代了就是最优值了,
	   >从原始线性规划的最优解得出对偶线性规划的最优解: 原始z=v+∑cixi 而最终解时,xi=bi'的最终解或者0, 而对偶目标函数是:z=v'+∑biyi 所以发现当yi=ci时或许就是最优解,构造后可以证明确实是.
	    >性质1: 原始的解xi带入原始线性规划的原始系数ci而不是迭代系数ci'同样也可以得到相同的目标值,因为所有的松驰型等价,利用此性质和yi的构造定义,可以推理出biyi目标值=v', 将这个构造解带入也满足对偶线性规划约束关系式组.从而证明一定有相交的可行解--即最优解.
	  >辅助线性规划:最大化-x0, -x0引入xi各个约束表达式中, 来使得如果最优值为0,则原始线性规划有可行解.	否则为负数而没有可行解.
	   >计算步骤:先x0---xn都为0,找到最小的bk, 从而xk作为替出变量, 来和其他变量来表达-x0, 从而进行下一步的优化,直到不能继续被优化.看z最大取值是否为0,是则原线性规划可行,有最优解...然后,最终被优化时得出的约束关系式可以替换到原来线性规划的目标函数中,来得到新的目标函数,看这次是否能有最优解.
	    >可行:但是也可能循环---即无界,也可能终止.
      ---这种算法可行的过程的猜测:就是最大化目标值,对其中各个正系数变量能取到的最大值(同时满足每个约束条件xi<=m & 的交集--就是取最小值)都取到.而负系数则变量取值为0, 这样来取到边界值作为目标值的最大值,又最优值一定在边界上---从而可行.
	>将不等式约束规范化：先规范化为都是<=形式，然后再定义松弛变量，s=右-左，从而s>=0约束，从而约束变为等式约束和m个松弛变量>=0的约束，那么引入基本变量、非基本变量，可以写成松驰型(N,B,A,b,c,v)。
	>椭球算法和内点法：
	>单源最短路径问题的线性规划形式：自己发现：i到j，首先，按照i到它的相邻节点,相邻节点再到额外的相邻节点，这样一层一层向外展开，直到出现循环或者到达j节点为终止，那么i->j之间最多经过n-1条边，所以可以定义每一层的边变量为xk, xk<-x(k-1).adj。或者利用本身存在的不等关系：du + w(u,v) <= dv , di=0, 求dj的最小值，求dj的最大值也可以，因为只要满足左边的那组约束，“最大值”也小于等于所有邻接节点到达的最小总距离---所以从小于等于这个满足的条件中取一个最大的----还因为实际算时：不是选择路径值---线性规划直接是值域--所以必须要选择端点值--端点值自然就是满足约束的最大值，如x2<=x1+3 如果只有一条路径到达，那么x2的真实取值应该是3，而不是<=3的数都可以。
	>最大流问题的线性规划形式：流入等于流出，流小于容量，min{c(u,v),fsu}<=fsv, 目标是最小化fsv, 这样来满足取到端点。目标或者是对s: 所有的流出-所有的流入 最大化
   >多项式上的操作：多项式的乘法.快速傅里叶变换。。多项式相乘的结果多项式的系数，由两个系数向量的卷积结果确定
    >多项式的点值表示:
	>多项式的乘法: A多项式和B多项式相乘得出C多项式, cj=∑ak*b(j-k) 则把cj当作c(j)函数看,c=a⊕b 卷积，c也是向量，所以当作向量的卷积。
	 >既然多项式就可以看作多项式函数表达式：yk=A(xk)--还可以形成一个矩阵等式。 那么因为有函数表达式的函数给定点，则一定可以确定，且点数>最高次次数 所以可以用点来表示，这就是多项式的点值表示。
	  >上述矩阵：就是范德蒙德矩阵。而它的行列式是一个连乘：∏(xk-xj) 恒大于0，从而确定可以解，解只有一个。数学化表达来证明！
	  >而这个确定的具体实现过程：就是插值。具体计算就是利用 拉格朗日公式：重新表达A(x)的代数形式/分数形式。带入点救得到多项式表达式。
	 >点值方式表达相乘的过程：A:取n个点，B：取n个点，那么如果C=A+B，那么C的点集就是A和B的点对应同x的相加，如果C=A*B, 因为C的确定需要2n个点，用A的n个点和B的n个点，对应相乘得出的点确实在C上，但是仅仅只有n个点，不够，所以还需要再在A(x),B(x)上再找n个点，来计算对应的乘积，n+i....从而总共得到C的2n个点，就可以表达出C了确定出C了。
	>加法群：(Zn, +) 
	>n个单位复根wn^(k)在乘法意义下形成一个群：即因为这些复根元素之间的运算具有乘法封闭性：因为wn^(j)*wn^(k)=wn^(j+k)=wn^((j+k)%n) 结果还是在这个复根集合内。wn=e^(i2pai/n)。
	 >求系数向量a的离散傅立叶变换-求值：矩阵形式: y = Wa , W就是 wn^(kj), 对每行元素：yk=∑aj*w^(kj) 就是系数向量a的离散傅立叶变换DFT,  而对于一个多项式A(x)=∑aj*x^(j), 可以分解为奇偶系数下标两半相加，A(x)=∑aj*x^(j) + ∑ai*x^(i)但是其实这样没有简化，第一项：a0 + a2x^2 + a4x^4+...并不是一个严格的多项式--但是可以由一个多项式转化：即由A0(x)=a0+a2x+a4x^2+...当A0()取值A0(x^2)来实现，同理发现第二项也可以类似由一个多项式A1(x)=a1+a1^x+a3x^2+...当xA1(x^2)来实现，从而有A(x)=A0(x^2) + xA1(x^2)，计算量直接看没有少--尽管可以递归分开计算了，但是当x=wn^k时，则yk=A(wn^k)=A0(wn^2k) + wn^k*A1(wn^2k), 因为(wn^k)^2=w(n/2)^k 即实际上当k=0...n时，结果只有n/2个不同的数，从而计算yk的时候，实际上y(k+n/2)也可以计算出来了：y(k+n/2)=A0(wn^2k) - wn^k*A1(wn^2k) 即可以直接利用A0和A1, 而A0,A1的计算，因为A(wn^k)=A0(wn^2k) + wn^k*A1(wn^2k)=A0(w(n/2)^k) + wn^k*A1(w(n/2)^k) 其中A0的项数为n/2，再次迭代时，就只有n/4个，那么lgn次后，会为1项，从而可以直接计算A0的值而返回了，而每次计算出的A0,A1都可以确定一个yk,长度开始为1，然后用两个yk来计算出y2k,即得到更大的长度的y, 继续递归返回，就会利用已经有的短的两个yk而拼装出更长的y，直到和n一样长。 
	  >FFT过程：定系数向量--->定n-->定wn-->定线性组合(递归到系数向量长度n为1时，直接可算)得到yk--->循环给另一个系数向量再定一次到wn(同理递归得到)--->指定k的范围0->n/2-1, 由y(wn^k)=y0[wn^2k]+wn^k * y1[wn^2k], 同理y(wn^(k+n/2))=y0[wn^2k] - wn^k * y1[wn^k]可以计算出y在[0,n]上的值从而返回。即y有两种表达：y=a1, when n=1; y={yk| y(wn^k)=y0[wn^2k]+wn^k * y1[wn^2k],y(wn^(k+n/2))=y0[wn^2k] - wn^k * y1[wn^k], k=0...n/2-1} when n>1 ， 算法可以可视化为金字塔自底向上合并计算，从长度为1的y两两合并为长度为2(加得一个值，减得一个值), 再继续往上，长度为2的y两两合并为长度为4(加得2个值，减得2个值)，最底层相加了n次(n/2组，每组2次运算)得上一层，上一层经过n次计算(n/4组，每组4次加或减运算)得上上一层，总共lgn层，总共的计算量就是nlgn
	   >迭代算法:考虑到上述金字塔计算,自底向上,所以可以先将最底层的先计算/并行甚至都可以,然后算上一层,但是注意因为a的分解按照奇偶位置--而不是一次切分---考察叶子节点的下标顺序和原序的一一对应后发现---对应关系就是lgn位二进制表达时时逆序关系,所以叶子元素位置要从a中确定.总共迭代lgn次.
	 >插值：计算aj , a=V^(-1) * y ,  aj = 1/n * ∑wn^(-kj)*yk  而此形式又可以用FFT过程方式来计算,因为也是wn线性组合,仅仅多了一个指数上的负号,不影响算法结构,因此也能在nlgn内计算出来.
	 >共同结论: DFTn^(-1)(DFTn(a))=a,  进一步的, DFT2n(a)*DFT2n(b)是一个系数为a⊕b的2n-1界的wn^k的多项式,那么它的逆离散傅里叶变换结果就是系数a⊕b, 即DFT2n^(-1)(DFT2n(a)*DFT2n(b))=a⊕b 这就是卷积定理.
	 >FFT电路: FFT计算过程的呈现.
   >整数数论算法：基于大素数的加密方法, 或计算离散对数.
    >a^b % n的结果集合:高效素数检测和现代密码学
	>多项式时间算法:
	>整除:d|a 其中a是分母, 可以化简为分子为1的数..;最大公约数可以整除线性组合.且是线性组合的最小正数.---证明方法:可以用a=kn1, b=kn2,k是公约数,然后经过线性组合来直观证明..。约数d和最大公约数m的关系：d|m 证明： 假设d是a,b的约束而不是最大公约数，那么n1和n2必然还有公约数,假设为c, 那么k=dc，从而d|k
	 >数的分解表达：a=1*xxx*..素数 来辅助证明
	>最大公约数的欧几里得算法：事先从线性组合的最小正数中找到灵感，即去试探线性组合，不断比较更小的两个线性组合，a=kn1, b=kn2那么如果b>a那么b-a就是更小的线性组合，再和a进行求最大公约数，来试图找到最小的正的线性组合，可以简单证明gcd(a,b)=gcd(b,a-b)---使用表示+反证法，进一步推论：gcd(Fn+1,Fn)=gcd(Fn,Fn-1) 即求两个斐波那契数的最大公约数---会经过n次到1停止---这也是算法的最大复杂度：：从而如果max{a,b}<Fn+1, 那么最多经过n次就可以计算出最大公约数，因为Fn是一个指数函数--小数次幂-且指数会变化--类似x^(1/x)这种，所以弱于指数的次数次lgb，。可以从表达式简单证明互质的两个数的差也是互质的(n1>n2和反证法)。从而有gcd(a,b)=gcd(b,a mod b) 而显然 a mod b <= b 所以直接降低了求最大公约数的两个数的大小，从而可以一直这么处理下去，直到gcd...=1 或者找到最大公约数，这就是欧几里得算法
	>模运算的群论描述：一个群由一个运算和运算对象集合确定：(S,⊕), 同时运算满足4大性质：封闭-单位元-逆元-结合律 ， 简记为：满足封闭与结合，具有单位和逆元， 如整数Z和+加法构成的群(Z,+), 如果满足交换律就是交换群，如果|S|<无穷，则是有限群
	 >模运算的加法和乘法：具有结合律特征：且容易证明。(a+b)%n=a%n+b%n , (ab)%n= a%n * b%n 模n加法群。 (Zn,+n)是一个有限交换群(模n再加再模)， +n表示相加后取n模，.n表示相乘后取n模
	  >(Zn,.n)是一个模n乘法交换群：其中群里的元素是和n互质的，即Zn={[a]n <-Zn: gcd(a,n)=1 } 这从定义上要求a和n必须互质，而gcd(a,n)=ax+bn 即线性组合，而要求gcd(a,n)=1=ax+bn 恒成立，则说明 (ax+bn)%n=1恒成立,得出ax%n=1，说明存在x使得ax%n=1即x是a的逆元，且x在Zn内--即x和n互质：证明--gcd(x,n)形式上和左边一样，而最小正数就是1，所以gcd(x,n)=1，互质，证明完毕。 
	 >欧拉phi函数： Φ(n)=n∏(1 - 1/p)其中 p|n且p是素数，从2开始到sqrt(n)的素数和自身n--如果是素数中寻找。。。。。 2,4,6,,,,,元素对加法封闭，但是没有单位元素也没有逆元---但特征是：不是有限群，是有限群，则必然会重复，即a(t+1)=a(1)=a(t)⊕a(1)，从而a(t)=e, t=ord(a) 一旦开始重复，那么集合的元素个数就不会再增加了。
	>求解模线性方程ax≡b mod n：先假定<a>是由a生成的Zn的子群,。拉格朗日定理：|<a>| | n 即是n的约数。。且这里有定义：<a>={a^(x): x>0}={ax mod n: x>0} 说明是加法运算。这个ax让人联想gcd(a,n)=ax+ny=d , 即有ax%n=d 那么d<-a， 即d是<a>的一个元素，因为<a>的定义表明它的一个元素和自己相运算一定属于这个元素，从而2d,3d,...(n/d-1)*d也属于这个<a>, 即<d><-<a>, 因为ax % n这个表达式中，d|a, 即a=kd, ax%n=kdx%n=kx*(d%n)则一定在<d>里面，从而<a><-<d> 说明<a>=<d>=<gcd(a,n)>
	 >前述已经表明：ax是<d>，这样的集合，所以只有当b mod n也在这个集合里才可能有解。即b mod n = kd , 即b=cn+kd=cmd+kd=(cm+k)d, 从而 d|b就是等价含义，即d|b才有解。假设有解，即b=kd, 假设a=cd, 则 cdx=kd, 解就是：x=k/c=b/d/(a/d) 是最小解，但是x+mn也是解，即无数个解--只是相同，但不同的解：观察cx=kd, 发现c(x+n/d)=kd也成立，同理c(x+i*n/d)=kd也成立，从而x+i*n/d都是可行解，显然当i=d时就开始重复了，所以只有i=0,...d-1共只有d个不同解。
	>中国剩余定理：可以证明x%ni=(x%n)%ni 。注意等式和恒等式：恒等式都在末尾有(mod n), 而等式则仅仅对某个元素有mod n , ()则代表对两边同时进行的意思。也注意到a^(k) %n的巨大作用：{0,d,2d,...}---这里可以推断一定有逆元的元素的特征：就是gcd(a,n)=1,否则没有逆元。
	 >ai是ni以内的互质数：ai<-Zni
	 >问题表述：如果ai=a mod ni, 其中ai<-Zni,  那么 a=? 或者a≡? 用ai,ni来表示：
	 >猜测推导完整解：首先 ai=a mod ni,  假设b是一个解，那么猜测b应该只用ai,ni来表示就可以了，也能满足ai=b mod ni,  而b(a1,n1,...ai,ni)猜测形式上ai互相之间则应该独立,即b=∑aimi, 然后确定系数，根据要求要满足ai=b % ni, 那么要求可以等价为：ajmj mod ni=0 mod n, mi mod ni=1 mod n 第一个要求则得出mj应当含有ni, 则因为各个因子等价地位而都要有从而mj=∏nj, 但是第二个要求连乘中,j!=i, 又要保证∏nj mod ni=1 mod ni, 即那么∏nj需要有个因子--且这个因子使得对ni之后为单位元，那么这个因子就是逆元(∏nj)^(-1)，从而mi=∏nj * (∏nj)^(-1) , 从而一个解为∑aimi, 显然再加一个项目c, 使得c mod ni=0恒成立即可，那么c=k∏ni=kn, 所以所有的解为：kn+∑aimi, k<-Z 。。。推论：当ai=aj全等，那么x就是a的倍数，.
	>欧拉定理：g^(Φ(n))≡1 mod n 非常妙的规律，或许这个周期可以从经验中归纳推导出来。
    >费马定理：当n素数的时候，Φ(n)=n-1, 从而g^(n-1)=1 mod n 这就是费马定理。
	>离散对数：Zn*上的一个原根g, 则g^z mod n可以在z取正整数的时候取便0->n-1的所有值，即ordn(g)=|Zn*| ，<g>的序列就取得Zn*的所有值。如果a<-Zn*, 那么 g到a的过程：g^z=a 称z是模n下原根g到a的离散对数：indn,g(a)
	 >根据欧拉定理，猜测有个性质：ordn(g)= Φ(n)。。当不是原根时。
	>离散对数定理：容易证明。假设x≡y(mod Φ(n)),那么自然的有 x=kΦ(n) + y , 那么g^(x)=g^(kΦ(n) + y)=g^y*(g^(Φ(n)))^k, 而很明显，原根g的Φ(n)次方对n的模是1， 即欧拉定理，g^(Φ(n))≡1 mod n ,从而g^(Φ(n))^k≡(1 mod n)^k=1 mod n, g^(x)≡g^y(mod n), 反过来如果有这个结论，那么已经有g<-Zn*,x和y之间必然是周期的，且相差k个周期，周期是Φ(n)，所以x≡y(mod Φ(n))
	>x是以n为模1的非平凡平方根：即x^2≡1 mod n , x存在，则n是合数，因为如果n是奇数，那么根据x^2≡1 mod p^e的推导，可以得出x^2-1=kp^e, 即p^e|(x-1)(x+1), 且只能整除其中一个p^e|(x-1)或者p^e|(x+1)从而x-1=kp^e,即x=1+kp^e, 从而x≡1 mod p^e或者x≡-1 mod p^e是平凡的。
	 >用反复平方法求数的幂： 是否存在高效的方法计算 a^b mod n 模取幂。。我想到的递归思想，如果知道a mod n,这个可以通过直接计算得到，那么a^2 mod n= (a mod n)^2 mod n， 而a mod n<n所以计算量不大， 计算得出后， 一旦计算出a^2 mod n,则直接二分可以计算出a^4 mod n, 直到2^k<b<2^(k+1),然后调整小的步骤继续接近，因为一定可以b=∑bi*2^k表达，所以遍历bi,对不为0的二分遍历--或者寻找最近的找到的，然后返回相乘 mod n。
	  >反复平方法：是因为发现遍历bi过程中，可以利用二进制关系从0恢复出b来，而恢复过程中，假设遍历到左到右k位，此时的计算拼装出来的值为c,则计算a^c 可以为下一次遍历时计算做铺垫，即和下一次计算a^c'有关系，而拼装过程就是增加c的过程，且要么增加2倍--要么增加2倍加1，看bi是否为1,bi决定， 假设是2倍，同时假设上一次求模后的值是d, 则a^2k mod n= (a^k mod n)^2 mod n很直接，即d'=d^2 mod n, 如果是增加2倍+1，那么a^(ak+1)=a^2k * a mod n = (d^2 mod n * a mod n )mod n=(d'' * a mod n)mod n = d'' mod n * a mod n = (d'' * a) mod n
	>RSA公钥加密系统：听到而无法破译，且核对是xxx发送的没其他人能伪造。只有目标者才能破译，只有回复者才能构造数字签名。自己的私钥加密得到数字签名发送给对方，对方的公钥加密后得到密文发送给对方。
	 >数字签名：可以核对，不能伪造。为签署的信息提供身份证明。回复某人消息时，就在消息后面添加一串数字签名：S(M), 那么接收者可以确定这个回复消息是xx回复的，只需要用他的P()公钥来解开即可---如果内容和回复的内容M'一样就证明了来源--M'可以附加其他内容。
	 >公钥P和私钥S对消息M的转换：两把钥匙无论先后，只要依次对M迭代处理，就还原到M: M=P(S(M)) 或者M=S(P(M)) 这种变换类似有：离散傅立叶变换DFT及其反变换。
	  >要求：P公开，但是无法在有效时间内计算出S, 同时S和P是逆变换关系。
	 >可以证明：一个消息M来源于他A，并且发送给我B。只需要A发送消息：Sa(Pb(M)) 即可。那么B用Pa解开得到证明来源于A,然后用Sb()解开得到消息证明发送给我，即只有我能看到。
	 >可以证明：先证明一个消息发送给我，再证明这个消息来源于他, 只需对方发送：Pb(Sa(M)) 这种方式应该是更安全的，验证步骤多的，更现实的。
	 >RSA公私钥的选择过程和正确性证明：选择大素数p,q 令n=pq, 则Φ(n)=(p-1)*(q-1), 选择小奇数e, 求对模Φ(n)的逆元d, 即ed≡1 mod Φ(n) , 那么有结论：M^e mod n作为密文，用密文^d mod n可以解开：证明：(M^e mod n)^d=M^ed mod n = M^(kΦ(n)+1) mod n = (M mod n * (M^Φ(n) mod n)^k) mod n = M mod n 从而得到了消息M, 可见消息的位数一定要<n的位数。同理，反过来d加密e解密也是一样的。
	  >破解的难度，自然就是逆元d的计算：因为 ed≡1 mod (p-1)(q-1), 即 ed = k(p-1)(q-1) + 1 从而(ed-1)|((p-1)(q-1)) 说明必须要因式分解(p-1)(q-1)这个数，然后用因子来试探找出d
	 >密钥管理模式的RSA: 发送方发送的内容：(K(M),Pb(K)) ,然后接受方通过Sb()得到K,然后K(K(M))=M得到M ，其中K比较短，所以效率高。
	 >消息M的短指纹：h(M).回复方发送的内容：(M,Sa(h(M))) ，那么接收方可以先计算h(M) 然后Pa(Sa(h(M)))来验证两者是否相等，来证明确实是a的回复。
	 >证书：更方便地分发密钥。假设存在可信的权威T,每个人都知道他的公钥Pt, 则某人A可以从T获取一条签署消息St(x)即A的证书，声明A的公钥Pa是x:Pa=x,， 那么假如A要向B发送消息，A将他的证书附加到签名信息中，B收到了消息--用自己的私钥解开，第一，得到了签名信息，第二得到了证书，第三，就是消息内容，然后通过Pt(St(x))来得到一个公钥，而用这个公钥来加密消息内容得出的结果和签名信息比对，匹配了，说明消息内容就是这个证书的公钥作者发送的内容---------证书的目的就是要证明消息时证书的公钥的人发送的：：因为除了T其他人不能伪造任何证书--因为不知道St。从而证书的公钥人-->就是签名的生成人。
   >正则表达式的匹配算法：
   >计算几何相关问题：
   >一般计算问题-NP完全的：
   >NP完全的问题的近似解：
   >数学结论：
    >矩阵相乘的递归性质的推导(根源在于线性组合表达式具有递归特征)：C=A*B， 对于Cij的表达式表示如C11,如果将表达式截断为两半，分别用括号包括，那么第一个括号里的也可以看作是某个矩阵的一行乘以另一个矩阵的一列，第二个括号里的内容也是可以这样看， 那么C11就可以看作是两组两个矩阵的乘积的和的第一个位置的元素，其他元素也是，从展开表达式，和源C的对应位置上看，看每个C元素，从而发现C是A,B分别分割为4份后的8个子矩阵对应位置的乘积和---乘法法则同样满足矩阵的乘法；从而得出了一个重要结论：矩阵的乘法，对于矩阵的一个元素如果是还是一个矩阵，只要另一个因子矩阵同样元素规模，那么同样满足矩阵的乘法，可以直接相乘得出相应位置的结果。即矩阵的元素为矩阵时依然满足矩阵的乘法法则。从而可以递归地计算矩阵相乘的结果：直至2*2规模的矩阵。傅立叶变换也具有递归性。
    >同时发生事件的概率：如果A事件发生圈定的范围就是B事件发生的大前提/范围，那么同时发生就是一个条件概率：P(AB)=P(A)*P(B|A) 如果两个事件无关，那么P(B|A)=P(B)
    >布尔不等式：并集事件的概率和各个事件独立的概率和的关系。
    >指示器随机变量：分解为连续求和计算。
     >0-1随机变量表达的是个数的概念(只是这个次数、个数是分布的)：也是这样定义它的目的之一。因此可以用它来进行相加减来表达其他意思的个数。尤其期望计算中。
   >经典问题练习：
    >给定数组的随机排列：0-n先随机选后交换法。
    >一根绳子随机2刀，三段可以构成一个三角形的概率：三段的分布函数应该一样且均匀，所以可以转换为(0,n)之间随机三个数，则P(a+b-c>0)通过卷积计算得到分布，可知：P(a+b-c>0)=5/6 .分布是一个斜边二次内凹梯形分布。
	>矩阵相乘的动态规划问题：矩阵链乘法问题: 乘法的先后顺序不同则标量乘法量不同。
	 >如果假定m[i,j]表示Ai...Aj相乘矩阵的代价。中间有一次划分k,可以表示出m[i,j] = m[i,k] + m[k+1,j] + pi-1pkpj  从k的所有取值中选择一个使得代价最小的一个值，来作为m[i,j]的代价；显然，这个过程程序化，只需要3层循环，i,k,k 而考察其中的过程发现m[1,2]=m[1,1] + m[2,2]从矩阵角度可以看到规律，且m[1,3]也由m[1,1]m[1,2]m[1,3]m[2,3]m[3,3]等历史求出来的值决定；而m[k,k]=0所以对于m矩阵，计算结果会从对角线逐渐向右顶角移动，从而完整全部实现最终得到m[1,n]。
	>最长公共子序列：可不连续子串。我想到的方法：去除0,1,2,3,4,5,...n个元素，分为n轮。一轮去除一个元素，每轮去除一个元素后得到的多个可能结果，进行比较，看是否相同---即是否有交集；没有则，双层遍历本轮产生的两个结果集合，而递归调用本函数(去除-比较-再次递归函数removeOneAndCompare(arr1, arr2))。复杂度是n(n-1)...(n-i+1)而超过1轮，则每轮都有重复的，重复次数为Aii=i*(i-1)*1, 所以如果采用中间缓存表，结果一样，第二轮少2倍，第三轮少3倍，i轮少i倍，所以复杂度为n(n-1)...(n-i+1)/(i*(i-1)...1)=Cni<=Cn,n/2<n^(n/2), 而恰好产生的结果数也是Cni,因此概率=Cni/2^n, 因此期望个数为>2^n/n
	 >描述的问题最初规模的数据结构/表达式的目标结果的某个度量，并且将度量其中的参数n,m...替换为i,j..., 再替换为i-1, j-1, 之类，来寻找与相临近的递归关系。
	 >表达式按规模分解：分解为小规模的组合。最佳的那种分解就是目标。
	>最优二叉搜索树的构造：逼近方法：对权重key数组按权重从高到低排序，然后用红黑树方式进行构造。
	 >重要性质1：任何一个相同k集合构造出的子树，加到某一个树的某个节点下，所增加的搜索代价都是固定的n*(k1...ki), n为附着节点的高度。因此一个最优二叉搜索树的某个连续k集合子树必然也是k集合的最优二叉搜索树，如果不是则可以用这个最优搜索树替代---从而和它本身已经是最优二叉搜索树矛盾。
	 >重要性质2：根节点指定：k集合中，指定根节点kr分出左子树和右子树。两个子树都是最优子树。根节点的指定就是最优指定。
	 >重要性质3：构造最优二叉搜索树：e(i,j)，root(i,j)已知，定义函数Node buildTree(i,j) 里面只需要计算根节点位置、递归、父子节点指针连接即可。
	>欧几里得旅行商问题：从左到右如果双调巡游，那么从左到右，问题的最优子结构也是最优的，因此可以用动态规划。最优的证明：去除最左边的点，右边的所有点有一个最优构造，而左边的点连接进最优的最优构造，只有一种情形，从而增加的代价是确定的：双调巡游有，但是一般情况下则没有，因为此时右边的点的组合有很多种。左边的点接进来则总代价变化不同，所以不能确定--子结构的最优加一个节点后不一定是最优。
	>编辑距离问题：248页。DNA序列对齐问题
	>活动选择问题：性质1：活动按结束时间先后排序的序列中，最早结束的活动am一定在这个序列的最大兼容活动序列中，因为除去am之后的剩下序列中找出的最大兼容序列一定>=不是除去am而是其他更多的则剩下的序列，因为此序列只会更短；而剩下中找出的按定义一定和am兼容。因此只需要对排好序的序列遍历一遍，就可以找到最大兼容活动序列。
	>0-1背包问题：拿走平均价值最高的那些？非，剩下的磅重不一定价值高。动态规划算法，总价值为c[i,j] 则讨论i=j时的最大价值，j=i+1时的最大价值，那么就可以拓展到i<j任意的价值了。
	 >我的方案：按重量从大到小排序：从左到右递归式选择，直到选出重量<=W最接近时，看价值，选择出价值最大的。因为本问题看起来没有最优子结构-----但实际上，n个商品的最大价值方案确实和n-1个商品的最大价值方案差别可能大，但是如果加上了n-1个商品的最大价值方案中重量的限制刚好少wn, 那么就有了，当然，去掉的这一个，要从序列中每个都去掉试一遍--来找到最佳的去掉(就是目标元素)。
	>分数背包问题：如果分数是任意小数，那么只需要按qi/wi从高到低排序，含金量最高的排前面，再按重量大小为长度尺度紧紧放在坐标轴上，那么W处为切割点，左边的就是取的量。如果不能任意切割，而是一份一份的，那么就一份一份的去掉，剩下中取最优的，最终得出最佳的去除而得出各个货物的份数。
	>赫夫曼编码问题：性质1：不定长编码，4位前进，只会识别出一个字符，不断往后，唯一重现。
	 >赫夫曼编码树：不定长编码的得出：关键字-频率得出且排序好，然后从低位开始两两构造三叉节点并加入排序。不定长编码的每个编码都是树的叶子节点，所以一个编码不会由两个编码顺序拼凑出来，---否则就是中间节点--从而矛盾。保证了正确性即可唯一恢复性。又因为频率高的叶子节点高度低，从而整体编码量少。
	>单处理器上带截止时间和惩罚的单位时间 任务 调度问题：将单位时间任务按照截止时间从小到大排序，出现Nn()>n时，表明需要延迟Nn()-n个任务，则选择前面这么多个惩罚最低的任务放到最后面，然后继续往后，直到遍历完所有任务。 
	>缓存管理问题：缓存优先级：元素的磁盘查询代价*元素的在线查询频率。
	>套利交易问题：可以深度优先遍历，找到回向边，然后开始找所包围的所有环，看乘积总值是否大于1,是则存在套利交易链。可以找出全部。
	 
	 
	
	
	