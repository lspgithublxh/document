---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	>程序的执行要想象为人在执行；多线程则是交接执行权给其他人执行；
	>抽象编程与具体填充：假设编程和实现假设。面向对象中一个对象属性就假设已经填充好了，一个接口的实例就假设已经在容器中有了。代码编码层面和虚拟机执行层面，都规定/定义/设计为 将 接口和实例分开，系统启动时/甚至具体接口调用时才去容器里找接口的实例(启动时 一方面建立实例容器，另一方面 对接口寻找匹配的实例和链接到实例---进行连接和关联)。资源填充 和 接口调用(抽象调用)，资源--接口的映射对。领域抽象，资源抽象，功能抽象。
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点

--混乱的答案，宁可不说；只回答真正掌握的；。没有逻辑，因为没有进行抽象；没有找到所在的流程环节、模型中的位置
--系统、中间件的介绍，不是一来就是组成结构；这层次已经太细了太具体了太里面了，必须要从最简洁最抽象最上层开始；最表面最近开始；务实，不僵硬，不突然，要自然，不要忽视和没注意没意识和跳过很多步；而是从问题出发、从困难出发、从疑惑出发
	>从问题出发：先明确问题；先明确表达出问题、疑惑点、黑箱、痛点、矛盾点、难点，表述的范围可以很大(完全不知道是什么怎么办)后面逐渐具体问；无论多少问题，先明确下来；尤其要全部且完整的描述下来；
		>问题的提出：先明确背景，自然衍生、过渡、转折、演化，逻辑关系上，什么时候什么事情什么人，事情什么阶段遇到的什么问题、阻碍、阻挠、缺陷、瓶颈、不够简洁、不够简便、不够方便、不够优雅、离目标远、离理想情况远、离期望/极限效果远；不够抽象的地方；把它们充分描述完整叙述结构式组织起来。
			>问题抽象：归结为一类问题；去除具体和细节而明确问题模型；
		>问题产生原因：过程；条件；	
		>问题导致的恶果：阻碍、损失；
		>理想的方案特征/效果/必做必不做的动作&事情/应当改变的环节: 
			>这种特征/必做必不做的前提、必要条件、必然要求、必然说明、必然指示、必然可以确定的更多的事情/结论：
				>一系列结论、约束得到之后(结合条件/问题/情况本身)逐渐可以清晰看到/归结出该具体问题符合的/满足的通用/一般的/一类的问题模型/函数模型/服务模型/IO模型/请求响应模型的轮廓：若干个具体模型
					>方案的装饰/补充: 补充可靠性/稳定性/高性能(从而高可用/高并发)：因为暂时只是一个裸机、容易受到伤害、有功能但没有抵抗力(仅为打火机的火而不是熊熊大火)
							>方案的用法规则：在请求缓存前使用
		>能将具体方案进行分类的维度/情况/模型/环节/流程/抽象表述 的确定：然后使用 抽象-具体 的方法来得到新方案；					
		>普通的方案：已有的方案；方案的抽象，方案的取值选择评价；方案的表象缺陷、劣势；。。模型、数据结构和算法、协议约定分担 维度 上考虑；
	>任何事情/事物都有顺序/逻辑：且几乎都是几种常见逻辑中的一种: 时间先后、空间远近、因果环扣、程度递增
--大总结：含义包括：重新 深刻理解：
--通用的建模架构能力+Flink深度强化学习的推荐系统。。。。而不是做简单的业务逻辑开发；用深度强化学习来做应用/解决实际问题(用户的识别问题和抉择问题)；用抽象建模架构出逻辑完整的方案(工具方案/服务方案)；
--一体两翼的发展模型：底座：增强操作系统、网络、搜索、推荐能力； 两翼：普通项目：则架构建模；特殊项目：则深度强化学习；。。四大基础+两大实践(应用/使用)。。基础：是为了解决自己的问题；实践：为了解决别人的问题(用户的问题/大众)；
--一次彻底弄懂，而不是 反复低温加热。看架构书和源码书，不看使用书。
--对话中胜利：一个是提问，二个是不断的输出-高能输出。
--牢固的观念: 系统都是被使用的。
--任何一个系统、产品、服务、方案、东西、事情，它要解决的核心问题是什么？理想的形态效果影响应该是什么？市面上对应的哪些产品达到了或者没达到或者很难达到？没达到是为什么是否有我们的机会？是否还有我们可以满足的缺口。找市场缺口。
--从缝纫机原理看方案所属的分类和方案内的环节。抽象出分类和环节。
--把自己当做cpu,调/使用各个服务/接口/类/系统。
--全新学习掌握方法：先定问题体系，先提问，定逻辑路径，后开始找答案--推导和思考和查阅资料。
	>旧方法：还是盲目阅读，还是从头到尾的阅读一遍的阅读。
--所有系统和方案的理解/研究/制定的出发点：都是 出发顶点/问题顶点/概念顶点，找到了顶点才能出发，出发要从顶点出发，才顺畅，没有后顾之忧
--计算机解决问题的方法：采集，记录，计算，展示，通知，跟踪 数据/信息。

--商业经营才能：(全新的解决问题的方法：提出问题)
--什么问题 是可以用互联网来解决的？ 只要满足什么特征，该问题就可以用互联网方式来解决? 该问题的本质是什么问题(如是信息传递问题？)该问题抽象一般化后是什么问题(资管、记录、通知、计算、采集识别调动、代理/中介/数据中心/信息中心/信息模拟线下过程中心、信息传递)(信息展示/发布/搜索/推荐 平台；信息池；信息可以是映射描述的现实事物的信息(如商品/价值物/人)，也可以是纯虚拟信息(游戏/知识/新闻/视频))
	>能用信息发布展示/活动追踪-信息记录/通知/协作/推荐/搜索 解决的问题：信息可以是 编辑的信息/映射的信息/等价现实的信息/等价现实任何事任何物的信息。内涵BAT的老业务(电商/聊天/游戏/信息流/搜索)。
	>能用数据驱动决策抉择与调度分配/识别与推理/观测采集与调动机电-生物 而解决的问题：如alphazero/图像识别/语音识别/视频识别/云计算/智慧城市/自动驾驶。内涵BAT新业务(云计算/视频语音识别-下棋打游戏智慧体/智能音箱/自动驾驶)
--码农之家和脚本之家、异步社区。从 面向对象-->模式-->架构：由小到大。
--给其他非软件行业的工程师/人员开发软件。三高三可(高可用高并发高性能,可扩展性可维护性可重用性)。
--最佳：一边看书，一边独立思考；(比起纯看书和纯思考都好)。因为 看书 要有沉淀，积累，独立思考 结论，总结。而不是流经书，翻翻而已，左进右出。
--说话：社交场合，最重要的是：要有自己的认知、决策和行动；对形势的判断和分析和预测。而不是被别人牵着走，或者置身事外。
--什么是最重要的? 就是你想做出一个什么东西...  这是最有价值的事情,是最重要的目标(比起学位和金钱和看多少书都重要);
	>不讲在公司的项目: 只讲自己 业余时间 做出的东西; ..  和 理解的东西... 总结起来 就是 四个方面: 架构 + 源码 + 算法 + 产品/作品
--不必指责和愤怒: 只需 战胜 和提防.
--莫忘理性决策：详细的明确和计算，一点也不能含糊。看看这次搬家时机的决策失误和搬家房间选择的失误，造成了金钱和时间上的巨大浪费。又比如以前自大没有投资股市---导致损失很大！！	拒绝感情用事和感动别人。
	>不能武断：不能一厢情愿。不能只见树木不见森林。
--兴趣不仅决定能力，而且决定性格，比经历更加影响性格；总结和思考 是兴趣带来的根本也是兴趣导致的根本活动；而性格能很大程度上影响命运---作。韩信(仰仗自己聪明而希望别人只记得我的好不记得我的坏)、赵括(自己负责精彩，麻烦交给别人--希望别人帮自己解决；只知顶层逻辑不知道低层逻辑)、李广(总觉得别人对自己不好，发现不了自己的错，不按程序办事，爱自己来，当别人按程序来--总觉得别人是让自己受气，受不了别人的指责)	
--在大部分有钱人和机构都将资本+利润存入股市的时候：说明股市是会升值的，股市就是最大的公司。多余的所有钱+利润 只有在股市才能分享。
	>既要有信心，也要有担忧： 激情和忧虑 都有 ，才是 理性的人。而不是两者都没有的麻木不仁、冷血和装。
	>做人不要尖酸刻薄，说话要说别人的好，坏处知道 但是不要说出来。有的人不喜欢被戴高帽，或者认为是反讽，这只是 好 没有说到点上而已。
	>面对别人指出的问题: 改就完了,且深刻反思和各种改进, 大量的收获和扩展.更强!!!错误的反思总结得到的东西让人更强!!!
	>已经是青年人了：要敢于争取
--理论观点/方法缺乏层次系统的组织，还是在等别人分配赚钱任务。概念、观点 还是片段、不连续的。
	>基本认知方式：提炼、总结、简化、抽象、封装 。
	>问题为 元素 进行组织：这次不以概念为元素，来更方便于实际使用、进行设计训练---工作也当作是设计训练。
	>填充所有的逻辑漏洞：
	>分层问题森林\分层问题 群: 一个n层的问题,其顶元素 只是 另一个n层问题的一个元素. 因此 k个 分层问题  构成 了 一个最顶层分层问题 , 整体 是一个 问题森林.
	>每一种策略/设计/具体化： 都必须明确它到底是为了解决什么问题。
	>范畴不明确：就会 陷入 “还有什么” 的困惑和迷途。范畴的向下具体划分和向上抽象统一更大范围。
--领域、问题、逻辑。(路径/方案/思路)(条件/目标/路径)	范畴。顶级思路/顶层思路。顶层领域，顶层问题。范畴与逻辑。范畴关系(同一范畴内、不同范畴内)、比较关系、规则关系、联动关系。
	>不能只以概念入手，也要从问题、思路入手。
	>谈话永远不能泛泛而谈：回答而已，别总想着怎么回答会好-显得聪明有创意有见解之类。必须要有目标，要预见和引导 话题走势走向，进而从当前条件 寻找 路径/思路。
	>开发时：反思总结 而 扭转观念，不要一来就想着实现代码，而应该想着本层逻辑、本层事务、具体交给下层实现-下层再进行拆解-完成它要做的那部分工作-塔式调用/直到具体的专门的一个个的实现//这个也是逆封装过程，类似塑造过程。
		>链式调用：默认实现Filter 放在 最后，用户提供的放在前面；从而用户提供了实现如果想提前返回则可以直接先返回不走默认。
		>插件的发现/用户回调类的注入：往往都是自动配置类bean  注入了外部的 beanFactory，而自动配置bean里就有本框架的核心类，而获取了bf,则各种规范的实现bean就都可以获取了，从而用在框架各个位置。
>举动-痛点：
	>解法/解决方案：
		>魔方还原七步法：每个公式本质---只换一个块的位置 而其他块都保持原位。
			>1.顶面十字：顶层棱块还原。R'UF'U' 直到颜色也要对齐侧面4个。
			>2.顶面还原：顶层角块还原。R'D'RD  每个棱块都这么操作1*3*5次；因为按照这个公式 ，一轮中只会改变一个棱块的位置，且棱块的位置最后又还原了；所以整个过程后棱块位置没有改变--但是角块位置改变了。
				>技巧：三色相同的角块先 转到应该位置的下方--底层可以顺逆自由转动，再转动公式；此公式的本质 就是 让 这个位置的角块不断变换方位。
			>3.中间层还原：还原中间层棱块。将正确块转到右上方棱块位置，然后动用 U'F'UFURU'R'来将右上方的转动到中间层棱块上。如果正确块 就在 中间层棱块上但错位了则要用两遍这个公式---先换出来再换进去。
				>如果是 左上方棱块 换到 面前中间层棱块，则公式为：URU'R'U'F'UF
			>4.顶面十字：
		>应用架构演进：目标明确-->背景痛点明确-->问题树呈现-->世界观明确(实体/过程/数据怎么看待怎么描述(一套新概念/新名词/新抽象/新范畴集合)，从而(用这些概念/范畴)可以怎么样来达到目标--或者目标等效为归结为简化为，从而形成 顶层思路)-->完成分层思路树呈现(思路拆分，每个环节怎么实现(用什么策略，调什么理想接口/抽象接口/假象接口；进一步，理想接口/假想接口 又用什么策略调什么下层接口来实现))--->领域明确 代码呈现(封装过程--最底层最具体的单一的功能是什么/原子业务是什么有什么--进行强壮封装/兼容问题封装/兼容异常情况封装使得该功能能适应更恶劣的各种突发意外的险恶情况，综合封装--更接近于用户需要的业务功能/更接近于用户使用习惯使用环境的形态的功能接口；塑造过程--领域关联网/属性封装为领域/自顶向下层层特征加持增强-直到实现特征的类--产生若干个具体类:方法实现时DIP调用注入的特征接口依赖--实现也抽象描述(塔式调用/隐藏实现式调用/不依赖实现式调用)--使得从顶层特征类(扩展接口)向下找可能找到不同的具体实现类)
			>RPC系统：目标：简洁高效通用的进程间通信(远程服务调用)
				>背景/需求/痛点/规格指标/结论-路径-思路方向/问题确认/问题细化/问题归结/问题模型/问题树呈现：
					>预备概念/概念设计/名词定义/观念宇宙/领域概念/世界认知/独特的理解模型/独特的塑造模型/独特的创新创意的描述模型/某方案某系统的世界观模型/精巧的概念结构/精巧的特征化概念/带约束的概念：
						>服务认知/服务约定/服务设计/服务目标/服务约束：
							>服务可复用：
							>服务共享一个标准契约：
							>服务是松耦合的：
							>服务是底层逻辑的封装：
							>服务是可组合、可编排的：
							>服务是自治的：
							>服务是无状态的：
							>服务是可被自动发现的：
					>痛点：远程调用比较麻烦，而且主要是技术问题，业务只是作为回调程序。
						>这些技术问题包括：按层次表达：从顶层到底层；按流程、按数据流过程环节表达：
							>就像本地调用一样调用远程服务：只需要 告诉 此系统 要调哪个服务、哪个接口、什么入参。
								>服务方服务呈现/暴露问题：暴露方式、查看方式(买东西一样的东西的说明书/服务的说明书,怎么用/什么效果)
								>服务方所在节点发现问题：注册中心心跳机制/租约机制、服务端注册、消费者被推送服务列表
									>注册中心机制：本身又带来新的技术问题
										>注册中心心跳机制： 
										>注册中心挂了：自动切换到另一台，即注册中心主备集群/对等集群。
										>注册中心全挂了：客户端需要缓存：尽管过期了。
								>用户调用接口的问题：必然需要提供实现类--而实现类必然是统一的走一个处理过程才最好--所以是提供动态代理类实现， 
								>向服务方发送传输调用信息问题：数据格式、通信方式、传输协议、序列化方式、熔断、降级
									>数据格式：
										>流式传输：
											>方案1：和服务端配套的输入输出包装流：ObjectOutputStream/ObjectInputStream
									>调用失败：
										>处理策略：
											>Failover: 失败 切换 其他节点。对于读和幂等接口。
											>Failback: 失败 重试 同一个节点。定时重发，对于消息通知接口。
											>Failfast: 失败 抛出错误。只发起一次调用，失败了就向上抛出；用于非幂等的写接口等。
									>序列化方式： 
										>二进制序列化协议：protocol buffer
										>文本类序列化协议：JSON
									>通信框架：	
								>服务方理解调用方的调用信息问题：映射到内部服务、鉴权、限流、...
								>服务方调用内部服务执行服务问题：
								>服务方将服务执行结果回复调用方的问题：
								>调用方接收服务方调用结果问题：结果理解、超时处理、异常处理、熔断降级
								>调用方对外展现结果的问题：数据格式。
								>服务方整体故障问题：单点故障--要求无状态设计
								>服务调用链路不明确、每次调用的耗时成败等特征的度量统计：属于验证论证证明测试方面，即服务质量 计算 所需要的信息的采集、汇总、计算、报表、预警。
									>服务监控：	
								>服务上线下线升级要关注的问题：属于 服务生命周期管理，	上线审批--上线随便造成资源分配问题；下线通知--调用方还在使用的问题；服务灰度发布--
								>服务运行中爆出问题的如何快速解决的问题：
									>思路-采集当时特征数据信息--分布式日志采集:
									>寻找这些特征数据/避免逐个机器上去看--海量日志在线检索: 
									>数据传给的服务内部如何实现的--分布式链路追踪/调用链可视化展示：
									>有问题的服务当前的情况--运行日志信息：
								--归结到服务治理的问题：服务治理的目标。下面是服务治理的层层递进，每层都有治理工具、治理成果。
									>让 服务方 对服务的上下线操作  对 其他服务的运行/调用方的使用 影响最小：设计一个 服务上线到下线 不得不走的流程：上线审批、下线通知、灰度发布。服务生命周期的规范管理，甚至是最基本的。
									>让调用方 用 到 更健壮稳定高可用的服务：服务限流、鉴权、服务路由、超时控制、自动扩展(线性扩展)。
									>让调用方 实时可以知道  当前调用的服务的质量情况并质量变化时预警通知：服务监控统计预警。
									>让调用方 在发现调用异常时 快速定位到异常的服务：分布式链路追踪-服务调用链、数据采集、日志搜索、虚拟机状态
				>顶层思路-完整思路-共性问题的回答/特有问题的回答：1.老思路：
					>概念设计/名词定义/所有约束明确：共性问题解决、共性设计	；特性问题解决，特性设计。
					>职责划分-事务分层-契和塔式调用、任务拆解、连带功能、强壮建设：
					>封装过程：
						>所有可能出现的风险、异常、问题、不足、缺陷和瓶颈：全部考虑到，并识别处理、提供扩展接口规范/插件规范(从而回调插件/扩展程序) 而封装起来- 对外不表现出这些问题/困境/弱势/不足缺点。
							>注册中心挂：
							>服务方挂：客户端容服务方灾
							>注册中心推送信息到消费者端网络 中断：
							>调用量突发增长：
					>塑造过程：
						>技术选型：
			>Hession: spring结合，servlet方式提供服务。
			>gRPC: 移动端使用；HTTP/2。
			>分布式服务框架：
		>通信框架：专题 
			>目标选择：支持 高性能、低延迟、支持大并发连接的 CS框架。
			>Socket层：Netty---对NIO的层层封装。