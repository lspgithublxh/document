---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	>程序的执行要想象为人在执行；多线程则是交接执行权给其他人执行；
	>抽象编程与具体填充：假设编程和实现假设。面向对象中一个对象属性就假设已经填充好了，一个接口的实例就假设已经在容器中有了。代码编码层面和虚拟机执行层面，都规定/定义/设计为 将 接口和实例分开，系统启动时/甚至具体接口调用时才去容器里找接口的实例(启动时 一方面建立实例容器，另一方面 对接口寻找匹配的实例和链接到实例---进行连接和关联)。资源填充 和 接口调用(抽象调用)，资源--接口的映射对。领域抽象，资源抽象，功能抽象。
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点

--混乱的答案，宁可不说；只回答真正掌握的；。没有逻辑，因为没有进行抽象；没有找到所在的流程环节、模型中的位置
--系统、中间件的介绍，不是一来就是组成结构；这层次已经太细了太具体了太里面了，必须要从最简洁最抽象最上层开始；最表面最近开始；务实，不僵硬，不突然，要自然，不要忽视和没注意没意识和跳过很多步；而是从问题出发、从困难出发、从疑惑出发
	>从问题出发：先明确问题；先明确表达出问题、疑惑点、黑箱、痛点、矛盾点、难点，表述的范围可以很大(完全不知道是什么怎么办)后面逐渐具体问；无论多少问题，先明确下来；尤其要全部且完整的描述下来；
		>问题的提出：先明确背景，自然衍生、过渡、转折、演化，逻辑关系上，什么时候什么事情什么人，事情什么阶段遇到的什么问题、阻碍、阻挠、缺陷、瓶颈、不够简洁、不够简便、不够方便、不够优雅、离目标远、离理想情况远、离期望/极限效果远；不够抽象的地方；把它们充分描述完整叙述结构式组织起来。
			>问题抽象：归结为一类问题；去除具体和细节而明确问题模型；
		>问题产生原因：过程；条件；	
		>问题导致的恶果：阻碍、损失；
		>理想的方案特征/效果/必做必不做的动作&事情/应当改变的环节: 
			>这种特征/必做必不做的前提、必要条件、必然要求、必然说明、必然指示、必然可以确定的更多的事情/结论：
				>一系列结论、约束得到之后(结合条件/问题/情况本身)逐渐可以清晰看到/归结出该具体问题符合的/满足的通用/一般的/一类的问题模型/函数模型/服务模型/IO模型/请求响应模型的轮廓：若干个具体模型
					>方案的装饰/补充: 补充可靠性/稳定性/高性能(从而高可用/高并发)：因为暂时只是一个裸机、容易受到伤害、有功能但没有抵抗力(仅为打火机的火而不是熊熊大火)
							>方案的用法规则：在请求缓存前使用
		>能将具体方案进行分类的维度/情况/模型/环节/流程/抽象表述 的确定：然后使用 抽象-具体 的方法来得到新方案；					
		>普通的方案：已有的方案；方案的抽象，方案的取值选择评价；方案的表象缺陷、劣势；。。模型、数据结构和算法、协议约定分担 维度 上考虑；
	>任何事情/事物都有顺序/逻辑：且几乎都是几种常见逻辑中的一种: 时间先后、空间远近、因果环扣、程度递增
--大总结：含义包括：重新 深刻理解：
--通用的建模架构能力+Flink深度强化学习的推荐系统。。。。而不是做简单的业务逻辑开发；用深度强化学习来做应用/解决实际问题(用户的识别问题和抉择问题)；用抽象建模架构出逻辑完整的方案(工具方案/服务方案)；
--一体两翼的发展模型：底座：增强操作系统、网络、搜索、推荐能力； 两翼：普通项目：则架构建模；特殊项目：则深度强化学习；。。四大基础+两大实践(应用/使用)。。基础：是为了解决自己的问题；实践：为了解决别人的问题(用户的问题/大众)；
--一次彻底弄懂，而不是 反复低温加热。看架构书和源码书，不看使用书。
--对话中胜利：一个是提问，二个是不断的输出-高能输出。
--牢固的观念: 系统都是被使用的。
--任何一个系统、产品、服务、方案、东西、事情，它要解决的核心问题是什么？理想的形态效果影响应该是什么？市面上对应的哪些产品达到了或者没达到或者很难达到？没达到是为什么是否有我们的机会？是否还有我们可以满足的缺口。找市场缺口。
--从缝纫机原理看方案所属的分类和方案内的环节。抽象出分类和环节。
--把自己当做cpu,调/使用各个服务/接口/类/系统。
--全新学习掌握方法：先定问题体系，先提问，定逻辑路径，后开始找答案--推导和思考和查阅资料。
	>旧方法：还是盲目阅读，还是从头到尾的阅读一遍的阅读。
--所有系统和方案的理解/研究/制定的出发点：都是 出发顶点/问题顶点/概念顶点，找到了顶点才能出发，出发要从顶点出发，才顺畅，没有后顾之忧
--计算机解决问题的方法：采集，记录，计算，展示，通知，跟踪 数据/信息。

--商业经营才能：(全新的解决问题的方法：提出问题)
--什么问题 是可以用互联网来解决的？ 只要满足什么特征，该问题就可以用互联网方式来解决? 该问题的本质是什么问题(如是信息传递问题？)该问题抽象一般化后是什么问题(资管、记录、通知、计算、采集识别调动、代理/中介/数据中心/信息中心/信息模拟线下过程中心、信息传递)(信息展示/发布/搜索/推荐 平台；信息池；信息可以是映射描述的现实事物的信息(如商品/价值物/人)，也可以是纯虚拟信息(游戏/知识/新闻/视频))
	>能用信息发布展示/活动追踪-信息记录/通知/协作/推荐/搜索 解决的问题：信息可以是 编辑的信息/映射的信息/等价现实的信息/等价现实任何事任何物的信息。内涵BAT的老业务(电商/聊天/游戏/信息流/搜索)。
	>能用数据驱动决策抉择与调度分配/识别与推理/观测采集与调动机电-生物 而解决的问题：如alphazero/图像识别/语音识别/视频识别/云计算/智慧城市/自动驾驶。内涵BAT新业务(云计算/视频语音识别-下棋打游戏智慧体/智能音箱/自动驾驶)
--码农之家和脚本之家、异步社区。从 面向对象-->模式-->架构：由小到大。
--给其他非软件行业的工程师/人员开发软件。三高三可(高可用高并发高性能,可扩展性可维护性可重用性)。
--最佳：一边看书，一边独立思考；(比起纯看书和纯思考都好)。因为 看书 要有沉淀，积累，独立思考 结论，总结。而不是流经书，翻翻而已，左进右出。
--说话：社交场合，最重要的是：要有自己的认知、决策和行动；对形势的判断和分析和预测。而不是被别人牵着走，或者置身事外。
--什么是最重要的? 就是你想做出一个什么东西...  这是最有价值的事情,是最重要的目标(比起学位和金钱和看多少书都重要);
	>不讲在公司的项目: 只讲自己 业余时间 做出的东西; ..  和 理解的东西... 总结起来 就是 四个方面: 架构 + 源码 + 算法 + 产品/作品
--不必指责和愤怒: 只需 战胜 和提防.
--莫忘理性决策：详细的明确和计算，一点也不能含糊。看看这次搬家时机的决策失误和搬家房间选择的失误，造成了金钱和时间上的巨大浪费。又比如以前自大没有投资股市---导致损失很大！！	拒绝感情用事和感动别人。
	>不能武断：不能一厢情愿。不能只见树木不见森林。
--兴趣不仅决定能力，而且决定性格，比经历更加影响性格；总结和思考 是兴趣带来的根本也是兴趣导致的根本活动；而性格能很大程度上影响命运---作。韩信(仰仗自己聪明而希望别人只记得我的好不记得我的坏)、赵括(自己负责精彩，麻烦交给别人--希望别人帮自己解决；只知顶层逻辑不知道低层逻辑)、李广(总觉得别人对自己不好，发现不了自己的错，不按程序办事，爱自己来，当别人按程序来--总觉得别人是让自己受气，受不了别人的指责)	
--在大部分有钱人和机构都将资本+利润存入股市的时候：说明股市是会升值的，股市就是最大的公司。多余的所有钱+利润 只有在股市才能分享。
	>既要有信心，也要有担忧： 激情和忧虑 都有 ，才是 理性的人。而不是两者都没有的麻木不仁、冷血和装。
	>做人不要尖酸刻薄，说话要说别人的好，坏处知道 但是不要说出来。有的人不喜欢被戴高帽，或者认为是反讽，这只是 好 没有说到点上而已。
	>面对别人指出的问题: 改就完了,且深刻反思和各种改进, 大量的收获和扩展.更强!!!错误的反思总结得到的东西让人更强!!!
	>已经是青年人了：要敢于争取
	>不要轻易拒绝做 看不起的事情、还早的事情、不重视的事情、觉得自己不需要的事情-觉得世俗/自大的事情(世俗也要同流合污)：买车摇号、社保缴纳、公积金缴纳、找女朋友、找好的房子、考在职硕、炒股-投资。多少件事情--明明顺手就可以做，却没有做，一直拖，导致损失惨重！！
		>每一件瞧不起、不重视、还早的事情：相反，都要早点做！！
		>机会错过 难再有：往往影响是决定性的。没把握机会 就是 决策性失误！
		>其他事情：私活-阿里云-本地开发-换电脑。
	>想到就要做，错过不再有：这是最重要的名言！！只有这样才能发挥才智 并且 赢得 胜利！！！	最重要的就是时机、机会，把握机会把握时机。
		>时机、战机 转瞬即逝：稍纵即逝。错过就是一辈子，错过就是奉上身家性命。犹豫不决和瞧不上和不需要而暂时不做延后做 都是错失良机、贻误军机。
			>说小了是 酸，说理性点 就是 后悔遗憾 承受损失。
	>商业机会：大部分来自于持续观察大家的生活---什么社会事件政策会怎样的影响人们的生活/会让人们的生活发生哪些改变； 人们生活中遇到了什么瓶颈/矛盾/困难/问题/需求/不足/遗憾/不开心的事情。		
--理论观点/方法缺乏层次系统的组织，还是在等别人分配赚钱任务。概念、观点 还是片段、不连续的。
	>基本认知方式：提炼、总结、简化、抽象、封装 。
	>问题为 元素 进行组织：这次不以概念为元素，来更方便于实际使用、进行设计训练---工作也当作是设计训练。
	>填充所有的逻辑漏洞：
	>分层问题森林\分层问题 群: 一个n层的问题,其顶元素 只是 另一个n层问题的一个元素. 因此 k个 分层问题  构成 了 一个最顶层分层问题 , 整体 是一个 问题森林.
	>每一种策略/设计/具体化： 都必须明确它到底是为了解决什么问题。
	>范畴不明确：就会 陷入 “还有什么” 的困惑和迷途。范畴的向下具体划分和向上抽象统一更大范围。
	>讲一个东西的内容时：可以看出是否结构化思考，是否很明确范畴，范畴化思考，不断的抽象上升又具体下降--树上遍历。因为问题，产生目标，想到思路，立刻执行。
--领域、问题、逻辑。(路径/方案/思路)(条件/目标/路径)	范畴。顶级思路/顶层思路。顶层领域，顶层问题。范畴与逻辑。范畴关系(同一范畴内、不同范畴内)、比较关系、规则关系、联动关系。
	>不能只以概念入手，也要从问题、思路入手。
	>谈话永远不能泛泛而谈：回答而已，别总想着怎么回答会好-显得聪明有创意有见解之类。必须要有目标，要预见和引导 话题走势走向，进而从当前条件 寻找 路径/思路。
	>开发时：反思总结 而 扭转观念，不要一来就想着实现代码，而应该想着本层逻辑、本层事务、具体交给下层实现-下层再进行拆解-完成它要做的那部分工作-塔式调用/直到具体的专门的一个个的实现//这个也是逆封装过程，类似塑造过程。
		>链式调用：默认实现Filter 放在 最后，用户提供的放在前面；从而用户提供了实现如果想提前返回则可以直接先返回不走默认。
		>插件的发现/用户回调类的注入：往往都是自动配置类bean  注入了外部的 beanFactory，而自动配置bean里就有本框架的核心类，而获取了bf,则各种规范的实现bean就都可以获取了，从而用在框架各个位置。
>举动-痛点：
	>解法/解决方案：
		>魔方还原七步法：每个公式本质---只换一个块的位置 而其他块都保持原位。
			>1.顶面十字：顶层棱块还原。R'UF'U' 直到颜色也要对齐侧面4个。
			>2.顶面还原：顶层角块还原。R'D'RD  每个棱块都这么操作1*3*5次；因为按照这个公式 ，一轮中只会改变一个棱块的位置，且棱块的位置最后又还原了；所以整个过程后棱块位置没有改变--但是角块位置改变了。
				>技巧：三色相同的角块先 转到应该位置的下方--底层可以顺逆自由转动，再转动公式；此公式的本质 就是 让 这个位置的角块不断变换方位。
			>3.中间层还原：还原中间层棱块。将正确块转到右上方棱块位置，然后动用 U'F'UFURU'R'来将右上方的转动到中间层棱块上。如果正确块 就在 中间层棱块上但错位了则要用两遍这个公式---先换出来再换进去。
				>如果是 左上方棱块 换到 面前中间层棱块，则公式为：URU'R'U'F'UF
				>两种算法特征：都是先 让 条件块 远离目标块，第二步 为 让目标块平行条件块，后面则是回退。盯着条件块的变化 ， 和 相对不变块的变化。
					>条件块回退后，继续同方向旋转，然后让目标块 和 条件块 垂直，接着是 回退。
					--四字统一规律：远离、平行；回退；惯性、垂直；回退； 
			>4.顶面十字：左上方棱块 走了一个正方体切角的三角形--下上回位，然后三次回退；FRU R'U'F'
			>5.顶面：观察2块。右上棱块+面前角块：  先：右上：来回，后角块：上去来，转两圈到平行对侧，再R回。R'U'RU'R'U2R
			>6.：相邻角块两者交换位置的想象。
			>7.: 相邻棱块两者交换位置的想象。
		>应用架构演进：目标明确-->背景痛点明确-->问题树呈现-->世界观明确(实体/过程/数据怎么看待怎么描述(一套新概念/新名词/新抽象/新范畴集合)，从而(用这些概念/范畴)可以怎么样来达到目标--或者目标等效为归结为简化为，从而形成 顶层思路)-->完成分层思路树呈现(思路拆分，每个环节怎么实现(用什么策略，调什么理想接口/抽象接口/假象接口；进一步，理想接口/假想接口 又用什么策略调什么下层接口来实现))--->领域明确 代码呈现(封装过程--最底层最具体的单一的功能是什么/原子业务是什么有什么--进行强壮封装/兼容问题封装/兼容异常情况封装使得该功能能适应更恶劣的各种突发意外的险恶情况，综合封装--更接近于用户需要的业务功能/更接近于用户使用习惯使用环境的形态的功能接口；塑造过程--领域关联网/属性封装为领域/自顶向下层层特征加持增强-直到实现特征的类--产生若干个具体类:方法实现时DIP调用注入的特征接口依赖--实现也抽象描述(塔式调用/隐藏实现式调用/不依赖实现式调用)--使得从顶层特征类(扩展接口)向下找可能找到不同的具体实现类)
			>RPC系统：目标：简洁高效通用的进程间通信(远程服务调用)
				>背景/需求/痛点/规格指标/结论-路径-思路方向/问题确认/问题细化/问题归结/问题模型/问题树呈现：
					>预备概念/概念设计/名词定义/观念宇宙/领域概念/世界认知/独特的理解模型/独特的塑造模型/独特的创新创意的描述模型/某方案某系统的世界观模型/精巧的概念结构/精巧的特征化概念/带约束的概念：
						>服务认知/服务约定/服务设计/服务目标/服务约束：
							>服务可复用：
							>服务共享一个标准契约：
							>服务是松耦合的：
							>服务是底层逻辑的封装：
							>服务是可组合、可编排的：
							>服务是自治的：
							>服务是无状态的：
							>服务是可被自动发现的：
					>痛点：远程调用比较麻烦，而且主要是技术问题，业务只是作为回调程序。
						>这些技术问题包括：按层次表达：从顶层到底层；按流程、按数据流过程环节表达：
							>就像本地调用一样调用远程服务：只需要 告诉 此系统 要调哪个服务、哪个接口、什么入参。
								>服务方服务呈现/暴露问题：暴露方式、查看方式(买东西一样的东西的说明书/服务的说明书,怎么用/什么效果)
								>服务方所在节点发现问题：注册中心心跳机制/租约机制、服务端注册、消费者被推送服务列表
									>注册中心机制：本身又带来新的技术问题
										>注册中心心跳机制： 会话机制+租约机制(zk客户端会定期发送session_下次失效时间到服务端 来维持长连接，一旦session_timeout没有收到心跳信息则认为session失效--删除与客户端相关的临时节点和watcher;而 客户端 自己因为网络断连 而失去连接后重新连接则选择另一个zk节点连接)
										>注册中心挂了：自动切换到另一台，即注册中心主备集群/对等集群。
										>注册中心全挂了：客户端需要缓存：尽管过期了。
										>注册中心高可用机制：
										>注册中心API接口：增加服务、修改服务、删除服务、删除订阅关系	
										>注册中心的推送机制/变更通知：但是变更通知里不包含具体的数据内容，具体内容应该客户端自己去拉取。
								>用户调用接口的问题：必然需要提供实现类--而实现类必然是统一的走一个处理过程才最好--所以是提供动态代理类实现， 
									>业务线程：不进行网络读写。
									>服务调用模式：
										>OneWay: 只请求，无应答。如消息通知 。异步化容易。
										>请求-应答模式：调数据。异步化：需要等待前一步非阻塞操作得到的结果。异步调用 更适应 恶劣的现实网络环境。
									>服务调用方式：
										>同步调用：业务线程 调用 通信框架发送数据后，等待，然后业务线程发数据-等待/异步回调-收到数据后 通知业务线程 /唤醒业务线程；
										>异步调用：Future-Listener 提供 主动 获取结果 和 被动 异步回调 通知 获取结果的 方式；。实现：即业务线程调用通信框架发送数据后，不是等待而是注册/同时注册 回调处理方法 到 通信框架，从而通信框架发送数据-等待/异步获取-收到结果后再调用 业务线程注册的处理方法。
											>用Future主动获取结果也比 同步调用效率更高/阻塞时间更短。
										>并行服务调用：BPM流程引擎。	
								>向服务方发送传输调用信息问题：数据格式、通信方式、传输协议、序列化方式、熔断、降级、服务路由
									>数据格式：
										>流式传输：
											>方案1：和服务端配套的输入输出包装流：ObjectOutputStream/ObjectInputStream
									>调用失败：
										>处理策略：
											>Failover: 失败 切换 其他节点。对于读和幂等接口。
												>失败原因：超时、流控、解码失败。重试次数限制3；
											>Failback: 失败 重试 同一个节点。定时重发，对于消息通知接口。
												>失败通知：不再重试？只是异常通知给消费者。
											>Failcache: 失败缓存。服务有状态路由；服务暂时不可用时，需要将消息缓存起来，等待T, 后重新发送； 对通知类服务。
												>失败原因：链路中断、流控。
											>Failfast: 快速失败。失败 记录日志而已。只发起一次调用，失败了不向上抛出；用于非幂等的写接口等。
											--新的扩展：
									>序列化方式： 
										>二进制序列化协议：protocol buffer
										>文本类序列化协议：JSON
									>通信框架：	netty
									>通信协议：自定义 消息格式  
									>服务路由：
										>路由策略：
										>路由配置策略：本地SPI\统一注册管理、动态下发
										>正常不跨机房调用服务：某机房挂了 则跨机房调用。
								>服务方理解调用方的调用信息问题：映射到内部服务、鉴权、限流、...
								>服务方调用内部服务执行服务问题：
								>服务方将服务执行结果回复调用方的问题：
								>调用方接收服务方调用结果问题：结果理解、超时处理、异常处理、熔断降级
								>调用方对外展现结果的问题：数据格式。
								>服务方整体故障问题：单点故障--要求无状态设计
								>服务调用链路不明确、每次调用的耗时成败等特征的度量统计：属于验证论证证明测试方面，即服务质量 计算 所需要的信息的采集、汇总、计算、报表、预警。
									>服务监控：	
								>服务上线下线升级要关注的问题：属于 服务生命周期管理，	上线审批--上线随便造成资源分配问题；下线通知--调用方还在使用的问题；服务灰度发布--
								>服务运行中爆出问题的如何快速解决的问题：
									>思路-采集当时特征数据信息--分布式日志采集:
									>寻找这些特征数据/避免逐个机器上去看--海量日志在线检索: 
									>数据传给的服务内部如何实现的--分布式链路追踪/调用链可视化展示：
									>有问题的服务当前的情况--运行日志信息：
								--归结到服务治理的问题：服务治理的目标。下面是服务治理的层层递进，每层都有治理工具、治理成果。
									>让 服务方 对服务的上下线操作  对 其他服务的运行/调用方的使用 影响最小：设计一个 服务上线到下线 不得不走的流程：上线审批、下线通知、灰度发布。服务生命周期的规范管理，甚至是最基本的。
									>让调用方 用 到 更健壮稳定高可用的服务：服务限流、鉴权、服务路由、超时控制、自动扩展(线性扩展)。
									>让调用方 实时可以知道  当前调用的服务的质量情况并质量变化时预警通知：服务监控统计预警。
									>让调用方 在发现调用异常时 快速定位到异常的服务：分布式链路追踪-服务调用链、数据采集、日志搜索、虚拟机状态
				>顶层思路-完整思路-共性问题的回答/特有问题的回答：1.老思路：
					>概念设计/名词定义/所有约束明确：共性问题解决、共性设计	；特性问题解决，特性设计。
					>职责划分-事务分层-契和塔式调用、任务拆解、连带功能、强壮建设：
					>封装过程：
						>所有可能出现的风险、异常、问题、不足、缺陷和瓶颈：全部考虑到，并识别处理、提供扩展接口规范/插件规范(从而回调插件/扩展程序) 而封装起来- 对外不表现出这些问题/困境/弱势/不足缺点。
							>注册中心挂：
							>服务方挂：客户端容服务方灾
							>注册中心推送信息到消费者端网络 中断：
							>调用量突发增长：
					>塑造过程：
						>技术选型：
			>Hession: spring结合，servlet方式提供服务。
			>gRPC: 移动端使用；HTTP/2。
			>分布式服务框架：
		>通信框架：专题 
			>目标选择：支持 高性能、低延迟、支持大并发连接的 CS框架。
			>Socket层：Netty---对NIO的层层封装。
				>链路有效性检测: 避免链路不可用。
			>性能设计：通信框架+序列化机制+线程模型：netty都可以做到：NIO异步非阻塞通信+protobuf + Reactor多线程模型	
		>数据序列化方式：MessagePack 更加方便，且支持java/c/c++,python,go,lua。 
			>序列化后的码流大小、序列化的速度、序列化时的资源占用消耗：。速度上 ： protobuf >json >hession
				>netty 的反序列化工具类：LineBasedFrameDecoder--回车换行解码器；DelimiterBasedFrameDecoder---分割符解码器；FixedLengthFrameDecoder--固定长度解码器；LengthFieldBasedFrameDecoder---通用半包解码器。
					>处理目的：后面的Handler收到的，即传递给后面的 就是 完整的 整包 消息。
			>编码器：MsgpackEncoder对象转数组。		
		>通信协议栈：对外公有协议http/restful , 对内二进制协议；	
			>通信模型：交互流程 +  调用消息的协议(组织"服务-接口-方法-参数/数据结构类型"的格式)。。。。没有心跳检测--可能会Hang住。
		>注册中心： 可靠性、可扩展性、安全性。
			>zk: 
				>恢复模式：选择leader;同步状态；
				>广播模式：事务顺序执行。每个修改是一个提议，由follower提出(client连接到follower向follower提出)，每个提议一个唯一的事务号。当leader同步数据到follower后，该follower才可以重新接收client的写请求。另外，认为 每个follower再接收用户写请求时 可能会先从leader同步当前状态，只有同步成功了才提交修改事务--否则提交失败，即便提交了事务，也要等待这个事务被leader执行成功了通知了该follower这个follower才能接收新的写请求---这就保证了follower状态和leader一致并且修改成功则表示修改更新到了其他的follower。
		>服务发布和引用：
			>服务发布：服务启动时，将 服务名+  ip-port + 带xx注解的接口和方法从bf里获取出来 打包在一起  序列化 后 发送 给 注册中心。
				>注解方式：可读性很强。
				>发布实现者：发布器Exporter。将发布行为本身 抽取 出来 专门做。
				>注册中心客户端1：在服务端的客户端。可以帮助 发送给注册中心。
				>注册中心客户都2：在消费者端的客户端。帮助建立心跳和拉取和监听服务列表。
			>服务引用：客户端启动时，将 服务名 作为入参 请求注册中心 的服务列表，缓存在本地，后维护租约心跳和服务变更监听回调。	
			>对等设计原则：发布形式完全对等。
			>启动顺序兼容：注册中心、服务、消费者 无先后都可以。
		>服务灰度发布：AB Test 就是 一种 灰度发布方式。保证整体系统的问题，便于灰度初始时发现、调整问题。 
			>灰度发布流程设计：目标：解决服务升级不兼容的问题
				>灰度环境划分、隔离和准备：
				>配置灰度规则 在 服务注册中心： 服务路由使用。
				>注册中心下发 灰度规则： 到 SLB负载均衡器、web前台集群、App后台服务集群。将流量/服务 路由 到 灰度环境 。
		>参数传递：和业务无关的：如调用者的ip, 链路追踪用的TraceID,spanId, TransactionId 等；需要分布式框架本身支持。
			>显式：方法入参；
			>隐式：ThreadLocal透传。但是如果 发生线程切换，任务交割其他线程执行，则有困难。
			>链式编排：入参为 上下文，轻量级BPM。一套自己的参数定义和传递机制。流程引擎。防止参数覆盖。
		>服务多版本管理：服务提供者版本，服务消费者版本。不同版本号，不同的代码。
			>版本号设计：Major + Minor + Micro   重大变更、少部分变更、bug修复
			>包打版本时机：开发完成时，每次部署时。
			>滚动升级和回退机制：
			>服务路由规则的定制：
			--OSGI：模块化和热插拔：
				>一个模块一个Bundle: 可以打包、部署、运行、升级、停止。
					>模块中 接口的导出、隐藏、依赖、版本管理、打包、部署、运行和升级 等 全生命周期管理。
						>从而可以：精确的管控  一个 jar 的哪些 接口 对 另一个依赖它的jar 可见。-----这样 可以  不依赖 不需要的东西！！！实现 很强 的 解耦合。package, interface级别。
							>B导出export哪些接口：A从这些接口中Import导入哪些接口。
			--Maven 的模块化管理+分布式服务框架自身的服务接口导入导出功能 ： 可以替换 OSGI相关功能。				
			>插件热部署和热升级：优雅停机。先通知注册中心，注册中心推送给消费者端 ，消费者端 不再调用，节点自生剩余的处理完成后，才开始停机，拉指定的版本，开始部署，完成后 通知注册中心--就像新节点一样。
		>流量控制：当资源成为瓶颈 时 启动 流量控制 机制-限流。属于服务治理，可以提高服务稳定性。(服务本身业务功能以外的事情里面 为提高服务质量  而 做的事情---服务治理)
			>限流策略：
				>针对访问速率的静态流控：根据服务质量等级协定SLA约定的QPS做全局的流量控制。
					>静态预分配方案：每个节点自己分配的流量，进行流量控制。
						>但云环境下：服务的弹性伸缩 使得节点数 处于动态变化之中。节点也可能崩溃宕机。所以运行期间节点变化是必然事件。
					>动态配额分配方案：即注册中心来动态推送每个节点的QPS给节点/可以根据节点负载情况进行加权计算。但需要流控周期。周期内不会再变。
					>动态配额申请方案：因为流控周期T的存在，上方案响应不够敏捷。且 服务中心下发压力 也更大。网关去做 则从源头上改善效果更好。
						>分布式令牌桶算法：每个节点去注册中心申请配额。初始分配 + 各个节点根据自身申请配额。宕机则释放配额，调整则更新自己的配额。所以总限流量下资源池可能还有剩余。
				>针对资源占用的动态流控：
					>资源占用查看：top/sar命令。cpu.mem.。应用资源：jvm堆空间/线程数/
					>分级流控：拒绝1/4还是拒绝1/8.。。
					>根据资源使用率，而流控等级升级或下降，来拒绝流量。总体来说不是因为流量大了而拒绝，而是流量大了导致cpm.mem紧张了达到阈值了 才要求进行流控。只要cpu.mem紧张了流量小也要流控，cpu.mem步紧张流量大也可以不流控。
						>措施：告警/拒绝流量，或者兼有。
				>针对消费者并发连接数的连接控制 和针对 并行访问数的并发控制：
					>并发控制：限制某个接口的某方法的并发执行数。客户端：则限制某接口的某方法的并发请求数。
				>连接控制：服务端控制客户端连接数。客户端也限制对服务的连接数。	
		>服务降级：业务高峰时 停某些边缘业务；某服务不可用时 不能流程失败，需要有默认值，做流程放通。
			>容错降级：服务不可用时 进行。 
				>服务不可用原因/服务异常原因 ； 
					>RPC异常: 网络超时异常、消息解码异常、流控异常、系统拥塞保护异常。
					>Service异常：登陆校验失败异常；数据库操作失败异常。
				>容错策略：
					>抛出异常：
					>屏蔽异常、执行默认bean:
				>触发时机：自动触发，运行时触发。
			>屏蔽降级：	不发起远程调用--直接返回空-本地值-不消耗公共资源。
				>过程：服务治理控制台--->选择服务降级菜单-->选定降级服务、降级策略--->发送到服务注册中心-->注册中心下发给消费者---匹配屏蔽服务则不再调用；下发给服务端---服务端更新本地服务发布缓存信息--更新服务降级属性为屏蔽降级	。
					>触发执行策略：人工执行。
					>降级配置：不调返回空、不调抛出异常、不调执行配置的本地bean。
					>恢复：人工。
			>业务层降级：业务逻辑决定。		
		>服务优先级调度：
			>发布时优先级策略：
				>使用线程调度器：线程优先级(优先级线程池--优先级不同 获得的 资源量也是不同的)
				>使用java优先级队列：Priority, 元素排序。。会偏向优先级高的，低的则很难被执行。
				>使用加权优先级队列：优先级别-普通队列  kv 这样的映射；工作线程按 加权值 取元素。
				>使用服务迁入迁出：利用服务动态发现机制。就是 迁出 低优先级 服务的 实例数。
			>资源瓶颈时优先级策略：
		>服务治理：因为问题，产生目标，想到思路，立刻执行。满足服务线下管控、保障线上高效运行。
			>服务微自治：
			>SOA Govermance: 服务建模、组装、部署管理。
			>基本方法：
				>流控：应对突发流量问题 
				>降级：下游服务不可用问题
				>路由：下游服务负载不均匀问题。属于优化。
				>灰度：新版本升级隐藏风险未知问题。
				>链路追踪：异常问题的排查问题。性能瓶颈排查问题。
				>统计预警：突发流量开发者 感知问题。
				>故障自动迁移：故障机器/节点 移除集群问题。