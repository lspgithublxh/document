>每个动作和目标，都可以升级，所以要专门定义分开。
>spring: 类的寻找、实例化、调用介入、释放(bean的生命周期各个阶段-全程参与)。
	>类的寻找： 
		>全部位置：
			>配置文件：spring-boot-autoconfigure.jar/spring.factories 包含：大量Configuration/Listener/Initializer/Filter/Analyzer/Provider
				>所有Jar里的spring.factories被加载的位置：spring-core.jar/SpringFactoriesLoader.class::loadSpringFactories(classLoader) 方法里面查找spring.factories文件的实现：直接classLoader.getResources()加载到的全部。
					>调用加载spring.factories里各种具体类型内容的地方：
						>1.SpringApplication 加载Listener之类时：
						>2.启动类的@SpringBootApplication注解的解析时：
							>此注解上有@EnableAutoConfiguration注解：
								>此注解@Import了 AutoConfigurationImportSelector 这个选择器：选择器直接实例化。后调用它的@processGroupImports()-->@getImports()时：去获取自动配置实体时 显式 用SpringFactoriesLoader从所有jar里的 spring.factories里 加载 EnableAutoConfiguration.class 类型的全部配置类项--一般得到130个配置类名--再经过OnClassCondition/OnWebApplicationConditon/OnBeanCondition过滤之后只有27个(如包括org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration)。或者在@AutoConfigurationImportSelector.selectImports()里也直接使用SpringFactoriesLoader 来获取 spring.factories里的所有	EnableAutoConfiguration.class的配置实现类类名 返回。
									>有的jar里的类被引入 只有一种路径：即通过 它的 spring.factories 里的 org.springframework.boot.autoconfigure.EnableAutoConfiguration= 自动配置项的值：。比如spring-cloud-netflix-zuul.jar ,而它的spring.factories里的自动配置项=org.springframework.cloud.netflix.zuul.ZuulServerAutoConfiguration,org.springframework.cloud.netflix.zuul.ZuulProxyAutoConfiguration
									>自动配置类 中具体的类 实例化 后被使用的场景：注意配置类 自己的属性也可以@Autowired注入属性。1.被用bf.getBean(Type)获取接口的实例方式被使用(如过滤器/监听器/)。2.类加载时static{}自己启动了相关初始化init()代码。3.
								>此注解上有@AutoConfigurationPackage注解：引入了 AutoConfigurationPackages.Registrar 这个仓库。
				>例外：有的自动配置类不会被加载：因为该自动配置类需要的Class在classpath上没有：明显报红。	
		>bd的构造：(属性值的注入和使用)
			>属性填充：
				>增加属性：
				>增加方法：注入方法 如 初始化方法 到 bd.initMethodName。
				>设置 
			>普通类的bd：
			>接口类的bd：
				>1.动态代理： 
				>2.指定专门类：专门 new RootBeanDefinition()填充 后放到bdf
					>配置 mbd.resolvedTargetType: 如resolvedTargetType=org.mybatis.spring.mapper.MapperFactoryBean, beanClass=org.mybatis.spring.mapper.MapperFactoryBean 有时 会设置 isFactoryBean=true
	>实例化：根据bd
		>实例化方式：
			>接口的专门指定类的bd的实例化：如 dao接口类的 指定类 MapperFactoryBean 的初始化：
		>初始化方式：普通感知设置步骤1 + 核心调用步骤3：即1.感知设置之后，2.用全部 BeanPostProcessor 的初始化前置(依次转换)和后置方法(依次转换) 包裹 @invokeInitMethods() 初始化方法。初始化方法 (依次执行)：1.InitializingBean.afterPropertiesSet() 2.bd.initMethodName 属性 上的方法名。
		>实例处理方式：
		>属性上的占位符替换值的过程：
			>从该bean的实例化的@populateBean()开始：最后会调 BeanPostProcessor:InstantiationAwareBeanPostProcessor:AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues()处理---->发现自动绑定的元数据：InjectionMetadata：发现过程：这个bean的所有属性/方法 上有@Autowired/@Value/@Inject 三个之一且 注解属性required=true, 则这个Field/Method需要自动绑定，封装为AutowiredMethodElement而加到集合；----->元数据注入属性值：metadata.inject(bean, beanName, pvs)--->遍历每个需要注入的属性: 进行注入 InjectedElement:element.inject(target, beanName, pvs) -->依赖解析@beanFactory.resolveDependency() 就是发现 这个name/type的属性 需要注入的bean/val的过程：
				>先通过解析器获取建议值：ContextAnnotationAutowireCandidateResolver:QualifierAnnotationAutowireCandidateResolver.getSuggestedValue() 获取注解的 value属性的值：--->这个值可能是占位符表达式,需要解析：
					>转解析器 PropertySourcesPlaceholderConfigurer: resolveStringValue() --->转到 AbstractPropertyResolver.resolveRequiredPlaceholders()解析：-->PropertyPlaceholderHelper.parseStringValue() 此方法会递归；---> 将占位符 当作key  尝试找到它的值：PropertySourcesPropertyResolver.getProperty()-->找的方法，从资源匹配中找：遍历 propertySources:PropertySources， 对每个资源 PropertySource： 从它的source里取：StandardServletEnvironment:source.getProperty(key)-->再转到 PropertySourcesPropertyResolver:propertyResolver.getProperty(key) 取-->最后到 DefaultConfig.getProperty() 取：System.getProperty(key)-->如果为空，尝试从 Properties:m_configProperties.getProperty()-->没有则从：System.getenv(key)取 。如果还没有：
						>转 ConfigPropertySource: getProperty(), 而此时 m_configProperties 属性 有很多远程值：。。如果没有，退回到 PropertySourcesPropertyResolver.getProperty()里 取下一个 propertySources:propertySource： CompositePropertySource:propertySources 有6个-->每个 PropertySource 都有多个远程属性；终究可以找到。。整个过程看：数据就是来自 解析器 的 属性源；PropertySourcesPlaceholderConfigurer.propertySources:PropertySource.source.propertyResolver.propertySources.PropertySource.propertySources.PropertySource.DefaultConfig:source。。。简化为：AbstractPropertyResolver.resolveRequiredPlaceholders()-->doResolvePlaceholders()-->	PropertySourcesPropertyResolver.getProperty()-->CompositePropertySource.getProperty()-->ConfigPropertySource.getProperty()-->DefaultConfig.getProperty()
				>
		>实例属性的来源：如何快速找到一个属性是哪个地方注入的？(对第三方的类)(总共哪些注入入口)
			>反射方式属性填充：@populateBean()里将bd:AbstractBeanDefinition.propertyValues:PropertyValues 处理后 根据属性名拼接"set"后找到对应的方法后 反射的方式将值设置到bean里。例子：MapperFactoryBean这个实现类的 抽象父类 SqlSessionDaoSupport 的 sqlSessionTemplate 属性的值(多态量)就是 这种方式反射设置的(可以发现没有任何代码引用方式进行设置)。
				>propertyValues的值的来源：1.mbd初始化时设置进去的；2.populateBean()时autowireByType()中unsatisfiedNonSimpleProperties()的实现：获取类及其父类的所有属性BeanWrapper.CachedIntrospectionResults.propertyDescriptors 并过滤掉基本类型属性 而得到的属性名称，再DependencyDescriptor从bf里查找到对应的实例bean(并会检查属性是否是Map/List之类), 然后放到k-v:MutablePropertyValues 里。
	>每个实例的bean化的方式：启动类就是第一个配置类。
		>配置类里方法上@Bean:
		>配置类上某个注解是一个被@Import(registry)注解的类：从而配置解析类 解析 配置类的@Import注解的时候 发现是registry类型 从而 添加到配置类的importBeanDefinitionRegistrars属性，后 refresh()调BeanFactoryPostProcessor处理时候 走 配置类 后 统一取配置类的这个属性来 调用些仓库的注册bean方法来注册了若干个bean。
			>registry注册的bean类型：
				>BeanFactoryPostProcessor: 在refresh()时候会直接专门调用所有的bean工厂处理器(从beanFacotry里取的)。
				>BeanPostProcessor: 在refresh()里有专门直接的调用bf里的所有bean后置处理器注册到处理器属性beanPostProcessors。在getBean()初始化bean:initializeBean()里面专门调用这个属性beanPostProcessors。
		>配置类上某个注解是一个被@Import(ImportSelector)注解的类:  从而配置解析类 解析 配置类的@Import注解的时候 发现是 selector 类型 调selector类的@selectImports()获取className集合，每个都当作类来注册，然后每个类还当作selector递归处理。
			>选择的类名类型：
				>ImportBeanDefinitionRegistrar: 在refresh()调 BeanFactoryPostProcessor 处理时 包含对 配置类处理器 的处理，而 配置类解析器 获取了所有配置类，而配置类有4处候选bean可以被引入，其中包括 通过配置类的 ImportBeanDefinitionRegistrar 列表 来注册 bd.
				>@Configuration/@Component: 即当作是配置类来处理。配置类里一般有多个@Bean方法。
		--扫项目下包加载类/扫jar中配置文件/...	
		>配置类上某个注解是一个被@Import(其他)注解的类：则当作是配置类来解析处理。
	>方法注入：
	>属性注入：
	>调用介入：
		>动态代理：拦截器/方法拦截器
	>释放回收：
		>销毁方法：
>tomcat:
	>spring-boot中创建过程：
		>ApplicationContext: onRefresh()刷新
			>创建webserver:
				>配置上下文：TomcatEmbeddedContext
	>结构：
		>服务器应用上下文：AbstractApplicationContext:ServletWebServerApplicationContext
			>服务器工厂：ServletWebServerFactory:TomcatServletWebServerFactory
				>服务器：TomcatWebServer
					>Tomcat： Tomcat	有生命周期LifecycleBase
						>服务器：Server:StandardServer 有生命周期LifecycleBase
							>服务：	Service/StandardService  (有生命周期LifecycleBase)
								>引擎：Engine/StandardEngine (有生命周期LifecycleBase) 继承了 容器 ContainerBase/Container
									>标准主机：Host:StandardHost 继承了容器 ContainerBase/Container
										>上下文：Context:StandardContext:TomcatEmbeddedContext 继承了容器 ContainerBase/Container 有生命周期LifecycleBase 
											>上下文监听器：LifecycleListener:FixContextListener
											>webapp加载器：Loader:WebappLoader
											>jar浏览器：JarScanner:StandardJarScanner
												>浏览过滤器：JarScanFilter:StandardJarScanFilter
											>默认servlet: StandardWrapper:<DefaultServlet> 继承了容器 ContainerBase/Container	
											>默认资源：WebResourceRoot:StandardRoot
											>名称上下文监听器：NamingContextListener
											>上下文管理器：StandardManager
											>servlet上下文：应用上下文 ServletContext:ApplicationContext
												>上下文面板：ApplicationContextFacade
											>servlet容器初始化者：ServletContainerInitializer:WsSci:TomcatStarter(服务器工厂类时增加进来)
												>服务端容器：WsServerContainer
												>servlet容器初始化者：TomcatStarter.ServletContextInitializer[]=ServletWebServerApplicationContext/
													>来源：bf里所有 ServletContextInitializer  类型的实现。包括：RegistrationBean:DynamicRegistrationBean:ServletRegistrationBean:DispatcherServletRegistrationBean
														>来源：spring.factories中 自动配置 DispatcherServletAutoConfiguration.DispatcherServletConfiguration.DispatcherServlet/DispatcherServletRegistrationConfiguration.DispatcherServletRegistrationBean
														>来源2：自动配置 中 HttpEncodingAutoConfiguration.CharacterEncodingFilter//FilterRegistrationBean //ApplicationFilterRegistration
															>configure()配置时：封装为新的一个 FilterMap 放到上下文 TomcatEmbeddedContext.filterMaps 其他filer如：formContentFilter/requestContextFilter/WsFilter(Tomcat WebSocket (JSR356) Filter)/
											>过滤器：FilterMap	
								>连接器：Connector/Connector
									>协议：org.apache.coyote.http11.Http11NioProtocol
										>端点：AbstractJsseEndpoint/NioEndpoint/
											>通道：ServerSocketChannel
												>socket: ServerSocket 
													>port: InetSocketAddress 就是 application.properties里配置的。
											>安全上下文：SSLImplementation
											>选择池：线程安全的 NioSelectorPool
												>选择器：Selector
											>事件调度：Poller 计票者。run型任务..。。一次请求新增一个
												>事件：PollerEvent
													>附件：SocketWrapperBase/NioSocketWrapper
												>文件发送：SendfileData
												>可读事件：SocketEvent.OPEN_READ
												>可写事件：SocketEvent
											>事件处理：SocketProcessorBase:SocketProcessor	转用处理器处理。
										>处理器：Handler:ConnectionHandler
											>处理器：Processor:AbstractProcessorLight:Http11Processor 主要负责分发/service/日志处理。
												>请求：Request
													>请求信息：RequestInfo
													>http请求：HttpServletRequest
													>门面实现：RequestFacade
												>响应：Response
												>输入缓冲：Http11InputBuffer
												>服务方法: service()
													>适配器：继续服务方法。Adapter:CoyoteAdapter 报头解析 
														>连接器：Connector
															>取服务：Service
																>取容器：Engine	
																	>取管道：Pipeline:StandardPipeline
																		>阀门：Valve:ValveBase:StandardHostValve:StandardWrapperValve 只有invoke(Request request, Response response)方法 有实际有意义的内容；-->内部核心：调 StandardWrapper:container.allocate()-->内部就是@loadServlet()来构建实际servlet并初始化--->后利用来创建过滤器链@ApplicationFilterFactory.createFilterChain()-->过滤器部分来自： wrapper.getParent():StandardContext.filterMaps--->后开始执行过滤器链：@filterChain.doFilter(request.getRequest(), response.getResponse())-->内部记录了位置，如果前面则filterConfig.getFilter().doFilter()，最后了则取之前创建过滤器而注入的 javax.servlet.Servlet:servlet.service(request, response)来执行。
																			>Servlet: 获取：StandardWrapper
																				>servletClass: org.springframework.web.servlet.DispatcherServlet
																				>instance: DispatcherServlet
																			>过滤器链：ApplicationFilterChain
																				>嵌入Servlet:
																				>嵌入过滤器：ApplicationFilterConfig->Filter
																					>过滤器来源：LifecycleBase:LifecycleListener，包含 Tomcat$FixContextListener， TomcatServletWebServerFactory$StaticResourceConfigurer, StandardHost$MemoryLeakTrackingListener
																			>执行过滤：doFilter()	
																				>内部doFilter: internalDoFilter()
																					>pos<n: 则继续走filter: Filter.doFilter(chain), pos++ , 而 chain作为参数
																					>pos=n: 则走servlet: servlet.service(request, response) 此时就已经走企业级 接口：javax.servlet.Servlet
																						>进一步：javax.servlet.http.HttpServlet 进一步则开始。模板是一层一层的，直到 org.springframework.web.servlet.DispatcherServlet.doDispatch()。
														>认证授权：
							>执行器服务：ScheduledExecutorService:ScheduledThreadPoolExecutor(注入的是java的ScheduledThreadPoolExecutor线程工厂TaskThreadFactory) -- 1.可以启动周期调度任务 ContainerBackgroundProcessorMonitor， 后者提交一个新的任务 ContainerBackgroundProcessor。
				>上下文客户端：TomcatContextCustomizer:TomcatWebSocketServletWebServerCustomizer(在自动配置WebSocketServletAutoConfiguration里@Bean方法方式实例化,后者在spring.factories里EnableAutoConfiguration)
					>增加WsSci到上下文：WsSci
			>servlet上下文初始化器：ServletContextInitializerBeans:<ServletContextInitializer> 所有初始化器 从 bf里 获取 ServletContextInitializer 类型的实例 onStartup		
				>
	>dispatcherServlet的注入过程：
		>自动配置类DispatcherServletConfiguration 实例化里面的@Bean方法： 这个bean：DispatcherServlet 
		>自动配置类DispatcherServletAutoConfiguration实例化里面的@Bean方法：这个bean: DispatcherServletRegistrationBean:ServletRegistrationBean:DynamicRegistrationBean:RegistrationBean:ServletContextInitializer 会注入 DispatcherServlet 实例 到 ServletRegistrationBean.servlet属性。同时强制设置 DynamicRegistrationBean.name=“dispatcherServlet”
		>创建Tomcat过程中：调 StandardContext.startInternal()时：方法里专门 调 注入的 initializers 来执行它们的启动方法：ServletContainerInitializer.onStartup(); (此时已经进入refresh()阶段，所以自然是从工厂里取出ServletContextInitializer.class类型注入的) ，典型的 实现类是：TomcatStarter，所以调 TomcatStarter.onStartup()--->内部又转调它实例化时注入的ServletContextInitializer[]: 执行它们的@onStartup(),有个实例是方法引用，即转执行 ServletWebServerApplicationContext.selfInitialize()-->里面也是 先获取 ServletContextInitializer.class的所有实例 逐个执行 它的@onStartup(servletContext)，实例就有：DispatcherServletRegistrationBean
			>转执行 RegistrationBean.onStartup(): 此时顺势就获取到了 里面之前设置了的 servlet 及其名字，然后注入上下文：@servletContext.addServlet(name, this.servlet)， 这个上下文为 入参传入的：ApplicationContextFacade 类型；---->方法内部 转调 context.addServlet(), 这个内部context:ApplicationContext 类型--->方法内部 又 先获取属性 ApplicationContext.context:TomcatEmbeddedContext 来找到 servletName 对应的引擎-->context.findChild(servletName) 这个引擎：Wrapper:StandardWrapper, 然后调用它的设置serlvetClass():wrapper.setServletClass(servlet.getClass().getName())---->自然就设置到了它的属性：StandardWrapper.servletClass 里。。
		>创建Tomcat过程中：调 StandardContext.startInternal() 执行了initializers.onStartup()之后，会调用 StandardContext.loadOnStartup()-->内部先获取所有的Wrapper:每个执行它们的@load()方法---->内部实现则核心：@loadServlet()---->内部即将上一步获取的 servletClass 属性上存的完整限定名称 反射方式实例化@instanceManager.newInstance(servletClass)
		>tomcat服务器启动时：调 TomcatWebServer.start()-->performDeferredLoadOnStartup()-->TomcatEmbeddedContext.deferredLoadOnStartup()-->TomcatEmbeddedContext.load(Wrapper wrapper)-->也是转调 Wrapper.load()-->同上。	
>mysql：
	>优化：
		>减少B+树分裂合并调整：id顺序增加的插入。
		>sql合并为1条：减少解析、创建事务、binlog日志刷盘数量和频率。
		>语句优化:	
			>update: 
			>select: 
				>小表驱动大表：
					>原因：in 是：外表走索引，内表走遍历；所以适合内表数量少的-索引加在外表上。 exists 是： 外表走遍历，内表走索引；所以适合外表数量少的-索引加在内表上。
				>order by: 优化掉 Using filesort。 一个是 最左匹配，则where里用=。order by 完整索引列，则也可以。
			>explain比较：
				>select_type: simple--简单查询；primary--最外层查询； subquery---映射为子查询； derived---子查询；union--联合查询；union result--使用联合查询的结果；
				>type: 连接的连接类型：const(使用常量通过主键唯一索引找到)-->eq_ref(通过其他列值给唯一索引找到,如inner join 一一索引列连接)-->ref(非唯一性索引找到)->range(范围扫描索引列)-->index(遍历索引树)-->all(遍历全表)	
				>key_len: 索引长度 越短越好
				>ref: 索引的哪一列被使用了
				>where: using where ---查询可收益于不同的索引；using index--使用覆盖索引(辅助索引+主键select) ， using tempory--结果排序使用临时表；using filesort---使用外部索引排序
			>limit的使用：找到结果就返回；提前终止，避免全表扫描；	limit 1;
			>业务：ip地址用整数---方便范围查询； 分页查询；统计行数--如果id自增则用max(id)就可；
			>order by: 可以不使用；
			>执行计划可视化：Mysql WorkBench；show profiling; 日志状态查看；
		>对表加读写锁：myisam
			>操作： A会话执行：lock table tablename read;
			>效果： A会话释放表锁之前,不能继续更新该表，也不能读其他表；B此时更新该表则会被阻塞；。。如果A加的是写锁，类似。
		>对行加读写锁：先 set autocommit=0;	两个会话则一个先update, 而另一个会话update同一条数据；但第一个还没有手动commit ;就会阻塞；在repeated read隔离级别下是成立的。
			>效果2：A:update 执行了但没有执行commit; B: 执行update同一条数据会阻塞，不同数据会成功；插入数据会成功(但是A是看不到的--因为可重复读的隔离级别)；
			>效果3：A:insert 执行了一条数据但没有commit;B:执行 insert同一个id的数据会阻塞(A提交后B直接报重复key)，不同id则会成功；update同一条id数据也会阻塞；但是update其他数据会成功；
				>说明：A先占用了行锁-X锁；(独占性质的行锁)
			>效果4：A:update where > 则会加next-key lock；已有数据和空隙 行上的锁都会被占用；B:update 已有范围内记录会阻塞；不存在的记录会成功-0条；insert所在间隙会阻塞；
			>效果5：A:select >= for update 也会加行锁和间隙锁；从而B再 select >= for update也会被阻塞；update/insert自然也会被阻塞；
		>设置是否自动提交：是对 会话 级别设置的；不同的会话则不同；且各自的设置不会互相影响其他会话的是否自动提交 配置；
		>设置事务隔离级别：也是会话 级别 设置的；SET transaction_isolation = 'REPEATABLE-READ'	;SELECT @@transaction_isolation; 不同会话 事务 的隔离级别 不同；
		>锁耗时统计：SHOW STATUS LIKE 'innodb_row_lock%'; 总共锁时；平均每次锁时；总共锁次数；
		>未使用索引会加表锁：A: UPDATE a SET rate = 2.5 WHERE rate = 2.11 如果rate列没有索引 那么 会加表锁；B: 此时如果 update 的某行即便rate != 2.11 也会被阻塞；
			>说明2： 如果 update 的where 发生了 整形转字符 这样的自动类型转换 导致 索引失效 自然也会加表锁；
		>系统查询：
			SELECT @@transaction_isolation; -- mysql8 可重复读； 
			SELECT VERSION(); -- 查看mysql 版本
			SHOW VARIABLES LIKE '%auto%' -- 是否开启自动提交
			SHOW STATUS LIKE 'innodb_row_lock%'; -- 锁耗时统计
			SHOW ENGINE INNODB STATUS; -- 查看 sql使用到的锁
		>查询全部执行过的sql: SHOW VARIABLES LIKE '%general%' 全局日志里。	
		>sql执行过程：
			>临时表：inner join 合并结果。SHOW STATUS LIKE 'CREATE%'，SHOW VARIABLES LIKE '%HEAP%'， 先使用内存临时表(memory存储引擎)，后使用磁盘临时表(myisam存储引擎)；
				>间接使用： group by b order by a； 长字符串列group by ；
			>派生表：子查询 ，存在内存中；尽量不*查。无法增加索引，比临时表慢；(子查询替换为使用视图---实际效果并不好)
			>inner join : 配合on使用 来匹配后一张表的记录 得到 结果，最后才where，所以where条件只能对第一个表关联，所以条件加到on上更好；
			>update A inner join B set A.t=B.t where: 如果A表 连接后 中间表膨胀了，比如A中1条关联了B中2条；那么 set 的时候 只会把B的第一条的值设置到A。。。。另外一方面，应该要加限制条件让结果表不膨胀--和A表一一对应；。。所以一定要准确关联一一关联写足关联在on上--避免膨胀产生的问题。where会限制结果集，然后才set执行；
				>注意：A left join B on  , on中 独立加对 A的限制 如A.id<1, 结果集中仍然是A的全部结果；left join 中的on 只影响 A中某行是否关联，但A中的某行一定保留(尽管一行没有关联到--由于对A的限制A.id<3)；但是inner join 则不一样，on 中 如果 限制了A(A.id<3)，则结果集中就没有限制的A的记录(A.id>=3的都没有)；
			>子查询： 
				>join 后的子查询可以；但是where 后面的子查询：exists() 是 外表遍历， 内表索引--外表数量少则可以；
					
	>死锁问题：
		>阻塞：update时候有其他语句正在update 而事务未提交;
		>问题1：update 语句执行了3min, 查看show processlist 发现在 sending data。explain 语句出现：Using where; Using index; Using join buffer (Block Nested Loop)
			>update 特征： update a inner join b on xx inner join c on xx 
>java:
	>线程池:
		>任务抛出异常：worker抛出异常->线程抛出异常；正常的worker死亡而已。
	>jvm：
		>优化：		
	>java并行操作：Stream	
>其他中间方案：
	>websocket: 在tomcat-embed实现中。
		>参考。https://www.cnblogs.com/ttjsndx/p/9268800.html
		>refresh()时： 
			>服务端点输出者：ServerEndpointExporter 的实例化。
				>注册端点：用户写的类，注册到 ServerContainer:WsWebSocketContainer:WsServerContainer
					>路径：UriTemplate
		>前端发起subscribable时：	后端启动一个任务 ExecutorSubscribableChannel.SendTask	
			>消息处理：UserDestinationMessageHandler/SimpleBrokerMessageHandler/WebSocketAnnotationMethodMessageHandler
				>消息解析：DefaultUserDestinationResolver
					>设置sessionId和targetDestination: 订阅路径 "-user" sessionId
				>将处理后的消息发送：SimpMessagingTemplate
					>通道发送：ExecutorSubscribableChannel
						>内部发送：再次以运行任务方式执行。对 SimpleBrokerMessageHandler 这个handler的handlerMessageInternel()处理是不同的：分消息类型处理。
							>message类型：1.根据destina 从订阅仓库AbstractSubscriptionRegistry 发现所有的订阅者：
								>发现订阅者的实际过程：SessionRegistry 内部维护了 ConcurrentMap<String, SessionInfo> sessions;
									>SessionInfo信息里有：Map<String, Subscription> subscriptionMap；匹配出 sessionid--destination; 通过sessionid得到 SessionInfo..最终得到一个sessionId的所有匹配到的subscriptionIds(因为一个消息可能可以匹配到多个destination)
										>对匹配的每个substriptions都向sessionInfo对应的用户发送消息：SessionInfo.MessageChannel:AbstractMessageChannel
		>前端发起普通连接：
			>线程池新增一个任务：SocketProcessor:SocketProcessorBase:Runnable。 新增并执行。
				>转给Handler处理：AbstractProtocol.ConnectionHandler
					>转到处理器：Http11Processor:AbstractProcessor:AbstractProcessorLight
						>转内部适配器：CoyoteAdapter.service()
							>直接调到Valve来Invoke: Connector:connector.getService().getContainer().getPipeline().getFirst().invoke() 而这个 Valve=StandardEngineValve, 内部调主机转：host.getPipeline().getFirst().invoke(request, response)-->StandardHostValve-->又到上下文转：context.getPipeline().getFirst().invoke(request, response):::StandardContextValve--->包装类转：wrapper.getPipeline().getFirst().invoke(request, response):::StandardWrapperValve---->包装类就到过滤器链： filterChain.doFilter():::ApplicationFilterChain----->就到一个个过滤器：filter.doFilter(request, response, this):::OncePerRequestFilter/WebRequestTraceFilter/ApplicationContextHeaderFilter/CharacterEncodingFilter/FormContentFilter/HiddenHttpMethodFilter/MetricsFilter/RequestContextFilter/WsFilter/WebStatFilter
								>filter处理完：开始servlet:servlet.service(request, response):DispatcherServlet:FrameworkServlet:HttpServletBean:HttpServlet 然后分方法处理：METHOD_HEAD/METHOD_POST/METHOD_PUT/METHOD_DELETE/METHOD_OPTIONS/METHOD_TRACE/METHOD_GET
									>转用Handler处理器处理：HttpRequestHandlerAdapter， 处理时，需要注入请求匹配到的6种handlerMappings之一：WebSocketHandlerMapping/RequestMappingHandlerMapping/BeanNameUrlHandlerMapping/RouterFunctionMapping/SimpleUrlHandlerMapping/WelcomePageHandlerMapping..。。。mapping里的handlerMap属性：string--Handler映射的构建过程：BeanPostProcessor 处理SimpleUrlHandlerMapping时从simpleUrlHandlerMapping.urlMap 转移到 AbstractUrlHandlerMapping.handlerMap
										>匹配方法：如请求路径匹配。核心方法：AbstractUrlHandlerMapping.getHandlerInternal() 匹配结果：HandlerExecutionChain:取里面的handler:SockJsHttpRequestHandler， 来处理请求：
											>转给DefaultSockJsService: 分路径sockJsPath 处理：/, /info, /iframe[0-9-.a-z_]*.html/websocket
												>对/info: 转给 AbstractSockJsService.InfoHandler 处理，然后分方法处理：HttpMethod.GET/OPTIONS
													>对get: 设置返回的多媒体类型：application/json; 缓冲：no-store, no-cache, must-revalidate, max-age=0， 返回内容：{"entropy":-758209608,"origins":["*:*"],"cookie_needed":true,"websocket":true} 然后写到输出流：response.getBody().write(content.getBytes()) 关闭。
									--拓展：DispatcherServlet里调用的 Hanlder处理器链HandlerExecutionChain：来自: 遍历 内部 HandlerMapping(SimpleUrlHandlerMapping两个(/**,/webjars/**; **/favicon.ico分别有Handler:ResourceHttpRequestHandler)/WebSocketHandlerMapping一个(/websocket/**,有Handler:SockJsHttpRequestHandler))/RequestMappingHandlerMapping(则有拦截器6个如ResourceUrlProviderExposingInterceptor,拦截 /**,/webjars/**,/**/favicon.ico) 列表，找出可以匹配request的一个过滤器链就返回,匹配过程：如请求路径匹配的方式找到一个HandlerMethod 直接new HandlerExecutionChain()放入.handler，	再将 mapping的adaptedInterceptors:HandlerInterceptor放入interceptors。形成完整的chain: 拦截器适配器的生成(用来生成ModelAndView,生成过程被HandlerChain包围：chain.applyPreHandle()/chain.applyPostHandle())：DispatcherServlet里已经有 若干个HandlerAdapter:RequestMappingHandlerAdapter, 找出其中第一个support HandlerExecutionChain.handler的那个(往往只要chain.hanlder是MethodHandler就支持)。
										>chain.applyPreHandle(): 就是调用 chain的所有拦截器HandlerInterceptor来处理。
					>转给内部确定的处理器:UpgradeProcessorInternal 此时按照socket status分发：	
						>实际分发者：WsHttpUpgradeHandler 按状态分发。
							>对OPEN_READ状态：使用 WsFrameServer 处理。 读状态继续分：
								>WAITING状态：转给 WsFrameBase 处理。
									>注册回调关闭：WsSession
										>实际给：StandardWebSocketHandlerAdapter 回调。
											>再转发给：SockJsWebSocketHandler
												>再：WebSocketServerSockJsSession
													>再：ExceptionWebSocketHandlerDecorator	
														>再：LoggingWebSocketHandlerDecorator
															>再内部的：StompSubProtocolHandler
																>再： ExecutorSubscribableChannel
		>前端发起断开连接：
			>线程池新增一个任务：ExecutorSubscribableChannel.SendTask
				>转处理器：SimpleBrokerMessageHandler。分消息类型.。。此类实例来源：自动配置方法@Bean:DelegatingWebSocketMessageBrokerConfiguration:AbstractMessageBrokerConfiguration.SimpleBrokerMessageHandler
					>DISCONNECT: SUBSCRIBE/CONNECT/MESSAGE
						>还是用通道：ExecutorSubscribableChannel
							>还是用Handler: SubProtocolWebSocketHandler 有生命周期LifecycleBase， 所以start()时候就将自己添加到了AbstractSubscribableChannel.handlers里；(同理 WebSocketAnnotationMethodMessageHandler/SimpleBrokerMessageHandler/UserDestinationMessageHandler 也是)
								>转handler: StompSubProtocolHandler  ：内部先 需要查出 WebSocketSession ,最后走内部方法 sendToClient() 。
									>取消息命令类型：StompCommand.MESSAGE/CONNECTED/ERROR 分别处理。
										>CONNECTED: 发送一个 SessionConnectedEvent 事件。从session取 heartbeat 和 Principal 用户。则转用ApplicationEventPublisher 来发送：属于spring-context服务。
											>取消息的负载：准备发送给客户端：先编译，后以二进制 或者text 形式 : 使用 WebSocketSession 发送： session.sendMessage()
												>最终使用WebSocketClientSockJsSession/XhrClientSockJsSession 来发送负载：
													>后者转用XhrTransport 发送：转 RestTemplateXhrTransport
														>转用 RestOperations 来发送：即spring-web的 restTemplate POST方法发。
															>转ClientHttpRequest ： SimpleBufferingClientHttpRequest 。采用 FileCopyUtils.copy(bufferedOutput, this.connection.getOutputStream()) 将消息内容放到 connection:HttpURLConnection 输出流里。
													>前者转WebSocketSession来发送：sendInternal(TextMessage) sendMessage(TextMessage)
														>具体实现AbstractSockJsSession:sendMessageInternal(String message) 加入缓冲 messageCache:Queue<String> 然后开始刷新：flushCache() 
															>刷数据实现1：PollingSockJsSession
																>只刷数据：writeFrame(frame) 来源：SockJsFrame.messageFrame(messageCodec, messages)
															>刷数据实现2：StreamingSockJsSession 
																>先刷数据：writeFrame(SockJsFrame) 创建的frame=SockJsFrame.messageFrame(messageCodec, message)
																	>writeFrame()的实现：AbstractSockJsSession.writeFrameInternal(frame) 就转到了AbstractHttpSockJsSession 来实现 ， 就是写入输出流里。
																>再发心跳：调度方式：scheduleHeartbeat() writeFrame(SockJsFrame) 创建的frame=SockJsFrame.heartbeatFrame() 就是 new SockJsFrame("h");即发一个h回去。 然后递归scheduleHeartbeat()
													--对 HttpRequestHandlerServlet 里的 service()方法，转其 HttpRequestHandler  实现调用，而实现类可以是 SockJsHttpRequestHandler  -->转到 SockJsService -->TransportHandlingSockJsService-->AbstractHttpSendingTransportHandler-->AbstractHttpSockJsSession-->PollingSockJsSession 这时开始批量写回数据：PollingSockJsSession:AbstractSockJsSession:AbstractHttpSockJsSession-->ServerHttpResponse:response.getBody().write()即消息写入了输出流里。
		>java作为客户端时：WsWebSocketContainer 里是websocket最底层的封装。
			>WsWebSocketContainer： 握手连接时--实际发起的连接：表为ws://ccptest.glodon.com/ccp/cloud_computing 里面为 http://ccptest.glodon.com/ccp/cloud_computing/719/b0a9a092dee848b9953d5d56792528e6/websocket  增加的报头：Sec-WebSocket-Key/Connection/Sec-WebSocket-Version/Host/Upgrade 方法为 GET
			>WsRemoteEndpointImplBase:WsRemoteEndpointImplClient: 发送订阅时--实际的消息发起和封装： 直接写到通道里: ["SUBSCRIBE\ndestination:/queue/app_message/GTCGBQWorker\nid:0\nreceipt:0\n\n\u0000"] 即直接在通道里写数据，不必再发连接。AsyncChannelWrapperNonSecure
		>日志输出：
			>创建bean:WebSocketMessageBrokerStats 时：用 TaskScheduler 调度任务来打印。
	>allopo：配置 ..client-->metaserver-->eurake-->config service-->mysql   。。。注册/发现/直连。。修改配置/推送-fallback拉取(adminservice-->mysql-->configservice(定期查mysql)-->client)
		>配置：属性结构+n套取值(不同环境/集群)
		>拉取本地配置：
		>拉取远程配置：并更新到本地；配置中心修改后实时生效；
			>使用：@EnableApolloConfig 配置 + @Value 取值；
		>参考：https://www.jianshu.com/p/5d9806493c0f	
		>spring-boot中的启动：
			>注册bean: 属性资源处理 PropertySourcesProcessor/ApolloAnnotationProcessor(特定注解的解析处理器)/SpringValueProcessor(spring注解的解析识别@Value)/SpringValueDefinitionProcessor(spring占位符表达式$#解析器)/ApolloJsonValueProcessor(@ApolloJsonValue解析器)(找到占位符表达式的值：StringValueResolver/BeanExpressionResolver/ExpressionParser 实际完成)
				>初始化获取配置：根据名称空间：PropertySourcesProcessor.initializePropertySources()-->ConfigService.getConfig(namespace)	
					>转到管理器：DefaultConfigManager， 通过DefaultConfigFactoryManager 获取配置工厂ConfigFactory:DefaultConfigFactory；
						>新建默认配置：new DefaultConfig(ConfigRepository) 注入配置工厂：配置工厂的获取：本地配置工厂 LocalFileConfigRepository (也会尝试远程获取)， 远程配置工厂：RemoteConfigRepository (创建时就远程获取@trySync()) :AbstractConfigRepository.trySync() -->sync()-->模板模式：LocalFileConfigRepository:loadFromLocalCacheFile() RemoteConfigRepository:loadApolloConfig()
							>远程下载：
								>RemoteConfigRepository: 
									>loadApolloConfig()
										>ConfigServiceLocator：updateConfigServices() 开启事务方式：
											>HttpUtil: 返回数据结构：List<ServiceDTO>
												>HttpURLConnection
										>封装查询url: assembleQueryConfigUrl() 结果如：http://10.0.197.95:8001/configs/gtc-service-v4/default/platform.cloudt?ip=10.2.96.11
										>使用url发起连接查询配置：ApolloConfig	
									>scheduleLongPollingRefresh()： 远程调度开启
										>转发给 RemoteConfigLongPollService: startLongPolling()长连接开始；-->doLongPollingRefresh()  无限循环里，每隔5s 带事务(cat) 地 调 getConfigServices()-->即使用 ConfigServiceLocator 来请求；List<ServiceDTO> --->进一步 assembleLongPollRefreshUrl()构造请求url--> 再发起http连接 获取到结果  ApolloConfigNotification 列表--->对每个通知---是通知变化 所在名称空间，从而根据这个名称空间再去查真正的全部配置：remoteConfigRepository.onLongPollNotified()--->trySync()-->sync()
		>获取到的配置如何更新到bean里：sync()获取到配置 ApolloConfig： 转到 Properties ，调监听器RepositoryChangeListener:DefaultConfig 处理：比较新旧配置，明确 增删改，封装到 ConfigChange， 再到 ConfigChangeEvent，调 ConfigChangeListener:AutoUpdateConfigChangeListener 处理：从 ConfigChangeEvent 获取所有改变了的key: 	对每个key, 从仓库获取值集合：SpringValueRegistry-->Collection<SpringValue> 每个SpringValue 就是 bean-field-placeholder ,bean-method-placeholder的封装体，即这个bean-field上用了本key的值注解，显然就要对每个更新：AutoUpdateConfigChangeListener.updateSpringValue() ：
			>首先解析获取新的值：-->AutoUpdateConfigChangeListener.resolvePropertyValue()-->PlaceholderHelper:placeholderHelper.resolvePropertyValue(), 具体实现：
				>核心还是解析占位符$表达式：AbstractBeanFactory.resolveEmbeddedValue()-->PropertyPlaceholderHelper.replacePlaceholders()--> 先解析出 占位符 ,后找占位符的值 PropertyPlaceholderConfigurer.PropertyPlaceholderConfigurerResolver:placeholderResolver.resolvePlaceholder(placeholder): 
					>寻找占位符的值的过程：PropertyPlaceholderConfigurer.resolvePlaceholder(), 因为PropertyPlaceholderConfigurerResolver实例创建时 注入了Properties， 实际就是从PropertyPlaceholderConfigurerResolver的Properties里获取的；
				>核心2：如果有bean表达式解析器，则要对解析的结果评估后再返回：evaluateBeanDefinitionString():beanFactory.getBeanExpressionResolver().evaluate(value):StandardBeanExpressionResolver
					>转 expressionParser.parseExpression().getValue(sec): TemplateAwareExpressionParser 实现：转 SpelExpressionParser  解析spel表达式：最后 得到 SpelExpression.SpelNodeImpl.TypedValue.value
			>然后更新注入到bean-field：springValue.update(value)-->就是反射注入：injectField()/injectMethod()
			--SpringValue的封装过程：每个bean实例化之后：BeanPostProcessor:SpringValueProcessor:ApolloProcessor.postProcessBeforeInitialization().processField()-->找@Value注解的Field, 封装到 new SpringValue(key, bean, field), key就是$表达式/#表达式；后注册到 SpringValueProcessor.SpringValueRegistry
			--拉取的远程配置在本地的存储：PropertySourcesProcessor:BeanFactoryPostProcessor 中处理：@initializePropertySources():
				>新增 new CompositePropertySource(“ApolloPropertySources”)对象：对每个名称空间，进行一次拉取-对拉取的每个配置：ConfigService.getConfig(namespace)-->经过处理：configPropertySourceFactory.getConfigPropertySource()转为ConfigPropertySource后加入 CompositePropertySource.propertySources:Set。。同时对每个ConfigPropertySource，增加同一个 监听器this.source.addChangeListener(listener)：new AutoUpdateConfigChangeListener..实际就是AbstractConfig.m_listeners:List<ConfigChangeListener>
					>注意获取配置的过程：ConfigService.getConfig(namespace)
						>交给 DefaultConfigManager-->DefaultConfigFactory-->new DefaultConfig(repository)注入的仓库=new LocalFileConfigRepository()->创建时:trySyncFromUpstream()-->updateFileProperties():获取已经拉下来的配置m_fileProperties:Properties，准备持久化到磁盘：persistLocalCacheFile():@m_fileProperties.store(out)
				>如果 enviroment:StandardServletEnvironment 里的属性源propertySources:MutablePropertySources 有"ApolloBootstrapPropertySources"属性了，将CompositePropertySource 加到它后面，否则放在第一位；MutablePropertySources.propertySourceList:List .PropertySource ..从而实际属性的沉淀者就是：ConfigPropertySource.source:DefaultConfig.m_configProperties:Properties
			--RemoteConfigRepository启动的周期刷新：schedulePeriodicRefresh()--> m_executorService.scheduleAtFixedRate() 5min执行一次trySync()->sync()->loadApolloConfig()得到 ApolloConfig-->通知监听器：fireRepositoryChange()-->RepositoryChangeListener:DefaultConfig.onRepositoryChange(Properties)入参就是新通知， 获取具体变更Map<String, ConfigChange>:(key=属性名)(过程中新属性会保存到本地DefaultConfig.m_configProperties)后：fireConfigChange(ConfigChangeEvent)-->通知监听器：AutoUpdateConfigChangeListener.onChange(ConfigChangeEvent):
				>获取全部增删改的key: 遍历，获取每个key所用在所有的bean-field:通过 springValueRegistry.get(beanFactory, key) 获取到 Multimap<String, SpringValue>， 得到每个配置key所被用在的bean-field的集合，那么下一个只需要将key对应的value设置到bean-field即可；即遍历 key-Collection<SpringValue>： 对每个SpringValue: 执行 updateSpringValue(val)--->过程分2步：先获取到属性对应的值value=@resolvePropertyValue(springValue) 后 将值设置到Field:@springValue.update(value)。。。注意：key对应的值不在ConfigChangeEvent里，而还是在 enviroment 的属性源里，所以还是通过resolvePropertyValue(springValue)来获取的-->内部就是通过 统一的 placeholderHelper.resolvePropertyValue()
					>实现也分两步：	
						>先 @beanFactory.resolveEmbeddedValue(SpringValue.placeholder) 得到一个值。
							>核心实现：PropertyPlaceholderHelper.replacePlaceholders()-->parseStringValue()就是常见的。
								>进一步交给：PropertyPlaceholderConfigurerResolver.resolvePlaceholder()->PropertyPlaceholderConfigurer.this.resolvePlaceholder(placeholderName, props, systemPropertiesMode) 核心依赖数据就是它的Properties:props属性。此属性来源：PropertyResourceConfigurer.postProcessBeanFactory()-->PropertyPlaceholderConfigurer.processProperties()
						>后通过评估表达式解析器处理：@evaluateBeanDefinitionString(val)-->即：beanFactory.getBeanExpressionResolver().evaluate(value)得到；
		>监听配置修改事件的监听器：带@ApolloConfigChangeListener注解的方法 且入参为一个：ConfigChangeEvent；， 这个方法可以在任何普通@Bean类内；然后调用 ApolloAnnotationProcessor:ApolloProcessor:BeanPostProcessor.postProcessBeforeInitialization()-->processMethod() 即统一的每个bean初始化前 找到这个类的所有方法 筛选 有这样特征的方法之后(如果有@ApolloConfig注解的Config类型的属性则直接注入Config实例)，封装 到一个new ConfigChangeListener()里，然后获取该注解默认的名称空间"application" ，调ConfigService.getConfig(namespace)获取 到具体配置Config;然后将监听器加入配置：config.addChangeListener(configChangeListener)---->由于这个获取配置的方法是静态方法，且内部是有缓存的，即实际只是执行了一次获取，因此这个数据和 ApollxxxInitializer里获取的一样--是同一个；监听器最终加到 了 AbstractConfig.m_listeners:List<ConfigChangeListener>里。。。
			>新配置下发：最终肯定要修改 DefaultConfig.m_configProperties,   得到新属性Properties，后@onRepositoryChange()开始： 前后比对@updateAndCalcConfigChanges() 得出新增的、删除的、更新的key,分别封装为不同类型的new ConfigChange()-->这样就得出了一个List<ConfigChange>;;由于m_configProperties 是一个AtomicReference对象，所以直接将新的set()进来即可---此时就已经变更了内部的配置了；2.增加配置版本；3.将List<ConfigChange>配置变更列表转为map封装到 new ConfigChangeEvent() 发送出去：即调用m_listeners每个具体listener发送出去：且是异步方式发送@fireConfigChange()。。。。
				>新属性Properties的得到过程：new RemoteConfigRepository()内部--->1.RemoteConfigRepository.schedulePeriodicRefresh()(每隔5min执行一次)->.trySync()-->.sync()主动拉取并比对，如果变更了则@this.fireRepositoryChange()-->遍历listeners:RepositoryChangeListener:listener.onRepositoryChange()  。。。 2. scheduleLongPollingRefresh()长连接刷新-->startLongPolling()-->延迟2s后执行@doLongPollingRefresh()--->无限循环中：Ralimiter限流次/5s,休眠5s:TimeUnit.SECONDS.sleep(5), 后主动请求服务端:get方式："http://xxx/.../notifications/v2", 响应为List<ApolloConfigNotification>,通知，然后通知给实际的每个repository: @notify(), 每个ApolloConfigNotification 包含 名称空间，对每个通知，遍历所有的 名称空间相关的仓库：m_longPollNamespaces.get(namespace):Collection<RemoteConfigRepository>,遍历每个仓库，调remoteConfigRepository.onLongPollNotified()-->内部再次异步调用@trySync()。。。。。结论就是 5s后新配置会被主动拉取而开始生效。
					>注意：获取List<ServiceDTO> 时的 获取meta url : assembleMetaServiceUrl()-->@m_configUtil.getMetaServerDomainName() 是从apollo-env.properties里按环境获取的。
>spring-boot 配置文件 加载过程：ConfigFileApplicationListener。尝试 ./config/bootstrap.xml|yml|yaml|properties, 再到 ./config/application.xml|yml|yaml|properties
	>
>eurake: 
	>注册服务的过程：
	>初始化：EurekaAutoServiceRegistration-->EurekaServiceRegistry-->EurekaRegistration-->从bf里创建了new CloudEurekaClient:DiscoveryClient()对象--->内部启动调度任务initScheduledTasks(), 包括TimedSupervisorTask，即30s一次的心跳任务；另一个工作则是instanceInfoReplicator.onDemandUpdate() -->最终提交一个任务：执行 InstanceInfoReplicator.this.run()-->内容即discoveryClient:SessionedEurekaHttpClient:EurekaHttpClientDecorator.register()，注册内容就是 将 一个 InstanceInfo 实例 发送  ,转给了 RetryableEurekaHttpClient.execute()-->RedirectingEurekaHttpClient.execute()-->MetricsCollectingEurekaHttpClient.execute()-->com.netflix.discovery.shared.transport.jersey.AbstractJerseyEurekaHttpClient#register(InstanceInfo)-->com.sun.jersey.api.client.Client#handle(ClientRequest)-->EurekaIdentityHeaderFilter-->GZIPContentEncodingFilter-->com.sun.jersey.client.apache4.ApacheHttpClient4Handler#handle(ClientRequest)-->终于转到了org.apache.http.impl.client.DefaultHttpClient.execute()
>zuul: 
	>引入：spring.factories里：ZuulServerAutoConfiguration/ZuulProxyAutoConfiguration。
		>注意：配置类里的@Bean注解的方法对应的bean，bd阶段仅仅包括name=methodName,resovledTargetClass=返回值Class, factoryMethodName=方法名；；实例化阶段，从@doCreateBean()内就直接-->createBeanInstance()-->发现 factoryMethodName不是空 就 @instantiateUsingFactoryMethod(beanName, mbd, args)工厂方法方式实例化了(bf.instantiationStrategy:CglibSubclassingInstantiationStrategy:SimpleInstantiationStrategy.instantiate()内部实现策略很直接--反射调用该@Bean注解的方法而已)(对于实例方法，则这个@Bean注解的mbd.factoryBeanName=所在的配置类的完整限定名--需要先getBean()得到-->在@instantiateUsingFactoryMethod()有表现)。
	>actuater 引入：WebFluxEndpointManagementContextConfiguration/JmxEndpointAutoConfiguration	
	>服务器的启动：一般都是随着生命周期 开始的：即 refresh()->finishRefresh()-->getLifecycleProcessor().onRefresh()(后才是发布上下文刷新完成事件)-->实现类：DefaultLifecycleProcessor.调用startBeans()-->取出所有 lifecycleBeans(bf里取Lifecycle.class类型)， 后按Phased分组排序：从小值的开始：start()启动；对每个Lifecycle 对象，先启动它的所有的依赖，再启动它自己bean.start()；。。。例如：org.springframework.boot.web.reactive.context.WebServerStartStopLifecycle，它的启动核心为：@NettyWebServer.start()-->实现为异步：HttpServerTcpConfig..onDispose().block(); 这个就是 reactor.netty.DisposableChannel#onDispose()范围了。reactor-netty.jar/ reactor-core.jar
	>实例化后：MeterRegistryPostProcessor-->MeterRegistry-->MeterBinder-->io.micrometer.core.instrument.binder.hystrix.HystrixMetricsBinder-->com.netflix.hystrix.strategy.HystrixPlugins-->ConfigurationManager-->DynamicURLConfiguration-->URLConfigurationSource
	>注：@PostConstruct 注解的方法的执行时机---CommonAnnotationBeanPostProcessor:InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization()即初始化方法调用之前(显然此时已经属性填充完毕了)
	>注：仅仅@ConfigurationProperties 注解的类的bd 构造和注册的时机：refresh()->invokeBeanFactoryPostProcessors()-->ConfigurationClassPostProcessor 处理时-->this.reader.loadBeanDefinitions(configClasses)时-->处理 PropertySourceBootstrapConfiguration 这个配置类时(类上有@EnableConfigurationProperties(PropertySourceBootstrapProperties.class)这个注解很多类上也有)，这个注解@Import得到的仓库为EnableConfigurationPropertiesRegistrar----即在解析这个配置类而从仓库导入bd阶段@loadBeanDefinitionsFromRegistrars()时就会执行：@registrar.registerBeanDefinitions(), 注册的bd:ConfigurationPropertiesBindingPostProcessor/ConfigurationPropertiesBinder.Factory/ConfigurationPropertiesBinder/BoundConfigurationProperties/ConfigurationBeanFactoryMetadata/; 间接注册的：注册@EnableConfigurationProperties注解上的value 即 PropertySourceBootstrapProperties 类 用 ConfigurationPropertiesBeanRegistrar.register(value) 实现，这个类 PropertySourceBootstrapProperties 上有@ConfigurationProperties注解，先获取它的值"spring.cloud.config."，然后构造bd名称="spring-cloud-config-org.springframework.cloud.bootstrap.config.PropertySourceBootstrapProperties", 最后再注册bd, 这就是配置类的bd解析注册过程；可见就是和普通配置类一起解析的 。
		>如果没有@EnableConfigurationProperties 专门引入的配置类，而是配置类自己@Configuration +@RefreshScope +@ConfigurationProperties ， 则bd类型=org.springframework.cloud.context.scope.GenericScope$LockedScopedProxyFactoryBean， 实例化时，因为是个工厂bean, 内部创建 GccWorkerProperties 的动态代理 存到了bf，然后在 RefreshScope.start()时候 取出这个 然后 调用 获取了动态代理，在初始化时候 一个 BeanPostProcessor:ConfigurationPropertiesBindingPostProcessor 进行 反射设置属性值； 。。。总结：发事件的时候 才 执行 bd的构建方法，(而此时 bf里已经有 @ConfigurationProperties 注解类的GenericScope$LockedScopedProxyFactoryBean 实例了----但名称是"gccWorkerProperties")；而此时在RefreshScope里的bd的构建的name="scopedTarget.gccWorkerProperties"(这个bd.scope="refresh"(其他值如"singleton")(beanClass=com.glodon.gtcp.gtc.configuration.GccWorkerProperties$$EnhancerBySpringCGLIB$$f7c0dbee---是GccWorkerProperties的动态代理类也是子类 也是 resovledTargetType) 所以被调用创建了---此时bf里还没有)，创建时因为是子类--所以父类构造方法自然也会执行；此时构造之后显然是空的，	后面 初始化方法之前的 ConfigurationPropertiesBindingPostProcessor 处理后 才绑定设置了属性；
			>注：常规的bd实例化 仅仅 是 bd.scope="singleton"或者""的 bd进行实例化：即@preInstantiateSingletons()的实例化----最后放到了单例池里：@doGetBean()-->@getSingleton()这个方法放进去了；如果scope不是单例 也不是 "prototype" 原型(这种方式 内部不缓存)  ，则调用bf.scopes:Scope.get() 内部创建对象后 放到 RefreshScope:GenericScope.cache:map 里----->从而以后 getBean()的时候实际上就 还会原路走一遍---但是此时缓冲里有直接就取出来了。。。。在比如 SessionScope/RequestScope 则把bd创建结果放到 RequestContextHolder.currentRequestAttributes():ServletRequestAttributes 这个对象里(setAttribute(x,x)): 分request/session: this.request.setAttribute(name, value)/session.setAttribute(name, value)
				>注： bd构建中 ，@RefreshScope 会带来 被注解类的代理：AnnotationConfigUtils.applyScopedProxyMode()-->ScopedProxyCreator.createScopedProxy()， 里面就是 确定name="scopedTarget." + originalBeanName;  注册bd, scope="refresh".beanClass="原类"；到外层后，再注册一个scope="", beanClass="org.springframework.aop.scope.ScopedProxyFactoryBean" 类的，name=originalBeanName 的 bd, 且 他的.decoratedBeanDefinition=前一个bd;;;这样，有@Scope.class 注解的 类 就有2个bd, 且scope不同 而放在不同的位置；；而知道 "scopedTarget.xxx" 名的 bd 在事件发送的时候创建bd为bf且 beanPostProcessor 反射设置属性而封装好，而 originalBeanName 创建的bean已经创建好--是 ScopedProxyFactoryBean类型，工厂类型--返回的是一个代理，这个代理在调用方法(get属性)的时候，走的通知/回调=DelegatingIntroductionInterceptor(封装为DefaultIntroductionAdvisor)--->invoke时直接交给 内部委托delegate=DefaultScopedObject(内部封装了bf+ "scopedTarget.gccWorkerProperties") 来调用相关方法..。originalBeanName 的bean调用方法时：先走了 org.springframework.cloud.context.scope.GenericScope.LockedScopedProxyFactoryBean.---因为找到的advice=org.springframework.cloud.context.scope.GenericScope.LockedScopedProxyFactoryBean 这个类是 子类， 调用getObject() 就是父类的方法，从而获得了代理proxy;----这个就是 配置实体 的代理类，从而可以得到实际的数据。。。LockedScopedProxyFactoryBean 设置的位置：bd配置类PostProcessorRegistrationDelegate设置和后置处理的时候：spring-cloud的一个Processor:GenericScope 将 @beanClass=ScopedProxyFactoryBean类型就重新设置=LockedScopedProxyFactoryBean，(导致bd.resolvedTargetType= org.springframework.cloud.context.scope.GenericScope$LockedScopedProxyFactoryBean)，，从而构造"gccWorkerProperties"的bean时实际类型是 LockedScopedProxyFactoryBean， 且它是个 MethodInterceptor类型，从而是个Intercepter, 在它@setBeanFactory()时就把自己加入了proxy的 advice里了。所以调用的时候 走的拦截器还是它；
	>一次请求的过程： 能串联起所有的事情。
		>DiscoveryClient.refreshRegistry(): 包含内容：1.从服务端获取配置并存储在本地：@getAndStoreFullRegistry(),; 2. 发送心跳事件：publishEvent(new HeartbeatEvent()); 3.监听者 获取服务名：@discoveryClient.getServices(), 服务名转路径@mapRouteToService(serviceId)(内部用ServiceRouteMapper实现)， 转成的路径如"/eureka-application/v1/**", 服务名和方法都封装到new ZuulRoute()里存到routesMap:key=服务名,val=ZuulRoute, 这个Map设置到 org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator.routes 里。
		>请求 到达 DispatcherServlet:  @doDispatch(request, response), 先寻找请求对应的 handler: @getHandler(processedRequest),此时 DispatcherServlet.handlerMappings 里有 ZuulHandlerMapping(毕竟 初始化 从bf里获取的HandlerMapping.class类型全部)， 这个mapping 覆写了lookupHandler(lookupPath, request)， 入参路径=uri, 开始了匹配服务的过程；1.先再注册Handler: 先获取到route List：List<Route> 然后遍历这个list: 将route.urlPath 和固定的ZuulHandlerMapping.zuul:ZuulController 作为入参调父类进行注册：@AbstractUrlHandlerMapping.registerHandler() 就注册到了 AbstractUrlHandlerMapping.handlerMap里；2.注册完成调父类方法来匹配Handler:@super.lookupHandler(urlPath, request) 这个urlPath显然是请求的，所以很长，直接匹配不行，所以进行匹配：AbstractHandlerMapping.pathMatcher:AntPathMatcher.match(urlPath, pattern) pattern模式就是 handerMap.keys() 即注册的路径集合；；一旦匹配到了，则取出key对应的value:Handler:ZuulController 出来，同时找到路径uri被模式匹配到之外的剩余部分,来参与构建拦截器链:@buildPathExposingHandler()-->拦截器链里一个new PathExposingHandlerInterceptor(bestMatchingPattern, pathWithinMapping)。。。。到外部之后，开始获取拦截器链的Handler 来进行 环绕处理：有4种Adapter可能支持 Handler:adapter.supports(handler)--->判断方式是看这个Handler的类型：Controller/HttpRequestHandler/HandlerFunction/HandlerMethod/Servlet, 是其中一种即可，得到之后用这个ha.handle()进行处理，-->内容就是调Handler:@((Controller) handler).handleRequest(request, response) 来处理；从而转到了ZuulController，--->后者直接进行 servlet转发：@ZuulServlet.service():-->内容为三个阶段：preRoute()->route()->postRoute()
			>过程：ZuulServlet-->ZuulRunner-->FilterProcessor-->找到所有的"pre"类型的 List<ZuulFilter>， 遍历 @processZuulFilter()-->对每个：filter.runFilter()-->ZuulFilter-->Servlet30WrapperFilter.run();;; 2. route(): 也是找到所有的"route"类型的 List<ZuulFilter>，之后遍历：如 RibbonRoutingFilter ，内部将构造请求执行，后得到 ClientHttpResponse 结果，如 调 http://10.2.96.11:9001/projects/1/file/listAll?projectId=1 。。。 3.postRoute()自然是 "post" 类型的ZuulFilter的处理：SendResponseFilter，添加报头 回写 数据而已；
	>zuul 管理的服务列表的更新： DynamicServerListLoadBalancer.restOfInit()方法开始：1.周期查询/监听方式获取服务的服务器列表并保存到本地@enableAndInitLearnNewServersFeature() 2.主动获取的方法@updateListOfServers()， 2.1长轮询/周期调用的类：PollingServerListUpdater；2.2监听变更消息/通知类：EurekaNotificationServerListUpdater---即先注册一个listener:EurekaEventListener:@eurekaClient.registerEventListener(this.updateListener) 收到之后重新请求完整的：@updateListOfServers()
		>
	>zuul 负载均衡 的过程： RibbonRoutingFilter 开始：@buildCommandContext()-->内部自定义的RequestContext:是ConcurrentHashMap的子类；存了：serviceId/retryable/loadBalancerKey(显然和负载均衡有关) 等信息，2. 构造uri: @this.helper.buildZuulRequestURI(request) 后和其他信息 如 loadBalancerKey 一起封装到new RibbonCommandContext()里，3.开始forward()-->先创建命令：@ribbonCommandFactory.create(context):RibbonCommand 此时不同的工厂则返回不同的命令类型---一般和客户端http类型有关：如 HttpClientRibbonCommandFactory 创建HttpClientRibbonCommand，封装过程实际上 用clientFactory获取了三个实现：入参都是 serviceId---即服务id, @getClient(serviceId, RibbonLoadBalancingHttpClient.class)/ @.getLoadBalancer(serviceId):DynamicServerListLoadBalancer:ILoadBalancer / @getClientConfig(serviceId):IClientConfig, 内部实现都是 context.getBean(type) 从bf里获取的(每个服务都有一个context/即是专门创建的上下文new AnnotationConfigApplicationContext()并缓存起来-->向里面注册了几个配置类：RibbonAutoConfiguration/RibbonEurekaAutoConfiguration/PropertyPlaceholderAutoConfiguration, 一个数据源：new MapPropertySource()(数据源kv仅仅为:"ribbon.client.name"->"gtc-service-v4, 然后开始刷新context.refresh()----刷新会将spring.factories里的ZuulProxyAutoConfiguration/ZuulProxyAutoConfiguration也带进来)命令创建好后，执行它AbstractRibbonCommand:HystrixCommand|RibbonCommand@HystrixExecutable.execute() 实现类HystrixCommand的内容很简洁：@queue().get()
		>queue(): 返回一个Future()对象。内部实现：两部分：1.toObservable().toBlocking().toFuture() 返回一个委托类实例Future:delegate，2. 构造一个new Future() ，而它的各个实现都是 调委托类，除了@cancel()方法较复杂；不止调委托类---还可能 获取 执行线程executionThread 而中断它；
			>toObservable(): 注册一个回调，进行异步执行命令；命令就是它自己：AbstractCommand; 先构造6个回调实例： 分别封装的 钩子函数(在命令状态为特定值时调用钩子函数) 为： 
				>1.主要在‘用户代码执行’ 命令状态下 执行@handleCommandEnd();  内部：先封装 剩余时间 等 到 一个new ExecutionResult()对象，然后调用@HystrixCommandMetrics:metrics.markCommandDone() 内部转和当前线程相关的@HystrixThreadEventStream.executionDone() -->内部仅仅@HystrixCommandCompletion.from()封装到new HystrixCommandCompletion() 然后发送出去：@rx.subjects.PublishSubject.onNext(event) 此时已经是rxjava.jar范围。 。。markCommandDone()之后执行命令：endCurrentThreadExecutingCommand.call()：：实际一种：1.Hystrix.startCurrentThreadExecutingCommand()创建的lamda表达式：内容很简单-调@endCurrentThreadExecutingCommand(list) 仅仅弹出 list一个元素；
				>2. 取消订阅：用户码 + 观察链创建 两个状态下：@executionHook.onUnsubscribe(_cmd) 后 @handleCommandEnd() 取消订阅毫无内容；
				>3.执行熔断机制：非 取消订阅状态下 调@applyHystrixSemantics()--> 内容：1.开始：@executionHook.onStart(_cmd)---仅仅为标记--无实际意义；2.每个请求都会调用的@HystrixCircuitBreaker：circuitBreaker.allowRequest() 是否要允许(含半开逻辑) 允许 则继续， 不允许 则 回退@handleShortCircuitViaFallback()
					>HystrixCircuitBreakerImpl.allowRequest()判断是否允许通过：内容：1.@properties.circuitBreakerForceOpen() 电路是否打开了，是则返回false不允许；然后看是否已经闭合@properties.circuitBreakerForceClosed()， 是则@isOpen()查看错误后仍然返回true; 剩余情况：关闭或者允许单个测试：@!isOpen() || allowSingleTest()
						>isOpen(): 内部标记circuitOpen，如果开，则返回true; 否则：看健康状态：metrics.getHealthCounts()， 得到 HealthCounts， 看2项指标：1.总请求数是否小于设定：health.getTotalRequests() < properties.circuitBreakerRequestVolumeThreshold()， 小于则正常；2.错误比例小于阈值：health.getErrorPercentage() < properties.circuitBreakerErrorThresholdPercentage() 则正常；否则就要设置电路为断开，且设置circuitOpenedOrLastTestedTime为当前时间；
						>allowSingleTest(): 如果当前链路断开， 且 circuitOpenedOrLastTestedTime + properties.circuitBreakerSleepWindowInMilliseconds() 休眠了足够久，则返回true--允许 ；并更新circuitOpenedOrLastTestedTime为当前时间；
					>允许之后：看执行策略：信号量 还是 默认的；TryableSemaphoreActual 类型的信号量；开始执行@executionSemaphore.tryAcquire() 并在成功后 后执行@executeCommandAndObserve()后 释放信号量。	
						>executeCommandAndObserve(cmd)(此时cmd=HttpClientRibbonCommand): 4个回调的构造；异常回调 + 状态标记 ； 先在特殊隔离机制下执行命令：@executeCommandWithSpecifiedIsolation(_cmd) (Observable 对象可以累加操作运算符，就像stream()集合的流式计算一样)： 内容：1.先标记开始，后设置executionHook.onExecutionStart(_cmd)之类，最后执行Observable@getUserExecutionObservable():@getExecutionObservable(): 对 HystrixCommand 的实现：核心为调用@Observable.just(run())而这个run()的实现：AbstractRibbonCommand--->内部就是this.client.execute(request, config) 可见还是http请求。
							>当执行到Observable.just(run())时：实际上下一步也走了 AbstractRibbonCommand.run()-->内部先创建了new RibbonApacheHttpRequest(this.context)请求实例，后调用了@this.client.executeWithLoadBalancer(request, config)-->client=RibbonLoadBalancingHttpClient,方法的实现：AbstractLoadBalancerAwareClient，-->先构建负载均衡命令：@buildLoadBalancerCommand()-->后提交命令command.submit()
								>buildLoadBalancerCommand(): 构建重试处理器：new RequestSpecificRetryHandler(); 后构建 new LoadBalancerCommand<T>(this) 命令。
								>submit(): 它的回调类：已经注入了Server: 利用server 先重构uri: @reconstructURIWithServer() 此时就会产生URI：确定host和path: 如"http://10.2.96.11:9001/projects/1/file/listAll", 然后主要执行@Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig))--->就到了 RibbonLoadBalancingHttpClient.execute()内部构造请求后@this.delegate.execute(httpUriRequest)-->委托类就是org.apache.http.impl.client.CloseableHttpClient， 所以到了 httpclient.jar
									>submit():主实现--非回调：为@selectServer()-->核心实现：@LoadBalancerContext:loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey)--->内部核心：@ILoadBalancer:lb.chooseServer(loadBalancerKey)--->内部核心：@IRule:rule.choose(key), 默认是 new RoundRobinRule() 规则；@lb.getAllServers():List<Server> 得到后自增nextServerIndex, allServers.get(nextServerIndex):Server 得到的就是选择的Server;
	>zuul 链路熔断 的过程： 
>archaius: 从 数据库/url路径获取kv;		
>curator 是zk客户端：curator 的 分层模型、域模型  
	>直接使用zk处：org.apache.curator.utils.DefaultZookeeperFactory:ZookeeperFactory.newZooKeeper()-->内部就 new ZooKeeper()初始化了客户端zk。
		>来源：new CuratorFrameworkImpl() 实例化时，从入参builder里获取了ZookeeperFactory,然后层层注入：CuratorZookeeperClient-->ConnectionState-->HandleHolder, 而在 new HandleHolder.Helper()里，直接用zk工厂实例化得到zk 放到 zooKeeperHandle 属性。
			>来源：CuratorFrameworkFactory.Builder.build():new CuratorFrameworkImpl(this)--:注入的factory就是写死的：new DefaultZookeeperFactory()。其他写死的：DefaultACLProvider
				>来源：则是用户自己配置获取CuratorFramework。
>spring-cloud ： 
	>@SpringCloudApplication 注解： 被注解：@SpringBootApplication/@EnableDiscoveryClient/@EnableCircuitBreaker 服务发现客户端和电路熔断器 注解 是独有的。
		>对于 @EnableDiscoveryClient 注解的@Import引入的类：EnableDiscoveryClientImportSelector---引入AutoServiceRegistrationConfiguration, 配置引入ConfigurationPropertiesBindingPostProcessorRegistrar/ConfigurationPropertiesBeanRegistrar 两个仓库，前一个仓库注入的是@EnableConfigurationProperties注解属性里配置的类，后一个仓库 引入两个bean: ConfigurationBeanFactoryMetaData:BeanFactoryPostProcessor/ConfigurationPropertiesBindingPostProcessor:BeanPostProcessor --属性绑定有关(@ConfigurationProperties上配置的属性)。。另外则是 父类 用 SpringFactoriesLoader 加载 spring.factories 里的 EnableDiscoveryClient 配置项的类名：就是 spring-cloud-netflix-eureka-client.jar里的 EurekaDiscoveryClientConfiguration---引入了bean: EurekaHealthCheckHandler/EurekaClientConfigurationRefresher。
		>对于 @EnableCircuitBreaker 注解的@Import 引入的类：EnableCircuitBreakerImportSelector---直接用父类，父类用 SpringFactoriesLoader 加载 spring.factories 里的 EnableCircuitBreaker 配置项的 所有实现类名--spring-cloud-netflix-core里就是 HystrixCircuitBreakerConfiguration --- 里面有一个切面：HystrixCommandAspect(将对有@HystrixCommand/@HystrixCollapser注解的方法进行进行around拦截)。
	>zuul: 网关：@EnableZuulProxy 被注解：@EnableDiscoveryClient/@EnableCircuitBreaker
		>ZuulFilter的子类的管理：
		>核心类：FilterRegistry内部 String--ZuulFilter 的map: filters . 这个仓库对象转入到 new FiltersEndpoint()里作为一个bean。
			>ZuulFilterInitializer: 将自己的filers放到 自己的仓库属性 FilterRegistry 里。
		>一次请求的处理过程：DispatcherServlet-->SimpleControllerHandlerAdapter-->ZuulController(为disptacherServlet匹配到的hanlder)-->父类：-->内部属性servletInstance=ZuulServlet-->路由到zuulRunner:ZuulRunner--->直接到 FilterProcessor-->找到匹配的过滤器ZuulFilter:RibbonRoutingFilter.run()(得到结果):SendResponseFilter-->执行runFilter():内部实现：写入tomcat:CoyoteOutputStream
		>核心领域： ZuulFilter/ZuulServlet/RibbonRoutingFilter/LoadBalancerContext/AbstractLoadBalancerAwareClient/RibbonLoadBalancingHttpClient/HystrixCommand
			>
	>各种 Conditional的 定义 和 使用： 
		>@Conditional(OnClassCondition.class)：@Conditional(DefaultDispatcherServletCondition.class)： 被注解的类 被注册之前需要满足的value指定的条件Condition：条件类都是继承SpringBootCondition/FilteringSpringBootCondition的,实现getMatchOutcome(context)方法，方法内部实现一般是从入参获取bf,然后获取bdMap里的相关信息，进行使用判断，然后返回一个ConditionOutcome对象--表明是否匹配及其说明信息。条件被使用：ConfigurationClassParser.processImports().processConfigurationClass()解析配置类的时候-->首先就是指挥/调用 ConditionEvaluator.shouldSkip()内Condition:condition.matches()内SpringBootCondition:getMatchOutcome()，匹配到了则skip不会解析这个配置类直接return。也在 processImports()内selector.getExclusionFilter()时：判断是否需要过滤： AutoConfigurationImportSelector.shouldExclude().filter()-->AutoConfigurationImportFilter.match()-->FilteringSpringBootCondition.match()
			>配置例子：DispatcherServletRegistrationConfiguration上配置了，条件 的实现方法进行的判断 就是如果 bf里有 "dispatcherServlet" 名称的bean但是类型不是	DispatcherServlet,那么就不匹配。
			>配置例子2：@ConditionalOnProperty(prefix = "spring.mvc.hiddenmethod.filter", name = "enabled", matchIfMissing = false)
		>@ConditionalOnProperty(value = "hystrix.stream.endpoint.enabled", matchIfMissing = true): 被注解类 如果 在Environment 未发现value指定的属性，则使用matchIfMissing默认值。这个注解被@Conditional(OnPropertyCondition.class)注解---即是用这个条件OnPropertyCondition来实现它的功能的。注意Environment:PropertyResolver ， 所以从ConditionContext 获取到Environment后，可以用来查属性值：resolver.containsProperty(key)|resolver.getProperty(key)--->多态量的实现类：PropertySourcesPropertyResolver, 内部.propertySources:PropertySources属性来实际存储，如果取得的key的value有占位符，则调PropertyPlaceholderHelper 来解析和替换；最后有必要会调 conversionService来convert。
		>@ConditionalOnWebApplication(type = Type.SERVLET) ：要求当前应用是servlet应用。
			>配置例子：DispatcherServletAutoConfiguration上配置了。
		>@ConditionalOnClass({ Endpoint.class, HystrixMetricsStreamServlet.class }) ：classpath上能发现指定的类-->因为内部实现是 Class.forName()反射来判断指定类是否可以被加载。自动配置类里使用。
		>@ConditionalOnMissingClass("org.springframework.boot.actuate.health.Health")： 要求bf里还没有指定类bean--实现关键：metadata.getReturnTypeName()查看被注解bean类型。自动配置类里使用。被@Conditional(OnBeanCondition.class)注解，即用OnBeanCondition条件实现的。@ConditionalOnMissingBean 无参数则直接表示匹配。
		>@ConditionalOnSingleCandidate(DataSource.class): bf里有 且是单例。
		>@ConditionalOnBean(MultipartResolver.class): 要求bf里已经有了指定类bean。
		>@ConditionalOnAvailableEndpoint
		>@AutoConfigureAfter(ServletWebServerFactoryAutoConfiguration.class) 
			>即在bd name的数组顺序上ServletWebServerFactoryAutoConfiguration就会先于DispatcherServletAutoConfiguration 
			>例子2：TransactionAutoConfiguration 上@AutoConfigureAfter(DataSourceTransactionManagerAutoConfiguration.class)
		>@ConfigurationProperties(prefix = "spring.mvc"): 被注解类的属性和外部.properties里的同名key绑定 并且这个被注解类被bean化到bf(证据)--->条件是这个被注解类需要被用在@EnableConfigurationProperties(WebMvcProperties.class)注解上。
			>例子：数据库配置的封装：DataSourceAutoConfiguration 自动配置类上 @EnableConfigurationProperties(DataSourceProperties.class) 注解，而 DataSourceProperties上 @ConfigurationProperties(prefix = "spring.datasource")
			>例子2： mybatis-plus: MybatisPlusAutoConfiguration 上 @EnableConfigurationProperties(MybatisPlusProperties.class)，MybatisPlusProperties 上 @ConfigurationProperties(prefix = Constants.MYBATIS_PLUS)
			>例子3：spring-boot-autoconfigure.jar 里TransactionAutoConfiguration 上@EnableConfigurationProperties(TransactionProperties.class) TransactionProperties 上 @EnableConfigurationProperties(TransactionProperties.class)
			>例子4：spring-boot-autoconfigure.jar 里 RedisAutoConfiguration 上@EnableConfigurationProperties(RedisProperties.class) RedisProperties上 @ConfigurationProperties(prefix = "spring.redis")
			>例子5： spring-cloud-commons.jar 里 LoadBalancerAutoConfiguration 上@EnableConfigurationProperties(LoadBalancerRetryProperties.class) LoadBalancerRetryProperties 上 @ConfigurationProperties("spring.cloud.loadbalancer.retry")
		>@EnableConfigurationProperties(WebMvcProperties.class): 将value类绑定其@ConfigurationProperties()指定的属性值 而 构造bd后 注册到 bdf.。ConfigurationPropertiesBeanRegistrar实现这个绑定和注册。
		>@Order: 
		>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10): 自动配置类的bd定义顺序。
		>@AliasFor(annotation = ConditionalOnMissingBean.class): 注解方法上的注解。
		>@Primary: 优先绑定
		>@ConditionalOnEnabledResourceChain : 也是基于@Conditional 实现。
		>@RefreshScope: AbstractBeanFactory.scopes 默认5个：request/session/refresh/websocket/application, 在 bf.doGetBean()里就查找bd的scope。有的bean就会存在某个scope.map里，当然bf里也有。
			>属性来源：apllo属性最后放到了这里：org.springframework.boot.context.properties.bind.Binder.Context#getSources()就是下面的。而Context实例来源：new Context()直接在Binder.bind()方法中。
				>SpringConfigurationPropertySource.propertySource:org.springframework.core.env.CompositePropertySource, 内部.propertySources 就有三个apollo的 ConfigPropertySource
					>apollo存储地：com.ctrip.framework.apollo.spring.config.ConfigPropertySource.source:com.ctrip.framework.apollo.internals.DefaultConfig
						>PropertyPlaceholderHelper 和 ConfigPropertySource 的关系：配置存在 PropertySource， 后者对象 存在 AbstractEnvironment.propertySources:MutablePropertySources 实例 ; 键的解析器 也存在 AbstractEnvironment.propertyResolver:ConfigurablePropertyResolver:PropertySourcesPropertyResolver(this.propertySources)实例
							>分别提供的接口：
								>propertyResolver.getProperty(key):  PropertySourcesPropertyResolver.propertySources 已经注入了 AbstractEnvironment.propertySources
									>解析过程: 1.用 propertySources 取得原始值 ；propertySource.getProperty(key) 2. 取得的值进行 占位符名 解析 为 实际值：@resolveNestedPlaceholders(value)-->实际交给了PropertyPlaceholderHelper.replacePlaceholders(),这个Helper认为的占位符开始结束是：${}，内部 走了经典的helper.@parseStringValue(value, placeholderResolver)其中placeholderResolver:PlaceholderResolver 是 一个方法引用：AbstractPropertyResolver::getPropertyAsRawString, 引用的实际方法就是：PropertySourcesPropertyResolver.getProperty(key,String.class) 即仍然是从 propertySources 里取 key对应的值；3. 转换为目标类型的值：convertValueIfNecessary(value, targetValueType) ---在getProperty(key)一个入参下 targetValueType=String.class 
										>parseStringValue(value, placeholderResolver): 上述知道，方法的  placeholderResolver 入参 就是方法引用，函数接口调用的PlaceholderResolver.resolvePlaceholder()方法 就是调用的 PropertySourcesPropertyResolver.getProperty(key,String.class)。。占位符 解析过程：1.找到 最外层的${,}@findPlaceholderEndIndex(), 取出包裹的内容，将它作为入参进行递归解析：@parseStringValue(), 从而这块内容 不会有${}了，记作s,然后从propertySources取实际值：即调用@placeholderResolver.resolvePlaceholder(s) ,如果这个实际值是null且valueSeparator不是null 则要取key的:冒号后的内容出来作为默认值---而冒号前段则递归解析得到值k--如果k不是null则解析值就是它--如果k是null则解析值是默认值，如果不是null 则这个实际值可能还是一个${}表达式，所以还要递归@parseStringValue()---当然此时这个${}表达式就不能在之前的解析中出现过--因为这样就陷入死循环了；这样把值 也解析过了，那么值就也一定没有${}了，记作w,然后把这个${}表达式替换为w:@result.replace(start,end,w); 接着start自然就赋值为end即可进行并列的下一部分的解析；
											>结论1：propertySource中，键和值都可以有${}表达式。
										>propertySource.getProperty(key): 是第一个重要步骤：从配置池取key对应的value: 所以跟这个 propertySource类型有关：
											>例如 org.springframework.core.env.CompositePropertySource 类型，则遍历内部的propertySources 来尝试 取, 
											>再比如 com.ctrip.framework.apollo.spring.config.ConfigPropertySource： 则是 用内部的com.ctrip.framework.apollo.internals.DefaultConfig#getProperty(key)来取，继续内部则是 两个地方：System.getProperty(key) 和 DefaultConfig.m_configProperties:Properties.getProperty(key)；
											>再比如 org.springframework.boot.context.properties.source.ConfigurationPropertySourcesPropertySource， 这个用来取key="spring.cloud.bootstrap.enabled" 这样的值，或者 spring.a[2] 这样的key的值，所以key本身都要解析：这个是通过@org.springframework.boot.context.properties.source.ConfigurationPropertyName.ElementsParser#parse()完成的；解析结果就是形成new Elements(source, start,end) start,end是两个数组，等长，表示source按.分的几段的每段的开始和结束pos；进一步封装到ConfigurationPropertyName()对象里， 然后输入给内部属性(集合类型,即有很多个,每个的具体数据源是不同的) SpringIterableConfigurationPropertySource:SpringConfigurationPropertySources:source.getConfigurationProperty(name)取出ConfigurationProperty对象，具体过程：先将name又转为 string:candidate, 后调SpringConfigurationPropertySource.propertySource:PropertySource:PropertiesPropertySource:MapPropertySource.getProperty(candidate)来取实际值, 内部就是 MapPropertySource.source:Properties.getProperty(key)而这个source里的值：64个，如"java.home"->,"java.class.path"->。 第二个 SpringConfigurationPropertySource的 数据源 为 SystemEnvironmentPropertySource, 包含如"JAVA_HOME"->"/xxx/"；
											--比如解析"${spring.cloud.bootstrap.name:bootstrap}"的过程：用PropertyPlaceholderHelper.parseStringValue()进行；没有最后提取了默认值。
											--注意属性的注入：ContextRefreshedEvent 发送时：即@refresh()->finishRefresh()-->publishEvent():SimpleApplicationEventMulticaster-->RefreshScope.eagerlyInitialize() 开始获取一批bean(有scope且非延迟)(名字如"scopedTarget.gccWorkerProperties")，才对@ConfigurationProperties 注解的类进行实例化：GenericScope.get(),在RefreshScope.onApplicationEvent()还在创建bean:@ConfigurationProperties注解的bean; 它的属性值的绑定：@initializeBean()-->applyBeanPostProcessorsBeforeInitialization()-->ConfigurationPropertiesBindingPostProcessor.postProcessBeforeInitialization()时-->ConfigurationPropertiesBinder.bind()来绑定-->JavaBeanBinder.bind()-->DataObjectPropertyBinder.bindProperty()--->Binder.bindProperty()找到每个属性的绑定值--->然后替换占位符@this.placeholdersResolver.resolvePlaceholders(result)，然后以反射的方式设置。很明显，对于所有bean, 在初始化调 ConfigurationPropertiesBindingPostProcessor 处理时，如果有@ConfigurationProperties 注解，则会创建一个封装了这个信息的 ConfigurationPropertiesBean 对象，然后才是开始实际的属性值上的绑定：this.binder.bind(ConfigurationPropertiesBean)：将配置类的属性 解析 为 key, 然后 用key从 enviroment 里取具体值；而这个bean名字是：前缀-完整限定名(这个是说明在构造bd的时候这么取名的,实际在ConfigurationPropertiesBeanRegistrar.register()完成命名,EnableConfigurationPropertiesRegistrar驱动命名)， 而构造一个new Binder:注入了 ConfigurationPropertiesBinder.propertySources---这个正是来自环境Enviroment,新增的PropertySourcesPlaceholdersResolver也是封装的同一个属性源；从而调@Binder.bind()两个入参：属性类+@ConfigurationProperties注解的前缀名，另一个是Handler; 注入的过程：1.@findProperty()发现前缀名对应的属性源，通过遍历属性源(即来自环境的 但封装为了ConfigurationPropertySource类型)，先用前缀名当key去 取， 一般显然没有值，然后找key相关的key:从SpringIterableConfigurationPropertySource.mappings这个包含了所有apollo配置的所有的完整key名的map---如果找到--则说明enviroment里有;  如果所有的数据源里都没找到，那么开始考虑前缀拼接：此时开始使用Binder.dataObjectBinders.bind(),转到JavaBeanBinder.bind():先 获取属性类的所有get/set方法 +field表明的成员属性，然后属性类以工厂方式实例化，然后遍历属性类每个属性(此时回到了Binder.bind())，入参即前缀append属性名(Element对象的append,相当于加了一个新段)形成新的name记作c，再次调用@findProperty()试图找到c作为key对应的value,即再次遍历所有的数据源；。。。。。注意: 在@bindObject()时候，自然会分绑定目标类的类型Bindable，如果发现是集合/map类型/数组--即@getAggregateBinder()不为空(MapBinder、CollectionBinder、ArrayBinder)，那么进行聚合绑定@bindAggregate();将key匹配的值反射方式调属性设置方法设置成功。。。。。绑定成功后，通过BeanSupplier.get()就将设置好的属性类实例 获取到了；---在@JavaBeanBinder.bind()就这样调用的；	注意；BeanSupplier来自Bindable.value-->即new BeanSupplier()里的内容；而这个来自propertiesBean.asBindTarget():Bindable,而这个实例来自构造：ConfigurationPropertiesBean.get(this.applicationContext, bean, beanName)，而构造过程中：bindTarget.withExistingValue(instance) 来将bf里的入参instance包裹了起来：实际就是Supplier的内容。
												>普通bean化的时间：AbstractApplicationContext.refresh()->@finishBeanFactoryInitialization()时候,bean化自然包括了 初始化；@PostConstruct
										>convertValueIfNecessary(value, string):	使用内部转换服务属性 来实际执行：AbstractPropertyResolver.ApplicationConversionService:conversionService.convert(value, targetType)， 转给 GenericConversionService.convert()-->内容：1.先从内部166个转换器中找出匹配目标类型的:converters.find(), 比如string就是无操作转换器：NoOpConverter, --->后使用转换器 转换：ConversionUtils.invokeConverter()--->converter.convert()无操作则直接返回；对于ArrayToCollectionConverter, 就会把数组转换为集合返回；
								>getPropertySources(): merge()
								>属性源添加时机：new StandardEnvironment() 时候 --> 添加了 new PropertiesPropertySource() 数据kv来自：System.getProperties(); 也添加了 new SystemEnvironmentPropertySource()-->数据kv来自：System.getenv()
									>第二处：spring-cloud里：BootstrapApplicationListener： new MapPropertySource() 只添加了两个kv:"spring.config.name"/"spring.main.web-application-type"
									>第三处：环境准备 事件发出时：HostInfoEnvironmentPostProcessor， new MapPropertySource() 添加了：“spring.cloud.client.hostname”、“spring.cloud.client.ip-address”。。同一个位置 ConfigFileApplicationListener：加载 classpath:/bootstrap.yml|xml|properties, 之后形成的 Document.propertySource  这个数据源的形成：YamlPropertySourceLoader.load()-->内部 new OriginTrackedMapPropertySource()-->kv值则来自new OriginTrackedYamlLoader(resource).load()：：这个解析出的值如："apollo.bootstrap.enabled"/"apollo.bootstrap.namespaces"->"application,gtcp.sdk,gtcp.common,gtcp.mq"
									>第四处：来自@EnableApolloConfig注解，后通过ApolloConfigRegistrar加到了PropertySourcesProcessor.NAMESPACE_NAMES中，然后在遍历这个集合时： Config config = ConfigService.getConfig(namespace); 封装为一个个new ConfigPropertySource() 再将集合封装到CompositePropertySource 加到 environment
									--额外的：新增一个数据源："feign"->new MapPropertySource():只一个kv:"feign.client.name"->"dd",  对每个配置文件其实都生成一个数据源："applicationConfig: [classpath:/application.yml]"-->new OriginTrackedMapPropertySource()::存值如 "server.port":9090
			>属性增加时间：prepreEnvironment时候 发事件 触发 ConfigFileApplicationListener.onApplicationEvent(), 触发了 org.springframework.cloud.client.HostInfoEnvironmentPostProcessor的执行，ApolloApplicationContextInitializer.postProcessEnvironment()的执行(这个初始化类来自apollo-client.jar/spring.factories)--->其中在initialize(StandardEnvironment)--->执行了从环境取名称空间后，封装数据源new CompositePropertySource()并填充数据：数据来源@ConfigService.getConfig(namespace)， 转换后添加到环境里：environment.getPropertySources().addFirst(composite)。注意这个 PropertySourcesPropertyResolver 里也有 propertySources, 这个来自AbstractEnvironment，最终还是来自Environment
				>也触发：org.springframework.boot.context.config.ConfigFileApplicationListener.load()的执行: 加载很多的配置文件，如bootstrap.yml, 
	>分布式锁：spring-cloud-alibaba	
	>分布式事务：XADataSourceAutoConfiguration
>baomidou：
	>从spring到mybatis到baomidou的过程：bd构造注入bdf阶段，bean构造并注入bf阶段	
		>MapperFactoryBean: 是一个工厂bean(在属性inject时就对每个Mapper新增了一个来获取getObject()实例)，所以看@getObject()-->getSqlSession().getMapper(this.mapperInterface)-->最终就是从MybatisMapperRegistry.getMapper()-->MapperProxyFactory.newInstance(sqlSession)-->生成Mapper的动态代理,h回调handler=MybatisMapperProxy。 mybatis-spring.jar 继承的 SqlSessionDaoSupport:mybatis-spring.jar有 sqlSessionTemplate:SqlSessionTemplate属性。而继承的 DaoSupport:spring-tx.jar
			>SqlSessionTemplate: 实现在 mybatis-spring.jar 接口 在 SqlSession: mybatis.jar
				>SqlSessionFactory:mybatis-spring.jar 实现在 DefaultSqlSessionFactory:mybatis.jar。。bean化是在自动配置类 MybatisPlusAutoConfiguration 里。用MybatisSqlSessionFactoryBean.-->调用new MybatisSqlSessionFactoryBuilder().build(targetConfiguration)--->父类new DefaultSqlSessionFactory(config)
					>Configuration: mybatis.jar
				>SqlSession:DefaultSqlSession  mybatis.jar
					>Executor:mybatis.jar
						>Transaction:mybatis.jar
							>Connection: rt.jar
		>MybatisMapperProxy: 回调类。运行阶段的接手类。它直接将接口、参数等封装到一个MybatisMapperMethod对象(构造时先根据接口名+方法名 从Configuration里取出 对应的 MappedStatement： 封装到 一个 SqlCommand对象里)，执行它.execute(SqlSession sqlSession, Object[] args)开始具体路由处理。---->根据SqlCommand表明的sql类型，分类转发，select类型下还会进一步区分。->
			>MybatisMapperMethod：继续驱动查询进度，核心即指挥调sqlSession.selectList(command.getName(), param)	, 多态量的接口和实现也是mybatis-xxx.jar里的。
				>SqlSession: 入参 多态量：SqlSessionTemplate，继续驱动进度。核心指挥调用 内部的动态代理类sqlSessionProxy(接口SqlSession,回调SqlSessionInterceptor).selectList(statement, parameter)，回调Handler也是mybatis里的。
					>SqlSessionInterceptor:内部SqlSession接口的动态代理Hanlder。继续驱动进度。调用集合包括：1.调用SqlSessionUtils来间接从事务管理器获取真正的SqlSession ; 2. 如果1没有获取到则从工厂SqlSessionFactory.openSession()获取sql会话：DefaultSqlSession。
						>SqlSessionUtils: 直接调用 TransactionSynchronizationManager.getResource(sessionFactory) 获取SqlSessionHolder,从而进一步获取SqlSession, 事务管理器来自spring-tx.jar。。如果没有则指挥 入参 SqlSessionFactory.openSession()获取 SqlSession, 而这个sessionFactory正是SqlSessionTemplate实例传过来的，而SqlSessionTemplate中的是自动配置实例化时 注入的 即这个实例为：DefaultSqlSessionFactory。最后得到 SqlSession 后尝试绑定到事务管理器TransactionSynchronizationManager.bindResource()条件是当前线程中的事务同步管理器是活跃的。
							>TransactionSynchronizationManager： 内部ThreadLocal:resources 是sessionholder存储池。但是可能为null。这个数据的注入bindResource()时机：事务管理器 在事务启动异常时 重新开启事务时 AbstractPlatformTransactionManager.getTransaction(TransactionDefinition)，或者 DataSourceUtils.doGetConnection(DataSource)获取连接时：--->而这个DataSourceUtils的调用者：JdbcTemplate.execute()/Transaction:SpringManagedTransaction.openConnection()/DefaultSqlSession.getConnection()/DatabasePopulatorUtils.execute()/TransactionAwareInvocationHandler:InvocationHandler.invoke(), 最后一个是动态代理的Handler，这个动态代理生成类 就是TransactionAwareDataSourceProxy:DelegatingDataSource:DataSource,代理的接口ConnectionProxy
							>DefaultSqlSessionFactory:  内部 核心指挥：1.从Configuration里取出Enviroment里的TransactionFactory-->这个来源来自MybatisSqlSessionFactoryBean.buildSqlSessionFactory()的实现代码里：实际正是如此--因为sqlSessionFactory的实例化方式就是这个；而这个实现里是明确注入Enviroment的transactionFactory=new SpringManagedTransactionFactory() 这个(顺便：MybatisSqlSessionFactoryBean里的dataSource也是直接自动配置类注入的)。 2. 调用这个事务工厂创建一个新事务：transactionFactory.newTransaction()-->即new SpringManagedTransaction(dataSource)这个事务。3.用configuration创建执行器：configuration.newExecutor()--而执行器类型则是配置mybatis-plus.executorType的值simple,所以新建了new MybatisSimpleExecutor:AbstractBaseExecutor:BaseExecutor:Executor, 可缓存而进一步封装到new MybatisCachingExecutor(executor)里，进一步封装拦截器进来：(拦截器为MybatisPlusAutoConfiguration的构造方法入参ObjectProvider<Interceptor[]> 注入的)(ObjectProvider:BeanObjectProvider:DependencyObjectProvider在DefaultListableBeanFactory里，调.getIfAvailable()就会进行实际按泛型类型从bf里获取)，即调interceptorChain.pluginAll(executor)将拦截器链内部List<Interceptor>逐个：interceptor.plugin(target) 层层包裹。常见拦截器：MybatisPlusInterceptor，包装过程：显然会是层层动态代理：Plugin.wrap(target, interceptor)-->内部取拦截器的@Intercepts.value的值形成类-方法set, 后开始构造动态代理：Proxy.newProxyInstance() 拦截器上注解的类就是要实现的接口，回调类是new Plugin(target, interceptor, signatureMap):InvocationHandler, 这个回调的invoke实现就是：取拦截器上注解的方法是否包括当前方法-->是则调当前的拦截器进行拦截interceptor.intercept(),否则直接方法反射。4.执行器封装到new DefaultSqlSession()返回。
						>Method: 即调用者接口SqlSession.selectList()方法。接口方法 + 现在获取到的实例，从而可以继续驱动前进： method.invoke(sqlSession, args)-->自然就是调用 DefaultSqlSession.selectList()
							>DefaultSqlSession: 继续驱动前进。调用配置取到匹配的MappedStatement,后用来 调用注入的Executor:MybatisCachingExecutor.query(statement,params),结果直接返回。因为Excutor是 Conficuration创建的，所以MybatisCachingExecutor 也是mybatis-plus里的，从而 重新回到了Mybatis-plus
								>MybatisCachingExecutor: 包裹了 MybatisSimpleExecutor,继续驱动前进。核心指挥调用： 1.用ms.getBoundSql()取到绑定的sql:BoundSql, 2.获取缓存Key：CacheKey, 都是mybatis.jar的多态量。3.使用绑定的sql开启查询
									>MappedStatement：获取绑定的sql: 回到了mybatis.jar。核心指挥 调用 1.ms内部属性sqlSource:SqlSource:DynamicSqlSource.getBoundSql(param) 获取绑定的Sql, 实际为RawSqlSource.getBoundSql(param)-->内部StaticSqlSource:sqlSource.getBoundSql(param)内部则直接new BoundSql()设置而返回。
										>DynamicSqlSource: 它的创建：Configuration.getDefaultScriptingLanguageInstance()得到LanguageDriver:XMLLanguageDriver后调它的.createSqlSource(script)创建--核心就是这个脚本script；具体创建过程：将script封装到new TextSqlNode(script)再new DynamicSqlSource(configuration, textSqlNode)而生成。而LanguageDriver所在	SqlRunnerInjector--->在MybatisSqlSessionFactoryBuilder中创建并调用它inject()(都在mybatis.jar)--->在SqlSessionFactoryBean中 调用构建器构建，但实际上调用者则是MybatisPlusAutoConfiguration 自动配置里的@Bean sqlSessionFactory()内使用MybatisSqlSessionFactoryBean.getObject()来获取到:new DefaultSqlSessionFactory(config);同理 sqlSessionTemplate(SqlSessionFactory)也是这么构建的new SqlSessionTemplate()。。---->这个bean在初始化方法内调用执行，由 MapperScannerRegistrar 引入；且在mybatais-plus-boot-starter.jar/META-INF/spring-autoconfigure-metadata.properties里配置了--这个配置文件是用来控制实例化先后顺序的：由AutoConfigurationMetadataLoader加载, 在AutoConfigurationSorter.AutoConfigurationClass 中会使用--如查找实例化前需要实例化的类名:封装到new AutoConfigurationClass()里-->并被AutoConfigurationSorter.getInPriorityOrder().sortByAnnotation()(内部实现就是getClassesRequestedAfter(className)得到应该在className之前的classNames，因为采用的是LinkedHashSet所以迭代器访问转为数组-元素是链表顺序--所以得到的这些自动配置类名是严格先后顺序的,129个,第一个MessageSourceAutoConfiguration/2PropertyPlaceholderAutoConfiguration/4ServletWebServerFactoryAutoConfiguration/5DispatcherServletAutoConfiguration)调用获取到--->后者被AutoConfigurationImportSelector.sortAutoConfigurations().selectImports()获取到返回-->从而在ConfigurationClassParser.processImports()时被加载。
									>AbstractBaseExecutor: 直接创建缓存键；new CacheKey();
									>查询转给委托属性MybatisSimpleExecutor:AbstractBaseExecutor 来完成,转到执行器 BaseExecutor.query()走查询流程，实际doQuery()则走MybatisSimpleExecutor的实现：阶段目标1：使用configuration构造语句处理器：StatementHandler: 直接新建new RoutingStatementHandler()内部委托为具体和sql相关类型: 如 PreparedStatementHandler 类型，内部构建自己的属性：参数handler+结果handler： 如 ParameterHandler:MybatisParameterHandler,ResultHandler:DefaultResultSetHandler 并经过插件过滤器链interceptorChain的层层包装；。2.准备语句prepareStatement()-->实现为：StatementHandler.prepare()入参有BaseExecutor.SpringManagedTransaction:transaction.getConnection()获取到的Connection--->这个连接实际上被动态代理了：被ConnectionLogger这个Handler包裹。然后使用handler参数化设置handler.parameterize(stmt)-->MybatisParameterHandler:parameterHandler.setParameters()对每个参数ParameterMapping设置：JdbcType/TypeHandler 找到对应的数据类型handler来设置：handler.setParameter()如IntegerTypeHandler-->实现非常经典：转调多态量java.sql.PreparedStatement:ps.setInt(i, parameter)从而交接给rt.jar接口实现类:PreparedStatementLogger作为Handler的动态代理(代理了的PreparedStatement接口的实例是Connection的实例获取的自然是驱动的实例,自然是驱动的com.mysql.jdbc.PreparedStatement:mysql-connector-java.jar)(它的ResultSet结果集方法的反射调用后的ResultSet也会被动态代理--Handler=ResultSetLogger)。 3.利用1得到的StatementHandler实际查询:handler.query(stmt, resultHandler) -->转发给委托属性 PreparedStatementHandler.query()，实际转手给java.sql.PreparedStatement来执行：PreparedStatement:ps.execute() 多态量的实现为Handler=PreparedStatementLogger的动态代理，代理的java.sql.PreparedStatement的实现类：com.mysql.jdbc.JDBC42PreparedStatement 或者有间接的com.zaxxer.hikari.pool.ProxyPreparedStatement(内部委托给JDBC42PreparedStatement)，因此回调反射调就执行了ProxyPreparedStatement.execute(),进一步调委托com.mysql.jdbc.PreparedStatement.execute() 就转手给了驱动；4.3执行后则开始用结果集Handler获取结果：DefaultResultSetHandler:resultSetHandler.handleResultSets(ps)--->内部核心：转调java.sql.Statement:stmt.getResultSet()来获取结果，多态量的实现类即PreparedStatementLogger，结果集封装到ResultSetWrapper对象后，DefaultResultSetHandler.getDiscriminatorValue()最终通过IntegerTypeHandler.getNullableResult(ResultSet rs, String columnName)-->rs.getInt(columnName)获取结果
			>数据源问题: DataSourceAutoConfiguration.PooledDataSourceAvailableCondition 中显式强行引用DataSourceBuilder, 其 build()方法可以创建数据源：依次尝试反射加载实例化和绑定：com.zaxxer.hikari.HikariDataSource/org.apache.tomcat.jdbc.pool.DataSource/org.apache.commons.dbcp2.BasicDataSource, 第一个会成功：因为@Configuration配置类PooledDataSourceConfiguration @Import了 DataSourceConfiguration.Hikari， 而此静态类@Configuration注解且有一个@Bean方法@dataSource(DataSourceProperties properties) 正是利用数据库配置DataSourceProperties-->封装了"spring.datasource"开头的.username/password/url/driverClassName  来创建；当Hikari 通过构造方法方式实例化后，当做配置类解析其内部@Bean就会创建这个数据源, 也是采用构造方法实例化HikariDataSource，。
>mybatis:
	>从spring到mybatis的过程：
		>核心领域：领域层次(引用关系)(属性引用、入参引用、局部变量引用)
			>dao接口类的指定类MapperFactoryBean的实例：MapperFactoryBean.mapperInterface=com.glodon.gtcp.gtc.dao.GtcCcpResolveTaskMapper 类的结构：MapperFactoryBean:SqlSessionDaoSupport:DaoSupport:InitializingBean/FactoryBean 
			>Configuration:MybatisConfiguration：全配置
				>MapperRegistry:MybatisMapperRegistry： MapperProxyFactory 仓库。同时用 MapperAnnotationBuilder 来解析 dao的xml。
					>MapperProxyFactory/MybatisMapperProxyFactory: 每个实例包含mapperInterface类，它的方法创建的Mapper接口的实例：Proxy.newProxyInstance()为动态代理，反射回调接口为 MapperProxy
						>MapperProxy/MybatisMapperProxy: 每个dao就有一个
							>SqlSession: 
					>MapperAnnotationBuilder:MybatisMapperAnnotationBuilder: @addMapper(Class<T> type) 解析dao 的xml	
						>loadXmlResource()：加载xml为流(同包同dao名xml文件)
							>XMLMapperBuilder: 
								>具体解析xml流.获取<mapper>的namespace属性后，具体一个个<mapper>节点下的各个节点<>的解析。
									>如 select|insert|update|delete: 每个节点用 XMLStatementBuilder.parseStatementNode() 解析，后用 MapperBuilderAssistant 解析 放到 MappedStatement.Builder 建造为 MappedStatement 对象放到 Configuration.mappedStatements:map, key=<>namespace.id 即名称空间+节点id
										>XMLStatementBuilder:  解析节点用：@parseStatementNode()-->内部先判断sql类型，后从配置里取LanguageDriver调.createSqlSource()-->内部用XMLScriptBuilder.parseScriptNode()-->内部根据Xnode解析生成List<SqlNode>而 封装到 MixedSqlNode:rootSqlNode,进一步封装到new DynamicSqlSource(configuration, rootSqlNode)；在动态解析sql时候就用这个SqlNode结构来用参数替换 就得到具体的sql:rootSqlNode.apply(DynamicContext:context)上下文就是configuration+parameter
											>SqlSource: DynamicSqlSource:
												>MixedSqlNode: 解析构成实际sql: apply(context)
													>TextSqlNode: 
														>GenericTokenParser: .parse(text)	解析"${xxx}"
															>BindingTokenParser:TokenHandler: @handleToken() 从绑定的参数里 取出 来使用： 如取 "_parameter"对应的参数值,后 ognl表达式处理：OgnlCache.getValue(content)即替换"ew.sqlSegment" 为 合法的sql带占位符的字符串" (ccp_task_id = #{ew.paramNameValuePairs.MPGENVAL1})" 
											>MapperBuilderAssistant: 
										>MapperBuilderAssistant: 
									>如 /mapper/resultMap 如 /mapper/parameterMap 
									>如 cache-ref: 解析放到 Configuration.cacheRefMap   
									>如 cache: MapperBuilderAssistant 建造一个 Cache  放到 Configuration.caches:map
								>用namespace的值当做类名反射加载 来当做mapper:	
						>parseCache(): dao类上缓存注解的处理：CacheNamespace如果有 也会 用MapperBuilderAssistant  建造一个 Cache 加到 Configuration.caches:map
						>dao的每个方法：调 @parseStatement(method)解析加入 configuration.mappedStatements；因为是先加入xml中的，所以如果dao里有重复的则不会加了。
						>dao类上缓存空间引用注解的处理：CacheNamespaceRef 。目的，引用某个 Cache	
						>注入mybatis-plus自己的基本CURD: 调用 GlobalConfigUtils.getSqlInjector(configuration).inspectInject(assistant, type) 实现---->核心为 因为dao继承了 BaseMapper 所以 直接获取它的这些基本curd方法，封装为AbstractMethod，逐个注入；m.inject()--->最终按m类型各自独立 调 builderAssistant.addMappedStatement()加入到Configuration.mappedStatements中。
							>Insert:AbstractMethod 加入的过程： 阶段目标: 1.拼装脚本sql字符串:insert+表名+列+值。2.用1的sql创建数据源languageDriver.createSqlSource(configuration, sql, modelClass)-->核心为用XPathParser.evalNode("/script") 来获得脚本对应的XNode； 过程为将脚本转 Document-->XPath:xpath.evaluate(expression, root, returnType:QName) 从而交接 转到rt.jar, QName也是rt.jar提供的领域； 得到Node ,封装到新的XNode对象-->mybatis使用来封装到XMLScriptBuilder对象来解析.parseScriptNode() 结束SqlSource的创建。3.调MapperBuilderAssistant:builderAssistant.addMappedStatement()将insert这个方法段 加入到Configuration.mappedStatements
								>XMLScriptBuilder: 解析Xnode节点： 阶段目标：1.解析Xnode为 MixedSqlNode: @parseDynamicTags(XNode)-->基本处理思想为：如果子节点是CDATA/TEXT类型则直接取出文本封装到new TextSqlNode()对象，如果不是动态sql则封装到StaticTextSqlNode；如果是ELEMENT类型则要取它name对应的Hanlder来专门处理：name=trim/where/set/foreach/if/choose/when/otherwise/bind等；handler则已经配置好了：直接找到NodeHandler-->如foreach对应的ForEachHandler， .handleNode(child),handle的过程就是递归获取节点属性+子节点MixedSqlNode, 最后一起封装到new ForEachSqlNode()对象里，然后顺序加到List<SqlNode> 集合里，解析完成自然将这个集合封装到new MixedSqlNode()对象里返回---：这个就是new DynamicSqlSource(configuration, rootSqlNode)的第二个参数。2.将1中DynamicSqlSource对象返回，从而结束 parseScriptNode()调用。
									>parseDynamicTags()里： 遍历子节点时会对每个子节点重新封装：node.newXNode(children.item(i))这个转移数据的过程new XNode()-->内部会解析Node里的数据，CDATA/TEXT时直接取内容，后用PropertyParser.parse(data, variables)来解析替换占位符"${}"：GenericTokenParser+VariableTokenHandler 组合的方式解析parser.parse(string)
						
			>启用@MapperScan()开始，引入注册仓库 MapperScannerRegistrar, 注册 一个 新增的bd: MapperScannerConfigurer	
>spring-tx: 小原理 
	>@EnableTransactionManagement: 作用：@Import了 TransactionManagementConfigurationSelector 选择器--->selectImports()了两个类：AutoProxyRegistrar/ProxyTransactionManagementConfiguration--->后者是一个配置类，它引入了@Bean类：1. AnnotationTransactionAttributeSource(内部注入事务注解解析类SpringTransactionAnnotationParser实例-->效果：解析org.springframework.transaction.annotation.Transactional注解里的内容：propagation/isolation/rollbackFor后封装到RuleBasedTransactionAttribute:TransactionAttribute()对象里返回:被使用时机AnnotationTransactionAttributeSource.determineTransactionAttribute()--->使用TransactionAttribute的实际：TransactionAspectSupport.invokeWithinTransaction()--->进一步则是TransactionInterceptor.invoke(MethodInvocation invocation)使用：方法即MethodInterceptor的，而MethodInterceptor已经是aop里的多态接口,所以是被spring-aop.jar框架调用: org.springframework.aop.framework.ReflectiveMethodInvocation.proceed():这个类实现了ProxyMethodInvocation:MethodInvocation:Invocation:Joinpoint， 而这个ReflectiveMethodInvocation被:CglibMethodInvocation/JdkDynamicAopProxy.invoke()强行new来使用, 而这两个类实现了java.lang.reflect.InvocationHandler接口--所以是回调类, 且 JdkDynamicAopProxy被DefaultAopProxyFactory 强行new来使用-->后者进一步被ProxyCreatorSupport使用-->ProxyFactoryBean.getObject().getSingletonInstance()--->在AbstractInterceptorDrivenBeanDefinitionDecorator:BeanDefinitionDecorator里有使用,用来定义RootBeanDefinition.beanClass; 另外ProxyFactory也引用DefaultAopProxyFactory, 且ProxyFactory.getProxy(ClassLoader)被十分广泛的使用--如AbstractAutoProxyCreator:SmartInstantiationAwareBeanPostProcessor:BeanPostProcessor,这个抽象类的子类：AbstractAdvisorAutoProxyCreator:AnnotationAwareAspectJAutoProxyCreator/DefaultAdvisorAutoProxyCreator/BeanNameAutoProxyCreator/InfrastructureAdvisorAutoProxyCreator---最后这个被AopConfigUtils引用-->则在AopAutoConfiguration/AutoProxyRegistrar中-->仓库显然在@EnableAspectJAutoProxy注解引入)/2. TransactionInterceptor 拦截器bean.3.Advisor:BeanFactoryTransactionAttributeSourceAdvisor
		>核心作用1：注册一个bd: BeanPostProcessor:InfrastructureAdvisorAutoProxyCreator; 它的实现/目的: 生成bean的动态代理，生成时机-BeanPostProcessor参与的两个重要时机：1.@doCreateBean()之前-实例化之前，2.@doCreateBean()内 初始化方法(环绕调用)调用 之后；(第4个时机实例化后在@populateBean()属性填充里)(第5、6个时机也在@populateBean()里，在实例化之后之后，为 "属性处理后"、“属性值处理后”)(时机依次为：实例化前、实例化后、属性处理后、属性值处理后、初始化前、初始化后)(其他时机：合并bd后)。。。。创建动态代理过程：1.获取所有合适的拦截器List<Advisor>：@getAdvicesAndAdvisorsForBean(); 总体来源：bds里找Advisor.class类型name拿来初步过滤(bd.role=BeanDefinition.ROLE_INFRASTRUCTURE即是后台角色,如@Bean有@Role(BeanDefinition.ROLE_INFRASTRUCTURE)注解，如TransactionInterceptor这个bean)后getBean()-->2.过滤：对每个Advisor: 如果是IntroductionAdvisor类型 则 它的ClassFilter 要匹配该bean类，如果是PointcutAdvisor类型 则 它的Pointcut的ClassFilter要匹配bean类 且 Pointcut的MethodMatcher 要匹配 bean类及其所有接口的所有方法中的一个(matches())(对于AspectJExpressionPointcut:MethodMatcher则是切点表达式匹配)-->3.对List<Advisor>排序：根据为OrderComparator比较器。4. 可以创建动态代理了：@createProxy():使用 new ProxyFactory()， 而惊奇的是 还有一部分 拦截器：AbstractAutoProxyCreator.interceptorNames(Advisor/Advice类型-->包装为Advisor) 会加进来(在前面) ，从而可以开始创建动态代理：proxyFactory.getProxy(getProxyClassLoader())。完成 BeanPostProcessor的功能。。。。注：创建的代理：如new JdkDynamicAopProxy(config)实例，其最终创建的动态代理，接口=找到过滤的那些+额外的可能3个:SpringProxy/Advised/DecoratingProxy, 回调类=JdkDynamicAopProxy 自己；而invoke()时访问的内部advised属性就是创建实例时注入的config,即JdkDynamicAopProxy.advised=config=ProxyFactory:ProxyCreatorSupport:AdvisedSupport:Advised 自己。。
			>在invoke()里利用advised 获取拦截器列表List<InterceptorAndDynamicMethodMatcher/Interceptor>：则实际来自：List<Advisor>的处理：对每个Advisor:1. 如果是PointcutAdvisor 类型则用 DefaultAdvisorAdapterRegistry.getInterceptors(advisor) 获取MethodInterceptor:Interceptor:Advice[], 具体过程：一个Advisor有一个 Advice,如果这个Advice是 MethodInterceptor 类型则直接加入返回结果MethodInterceptor[]，然后看Advice是否是AfterReturningAdvice/MethodBeforeAdvice/ThrowsAdvice 类型，是则对应加 AfterReturningAdviceInterceptor(advice)/MethodBeforeAdviceInterceptor(advice)/ThrowsAdviceInterceptor(advice)拦截器到结果集；；实际来看；一般只返回一个：如TransactionInterceptor:MethodInterceptor 则直接加而返回；对前向通知则返回：MethodBeforeAdviceInterceptor:MethodInterceptor。。。。实际Intercepter调用过程invoke():即1.对于AOP的Advice则在实际方法前后反射调拦截方法Advice.method；2.对事务拦截器：则实际方法前新建事务并开启，实际方法后提交事务或者关闭事务。  ....对其他Advisor 如IntroductionAdvisor也是同理获取拦截器：
				>invoke()后续：在获取了拦截器列表后，和Method/targetClass一起封装到 new ReflectiveMethodInvocation()开始调用.proceed()。。1.对InterceptorAndDynamicMethodMatcher类型拦截器(即pointcutAdvisor的pointcut.methodMatcher.isRuntime=true, 则这个Advisor的MethodIntercepter都要封装为InterceptorAndDynamicMethodMatcher): 则要进行动态方法匹配，匹配到了则调它的interceptor.invoke(this),没匹配则什么也不做，下一个拦截器；2.普通拦截器MethodInterceptor类型，则直接.invoke(this)
					>事务拦截器invoke()过程：1.获取方法上的事务注解属性--封装为TransactionAttribute对象；2.从bf里获取TransactionManager实例；3.要求pm必须是PlatformTransactionManager类型(即必须实现 获取事务/提交事务/回滚事务 接口)(此时实现类:DataSourceTransactionManager/JtaTransactionManager:AbstractPlatformTransactionManager, 前者则进入spring-jdbc.jar框架领域)。4.开始用ptm办事：4.1获取事务状态:tm.getTransaction(txAttr)(抽象类提供)-->内容：子类创建实际的事务对象：doGetTransaction()->如DataSourceTransactionManager的实现为 创建 DataSourceTransactionObject对象，并封装属性-事务可嵌套/ptm的数据源--由于此时如果是首次进入事务拦截器 则未绑定数据源和ConnectionHolder，所以DataSourceTransactionObject对象 没有ConnectionHolder,(如果存在事务则看 事务传播级别设置属性了)，再看事务传播级别，如果强制级别-则抛异常，如果要求有事务/嵌套/新事务 则 先悬挂@suspend(null)-->实际内容就是解绑 数据源-连接Holder 映射对：TransactionSynchronizationManager.unbindResource()得到旧连接Holder--后封装到new SuspendedResourcesHolder(suspendedResources)里，然后开启事务@startTransaction()-->内容：开启新事务状态后实际开启事务new DefaultTransactionStatus() + doBegin(事务注解对象+事务对象)-->如果事务对象里没有连接Holder 则创建一个(创建obtainDataSource().getConnection()后封装到new ConnectionHolder(newCon)毕竟数据源就在ptm里)，后设置连接Connection的事务隔离级别、是否只读、是否自动提交；如果强制只读 那么要用连接创建语句对象Statement来执行"SET TRANSACTION READ ONLY"语句; 开始绑定数据源和连接的关系TransactionSynchronizationManager.bindResource()以便在本线程内复用连接；doBegin就结束了，也是 startTransaction()的主要内容----可见根本主要做的事 就是 设置 Connection的 事务有关属性 + 绑定数据源和连接的关系以复用；。。tm.getTransaction()返回的对象就是当前Connection里的事务状态，外层则将它封装到一个new TransactionInfo()对象里。。。5.开始proceed()实际方法的执行；6.如果抛出了异常：如果异常是RuntimeException/Error, 则要回滚 txInfo.getTransactionManager().rollback()-->内容：有保存点则回滚到保存点@conHolder.getConnection().rollback((Savepoint) savepoint)否则直接回滚con.rollback()；；其他异常则不回滚 而是继续尝试提交txInfo.getTransactionManager().commit()--->内容：如果DefaultTransactionStatus.rollbackOnly=true则局部回滚processRollback()，否则全局回滚processRollback()--即回滚后还要抛出异常UnexpectedRollbackException:TransactionException:RuntimeException，再否则才真正提交processCommit()-->内容：有保存点则释放保存点conHolder.getConnection().releaseSavepoint((Savepoint) savepoint)，如果是新事务 则直接提交con.commit()，其他时候只取 status.isGlobalRollbackOnly()，值为true则要抛出异常：UnexpectedRollbackException。。可见即便是本次提交了也可能向外提交回滚异常；7.如果没有抛出异常，则直接提交txInfo.getTransactionManager().commit(),；8.最后返回方法proceed执行的结果；
		>核心作用2: 注入配置类bd: ProxyTransactionManagementConfiguration--带@Configuration注解：作用：引入三个bd:TransactionAttributeSource/TransactionInterceptor/BeanFactoryTransactionAttributeSourceAdvisor:PointcutAdvisor, 其中最后这个引用了前2个；而最后这个是个Advisor--很明显且是PointcutAdvisor类型--但是pointCut=TransactionAttributeSourcePointcut:StaticMethodMatcherPointcut:StaticMethodMatcher 表明ClassFilter默认匹配 且isRunTime=false所以不是动态方法匹配，而pointcut匹配方法的实现：为 方法上/类上 有spring的注解@Transactional (ejb/javax的注解都已废弃)，并用SpringTransactionAnnotationParser 解析这个注解 封装各个注解属性得到new TransactionAttribute()对象 缓存起来；；这个匹配方法matches()在上述 寻找所有候选Advisor时 用AopUtils 过滤时 也使用了matches()；。。。结论：显然一般的方法就不会被事务拦截器拦截；
	>执行时机：先是动态代理类走方法时，调回调invoke()如JdkDynamicAopProxy.invoke(), 内部专门转交给new ReflectiveMethodInvocation().proceed()处理(此时已然在spring-aop里)，此类封装了拦截器和动态拦截Advice(来源：Advisor-->Advice:MethodInterceptor:Interceptor:Advice, MethodBeforeAdviceInterceptor(Advice):MethodInterceptor:Advice 包装了Advice), proceed()时候就先走Advice.intercepter.invoke()或者自己Advice.invoke()	；而TransactionInterceptor:MethodInterceptor 但是不一定会获取到 事务拦截器。
>jedis: redis客户端：领域抽象和业务封装 的过程。业务规则的封装；逻辑的封装；业务逻辑的封装；片段的业务逻辑的封装；功能的封装；片段功能的封装；
	>领域抽象和业务封装： 从连接redis服务端开始的封装，模拟redis发送命令的客户端。
		>最底层开始：Socket 方式和服务端建立连接：封装在Connection里：
			>Connection: 内部封装Socket 实例和参数设置(重用地址、keepalive、无缓冲delay、无拥塞控制的徘徊时间、连接超时时间)，如果ssl则调rt.jar里实现--要么用DefaultSSLSocketFactory要么用"ssl.SocketFactory.provider"配置的工厂来实例化得到SSLSocketFactory工厂，进一步创建socket;socket的输入输出流 封装到RedisOutputStream/RedisInputStream, 对外提供connect()方法，依赖 Protocol后 整体对外提供 命令发送统一接口方法 sendCommand()方法(具体命令作为入参)
			>Protocol： 命令发送规范的封装：*bytelength\r\n$commandLength\r\ncommand\r\n$argLength\r\narg\r\n   来将命令输入到socket.outputStream, 从而封装出 sendCommand()方法 对外提供。2.自然也对外封装了read()方法，实现即 从 socket输入流里读取：第一个byte:是类型，以便分类处理、甚至递归处理。
				>BinaryClient: 继承了Connection， 是发送命令功能的进一步封装，将命令具体化到方法而不是统一的方法(用入参区分不同命令) 从而更加精确和限制和人性；即 对外提供如 lpop(key)方法、lset(key,index,value)方法等。2.因为连接 可能涉及验证，要发送 auth 命令，所以覆盖父类connect()方法；在auth 之后 可能要 选择库,要发送select 命令，因此都是connect()被重写的理由。
					>Client： 继承 BinaryClient, 来提供字符串化的命令接口，比BinaryClient更加人性化；同时引用了SafeEncoder，编解码为byte[]来给BinaryClient。
						>BinaryJedis: 属性引用Client方式 进一步封装：且整合 事务Transaction 管道Pipeline 进来，调度指挥三个 继续对外提供 方法式命令服务：lpop()/get()等常规方法，且 独立封装出 新方法(联合三者的方法,或者联合一者的多个方法) resetState()(相当于一个门面方法,client/transaction/pipeline都要重置状态)/watch(key)(先调client发送命令,后调client获取状态码结果) (因为读写都是异步的,所以写之后要调读 而写方法本身不返回结果)，或者是封装出提供将字符串结果封装为对象的服务：getBinaryTupledSet()。。最核心的：封装往返，封装对象式入参和返回。
							>Jedis: 继承BinaryJedis， 弥补BinaryClient没有封装的部分Client的功能，尤其运维相关 如：sentinel failover masterName 这样的功能(主服务器失效时,不问其他Sentinel强制开启一次故障迁移)，从而对外封装提供了sentinelFailover()这样的方法服务；也封装一些来回。
								>JedisFactory: 内部局部变量引用Jedis,封装它到工厂方法makeObject()里，且进一步封装到DefaultPooledObject里。
								>JedisPool: 
						>Pipeline: 利用Client封装了 多键操作, 即 大部分命令 的 批量操作：如hgetall 命令的批量操作。mset原子性，但pipeline不是原子性。原理：批量命令：multi 开头,xxxx多个命令，然后flush发送，然后n次读取对象(同命令数) 并进一步封装。
						>Transaction: 利用Client封装了类似Pipeline
			>SafeEncoder: 封装了编码方法：对byte[]封装为UTF-8的String
			>BaseObject: 表示一个池里的元素，无特殊封装。
				>BaseGenericObjectPool:	继承 BaseObject 基本对象，封装池化基本方法：设置剔除策略类 服务、启动剔除任务服务
					>GenericObjectPool: 池化的封装
>流计算/函数式编程：一切函数基于集合、Stream。价值：封装了一堆常用函数，每个函数内部调用了其他函数(为了彻底的通用性，所以无需指定这些函数属性 的实例 一定是某个接口的实现者，实例完全可以匿名，实例完全可以是任何 满足函数入参出参个数(类型)规范的 任何类的任何方法)。即：存在一个接口A的变量，可以赋值为任意类的符合接口A里唯一方法 的 特征 的 方法的 引用(自从 方法可以被引用，从而可以赋值给xxx), 这种接口是特殊的---即函数式接口；因为可以被赋值 指定特征的 (无论哪个类中有的,即这个类无需实现该接口---可以引用它的方法(引用)(Lamda类型) 但不能引用它的实例)方法引用；
	>常见技巧：方法引用，作为一个函数调用的输入；而这个函数实际直接将该函数调用封装到一个对象而返回这个对象。函数作为实体 封装 到新建的对象；对象传递给一个函数A，这个函数就可以访问对象 获取回调函数 并应用 于自己所在类内部 的 数据结构。从而只有到了A被调用的时候，注入的对象才被调用，而对象的回调函数才被获取来应用；
	>典型实现例子：最核心 是明确：函数功能---利用了回调函数的函数。(甚至一个类的所有成员 都是 方法引用类型/函数式接口)
		>Map.computeIfAbsent(): 内部流程分几步，每步需要怎样的回调函数.。
		>Collectors.groupingBy(): 
		>Collectors.collectingAndThen(): 
		>Comparator.comparingInt():
		>java.util.function.*下有各种函数式接口：即 方面 对应 引用 各种 参数特征/返回值特征的方法；例如：Comsumer 函数式接口 就引用了 单参无返回 这种特征的方法；。。每个类Z的方法B引用：类类型为：Z$$Lambda$1/2046562095 每次引用都生成一个新的类，相应实例@sss
			>例子：java.util.function.Predicate 就是 单参 boolean返回：boolean test(T t)。
			>例子2：java.util.function.Function 单参单返回：R apply(T t)
			>例子3： java.util.function.IntFunction 单参单返回：R apply(int value) 一般是 引用 数组构造方法。因为这个方法就是需要数组长度而已，返回一个数组对象；
	>封装过程：(流对象定义的封装)
		>AutoCloseable: 最顶层 最基本 特征：对象可能持有资源，需要释放；所以定义 一个释放方法：void close() 表示 对象释放它持有的资源(一般try-catch上的)。
			>BaseStream： 进一步需要的特征：规定为一个流类型 的对象， 流的特征：元素序列， 所以可以进行的操作：1.迭代序列的每个元素，因此定义iterator()方法-返回迭代器；2.分割序列：spliterator() 返回分割器。3.对元素操作是否允许并行执行：isParallel() 。4.流有并行流和顺序流类型：并且可以相互转换；所以提供转换方法：sequential() 和 parallel() 5.可以返回无序流：unordered() 6.对象释放资源的事件 可能需要被监听：所以定义 onClose(Runnable closeHandler) 方法，可以添加handler,在onclose()执行时调用(这个handler链)；
				>Stream: 支持顺序和并行操作 序列中对象，而操作 需要封装 到一个专门的地方--管道Pipeline(内部同时有资源source:array/collection/channel/generator function)(管道内的操作操作管道内的序列), 操作将流转换为另一个流，(集合为了管理元素，流则不提供读写---而是调用操作 来操作 source里的对象，内部可以用迭代器访问元素)，流操作的入参一般为lamda表达式/方法引用(不修改流资源)。定义一批基本的 通用的 序列元素操作函数(有这些操作可以认为是流的大部分特征了)：1.过滤筛选操作-返回新的流：Stream filter(Predicate); 2.对元素应用注入的单入单出方法 得到一个等元素个数的新的流：map(Function) 3.内部元素应用注入的 映射为整数的方法 得到整数序列 从而封装到 一个 整数流里：IntStream mapToInt(ToIntFunction) 4. 每个元素映射为一个流 (常见于元素有集合属性(或者可以产生一个集合)--而需要访问这个集合)(例如文件的行流，每行可以得到单词集合，单词集合转流，那么就可以得到n个单词流，然后合并为一个流) 然后合并为一个流：Stream flatMap(Function) (入参就是流映射函数)。 5.去重:Stream distinct();6.自然排序：Stream sorted()；带比较器：Stream sorted(Comparator) 7.仅仅对元素 应用 注入的方法：元素不变；Stream peek(Consumer). 8.收集前n个元素 返回新的流：Stream limit(long) 9.忽略前n个元素 返回新的流：10.只应用注入的方法 到元素 而不返回流：void forEach(Consumer) 11.序列转放到数组里返回：Object[] toArray()；12.序列转放到 应用 注入的 数组构造 函数 产生的数组里：A[] toArray(IntFunction<A[]>) 13.合并方法/压缩方法：用默认值，和第一个元素开始进行合并--具体合并动作为注入的方法；典型压缩方法：求和、求极值、求平均。T reduce(T,BinaryOperator); 无需默认值的合并：Optional reduce(BinaryOperator) 14.回调1产生一个对象C，回调2将 这个对象C和序列的所有元素都应用一遍： 最后返回C: R collect(Supplier<R>, BiConsumer<R, ? super T>,BiConsumer<R, R>)(最后一个用于并行，将每个并行产生的结果 再次两两结合 而返回)；15.利用收集器来处理得到结果：R collect(Collector) 16.根据注入的比较器Optional<T> min(Comparator)得到序列元素的最小值；其他：如最大值，元素个数；17.是否存在满足条件的一个元素：boolean anyMatch(Predicate) 其他如全部匹配、没有匹配；18.筛选第一个元素findFirst()某个元素findAny()
					>IntStream: 
	>辅助工具：
		>java.util.Optional: 含值操作；
			>常见使用：1.(入参可为空的)设值 Optional.ofNullable(v)  2. 取值：存在性--isPresent()，被动回调消费--ifPresent(Consumer) 3. 过滤：filter(Predicate) 4.映射：map(Function) ；映射为Optional:flatMap(Function) 5.取值 否则 取注入的默认值：T orElse(T) 用于取消三元运算赋值；默认值如果是回调产生的：T orElseGet(Supplier)
		>java.util.stream.Collector: 普通的接口,定义为收集器类型--将序列元素累计运算后放到结果容器里，所以需要 四个基本特征函数: 1.创建一个新的结果容器supplier(); 2.吸收一个新的序列元素到结果容器里进行融合accumulator() 3.多个结果容器 两两合并为新的结果容器combiner()--因为对于并行实现：是先将序列分割为多段，每段用独立的结果容器吸收该段的一个个元素，所以产生了多个结果容器，所以需要两两合并结果容器 4.可选的对结果容器 转换 为一个结果finisher()。为了彻底的通用性--四个基本方法的返回类型也是函数式接口。。自定义一个Collector的函数：5.指定supplier/accumulator/combiner/finisher/characteristics 而创建一个Collector: of(Supplier,BiConsumer,BinaryOperator,Characteristics...)
			>方法引用：某个方法引用，代表的这个方法实际 入参签名格式：第一个参数都代表了this, 第二个参数开始才是实际的用户写的显式的参数；所以将一个方法引用赋值给一个函数式接口时 需要对应一致。
			>函数式接口：往往有泛型；第一个泛型认为是 方法所属类，第二个开始才是方法的实际参数；(这么设计是有必要的，因为函数式接口可以接收任意类的合规方法，有必要指明具体是哪个类)。。静态方法则无需指明所属类-所以泛型从第一个参数开始；。。言下之意---实例方法的函数式接口的规定方法 至少一个参数/泛型。但是对于特殊的：构造方法，则第一个参数就是实际方法参数---不是this--因为没有this,且认为可以有返回值也可以没有返回值--两种函数式接口都支持；
			>例子： 非常经典的：Collector.of(TreeSet::new, TreeSet::add,(left, right) -> { left.addAll(right); return left; })； 就是将序列元素加到创建的TreeSet集合里--返回这个集合；
		>java.util.stream.Collectors: 收集器工具：产生各种 supplier-accumulater-combiner 类型的收集器；
			>一个具体的收集器：有独特具体的专门设计的supplier-accumulater-combiner, 例如 对 累加器：可能：将 累加过程 分解为 2个步骤：1.先用事先注入的函数式接口 应用 到 注入的元素 上 得到一个结果，再将这个结果和supplier进行合并---自然的需要自定义容器 并定义累加方法；并定义 完成器方法；比如 Collectors.summingInt(ToIntFunction) 产生的用来对元素某个属性求和的累加器(需要指定是调用/应用 哪个 函数式接口 来获取到属性值)---称为统计收集器；
			>处理过程中(一般为累加时)需要额外的收集器的收集器：例如分组统计累加器：假如要设计一个这样的累加器，则在累加时，先用事先注入的函数式接口应用于元素而得到分组的key, 按key将元素放到对应的list里，最后在finisher()阶段，将这个key-list 的每个list都转为一个Stream 而应用注入的统计收集器 而得到一个统计结果v， 构成k-v进行存储，从而返回k-v这样的一个map;就是分组统计的结果了。。当然可以是非统计收集器，任意收集器都可以---就是v就是这个收集器处理list后返回的类型而已；例如直接返回每个list。。。Collectors 已经实现的这种分组统计收集器：Collectors.groupingBy(Function,Collector)。。如果前面说的那个存储 k-list 的 map 不是内部自己产生 而也是用户提供 函数式接口提供，则这个分组方法为：Collectors.groupingBy(Function,Supplier,Collector)---实现代码也非常经典(但是必然都会使用 Collectors 自己封装的 Collector需要的五大部件: 到 Collector的自己的实现类new CollectorImpl()里-----Collectors的各种生成收集器的目的就是构造一个 五大部件各种不同的 new CollectorImpl()实例)
				>上述说到：finisher()中进行处理。另一种方式就是在 accumulate()累加的时候就处理(因为此时可以获取到 注入的收集器的累加器+提供器)。
			>有专门finisher的收集器：Collectors.collectingAndThen(Collector,Function) 往往就是对第一个收集器的结果进行一个映射：例如，如果第一个收集器的功能是 将一个序列元素分组为一个以A类型为key,B类型为val的map, 那么这个Function:就可以表示为将map映射为一个list(每个元素为k-v封装为一个的实体)。	
				>实例方法的入参：一定大于等于1个；实例方法的方法引用，必须赋值给 一个  至少一个入参 的 函数式接口；
>idea 插件开发：
	>直接新建工程：Groovy
	>右键Generate...(即Alt+Insert)： 添加子菜单、并生成一串代码、放到光标处；
	>help 菜单下增加一个子项：最简单的插件：新建工程 无需选groovy; https://blog.csdn.net/y4x5M0nivSrJaY3X92c/article/details/105852046?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-8.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-8.control
	>参考：https://zhuanlan.zhihu.com/p/149851915 https://blog.csdn.net/chengtt_love/article/details/53745025  https://jetbrains.org/intellij/sdk/docs/tutorials/action_system/working_with_custom_actions.html  https://www.cnblogs.com/antlord/p/12863323.html
	>第三方插件实现参考:
		>swagger-helper: 在 DTO 类上 增加 @ApiModel 和 在它属性上增加@ApiModelProperty 两个注解。 核心实现类：com.sharedaka.processor.business.SwaggerApiModelProcessor，  被 SwaggerActionDispatcher.dispatcher()调用， 后者 又被 SwaggerAnnotationGenerateAction.actionPerformed() 这个action调用；。。。。参考之后非常容易，甚至只需要2个类 就可以实现这个功能；建立了自己的插件。
>整理jar的架构：领域模型和架构。
	>架构：
		>实现类的多态量：自己获取(bf/spi/), 外部注入
		>多态量的实现类：自己获取(bf/spi/), 外部注入
		>提供了一个什么功能的框架/模板：固定了一个什么流程/步骤。方法实现是一个怎么样的多态量编程。多态量的某个方法调用返回是另一个多态量。最顶层的指挥(多态量)调用(多态量的方法)，每个多态量内部的指挥调用(下一层的指挥调用)。(jar/框架的每个实现类的方法实现都是这样的顶层指挥调用)。调用框架、继承框架，被框架调用、被框架继承使用。(第三方jar调用 开发者写的项目代码，这种jar就是框架jar；用户写的就是被框架Jar当做装饰/工具/条件/命令/参数，而框架自己已经完整的在做一件事情-自己控制整个流程(开启和结束)、自己主动去调用用户写的程序(当然用户程序要有规范/如注解/如继承，而框架提供的注解和接口 就是要求用户编写的程序应该具有的规范(注解类/实现接口))，用户写的程序只是介入/引导/建议-搭个顺风车/是货物/是被动的)。。程序启动，启动的是框架，而不是启动的用户写的程序、项目。
			>开发者调 工具jar:
			>框架jar 调 开发者代码/项目：对于任何一个框架，必须明确2点：它的功能/完整做的事情，它对介入者/开发者 要求的规范(介入哪个环节的代码/类要具备什么特征(实现某个接口/继承某个类/被某个注解注解))。。一个框架的功能是闭环了的。最好有第三点：框架的边界(哪里开始哪里结束,哪个环节开始接手哪个环节开始交接)/作用域/作用范围。
				>Tomcat: web容器框架(实现服务端功能，接收前端调用请求-解析-查找并调用符合规范的介入者得到结果-返回处理结果给调用端)， 将javax 接口 当做 规范。查找时直接查找 实现了这个规范的类/或者在启动可以 启动框架 的 主函数 时 从主函数注入到框架的类(例如spring-boot的启动类启动时调用SpringApplication来帮助启动 Spring框架+Tomcat框架(此种方式启动框架,对主函数来说,框架就是个工具(尽管对用户项目代码来说Tomcat就是框架)) 时(先启动Spring框架后Tomcat框架) 就先进行了对Tomcat框架(实例)(结构/配置池)注入了各个环节 符合它规范的从而它会捎带调用的 类)，典型的 Tomcat框架的 StandardWrapperValve/StandardWrapper 依赖了规范:多态量(接口)Servlet:javax.servlet.Servlet, 而这个规范/多态量的实现类 就是 对注入的字符串servletClass:String反射加载实例化实现的---而这个servlet名称 就是 主程序调spring-boot在启动spring容器时的自动配置解析就得到了DispatcherServlet并存储到一个Class:servletClass:属性 而在启动tomcat框架时获取到这个Class属性即实际值为为DispatcherServlet 来注入的。从而后面的行为表现就是接受到请求后转Servlet时转到了Spring-webmvc的：org.springframework.web.servlet.DispatcherServlet。
				>Spring: bean容器框架，可以bean化/实例化 各种地方出现的各种类：规范为 @Component..../@Autowired...等注解，(类上/方法上)
					>介入实例化：要求的规范：1.对接口的实例化，需要设置bd.resolvedClass
				>Spring-webmvc框架：url映射method框架，作为Tomcat的接手框架，在Tomcat调用之后 开始独立行为，即解析请求 再从符合规范的方法中找到匹配的方法，再反射调用 这个方法(并提供足够的需要的入参)，当然会环绕 反射 有拦截器链的调用。规范：类上@Controller...注解，内部方法@RequestMapping 注解，并且该类符合spring bean化/实例化规范(bean容器框架规范)。框架接手类: DispatcherServlet, 框架转手类：ServletInvocableHandlerMethod--它实现了spring-web.jar框架介入规范:继承 InvocableHandlerMethod 类。即转手给了spring-web.jar框架(接手类InvocableHandlerMethod,转手类:HandlerMethod反射调用注入的用户bean+method)
				>Mybatis: ORM框架，负责接手用户的对象方法查询 转为 sql 查询，并将sql查询结果转换为对象实例；作用范围/作用域/边界：dao接口方法调用<-->sql查询， 具体执行查询 则转接给数据库连接池框架如Driud。规范：dao接口上@Mapper注解,dao接口包下同名xml文件(结构定义规范http://mybatis.org/dtd/mybatis-3-mapper.dtd),方法名匹配sql节点端id值。启用此框架 + 全局的配置要求：启动类注解@MapperScan(dao所在包路径)
				>Mybatis Plus：作用域：。框架接手类：1.启动环节：实现了Mybatis 框架规范的 Configuration 接口的 com.baomidou.mybatisplus.core.MybatisConfiguration；交接于AbstractMethod(引用了mybatis.jar 的 MapperBuilderAssistant:BaseBuilder,调其来添加MappedStatement 到 MybatisConfiguration.mappedStatements(显然就添加了若干个自己生成的常见curd sql:DefaultSqlInjector类里指定的17个对象生成的sql))。 2.
				>Spring-tx: 事务框架。规范：1.实例化dao环节: 专门类需要继承 DaoSupport 类(配置检查/针对关联)。启用本框架 + 要求的 全局配置：。框架接手类：1.获取SqlSession环节：mybatis-spring.jar的SqlSessionUtils里调用的TransactionSynchronizationManager；2. 动态代理的bean在调用方法时走Handler时走advised的advisor列表的拦截器集合时--其中和事务有关的advisor=BeanFactoryTransactionAttributeSourceAdvisor,得到的Advice=TransactionInterceptor直接被当作拦截器invoke;;;交接类：调ptm各个方法时候交给了spring-jdbc.jar里的DataSourceTransactionManager, 后者在设置连接的事务属性时交给了rt.jar的java.sql.Connection的实现类。启用此框架 + 全局配置要求：1.配置类/启动类上被@EnableTransactionManagement 注解。
				>Zuul: 作用域：接收类-交接类；启用规范；
				>RxJava:RxJavaHooks/Observable/OnSubscribeLift
				--说明：
					>规范：bf是最大的规范；实现框架要求的接口后 并注解要spring bean化 从而被实例化放到bf里就可以了，其他框架会根据类型查出来使用。
						>只要开发者写的东西符合 给定的规范： 则给定的框架运行起来后 会主动 准确 调用 开发者写的模块 和代码。这些规范 包括： 接口、类的继承和实现，标记标签注解的添加--情报采集--标识，专门工具类的使用--辅助，代码层次结构约定--方便处理。
							>框架的代码侵入：注解也是侵入，但影响较小。避免类的侵入式，使用DIP方式的代理类，而代理类作为业务逻辑的插件。例如：让spring依赖业务，但业务逻辑并不依赖spring。
	>领域模型：	概念精简和共享，来描述一个事情。领域抽象和业务封装。(编程就是在指挥千军万马).边界与逻辑，环节和步骤，依赖和用途(数据依赖和数据用途)，任务和指派(拆分和分配)，反馈和利用(调用来取得依赖(有返回的方法调用,有=赋值的语句,无返回值则纯转接和准备))。
		>独立无关自边界领域和封装继承有关边界内领域：
>业务重点：
	>要维护的数据组织：CURD
		>数据的层次结构：数据的抽象关系。
	>基于 数+动作/服务+参数 编程：面向函数编程。
	>领域建模有关：
		>开发问题：抽象不足，建立的表就过于具体，当要新增同级类似的对象时，这个表记录就无法存，含义就不会，就要新建表。
>技术关系：
	>dubbo/Feiclient->dubbo/Service-->baomidou-->mybatis-->sharding-jbdc-->druid-->jdbc-->mysql
	>源代码：关键是抽象它实现的功能模型(抽象一般的语言概念来描述)。
	>扩展性：就是把 1."改"类(增删改代码) 完成的事 转换为 "增" 类 来完成(从而不丢失记录)。2."静态数据" 改为 "动态函数获取"(lamda表达式/共享配置)。3."简单两步if-else" 改为 一个函数实现。4.约定规范-减少映射和判断(同一含义的属性在不同表中同一字段名称)。5.深度介入框架实现功能过程中的每个阶段/环节
		
>项目：
	>能否看到所有的问题：发现的所有问题/可以做的事情。
		>数据库：
			>字段设计：价格是否表示为分-准确同时更小空间(避免位数更多而自动四舍五入)。
		>业务：
			>名称：controller-->api
	>存在的所有的痛点：	
	>搭建经验：加依赖 + 启用依赖 + 配置。。
		>数据库：mybatis-baomidou  mysql-connector-java 等 需要；(驱动+sessionFactory...)
			