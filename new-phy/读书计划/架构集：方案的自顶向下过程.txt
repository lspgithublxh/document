---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>架构：展现和承载实现 功能和流程(先后动作/协调动作/触发传递事件激发响应动作)的所有对象构成的物理形态结构和设施(用户/开发者使用最简单-扩展增强替换去除最简单最方便最小代价花费)(接口/容器)。面向用户或者面向开发者。
	
>举动-痛点： 架构能力是一种经验能力,需要训练.
	>解法/解决方案：面向对象
		>启发例子: 一个RPC框架的设计考虑确定方案的过程\一个分库分表框架的设计考虑过程\一个ORM框架的架构过程:
			>框架设计: 定义-阐述
				>定义: (分层定义)
					>初步描述: 一个客户端a向一个服务端b发出网络服务计算请求,服务端处理请求执行本地代码计算,返回结果给客户端.
					>迭代描述: n次 : 概念的泛化和流程的细化: 直到一般的场景/最一般最泛化/全部包括的场景/未来稳定时的场景/未来需求稳定-拓展稳定时的场景::场景决定结构架构;;且所有种类的场景
						>扩展式设计：从最简单单一的系统开始：点对点调用开始。。这种方式会很乱，最后就是想到什么加什么，没有先后实现顺序，结果就是越加越乱。成为一团乱麻、重复实现、冗余大量、毫无联系、非最简实现、使用也不方便，问题越来越多。这就是典型的先实现功能功能再说的思想导致的。
						>细化式设计：从最大的目标最强大完备完善的功能的设想的系统开始：以终为始。设想5年后这个系统应该是什么样子？或者我们希望它是什么样子？然后开始想达到这个样子的策略、做法、路线、监控管理。
					>所有的对象: 每个对象的属性(所有取值)和具有的行为和行为具有的所有特征
				>实现:	
					>一个流程所经过的所有的环节和每个环节负责对象能完成环节工作而要事先做的所有的准备：自身完成，增加扩展点完成---使用外部注入属性对象(接口)/使用子类实现(抽象方法)/使用注入参数调用方法实现(回调/链式)
					>所有的环节: 一个纯粹单一的过程就定义为一个环节; 每个简单独立的功能都是一个环节
						>宏观分解: 系统整体直接看
						>迭代分解: 单一环节放大看
					>每个环节需要确定的所有的事情: 要考虑的问题，准确提出真正值得需要考虑的问题根本的问题
					>每个环节可能出的问题/意外: 预防和处理的措施
					>每个环节的职责: 功能.文本描述; 承接前,后 
					>每个环节的逻辑实现: 抽象的数据流转 和处理
					>每个环节的普通实现和用户使用最简最一般最可扩展的实现: 设计模式的使用
			>rpc框架设计过程：抽象描述，抽象描述，抽象描述。不涉及任何具体具体的动作规定和流程规定。
				>定义：
					>细化式设计：特性描述：宏观特性。
						>最强大完备完善的设计目标：
							>基本：远程调用实现
							>性能：调用快、耗时短
							>抗灾设计：网络中断？服务端负载高处理慢？服务端拒绝？网络拥塞超时？服务端节点崩溃/无法访问？
							>用户使用体验：使用方便、接口调用如本地调用；不关心服务在哪里，服务有哪些节点、服务节点变更？注册降级服务即可，不用主动关心监听服务崩溃、网络崩溃？
							>高并发设计：客户端并发请求；服务端可承接高并发请求？(nio/事件驱动)
							>高稳定设计：服务端维护自身稳定而做的限制：限制请求数
							>监控追踪设计：某次调用失败 是哪个服务失败导致的？某种类型调用耗时分别在哪里？瓶颈在哪里？
							>安全设计：调用权限？访问控制？
						>所有可能的流程：
							>一次远程调用流程：
							>一次服务端心跳检测的流程：
							>一次推送配置到客户端/服务端的流程：
							>一次访问请求完整过程记录和发送到监控平台的流程：
							>一次服务端内部处理的流程：
							>一次客户端内部发送请求前的处理流程：
						>所有可能的对象：
							>服务端：鉴权器、限流器、服务接收发送模块、服务接口请求处理模块、服务调用过程记录模块-发送到监控中心模块：注册中心注册监听模块
							>客户端：编码-压缩器、负载均衡器、发送接收模块、注册中心监听模块、调用过程记录发送模块
							>注册中心：服务注册记录模块、服务心跳模块、服务配置变动推送模块
							>监控中心：监听接收调用记录模块、处理记录模块、展示记录模块、响应管理请求模块
				>详细定义：详细规则、规范、语法定义一般--所有可能填充取值标记出来。。描述当作抽象的词。
					>一次客户端内部发送请求前的处理流程：的所有的环节
						>用户指定调用哪个服务、接口、哪个方法、什么入参：并期望什么结果；直接像本地调用一样书写。只是接口实例的获取，是专门获取的。
							>如何指定服务、接口、方法和入参？：xml配置中指定？还是@RemoteInterface注解中指定
						>封装调用信息为一个任务推入处理队列：
							>队列在本地？直接推送，还是中间者推送？队列是阻塞队列还是非阻塞的？固定长度多少？什么底层实现？
						>请求处理线程池从队列取出任务：序列化编码、压缩、放到发送队列
						>请求发送线程池从队列取出发送数据块：分割、单元化 、填充、加密，创建安全通道/隧道，发送。
						>响应线程池监听服务端到达的请求：组装、解密 恢复出原信息 放到响应队列
						>请求返回处理线程池从队列取出响应信息：解压、确定请求号、返回结果反序列化、结果设置到调用者指定的变量下、唤醒对应的请求调用者线程。
						>请求调用者醒来，得到变量对应的返回值：开始操作值进行下一步的处理。
		>启发例子2: 技术选型过程.一个流程图: 如 数据库选型