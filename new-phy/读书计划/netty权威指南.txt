---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	
>举动-痛点：实现、好的实现；使用简便、扩展简便、通用、高效快速的实现；讲究工程方法；
	>解法/解决方案：linux---所有的外设都是文件--相关属性和操作： 描述符(结构体) + 读写 操作；
		>linux IO模型：
			>阻塞IO模型：应用 系统调用 到内核，无数据则等待数据准备好，并拷贝到用户区；
			>非阻塞IO模型： 应用轮询 系统调用到 内核：无数据直接返回；有数据拷贝到用户区；recvfrom
			>IO复用模型：select/poll 函数，进程传递多个fd给这函数，阻塞，select/poll内部顺序扫描fd 是否就绪，某一轮只是有一个就绪就返回，然后调用recvfrom读取数据。epoll系统调用---基于事件驱动--代替顺序扫描--性能更高；即事件到来自己回调；
				>最大文件句柄数：fd，1GB内存，可以10w?。select 轮询导致量大之后效率变低；而epoll则更高---尤其idle connetion 多的时候；epoll用了mmap --内核用户共用空间--因此避免了数据复制；	fd的callback函数；
				>线程池：minPoolsize=核数比较好；数组阻塞队列，2min poll
				>JDK selector 实现：epoll() 没有最大连接句柄 1024/2048 限制；
			>信号驱动I/O模型： 开启套接字 信号驱动 IO功能；调用 sigaction 系统调用 来执行一个 信号处理函数；数据就绪，则为该进程生成一个SIGIO信号，通过信号回调通知应用调用recvfrom 来读取数据；
			>异步IO模型：上述是通知我们 可以开始IO了， 而这里是通知 我们 IO完成了，直接回调用户程序处理数据即可-----即把数据复制到用户数据区也带做了；
		>AIO: 客户端：连接完成---执行回调；写入客户端通道完成执行回调；	读取客户端通道数据完成 执行回调；；；服务端：读完写完也都有执行回调；
			>可靠性：和 吞吐量 ；都高；同步非阻塞和异步非阻塞；
		>NIO：应该解决的问题：网络闪断、客户端重复接入、客户端安全认证、消息的编解码、半包读写、失败缓存、网络拥塞、异常码流；；即可靠性这一块工作是重点能力；命门不要太多；	
			>Selector 空轮询问题？导致cpu1100%
		>Netty: 健壮、功能、性能、可定制性、可扩展性；Hadoop-->RPC框架avro使用netty做底层通信框架；
			>功能：预置多种编解码功能；支持多种主流协议；
			>定制能力强：通过ChannelHandler对通信框架进行灵活扩展；
			>成熟稳定：修复所有发现的JDK NIO BUG;
			>社区活跃：版本迭代周期短；大规模商业应用，场景丰富，应用广泛；
			---服务端配置：线程、通道、选项、回调；监听和关闭；
		>Netty应用：预配(装配)、监听、回调；
			>NioEventLoopGroup: 线程组；监听客户端请求和通道读写用；
			>避免频繁唤醒Selector而做的事：write先写缓冲数组ByteBuf，再flush写入SocketChannel
			>ServerBootstrap: 辅助启动类；
			>closeFuture().sync()异步关闭：
		>TCP粘包/拆包问题：源于包的批量发送，和 报文拆解为多个包；
			>粘包：就是数据没有一次发全---而分多次发送；缓冲区不够；TCP段限制；IP数据包MTU限制(路径限制)；或者：一次数据量太少，而缓存到足够大之后才发送；从而服务器端收到一个包含多次写入的数据；
				>解法：用户层主动定长分段发送；先发送总长度；
				>LineBasedFrameDecoder: 在通道中可以增加的几类实例：回调/解码器/；有序增加到通道中；StringDecoder
					>编码器的意义：仅仅是展示给用户看，消息是分开的而已；实际传输到服务器上的：依然是长数据包；
		>编解码技术：序列化和反序列化
			>java序列化：跨语言：不行；编码时空花费：低；编码结果流：大；编码性能：低；
			>protobuf: 跨语言：支持；花费：高效； 编码结果流：二进制编码；Entity/API生成：自动；性能：高；使用：描述文件+工具 ；。。
			>JBoss Marshalling: 跨语言：只java;
			>对象编解码器：ObjectEncoder/ObjectDecoder: 使得API可以直接发送对象实例；
				>ProtobufDecoder/ProtobufVarint32LengthFieldPrepender: protobuf对象被protobuf编解码。。半包处理：LengthFieldBasedFrameDecoder
				>MarshallingCodeCFactory.build...
		>Netty多协议开发和应用：		
			>HTTP服务端客户端开发：HttpRequestDecoder/HttpObjectAggregator/HttpResponseEncoder/ChunkedWriteHandler/HttpFileServletHandler
				>xml绑定框架：JiBx: 将POJO生成绑定文件+Schema定义文件；而将对象转XML对象；同样接收端也能反转；
			>Websocket协议开发：	通过HTTP请求建立websocket连接：Upgrade: websocket; 返回 新的报头：Connection: Upgrade
			>UDP协议的开发：音频视频。以数据报为单位进行收发。DatagramPacket
		>Netty源码分析：
			>ByteBuffer: position,limit,capacity; ByteBuf: readIndex,writeIndex,capacity   。动态扩展：也是常规的：新增一个更长的ByteBuffer对象，来替换原来的；
				>mark/reset: 是 position 的 备份和恢复； ByteBuf中则是：readIndex/writeIndex 两个分别的备份和恢复
				>直接内存：分配和回收慢；但是读写Channel快；。所以IO通信线程的读写缓冲区用DirectByteBuf, 业务消息的编解码用HeapByteBuf
				>ResourceLeakDetector: 检测对象是否泄漏
				>ByteBuf: 最大特点：支持动态扩展---增长策略：阈值前倍增；阈值后线性增长；
				>线程安全的更新属性：AtomicIntegerFieldUpdater 这种类型对属性的包装，以原子操作；更新属性的方法的入参：对象引用+属性偏移量objectFieldOffset+新的值。。CAS方式：对象引用+旧值+新值
				>应用预先申请一大块内存：Memory Arena
				>PooledDirectByteBuf ：池化方式来获取对象而不是new方式，例如用newInstance(),实现是从池子中分配划出一个；
			>Channel: 	什么是SPI? 语言上定义，虚拟机实现；
				>写：写入环形数组ChannelOutboundBuffer(指针：unflushed,flushed)；flush()则发送。ChannelPromise
				>NioSocketChannel:
				>NioServerSocketChannel: 
				>EventLoop: Reactor线程组。。。DefaultChannelPipeline 实际的连接和关闭方法；
				>写半包：就是缓冲区只发送了一部分，剩下一部分没发；缓冲区可读的数据小于要求的数据，则是半包，直接返回空，等下次读。解法：两类：分割符 和 定长 确定要发送的数据的长度；从而从接收缓冲区接收完整的消息体；	
				---性能问题；往往是因为没有自适应导致的；比如容量：过小则频繁扩张；过大利用率低；并发情况下各个客户端不同也要自适应分配缓冲；AdaptiveRecvByteBufAllocator
			>ChannelPipeline: 负责ChannelHandler的管理和事件拦截与调度；
				>过程：Channel读取到ByteBuf--->触发事件-->NioEventLoop 获取ByteBuf数据调用ChannelPipeline::fireChannelRead(msg)
					>firexxx: HeadHanlder处理-->ChannelHandler1处理-->...--->TailHandler处理。。。而 ChannelHandlerContext.write()则是反过来 。。ChannelHandlerContext 核心，是用户和TCP之间的API..，就像FilterChain 	, 每个Hanlder类似Fitler, 继承 ChannelHandlerAdapter
				>每个Channel一个ChannelPipeline: 管道 是 Hanlder 的管理容器，
			>ChannelHandler: 有connect()方法，底层调用Unsafe.connect()完成真正的连接；
				>应用类别：编解码：ByteToMessage; MessageToMessage
			>EventLoop/EventLoopGroup: 	普通线程池：一组worker+一个任务队列。。提交任务+线程池调度模式；提交任务+用户调度模式
				>单线程Reactor模型：
				>多线程Reactor模型：
				>主从多线程Reactor模型：NioEventLoop 调用 ChannelPipeline 是直接调用；。。
				--使用2个线程组：一个线程组：做acceptor任务, 另一个线程组：做I/O任务；
				>NioEventLoop: 有execute()/schedule()等普通线程池的功能；
					>Selector: 实例化：通过SPI提供；或者sun.nio.cn.SelectorImpl.....。。。消息队列有消息：selectNow(), 没有消息：select() 进行轮询；
						>空轮询：某次轮询结果为空，且没有消息要处理；无wakeup。计数，；重建 Selector, 重新注册老Selector上的Channel和事件
			>Future/Promise: GenericFutureListener 异步通知机制回调 比Future.get()更好：即 Future.addListener(new ChannelFutureListener)			
				>Promise: 是可写的Future: 用于设置IO操作的结果；即当IO操作发送异常如write中，会操作 Promise对象 设置状态信息；
		>java内存模型：
			>区域划分：主内存、工作内存：
			>内存交互协议：8种操作：完成主内存和工作内存的变量访问
				>lock: 主内存变量线程独占尝试
				>unlock: 主内存变量线程独占解除
				>read/load/use: 从主存-->总线-->工作内存->处理器
				>assign/store/write: 从cpu处理器-->工作内存-->总线-->主存 
			>线程实现方式：内核线程实现/用户线程实现/混合实现	
			>同步机制：	
				>重量级synchronized: 线程可能阻塞和唤醒
				>轻量级volatile：1.A线程修改后B线程读取会从主存中加载；2.编译时禁止指令重排序和优化	。。但是没有互斥性(线程不会阻塞和唤醒)--即可以并发修改有volatile修饰的变量；
				>非阻塞同步：CAS x86指令集中是cmpxchg指令； ARM/PowerPC指令集下为Idrex/strex指令
					>对某个整型属性的更新：先建立这个属性的AtoimcIntegerFieldUpdater 对象， 然后使用这个对象的compareAndSet(this,oldv,newv)
		>Netty逻辑架构：关键架构质量属性；
			>高性能原因：
				>异步非阻塞IO模型+Reactor线程模型；
				>TCP接收发送缓冲区：直接内存；环形数组缓冲区 无锁化并发编程；
				>内存池：
				>优雅停机：JVM shutdown hook 关闭前处理
			>应用：	
				>dubbo: 
					>节点间通信：Netty+二进制编解码私有协议
					>服务注册中心：Zk,消费方软负载均衡+Failover
					>服务治理框架：
					>服务监控中心：辅助容量规划；
					--质量属性：
						>连通性：四者之间的连通关系；
						>健壮性：注册中心宕机、监控中心宕机、服务提供者宕机
						>伸缩性：注册中心对等集群，可动态增加机器部署；服务提供者无状态，可动态增加动态部署实例
						>升级性：动态部署；
					--调用过程：
						>Serivce-->DubboInvoker-->Requestor-->Netty Client--->Netty Server-->Responder-->DubboExporter-->ServiceImpl
					--Netty的作用：
						>数据传输：
						>心跳检测：
						>流量控制：
					--提出和解决问题：
						>高效序列化：
						>线程模型调优：
						>高效Buffer使用：
						>心跳重连策略：
						>优雅停机：
						>宕机异常处理：
						>NIO并发安全处理：
				>rocketmq: 
				>avro: