---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。

>举动-痛点：
	>解法/解决方案：上下文切换问题；死锁问题；受限于软件和硬件的资源限制问题；
		>时间片：几十ms
		>线程创建开销：
		>线程上下文切换开销：
			>开销计算：vmstat 1 查看cs列--即上下文每秒切换次数。 Lmbench3可以分析上下文切换的时长。
		>减少上线文切换：
			>无锁并发编程：人工方式，各个线程处理不同的数据段。
			>CAS算法: 硬件指令CMPXCHG, 先比较再更新。
		>使用最少线程：任务少，无需太多线程。
		>协程：单线程里实现多任务的调度。
		>虚拟机栈分析：
			>等待线程分析：jstack 3113 > file;  grep java.lang.Thread.State file | awk '{print $2$3$4$5}' | sort|uniq -c 
				>如果大量发现 WAITING(on object monitor) 即在等待池中的线程。那么可以减少相应的线程池中核心线程的数量。
			>死锁分析：尤其因为异常而没有释放锁，极容易造成死锁和阻塞。数据库锁也是。	
				>如果发现栈信息里出现： BLOCKED (on object monitor) 即在阻塞池entrylist中，则危险。
				>解法：使用一个锁；使用超时的tryLock锁；
		>资源限制的挑战：并发的个数要考虑是否超过了资源限制。
			>数据库连接数|socket连接数：
			>服务器带宽：
			