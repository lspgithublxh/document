---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。

>举动-痛点：
	>解法/解决方案：
		>比特币: 前所未有的交易模式
			>核心技术:
				>工作量证明:
				>共识机制:
				--区块链结构设计:
					>区块链技术:
						>分布式记账本: 对于资产的管理十分关键;
					>区块链特征:
						>分布式容错性: 分布式网络极其鲁棒,容忍部分节点异常;;
						>不可篡改:一致提交, 一直存在;不可被销毁或者修改...可信
						>隐私保护性: 数据泄漏,无法解析;..安全
			>核心业务:
				>去中心化的数字货币机制:
					>可靠的交易记录系统:
						>准确公正记录每一笔交易, 并且无法被恶意篡改:
						>
					>一套合理的货币发行机制:
					
		>以太坊: 智能合约机制
		>超级账本: 联盟式分布式账本平台
		>具体开发的例子：https://niocoder.com/2018/03/10/%E7%94%A8Java%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9D%97%E9%93%BE-part1/
			>每个区块的属性：5个。hash, previousHash, timestamp,data, nonce; 其中 hash就是本区块的hash，是需要计算出来的，且具有一定特征---以k个0开头的，nonce是调节因子，是个整数，计算方法：hash = hash-xx(pre+timestamp+nonce+data)， nonce从0开始尝试，直到首次出现hash以k个0开头为止；
				>莱特币中：这个k是442592左右；计算出一个块的hash值的过程 就是 挖矿的过程。
				>不易篡改：因为：每次计算块都非常耗时，所以如果有人篡改了某个区块里的data/timestamp等数据，就会导致区块失效，如果他要要区块生效，那么必须计算该区块后面的所有的区块的hash，才能形成新的正确的区块；
			>区块链：可以看作是一个 json数组。		
			>交易模型：属性中 data 替换为marklet, 新增属性transactions 链表， marklet = func1(transactions) 
				>验证：每个事务的输入inputs 和 上一个事务 的输出outputs	比较和验证，
				>转账：余额，需要从整个区块链的每个区块的事务的遍历中获取到, 足够的output: A计算出来传递给事务的inputs, 而区块链的总的全部outputs则删除掉A部分；然后新增一个事务，添加；添加过程中会 处理事务：该事务的输出list里--添加两条输出:分别接收者增加+value,发送者增加+inputs-value, 其中inputs就是发送者自己的链上的部分的输入(一定比value大)，然后区块链的总的outputs则增加这两条output即可。
					>所以最核心的：是区块链的总的outputs，这个上面才知道所有的用户的全部余额；
					>每个事务：有一个签名：signature = 椭圆函数(发送者私钥, 发送者+接收者+转账额度) 显然只有用户自己能有私钥--自己才能生成正确。 验证则用发送者的公钥才可以。因此一个事务无法被篡改；
						>事务其他属性：接收者公钥、发送者公钥
					>钱包：负责生成一个事务：
						>条件：传入接收者的公钥、转账额度；
						>过程：查找区块链上自己的余额，删除足够的ouputs, 作为inputs输入新建的事务，使用自己的私钥使得事务生成签名；使得这个事务是有效的---而不是伪造的；
					>区块添加事务： 负责记账。即添加新的output到区块链上。(一个区块添加一个事务)
						>过程：验证事务是有效的，调用事务的处理事务方法，使得计算出接收者新增量和发送者余额量，分别生成两条新的ouput添加到outputs属性，同时也添加到全局的UTXOS输出里。完整资产的转移。
						