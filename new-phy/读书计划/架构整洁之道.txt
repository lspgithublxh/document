---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>抽象描述就是用抽象概念、一般概念来描述事情；比如 数据、事物、页面 之类的范畴类的概念(n个量的集合体)---而不是具体各种度量已经明确的实体；
	
>互联网应用的本质/核心的功能 就是 请求数据。在用户看来 最高层描述抽象描述一般化描述是这样； 在服务端看来，就是存储上传的数据/主动采集数据/组织数据/处理数据/挖掘数据/查询计算/响应请求；	
	>每个用户使用数据服务最基本的条件 就是 请求建立自己的数字身份；来参与数字生活活动，进行消费和服务；。。互联网是一个生产者消费者系统；
		>新设计的价值活动：详细的环节/阶段/活动规则/参与规则；所有可能的体验通道/体验实例/体验例子/体验经历；
		>新设计的虚拟活动：可能对现实有映射；交流平台；商务平台；商品展示平台；。超链接的跳转--这个动作又可以被控制--从而可以当作流程推动--而页面是一个环节；
>举动-痛点：实现、好的实现；使用简便、扩展简便、通用、高效快速的实现；讲究工程方法；
	>解法/解决方案：代码需要易读、易扩展、易维护、甚至可以直接重用。用工程的方法来编写代码。编程是一种工业设计。
		>很多跷跷板一样的平衡问题：基于业务分析给出平衡的方案。简化和轻量化这个系统。
		>编程范式：结构化编程、面向对象编程、函数式编程
			>结构化编程：自顶向下 层层细化。
				>将一段程序递归降解为一系列可证明的小函数：
			>面向对象编程：封装、多态、继承。
				>封装：以对外提供方法方式的访问，而不是直接属性访问，因为方法可以灵活增加内容---从而可以对外部访问进行自由灵活控制。
				>本质：是一个对象定义的过程。定义一个个对象的过程；对象的独特性完全是由它的独特的方法和数据结构确定的。方法定义了特征，或者说特征用方法来定义；特征可以专门封装起来以便被类/对象重用/复用(继承的方式)，也可以用来指代一大类对象/以大类类(接口变量)。
					>过程：定义特征、定义类。封装特征，封装类。定义普遍应具有的特征，定义具有某特征 且有自己独特方法的类；
					>方法内实现的编码过程：特征接口特征方法，层层封装 该层会遇到的各种情况 下的各种判断和决策；专门单一实现某个功能的方法则是真正的实现，其他类中的方法都调用这个具体的实现而层层向上封装---各种异常情况和异常输入异常环境的判断+调用该具体的方法(也是对该方法的保护和准确调用、有效调用)、兼容-适应实际场景、使用(用在更大的实际使用场景中)、扩展(功能增强、增加切面)。
						>好处：减少依赖，避免直接依赖最底层的实现、变动最大的实现，让底层的变动削弱并消失在向上传递过程中--被处理掉-调节掉-兼容掉。
						>高层实现策略、底层实现功能：
			>函数式编程：以函数为基本单元，没有变量--不能重复赋值---隔离了可变性。避免死锁、状态冲突。没有赋值语句，限制了赋值。限制赋值就是限制对变量的修改，就是消除并发控制。
				>认为的处理过程：调用一个函数，入参是另一个函数的引用(不是调用这个函数的结果)。。。定义函数和调用函数。变量是不可变的。
				>将大部分处理逻辑归于 不可变组件：而可变状态组件的逻辑应该越少越好。
				>将修改  替换为日志： 将查询最新  就变为了查询历史并计算总和。增加查询的速度，则可以归结存档k个历史日志；。。例如修改用户的存款总数。
					>消除了 更新和删除 操作：从而不需要 并发控制；CRUD,变为了CR.。。就像源代码管理程序一样。
		>设计原则：软件架构的规则
		>软件架构：
			>三大关注点：功能性-结构化编程、组件独立性--面向对象编程、数据管理--函数式编程。
		>要解决的问题：分离 控制代码(多线程、异步、服务发现、部署、弹性伸缩)  和 业务逻辑。分离方式：比如注解化、框架化、回调化。
			>简单-简陋、平衡-妥协、迭代-半成品：
			>运用：SOC--关注点分离、SRP--单一职责原则--隔离责任，OCP--开闭原则-保持核心关注点的封闭。
				>目的：用最小的人力成本来构建和维护系统需求。避免跨边界调用---微服务。降低未来的变更成本。
				>误区：低估良好设计、整洁代码的重要性。	
				>观点：系统架构重要，但是不紧急。	
		>编程范式：什么时候采用什么样的代码结构。		
		>设计原则： SOLID
			>SRP: 单一职责原则；
				>任何一个模块：都应该有且仅有一个被修改的原因。
				>业务逻辑/业务规则属于谁，这个方法就放在哪个类里：而不是看方法涉及了什么对象什么类，领域对象只提供基本方法，而业务对象 才提供业务逻辑方法---顺便调用领域对象而已。
					>底层基本领域对象：
					>中层业务规则逻辑对象：
					--共享的不好的地方：需要同步，同步就带来竞争，竞争可能产生死锁；死锁造成更大的开销和浪费；同步出问题可能带来数据不一致；。。共享可能带来阻碍变化，阻碍灵活性。冲突的概率大大增大--集中的坏处。而重复建设比起来 都不算什么坏事。
			>OCP： 开闭原则。允许新增代码来修改系统行为，而不是只能靠修改原来的代码。
				>最高层次的应用策略/业务逻辑/业务规则：被其他模块依赖，而不依赖任何模块。从而它不受其他模块变更的影响。为核心组件。
					>从最高层次的类开始：分层依赖。按照被修改的原因、修改的方式、修改的时间 而分层分组隔离。相互隔离的组件/函数分组 整理成 组件结构，使得高阶组件不会因为低阶组件被修改而受到影响。
					>避免传递依赖：需要增加中间类。比如一个类依赖了多个层次的对象，那么其他类依赖它那么就会传递式的依赖底层类(如因为接口的入参)，所以要增加中间类。
						>元组：软件系统不应该依赖其不直接使用的组件。
				>地位：是架构设计的主导原则。目标是让系统易于扩展。同时限制其每次修改所影响的范围；实现方式为：将系统划分为一系组件，并将组件间的依赖关系按层次结构进行组织，使得高阶组件不会因为低阶组件被修改而受到影响。
					>从而修改：只影响它及其以下依赖它的。
			>LSP: 里氏替换原则。可替换的组件来构建系统，则组件需要遵守同样的约定/实现相同的接口
				>内容：接口的类之间具有可替换性。
			>ISP: 接口隔离。避免不必要的依赖。不要依赖它不需要的东西---定义出一个新的中间类来屏蔽。
				>同一个接口上定义的特征：必须和这个接口的含义相关，且子类对于这些特征一定都需要。如果不是都需要，那么就需要将不需要的特征拆分出放到一个新的接口。
				>接口的层次结构：如果一个子类需要多个接口里的方法，那么可以定一个新的接口--继承那些需要的接口，从而这个子类只需要依赖这个新的接口即可。
					>动态类型语言：不需要对调用的方法的返回值的类型进行声明，相当于天然的是任意接口类型的变量。
			>DIP: 依赖反转原则。高层策略性代码 不应该依赖底层具体实现的代码；而底层实现的代码反而应该依赖高层策略代码。
				>多使用：稳定的抽象接口，少依赖多变的具体实现。。。依赖反转：本来依赖是依赖 真正具体的哪个，但是实际使用应该依赖 依赖的接口---即依赖的依赖。本来是A 依赖B，改成了B依赖C,A依赖C。也不叫间接依赖，而B变成了依赖方，所以依赖反转了。
					>实例的获取：工厂接口。工厂本身：也是接口。工厂的实现类，实现创建对象的接口方法，返回实例接口，而内部new 具体实现类。
				>少使用：继承具体实现类。
		>组件构建原则：
			>组件：软件的部署单元。.jar, .dll, 动态链接文件和 静态链接文件。
			>组件聚合：
				>REP: 复用/发布等同原则
					>组件要有组件版本号：
				>CCP: 共同闭包原则 。一个组件不应该存在多个变更的原因。变更原因相同的多个类  在同一个 组件中。
					>通过全新的封装  的方式 进行扩展：
				>CRP: 共同复用原则.。不要强迫一个组件的用户 依赖他们 不需要的东西。
					>不要依赖不需要的东西。
			>组件耦合：
				>无依赖环原则：组件有版本，某个组件升级了，依赖方可以选择是否升级为最新的版本。DAG--有向无环图。
					>形成环的各个组件：等效为一个组件，所以需要同一个版本。
					>消除环的方法：依赖反转。即将依赖改为了不依赖。DIP。引进了一个新的组件，原来的AB两个组件依赖它。
				>稳定依赖原则：依赖关系指向更稳定的方向。SDP	
					>稳定性：即变更它需要很大的成本/工作量。独立的组件，没有依赖其他组件的组件，就是最稳定的。如果有其他组件依赖这个组件，这个组件需要对依赖它的组件负责。
						>如果一个组件依赖多个组件：那么它就有多个变更的原因。
						>一个组件的位置稳定性：出的越多，入的越少，越不稳定。被依赖的多，则它越难被变更，而它没有依赖外部，则也没有了来自外部的变更的理由。	
							>组件依赖其他组件：则主动依赖的组件的稳定性应该更加稳定。
					>组件结构图：不稳定组件放在上层，稳定的组件放在下层，即被依赖的组件放在下层。不稳定组件 就易于变更，这个看需要。		没有任何方法的接口 往往稳定。
				>稳定抽象原则：一个组件的抽象化 程度应该和它的稳定性保持一致。SAP
					>稳定的组件应该是抽象的：稳定度=抽象类和接口的比例。
					>具体且稳定的、抽象且不稳定的：一个痛苦--难以变更、一个没用--没有被依赖--被依赖数量为0。
		>软件架构：最大化生产力的系统设计方向。不佳设计带来的麻烦 而 产生  的 良好设计的标准和方法的需求。 
			>麻烦出现的时候：新增需求的时候、开发部署和补充开发的时候。
			>用抽象类和接口来描述抽象策略：具体实现则注入。
			>划分、隔离系统组件：
		>划分边界：分割元素，以便约束边界两侧之间的依赖关系。	
			>为了降低构建和维护一个系统所需的人力资源：需要减少系统中存在的耦合。
			>插件式架构：业务逻辑不可变，所以是被依赖的，被UI，DB依赖，而本身不依赖其他什么组件。
			>跨边界调用：构造合理的跨边界调用。低层进程成为高层进程的一个插件。
		>策略层次：校验输入的策略、描述业务逻辑的策略、描述计算报告的格式的策略。将这些策略分离，按变更方式重新分组；	
			>低层组件依赖高层组件：越重要的越不希望受到影响的放在上层。策略隔离。针对系统低层组件的紧急小修改几乎不会影响系统中更高级、更重要的组件。
		>业务逻辑：	真正用于赚钱或者省钱的业务逻辑与过程。无论这个逻辑在计算机上实现还是 人工执行 ，它们在赚钱和省钱方面的效果/目的/作用都是一样的。
			>关键业务逻辑：和关键业务数据 有关系，由逻辑的处理 实现。以规则处理数据的过程，让数据不断演化不断反应现实(解决现实问题/记录现实过程/累积现实过程)
				>关键业务逻辑+关键业务数据：放在一个对象中处理，对象就是 业务实体。高层概念。
				>用例：如何操作一个业务系统的描述。场景下的业务逻辑。和输入输出相关。
				---一个项目：最佳状态是  只有业务逻辑代码，其他低层概念的实现  都是插件。
		>尖叫的软件架构：尽可能的允许用户推迟和延迟决定 采用什么框架、数据库、Web服务 以及其他跟环境相关的工具。且让我们很容易改变这些决定。到处都是插槽和扣子。
			>架构设计的主题：先看这个系统的用例。
		>整洁架构：
			>六边形架构：
			>DCI架构：
			>BCE架构：
			--架构系统特征：独立于框架--不依赖某个功能丰富的框架，可被测试，独立于UI--变更UI容易，独立于数据库--业务逻辑和数据库之间解耦--想替换为其他数据库很容易---那么自然要和ORM解耦。不依赖 就是  不引用。
			>不完全边界：
		>设计架构边界：完全实现边界将会带来多大的成本。不设计边界 会出什么问题，设计需要多少成本。		
		>Main组件：自由的生成/封装出一个个的容器--数据-方法结构。视为一种插件。
		>服务：宏观与微观
			>架构设计的任务：找到高层策略和 低层实现/细节  之间的 架构边界 ，同时保证这些边界遵守依赖关系规则；
				>系统架构的定义：由 那些跨越 架构边界 的关键函数调用 来定义的。
			>服务所带来的好处：
				>解耦合：仅仅在 变量层面。任何形式的共享数据行为 都会导致 强耦合。
				>独立开发部署： 因为服务之间通过数据、行为 耦合了，所以它们的开发、部署和升级运维 也需要 彼此协调。增加一个功能，其实也需要各个服务都要做调整；
				>单体方式：新增新功能，可能只是新增一个jar， 并加到classpath上。
			>系统的架构边界: 不落在服务之间，而是穿透所有服务，在服务内部以组件的形式存在。服务内部的组件边界 才是 系统的架构边界。就是 接口/实现 的 边界。	
		>测试边界：测试也是一种系统组件。系统架构中 最外圈的 程序。支持开发过程。
			>可测试性设计：测试专用API
		>整洁的嵌入式架构：硬件依赖关系。软件要和固件功能分隔开，抽象出完全业务逻辑的部分和具体不变的实现部分。。从而让软件拥有更长的有效生命周期。	
			>程序不仅可以工作：而且可以长久工作，高效工作快速工作。代码结构。
			>分层：硬件、固件、HAL-硬件抽象层、os操作系统、OSAL、软件。。基于接口编程。
				>层层向上：考虑更少的具体维度；每层实现一个维度，隐藏一个维度，消耗一个维度，兼容一个维度，封装一个维度，不对外暴露一个维度。封装一层情况，分发一层情况，讨论一层情况。每层讨论一个维度。
		>实现细节：
			>数据库只是实现细节：在系统架构中并不占据 重要角色。重要的是数据模型。
				>文件系统：关注名称的索引。数据库系统：关注内容的索引。
			>web是实现细节：？GUI是实现细节。	
			>应用程序框架是实现细节：
		>案例：系统架构设计
			>用例分析：角色和用例
				>明确所有的角色：和角色要做的事情，为角色服务。角色的劳作和角色的收获。
			>组件架构：每个角色的 视图-展示器-交互器-控制器，每个器之间的调用关系 是系统架构边界。	
				>每个组件：是一个器，是一个jar,为交付单位--单独构建单独部署。最小的部署单元。
			>依赖关系管理：根据开闭原则  自底向上 封装 。从底层细节道高层策略组件。按角色隔离，依赖关系隔离。来把不同变更原因和变更速率的 组件 分隔开来。变更原因因为角色，变更速率因为层级-依赖关系。	
		>案例2：构建一个在线书店 
			>分层架构：MVC
			>垂直切分：
			>业务领域代码和具体实现细节 隔离 的架构：内部代码--Domain, 外部代码--Infrastructure
				>一个架构设计原则：web控制器 永远不应该 直接访问 数据层。
				>java9 模块系统： 