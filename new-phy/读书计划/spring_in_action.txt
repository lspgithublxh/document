--------spring的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。


#现实开发中遇到了什么痛点导致spring的开发？  
>1.举动-痛点：属性直接赋值、本类方法封闭赋值：导致属性的实例值无法由外部改变。需要修改代码、重新编译。类与类之间耦合太紧密。甚至不需要依赖类，而是接口而已。
    >解法/处理思想：所有属性都是由外部注入。内部不做对属性赋值的操作。使得实例化一个类变成一个拼装组合的过程。且：属性是接口类、顶级父类。类之间变得“松耦合”(因为依赖的是接口了)。实例也方便重用。。同理微服务的产生的原因之一也是“服务的松耦合”
	  >对于有大量的层层依赖关系的类的实例化/对于层层依赖：类之间形成多叉树的关系。在最底层必然是常量属性的类，实例化不再依赖注入而等待依赖类的实例化；从而这些类的实例化后，注入到直接依赖的类的实例里而完成对此类的实例的封装；同理继续向上注入，直到最顶级的不被依赖的类实例被注入完成。而且“实例化”和“注入”完全可以由第三方类来完成实现。
	>新痛点：装配方案(xml/java类)
	 >装配方案描述：就是要描述一个bean如何构造，一个bean依赖其他bean的引用关系的表达。
		>用xml描述，bean本身构造参数，bean的某个属性引用某个bean id来描述引用关系(属性名\bean id名对应出来即可)。缺点在于：描述能力受限于spring提供的语法，特别的构造方法就会很麻烦。应用路径：即.../classes/下。
		>用java类描述：某个方法返回一个实例，这个实例就是一个bean了，而内部就可以随心所欲的写；引用其他类的实例，则调用其他返回bean的方法即可。缺点在于修改时需要重新编译。

>2,举动-痛点：为了监测方法和保障方法，而在方法里添加的日志打印、统计发送、安全校验 这些系统服务，与方法本身代表的功能没有直接关系的非业务逻辑代码，要做的事太多且无关本身，显得冗余，混乱。业务逻辑和系统逻辑耦合过于紧密。即不需要依赖系统类，不需要显式调用，而仅仅注解说明而已。
	>解法/处理思想：方法应该专注于业务代码逻辑，系统服务代码应该在方法体之外，同时会随着方法的调用而执行。那么一种办法就是把各个系统服务注解到方法上，而类的实例用该类的代理类的实例替换。而代理类的实例重写了父类的代码，指向了一个统一的Intercept类的intercept()方法，此方法根据父类方法上的注解而执行before要做的事，然后invoke()父类方法，然后做注解决定的after要做的事。
		>切面与应用的关系：想象切面为调用链中的过滤器拦截器，而应用就是controller。切面是应用的背景图，三大切面：日志切面、事务切面、安全切面。	一个切面的切点就是需要该切面工作的所有方法，一个切面的前通知和后通知就是切点执行前执行的切面的方法和切点执行后执行的切面的方法。
				
				
>3.举动-痛点：模板式代码经常出现的场景，比如数据库连接，查出结果后，封装数据，然后关闭数据库，这三大部分的第一第三部分是模板形的，且第二依赖第一中多个变量，第三依赖第一第二中多个变量的，因此不方便注解方式放到一个统一的请求容器里--会产生更多的冗余，且不好做统一的before/after依赖传递和处理。模板和业务逻辑依赖太重。
	>解法/处理思想：模板代码不应该显式出现，但是模板调用是需要的，又因为模板对于实际业务代码 是环绕关系的，所以业务代码要封装到一个回调方法里，回调方法在一个匿名内部类里，内部类实例注入到模板调用里。或者用我自己的方式，即反射的机制-不需要匿名内部类实例。

	
	
>4.举动-痛点： 实例的直接获取、实例的重用，决定要把实例放到一个统一的容器里；另外，发布事件给事件监听者也需要一个独立的第三方来做。
	>解法/处理思想：beanFactory太单一。ApplicationContext应用上下文更完善。