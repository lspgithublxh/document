---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
	
>举动-痛点：满足多种不同的分组交换计算机网络的互联需求
	>解法/解决方案： TCP/IP体系结构
		>TCP/IP 是构成internet的基础：Internet体系结构在几个目标指导下建立。
			>首要目标：将多种网络互联起来，并在互联的网路上同时运行多个应用。
			>二级目标列表：
				>在网络网关失效时候能够持续。
				>支持多种类型的通信服务。
				>兼容多种网络：
				>允许对其资源的分布式管理
				>经济有效的：允许低能力主机接入
				>使用的资源必须是可统计的：
			>基本概念：
				>连接：通话双方之间建立的一条用于传输数据的物理通道/线路。
				>分组：一定字节数的数字信息块。分组通过网络。
				>多路复用：来自不同发送方的块/分组可以组合，而且以后可以分解。使得：网络更有弹性(路径可以改变)、基于统计复用可以更好的利用网络链路和交换设备。
				>分组交换机：
					>内部缓存和队列：存储到达的分组；FIFO服务。
				>面向连接：需要在每个交换机中为每个连接存储一些信息和状态。最流行联网方式。
					>每个分组只携带少量信息，提供到某个状态表的索引。
						>分组中的12位逻辑信道标识符LCI 或者 逻辑信道号LCN
					>交换机中的每个流状态 和 LCN/LCI结合：决定分组交换路径中的下一台交换机。
					>使用信令协议在一条虚电路上交换数据之前：每个流状态已经建立；协议支持 连接建立、连接清除、连接状态信息获取。	
				>数据报：特定类型的分组。有关来源和最终目的地的所有识别信息都位于分组中。所以数据包较大，但不需要交换机维护连接状态；	
					>用于建立无连级的网络：没必要使用复杂的信令协议。
				>消息边界：数据报提供开始和结束UDP；分组交换 中 分组不提供，需要应用自行处理--TCP流协议。	
				>命运共享相关原则：将所有必要的状态放在通信端点；。。。哪些在网络中实现，哪些在端实现。
				>差错控制和流量控制：
					>数据损坏或丢失：硬件问题、传输中被修改；无线网络超出范围。
					>差错控制：上述错误的处理
						>少数差错位出错：数学代码检测和修复。
						>多数位损坏：整个分组重新发送/重新传输。
					>流量控制：降低发送方的发送速度；TCP在端主机中实现速率控制；	
				>分层：实现协议簇的常用方案。	
					>OSI七层：
						>物理层：定义一种通过某种通信介质传输数字信息的方法；。怎么物理表示0/1，并被接收端识别；
						>链路层：定义为共享相同介质的邻居之间建立连接的协议或方法；。。一般两个邻居。Wifi,以太网则是多接入链路层网络；可见链路层是可能多种形式的,且同时存在。
						>网络层：定义针对主机的地址方案(涉及跨多个邻居--转发数据包了)，分组从一台主机发送到另一台主机的路由算法；可互操作的分组格式--可通过不同类型的链路层网络；	
						>传输层：定义会话之间的数据流。
						>会话层：连接初始化和重新启动、增加检查点；
						>表示层：信息的格式转换和标准化编码；
						>应用层：定义一种类型的应用传输数据的语法、语义、流程。
					>分层体系结构：
						>优点：协议复用；允许多种协议共存同一基础设施。相同协议对象的多个实例同时存在，也允许；
							>协议标识符：用于指出链路层帧携带的协议，在每个分组中包含。
							>封装：N层的协议数据单元PDU对象 被N-1层携带时，被称为在相邻低层的封装；封装就是N-1层在N层的数据包前面增加一个报头；那么多个N层的数据包就可以复用N-1层的能力了，；N-1层分解数据包 然后映射到N层，也可以根据报头确定接收协议和程序；
								>每层都有消息对象PDU: 上层提供的PDU, 本层承诺不查看PDU中的内容；。接收方基于标识符:硬件地址/端口地址/ip地址 来拆解 
							---上层 对 下下层 没有直接依赖：所以定义可以更加抽象和广泛通用。
					>ARPANET参考模型：
						>链路层：ARP地址解析协议：完成IP层使用的地址和链路层使用的地址之间的转换。
							>以太网帧：48位目的地址+16位以太网类型(IPV4/IPV6/ARP)
							>接收帧：帧的目的地址和接收方的一个地址匹配
							>选择处理帧的网络协议：根据帧的以太网类型字段；
							>去除帧的头部尾部信息：将帧的有效载荷交给
						>网络层：数据：分组。大的分组放入链路层的PDU-帧时，需要切分为多个小的分片，到达目的地后组合。
							>第三层地址：用于路由器选择对应合适的网络出口：到达下一跳。过程为：转发。IP地址。
							>地址类型：决定如何转发：
								>单播：目的地是一台主机
								>广播；目的地是一个指定网络中的所有主机
								>组播：目的地是属于一个组播组的一组主机
							>ip检测：目的ip地址，是否和自己的一个Ip地址匹配，数据报头没错
							>检测8位ipv4协议字段：决定调用哪个协议来处理。ICMP/IGMP/IPv4/TCP/UDP/IPV6 ，ipv4表示 一个IP数据报可能出现在另一个IP数据报的有效载荷中；是隧道技术的基础；违反了分层和封装的概念；
						>网络层2：控制消息协议ICMP;用于IP层和IP层之间交换 差错信息和其他重要信息。ping ,traceroute 都是用了 ICMP..。。ICMP消息被封装在IP数据包中，与传输层相同的封装方式。
						>传输层： 
							>TCP: 处理数据包丢失、重复和重新排序等IP层不处理的问题；。。。TCP传输层就是对IP层的容错容灾；
								>面向连接：不保留消息边界；
								>可靠的数据流传输：将来自应用的数据分解为在网络层中传输的适当尺寸的块；确认收到的分组和设置超时；--以便对方能够确认自己发送的分组；
							>UDP: 提供比IP协议稍多的功能；允许应用发送数据报并保留消息边界；不强制实现速率控制或者差错控制。	
								>可靠性需要应用层提供：提供一套端口号，用于复用、分解数据和 校验 数据的完整性。
							>DCCP: 数据报拥塞控制协议。面向连接、不可靠的数据报交换；拥有拥塞控制功能；发送方控制发送速率；
							>SCTP: 流控制传输协议。可靠交付，但是不要求严格保持数据的顺序；允许多个数据流逻辑上在同一连接上传输；
							--通过端口号：匹配到对应的应用。
						>应用层：和应用的细节有关。	
					>端口号：IANA分配，16位非负整数。
						>熟知端口号：0-1023: SSH:22, FTP:20,HTTP:80,HTTPS:443
						>注册端口号1024-49151:
						>动态端口号49152-65535:
					>DNS: 分布式数据库；提供主机名和IP地址之间的映射；
					>P2P: 应用既是客户机也是服务器。
					>RFC: 征求意见。
					>与Internet体系结构相关的攻击：
						>欺骗：IP数据报的源地址 伪造。
						>分布式Dos攻击：拒绝服务；向一台服务器发送大量IP数据报，使它花费时间处理接收的分组，无暇其他工作。
						>未授权访问攻击：僵尸网络。，利用协议漏洞控制系统。
						---没有加密：尽管加密有三大好处：不可否认、保密、完整性。
					>看重分组交换的原因：鲁棒性和效率。	
		>Internet地址结构：
			>定义IP地址：
				>格式：ipv6: 8块4位16进制数，:冒号分割；。::双冒号表示连续x个0块；只用一次；；ipv6嵌入ipv4: ::ffff:xxx.xxx.xxx.xxx  如果是URL中，则[ipv6]:port来表示。
				>5类地址：第一个0所在的位置决定了是哪种地址；从1->5分别是A->E类地址；E类地址第一个0所在位置>=5
					>主机号：3字节,2字节，1字节。D类地址 则是组播，没有主机号
					>网络号：非主机号-网络标记号：路由器做出路由决策的依据。
				>子网寻址：站点被分配A-C类地址；对地址的主机部分，再划分为子网号+主机号
					>路由器找到子网ID：通过一个配置参数。
				>子网掩码：使得路由器根据ip地址获得子网信息。静态或者动态；连续1+连续0组成。是一种位置标记。---主机号开始位置索引标记。	
				>子网：地址 & 子网掩码 得到：128.32.1.0/24
				>可变长子网掩码：VLSM
				>动态路由协议：OSPF,IS-IS,RIPv2
				>子网广播地址：主机号全是1， 数据报被接收后发送给子网中所有的主机。
				>本地网络广播：255.255.255.255
				>无类别域间路由：CIDR： 前缀+后面的任意组合。
				--问题：减少路由表条目数 同时 维护到所有的目的地距离最短
			>分配IP地址：
				>分层路由思想：地址分配有规律；按网络号分配、子网络号分配。以较少的路由表条目数。拓扑敏感寻址。IP前缀合并，以减少条目数。
				>特殊用途地址：
					>主机回送地址：127.0.0.1/8
					>专用网络地址：172.16.0.0/12
					>专用网络地址：192.168.0.0/16
					>组播地址：标记+组号
					>任播地址：如用于找到DNS服务器。
				>whois服务：http://www.ripe.net/whois 搜索 一个ip的地址，
				>一台主机：有 主机回送地址+一些组播地址+单播地址；
					>查看一台主机使用的组播地址：netstat -gn 
				>中小规模企业：需要多个IP地址。如 128.32.2.64/26 所有来自或前往这个网络的流量都发送到 企业边界路由器
					>边界路由器的内网端：128.32.2.65/26  连接的DMZ网络。这个网络上有Internet可见的其他服务器：128.32.2.(66-127)/26,其中一个地址可以是一个NAT内部路由器的地址如：128.32.2.66/26, 这个路由器的另一端是内部地址10.0.0.1/16,连接了更多的其他内部计算机。
		>链路层： 帧。 分组，段。
			>帧：可变长度；xB到xKB.上限称为 MTU最大传输单元。
			>以太网：
				>网络结构：共享的电缆段+多个站；
					>传输：当介质确认为空闲状态时，链路层的一个PDU帧 可以从一个站传输到另一个或者多个站。
					>碰撞：多个站同时发送PDU帧；被检测到后，随机等待一个时间后，重新发送；。这种方法：带冲突检测的载波侦听多路访问CSMA/CD, 是每个以太网接口实现的一种分布式算法。
						>载波侦听：检测目前网络中正在发送的信号，空闲了发送自己的帧；
						>同时监听到空闲而发送：则电信号重叠碰撞，等待随机时间后再发；最多等待16次。超过则判定为超时。
				>速度：已经达到100Gb/s
				>星型拓扑结构：每个站之间的线路不共享；中心为以太网交换机。	
				>无线局域网：802.11帧格式同802.3。。使用CSMA/CA 冲突避免。
				>帧格式：802.3
					>前导字段：接收器电路用来确定一个帧的到达时间。并确定编码位之间的时间量。
					>帧起始分割符：SFD: 0xAB
					>目的地址：DST 48位 
					>源地址：SRC 称为 MAC地址，802地址，硬件地址，物理地址。也可以是广播地址，使用ARP协议解析。组播功能用ICMPv6协议 以实现网络层地址和链路层地址之间的转换。
					>类型/长度字段：用于确定头部后面的数据类型。取值：IPv4/IPv6/ARP/Q标签帧；标准帧大小：2000B
					>多种标签：如服务质量Qos指示符。
					>数据区/有效载荷：放高层PDU; 不足可以被填充0
					>循环冗余校验字段FCS：CRC 对帧完整性的检查。
						>CRC码生成过程：原数据 接n个0， 除以 一个n+1位的数(称为生成多项式)， 得到余数， 求余数的反码。 这个反码就是放到CRC位置的值。
							>以太网中：n=32, CRC32的n+1位的生成多项式 是固定的值：1000001xxxxxx
						>接收方的校验：会根据信息再次运算生成余数的反码，来看和FCS是否匹配，不匹配说明受损，通常被丢弃。
				>帧大小：最小64B---有效载荷48B。。最大1518B(14B头部+4BCRC)----一般TCP/IP数据报64kB所以需要44个帧---因此每帧效率大约98%
					>帧大小的设计原因：这个帧的最后一位还没发送时，必须收到第一位返回的值，即收到第一位的返回而还处于传输过程中。这就导致了线缆最大长度不得超过5000m,设计为2500m.。这样发送端可以检测到是哪个帧发生了冲突---如果发送过程中产生了冲突；冲突了则发送一个高电压干扰信号提醒其他站，然后退避。
					>超级巨型帧：9000B,非标准的以太网扩展，千兆以太网交换机中使用。
				>虚拟局域网：VLAN.以太网交换机将主机之间的流量分隔为常见的VLAN.
					>工作站到VLAN的映射：通过端口分配WLAN，。不同VLAN的站连接到同一个交换机，交换机确保流量不在两个VLAN之间泄漏；
					>linux中用命令 为 VLAN ID=2的接口 eth1 添加删除虚拟接口，修改虚拟接口的命名方式并添加新接口：vconfig add eth1 2    用wireshark查看
				>链路聚合：有的系统配备	多个网络接口，具有绑定/链路聚合的能力。
					>链路聚合控制协议LACP：使用一种特定格式的IEEE 802帧。避免手动配置，简化链路聚合的建立工作。
				>局域网唤醒Wol\省电和魔术分组：	
					>唤醒：使linux网络接口或主机脱离低功耗/睡眠状态：基于某类分组的传输来实现。这种分组可以用来触发可配置的功率状态改变。
						>被以下几种帧触发：任何物理层的活动p,发往站的单播帧u，组播帧m,广播帧b,ARP帧a,魔术分组帧g,包括密码的魔术分组帧。
				>链路层流量控制：跨越不同速率网段时，可能需要由交换机将帧缓存一段时间。持续一段时间，帧可能被丢弃。
					>缓解方法1：发送方采取流量控制。网卡和交换机之间：发送特殊信号帧 来传达流量控制含义。PAUSE帧实现。
						>PAUSE消息：类型字段值：0x8808,MAC控制操作码=0x0001,一个站收到这样的帧，则表示建议它减缓发送速率。包含hold-off值，表明继续发送前需要暂停多长时间。
				>网桥和交换机：用于连接多个物理的链路层网络
					>交换机：高性能的网桥。
					>网桥：每个网桥 通过一段时间的对域外MAC地址的学习后，最终每个交换机知道 每个站 可由哪个端口到达。
						>过滤数据库：基于每个端口的列表。
							>首次打开一个网关：数据库是空的，这时收到的帧，如果目的地不是它，则会转发给所有的端口；洪泛。
							>作为网桥：有两个端口的PC也可以。
								>启用网桥：brctl addbr br0... 给网桥添加接口；brctl add br br0 eth0
								>显示网桥细节：brctl showmacs br0
					>生成树协议：STP,可以抑制放大。方法：禁用某些端口---避免形成拓扑环路。
						>生成树：没有环路。一张图存在多个生成树。
						>STP: 用于生成一个图的一个生成树。节点为交换机，链路为边，所以STP会选择某些链路而生成一个树，剩下的链路则不被选择。实现方法1：广度优先遍历
							>新的问题：网桥启用或关闭、接口卡更换或MAC地址改变；；所以需要维护生成树，实现：交换 称为网桥协议数据单元BPDU的帧。
								>BPDU结构：传统以太网帧头部(到L/T长度类型) + LLC/SNAP(0x424203) + 协议ID号()+版本(STP/RSTP)+类型+标识(拓扑变化TC/拓扑变化确认TCA)+附加位+根ID+消息有效期+最大有效期+欢迎时间+转发延迟
							>选择根网桥：VLAN中为标识符最小的网桥；	
						>生成树的选择：链路速度作为该链路的成本，10Mb/s成本100，100Mb/s成本19，所以可以生成一颗成本总和最小的生成树。	
				>网桥端口状态机：阻塞->侦听-->学习-->转发-->禁止		
					>端口角色：根端口、指定端口、备用端口、备份端口
			>无线局域网：wifi 802.11面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。
				>站-接入点AP-分布式服务DS: 站 连接到接入点， 接入点连接到分布式服务：交换机/有线或者无线的主干，形成一个扩展的无线局域网；ESS. 每个ESS有一个ESSID,作为一个网络的名称。----基础设施模式。另一种模式：Ad hoc 自组织模式---站到站通信，，独立基本服务集IBSS
				>帧结构：
					>前导码：用于同步
					>物理层汇聚程序PLCP头部：提供特定的物理层信息。
					>MAC PDU: MPDU
						>帧控制字：
							>2位类型字段：管理帧、控制帧、数据帧
								>管理帧：创建、维持、终止 站 和 接入点 之间的连接。用于确定：是否采用加密、传输网络名称SSID/ESSID,支持哪种传输速率，采用的时间数据库
									>站发现可用网络的过程：和发现相关配置信息，方式：扫描。
										>主动探测网络：扫描时传输一个特殊的管理帧。linux上手动扫描：iwlist wlan0 scan 	
								>控制帧：RTS/CTS和ACK 流量控制。
									>一个站在发送数据帧前：发送一个RTS帧。接收方同意，则返回CTS帧。等待时间后，向站发送数据帧。
									>无线网络中：帧交付出错概率更大。采用 重传/确认 ACK机制，在指定的时间内没有收到ACK会导致帧的重传。重传帧-的重试位设置，接收点保持了缓存条目，从而可以删除重复的帧。
								>数据帧：802.11帧和链路层帧LLC之间存在一对一的关系；但是802.11帧支持帧的分片和聚合。每个分片有自己的MAC头部和CRC尾部。接收方为每一个分片产生一个ACK, 。分片只用于单播；
									>分片的顺序控制：每个分片有一个序列号12位：相同，一个分片号4位：各不相同；。。帧控制字中的	更多 标记 就是 	更多分片没有到达的意思。根据分片号就可以重组原始帧，交给高层协议来处理。大小：256B,-2048B
									>缓存利于批量交付：一次将缓存队列里的全部数据聚合后发送。A-MPDU,参与聚合的每个帧有自己的MAC头部和FCS，这样A-MPDU 可携带64KB的数据，，当然A-MPDU有自己的前导+PLCP头部等。
								--时间同步和省电模式
									>省电模式：PSM 使站进入有限电源状态的方式。
									>时间同步功能：TSF
				>介质访问控制：需要协同传输。
					>三种方法控制共享的无线介质：
						>点协调功能：PCF
						>分布式协调功能：DCF  位 CSMA/CA 一个站可以查看介质是否空闲；空闲则有机会传输。非空闲则等待随机时间，再次查看。
							>载波侦听：
								>虚拟载波侦听：站的侦听：检查每个MAC帧中的持续时间字段。RTS/CTS帧中都有 持续时间 字段。
									>设置持续时间字段：基于帧长度、传输速率、PHY特性；每个站内：网络分配向量NAV的本地计数器。用于估计介质传输当前帧所需的时间+尝试下一次传输之前需要等待的时间。NAV=0,则收到了ACK,否则认为介质是繁忙的。
								>物理载波侦听：
									>评估信道是否空闲：基于能量和波形识别PLCP. 称为空间信道评估CCA
							>冲突避免/退避过程：
								>确定某个信道空闲时，由于很多站可能在等待信道变空闲，所以每个站在发送之前需要计算和等待一个退避时间：= 随机数*时隙(即使us)
								>无线环境中 冲突检测 不实际：因为难以监听自己之外的传输，因此采用冲突避免。站收到源的帧后，等待一小段时间SIFS后发送ACK,不考虑介质是否繁忙。源站一段时间内内没有收到则启动退避过程。
							--Qos: 	在网络利用率和拥塞较高时，支持Qos可能时可取的。Wifi设备有的支持。
								>Qos站：QSTA 高吞吐量站 提供这种。
								>Qos接入点：QAP
								>Qos BSS: QBSS
						>混合协调功能：HCF 支持基于竞争和可控制的信道访问。
							>两种信道访问方法：
								>HFCA控制信道访问HCCA：基于预约的访问。
									>使用轮询来控制信道访问：同步方式访问。优先于基于竞争的EDCA访问。
								>增强型DCF信道访问EDCA：基于竞争的访问。
									>8个用户优先级映射为4个访问类别AC：优先级7最高 。访问类别：背景-尽力而为-视频-音频流量。优先级1-2用于背景AC,03用于尽力而为AC,45视频AC,67音频AC
					>速率-频率范围-信道：5GHz为基本中心频率，信道36：则 +36*5MHz, 信道宽度可达40MHz				
						>AP安装过程：需要指定 其 运行信道，并由用户所在的站修改信道以便连接到AP.如40MHz信道，运行在5GHz以上的U-NII频段。
						>802.11n: 为支持更高吞吐量，采用多输入多输出MIMO 管理空间流：一个给定信道上最多支持4个这种空间流。信道宽度40MHz---更宽则有更大的最大传输速率--432Mb/s
							>单个流的性能的提高：更高效的调制方案。MIMO-正交频分复用OFDM, 每个20MHz信道 最多承载52个数据载波，每个40MHz最多承载108个数据载波。
								>性能更高的调制方案：更容易遭到噪声干扰；
							>更有效的转发纠错编码：编码率5/6,每个流性能提升到65Mb/s, 将保护间隔GI从800ns减少到400ns,每个流的最大性能可提高到72.2Mb/s,。这样，通过4个空间流的完美协同操作，这样可提供最高600Mb/s的传输速率；
							>安全模型：在站和AP之间提供隐私保护。
								>有线等效加密：WEP 。RC4加密算法。
								>wifi保密访问：WPA . 使用加密块代替密钥 方式。RC4加密算法。
									>临时密钥完整性协议：TKIP,确保每个帧都用不同密钥加密；
									>Michael消息完整性检查：
									--通过硬件升级方式使设备支持WEP功能。
								>WPA2: 	AES高级加密标准算法。
									>CCMP: 基于计数器模式的AES,128位的块+128位密钥，。强健安全网络RSN，
								--授权实现：
									>扩展身份验证协议EAP：可使用多种标准和非标准化的认证协议；可以用于建立密钥--包括WEP密钥
								--预共享密钥和802.1x可用于认证和初始化密钥。	
			>点到点协议：在串行链路上传输IP数据报的流行方法。					
				>链路控制协议：LCP 建立链路的基本方法。
					>建立和维护低层的双方通信路径：只需要关注一条链路的两端，无需处理共享资源访问的问题。
					>链路必须支持双向操作：以及异步或者同步操作；位级别帧格式，基于高级数据链路控制HDLC建立链路协议；
				>一系列NCP协议：用于为各种协议(IPV4,IPv6)建立网络层链路。
				>基本帧格式：
					>标志字段：0x7E 0x7E端点用来发现帧的开始和结束。出现在帧中则替换为 0x7D5E ,0x7D5D
					>地址+控制字段：HDLC的。地址：0xFF 所有站。控制字段：指示帧序列和重传行为：固定值：0x03,. 实际传输可以消除这两个字段。
					>协议字段：表明携带的数据类型。
						>协议号的分配方式：高位字节的最低有效位为0，低位字节的最低有效位为1，
					>最后为16位的FCS：CRC16,生成多项式：略。涵盖：FCS和标志字段外的内容。		
				>LCP操作：用于建立PPP链路和各方商定选项；	
					>交换过程：一对包含选项列表的配置请求+配置确认，一个认证交换、数据交换，和一个终止交换；
				>LCP选项：建立一条由一个或者多个NCP使用的链路时，可以对一些选项进行协商。
					>PPP缺少长度字段：串行链路不提供帧封装，对PPP帧大小没有限制，
					>PPP支持一种交换链路质量报告信息的机制：
				>多链路PPP：用于将多条点对点链路聚合为一条链路；	
				>压缩控制协议：LCP可协商一个使得压缩控制协议CCP生效的选项。
					>CCP: 链路进入网络状态时协商。
						>分组交换过程：
						>格式：压缩帧
				>PPP认证：链路处于网络状态前，有必要使用某种认证机制，以识别建立链路的对方身份。
					>有哪些认证方案？
						>最简单、安全性最低的认证方案：密码认证协议PAP ， 请求对方发送密码而已，不加密。像LCP分组，只是协议字段值为0xC023
						>更安全的认证方法：查询-握手认证协议CHAP：一方 发送一个新的随机值，收到之后返回：f(随机值+共享密钥 )	
						>EAP: 可用于各种网络的认证框架。
							>消息格式：可以携带各种认证。
				>网络控制协议：关注支持IPv4/IPv6的NCP
					>在LCP完成链路建立和认证之后，该链路每端都进入网络状态：并使用一个或多个NCP进行网络层的相关协商。
					>IPCP: 用于在链路上建立一条IPv4连接：
						>IPCP分组：使用和LCP相同的分组交换机制和分组格式，除了协议字段值为：0x8021。
				>头部压缩：因为PPP拨号线路速率较慢，而很多小的分组时使用TCP/IP,同一TCP连接上的分组之间变化不大，因此压缩高层协议头部。
					>VJ压缩：一个常见的TCP/IP头部组合是20+20字节，一条链路上的分组之间头部差别很小，因此简化。
					>IP头部压缩新方案: 鲁棒性头部压缩。
				----总之，链路建立 是一个多轮多步骤多方面的协商过程，请求-接受，请求-拒绝-重新协商	
			>环回：使用Internet协议来与同一计算机上的服务器通信。
				>网络层的环回：使用一个虚拟的环回网络接口 来实现。并非真正的网络接口，而是一个操作系统提供的专用软件。	ipv4:127.., ipv6: ::1 localhost 环回地址。linux中，环回接口：lo 
					>过程：数据报到网络层后，离开网络层时，回送到网络层协议栈。可以没有任何硬件开销。ifconfig lo
			>MTU和路径MTU：		
				>链路层网络：以太网。有效载荷字节数：1500；最大传输单元：MTU.
				>分组网络：以太网。IP数据报长度大于链路层MTU，则切割为多个分片，每个分片<MTU..。。包含所有链路的通信网络路径上，最小的MTU为路径MTU
					>IPv4路径MTU发现机制：
				>流类型网络：串行链路。PPP
			>隧道基础：
				>两台计算机通过Internet建立一条虚拟链路：VPN提供这种服务。
					>实现这类服务：隧道。	
						>隧道：高层分组中携带低层数据。如Ipv4分组中携带Ipv4数据 或者携带以太网数据。此时头部协议不再严格分层。允许形成 覆盖网络。
						>为某一层的分组建立隧道的协议： 
							>通用路由封装: GRE 用于网络基础设施内的流量传输。如ISP之间。像第三层隧道技术。
								>GRE头部：4B，2B的校验和选项+标识符(密钥：表示同一流的分组)+序列号
							>Microsoft专用的点对点隧道协议：PPTP 用于用户和ISP，用户和企业内部网之间。并需要加密-如使用MPPE。。是GRE+PPP。可基于PPP提供虚拟的点到点链路。
								>常用于携带第二层帧：如以太网帧。
								>PPTP头部：改进的GRE。R+S+A+标识+回溯+密钥+序列号+确认号
								>建立过程：
									>客户机发送：类型为1的控制消息--表示客户机希望建立一个控制连接.服务器响应。
									>客户机发送：类型为7的控制消息--表示客户机的呼叫请求。窗口设置：64，PPTP采用了自适应的超时机制，根据链路的往返时间进行估算。
							>第二层隧道协议：L2TP
					>单向链路：UDL 链路仅在一个方向上工作。造成无法交换信息---新的标准--卫星提供下行流量
						>动态隧道配置协议DTCP：在下行链路中发送组播hello消息，
			>链路层相关的攻击：			
				>攻击目标：交换机。交换机中有一个基于每个端口的站列表；表被快速填充---被大量伪装的站填充，交换机可能被迫放弃合法条目；导致中断对合法站的服务。STP
				>wifi环境：WPA2更安全。
				>隧道经常是目标：也是攻击工具。
			---链路层技术：分组交换链路：以太网+wifi ，点到点交换链路:PPP 
		>地址解析协议：
			>IP协议设计目标：为跨越不同类型物理网络的分组交换提供互操作。 这需要网络层软件使用的地址和底层网络硬件使用的地址之间的转换。
				>网络接口硬件：硬件地址：48位MAC地址. 设备制造商定义的，存储在设备的永久性内存中。不会改变；
			>ARP: 地址解析协议，提供了在IPv4地址和各种网络技术使用的硬件地址之间的映射。IPv6使用邻居发现协议，并入ICMPv6	
				>网络接口的IP地址：用户或者网络管理员分配的。移动时，甚至从附近的网络连接点的地址池中获得。
				>目的地为同一IP子网的系统：ARP工作。
					>工作过程：ARP向一个共享的链路层网段上 的所有主机发送 ARP请求 以太网帧，称为链路层广播，意思为：如果你配置的地址为xx.xx.xx.xx，回应你的MAC地址。
						>应答：包含IPv4地址+对应的MAC地址，直接发送给请求方；请求方则记录这个映射在内存中。缓存20min
						>传数据：发送方将数据报封装在以太网帧中发送到目的主机，目的地址自然是上一步学习获取到的以太网地址。。。。这是直接交付模式，不需要路由器。PPP不需要ARP..
					>主机和路由器上的ARP缓存：linux上 arp 命令查看。arp -a 	
				>帧格式：
					>标准以太网头部：14B ： DST6+SRC6+长度/类型2(0x0806)
					>硬件类型2+协议类型2+硬件大小1+协议大小1：硬件地址类型如以太网1，协议类型如ipv4:0x0800
					>op字段：2 . 标记ARP请求1，ARP应答2
					>发送方硬件地址：6
					>发送方协议地址：4
					>目的硬件地址：6 ARP请求为ff:ff:ff:ff:ff:ff
					>目的协议地址：4 
				--使用tcpdump查看一个正在执行的正常的TCP/IP应用运行ARP所实际发生的过程：Telnet为例。
					telnet 10.0.0.3 www 
					另一个cmd: tcpdump -e
				--免费ARP：发送自己拥有的IP地址	
				--ARP探测分组：发送方协议字段为0，目的为；IPv4地址冲突检测ACD; 因为这样发送的分组，收到的就有各方的ip地址；没有冲突，则向广播域发送2个ARP请求，表明它在使用的这个IpV4地址；	
				--配置ARP条目：arp -s ip地址 以太网地址，临时的会超时。
			>使用ARP设置嵌入式设备的IPv4地址：另一种是通过DHCP自动分配地址；	
			>与ARP相关的攻击：代理ARP；静态条目处理
		>Internet协议：	
			>架构目标：无连接，不容错的数据报交付服务。可靠性由TCP提供。路由器上有简单的容错：缓冲区满时，丢弃新到的IP数据报。
				>无连接：路由器不维护数据报有关的链路信息，每个数据报独立于其他数据报来处理。IP数据报可以不按照顺序交付。起止相同，但走的链路甚至都可能不一样。中间可能被复制出错。TCP需要处理这些问题(IP数据报的顺序、丢失、错误)，保证可靠性，来提供可靠性。
			>IP数据报格式：
				>报头：类型长度、版本、地址 之类。
					>IPv4: 20B, 4字节数据的传输：高位优先 的字节顺序。称为：网络字节序。
						>版本字段：值4，半个字节。
						>头部长度：IHL 4位-半个字节,保存头部中32位字的个数。
						>区分服务字段：6位，DS
						>显式拥塞通知字段：2位 。ECN 用于数据报转发时的特殊处理。为数据报标识 拥塞标记符， 这样接收方收到后检测到这位，那么就向发送方发送减缓发送速率的信息。
						>总长度字段：16位。Ipv4数据报的总长度：因此最大65535B。。主机不需要接受大于576B的IPv4数据报；UDP则限制为512B
							>被分片后：每个分片的总长度：是这个分片的长度；
						>标识字段：标识由IPv4主机发送的数据报。存发送主机内部的一个内部计数器的值，每次发送+1，
						>生存期字段：TTL, 设置数据报可经过的路由器数量的上限；发送方初始化为如64，每台路由器在发送时将这个值-1，当这个值为0时，该数据报被丢弃，然后发送一个ICMP消息通知发送方。这样可以避免路由环路导致的数据报在网络中永远循环。跳数限制。
						>协议字段：有效载荷部分的数据类型；17UDP/6TCP. 这提供了多路分解的功能，以便IP协议可以携带多种协议类型的有效载荷；
						>头部校验和字段：仅计算IPv4头部；有效载荷需要其他层协议进行--如ICMP/IGMP/UDP/TCP；有自己的头部和数据的校验和。因为经过一台路由器，TTL会减1，所以头部校验和需要重新计算；
							>Internet校验和：非CRC校验算法；而是：先将校验位设置0，计算头部16位二进制反码和---算法：循环进位加法。
							>接受到一个IPv4数据报：对头部计算校验和，看是否和校验位同；不同则丢弃接收到的数据报。不生成差错信息。
							--阿贝尔交换群：
								>集合中的元素对运算 满足性质：闭包性、结合性、交换性、单位元乘法性、单位元分解性、
						>源IP地址+目的IP地址：都是32位；
					>IPv6: 40B
					--IPv4选项：在头部之后，8位类型字段标识，复制1+类别2+编号5
					--分片：ipv4主机或者路由器可以对数据报分片，数据报超过下一跳MTU就会。ipv6只有数据报发送者可以分片。
				>分片头部：8B --含32位标识符(标识分片属于一个数据报)+分片偏移量(8字节数为单位)(13位)。。构造一个IPv6分片：ping -l 3952 ff01::2   负载包含分片头部。
					>新增的开销：网络层：IP头每个40B，分片头每个8B;  链路层：每个帧头部14B，校验和4B
				>IP数据：
			>IP数据报的转发：大多数主机既可以配置为路由器，也可以配置为主机。主机：不转发不是由它生成的数据报。
				>路由表/转发表：每转发一个数据报，都要查。
					>每个条目的字段：
						>目的地：32位，针对所有目的地--则为0，。主机路由：则完整的IP地址。用于与一个掩码操作结果相匹配
						>掩码：32位，用作数据报目的IP地址按位 与 操作；目的IP地址需要在转发表中查找。掩码结果需要在转发表的多个目的地中比较。
						>下一跳：32位，下一个IP实体--路由器/主机的32位IPv4地址，数据报被转发到该地址；共享同一网络前缀？
						>接口：IP层使用的标识符。用于选择输出数据报的源IP地址。无线接口/以太网接口/串行PPP接口；
						--可见，不包含到任何目的地的完整转发路径；只提供下一跳的IP地址；它假设下一跳更接近目的地，且下一跳与本路由器的执行转发的系统直接连接；---共享同一网络前缀；也假设与下一跳实体之间没有环路，数据报不会在网络中循环；直到TTL到期。
						--确保路由表正确的协议：RIP，OSPF，BGP，IS-IS，		
				>大致过程：
					>先看目的地址：是否为自己的IP地址，或者时IP组播地址广播地址-且可以接收。是则将数据报交付给 ipv4头部的协议字段 /ipv6头部的下一个头部字段 指定的 协议模块。不是：如果IP层配置为路由器，则转发该数据报；或者丢弃数据报；或者ICMP消息可能发送回源节点，以表明发生了一个错误；
				>详细过程：
					>检查IP数据报中的目的地址D：用该值在转发表中执行 最长前缀匹配 算法： 
						>匹配条目：假设条目为ej,掩码字段值为mj, 目的地值为dj,下一跳字段值nk;  则计算：D & mj 这个结果就是 dj', 和  dj比较，相同则表示匹配；此时看掩码中1的位数，位数越多的，则所在条目更匹配；则找出最匹配的条目，它的nk作为转发数据报的下一跳IP地址；
							>如果没有发现匹配的条目：数据报则无法交付；则向生成数据报的应用程序发送 主机不可达 错误；ICMP消息；多个条目匹配到-相同位数；则第一个或者随机一个；
								>对于主机：没有发现匹配，一般走默认路由条目；路由器一般也有默认路由：掩码=0，目的地=0。
					--直接交付：无需路由器。。条目的网关部分包含 发送主机 的 网络接口。
					--间接交付：IP数据报的目的地址就是下一跳路由器的链路层地址；
						>默认路由器的路由表：一般一侧为内网地址---连接到主机，另一侧连接到其他路由器---为公网地址；且转发主机的数据报时候，会经过NAT转换，将数据报的源ip地址转换为这个公网端口的ip地址；
							>链路本地地址：ping6 fe80:204:5aff:fe9f:9e80
							--查看到达目的IP的路径：traceroute/tracert: traceroute -n ftp.uu.net 展示经过的每个IP跳步。使用UDP+ICMP完成；
				>移动IP：是一种特殊的协议；MIPv6
					>基本模型: 双向隧道。移动节点：MN；通信节点：CN。 家乡地址：hoA , 从家乡网络的网络前缀获得的IP地址；漫游到另一个可访问的网络时，被赋予另一个地址：转交地址CoA.
						>当一个CN与一个MN通信时，该流量需要通过MN的家乡代理HA来路由。HA是特殊类型的路由器，部署在网络基础设施中。MN的HoA和CoA之间的关联为MN绑定；
						>当MN移动连接到一个新的CN时：接收自己的CoA,并向自己的HA发送一个绑定更新消息。HA响应一个 绑定确认。然后HA来路由MN的流量，并使用一种双向的IPv6分组隧道，且这些消息通过IPsec的封装安全有效负载ESP来保护；也可以确保HA不会被一个伪造的MN绑定消息欺骗。
						--新问题：HA和MN之间距离远 从而 路由效率低：路由优化RO 的办法。确保RO安全和可用 则相应复杂。
							>RO操作：
								>注册绑定的建立和维护：MN向CN证明自己的真实身份---RRP返回路由程序来完成；支持RRP的消息在MN和HA之间不使用IPsec..。。RRP使用一些移动消息 HoTI/HoT/CoTI/CoT等向CN验证一个特定的MN的家乡地址和转交地址可达。类似通过HA而交换对称密钥，从而MN和CN之间可以直接传输数据。
								>所有绑定建立后的数据报交换方法：
				>IP数据报的主机处理：				
					>主机模式：
						>强主机模式：目的ip地址 与数据报到达的接口配置的IP地址匹配；才同意把数据报交付本地协议栈；
						>弱主机模式：目的ip地址 和数据到达的任意接口任意本地地址匹配，都会被接收的协议栈处理。
					>地址选择：一个接口可能多个对外地址
						>默认地址选择：策略表；最长前缀匹配查找表；
							>源地址选择算法：
							>目的地址选择算法：
				>与IP相关的攻击：
					>分片重组、IP欺骗攻击--源IP
		>系统配置：DHCP 和 自动配置 
			>配置项：本地名称、接口标识符(ip地址如)
				>每个接口都需要：IP地址、子网掩码、广播地址(ipv4)。DNS服务器和路由器的IP地址。对于移动IP： 一个家乡代理 的找到是必要的。其他要素：组播路由器、VPN网关、会话发起协议SIP/VoIP网关；
				>建立基本要素和协议和程序：动态主机配置协议DHCP, ipv4/ipv6无状态地址自动配置；ISP也可以通过PPP结合以太网来配置客户端系统；
					>配置方法：路由器和服务器：输入配置信息到文件；
			>DHCP: 用于为主机指定配置信息。
				>DHCP客户机：客户端操作系统一般都支持；68端口
					>从DHCP服务器获得的内容：IP地址、子网掩码、路由器的IP地址、DNS服务器的IP地址；其他服务的相关信息；
				>DHCP服务端：67端口
					>地址管理：IP地址的动态分配，并为客户机提供地址租用；
						>自动分配：客户端从服务器配置的地址池中获取一个不可撤销的IP地址；
						>手动分配：地址不是服务器端维护的可分配池的一部分，DHCP此时仅仅用来传输地址。
						>动态分配: 客户端从服务器配置的地址池中获取一个可撤销的IP地址；
							>可用地址池：一个连续的IP地址范围；
							>租用期：一段时间，地址只在这个期间有效；可以续约。
							>客户机请求：内容：客户机名称、请求的租用期、最后使用的地址和其他参数如MAC地址；
							>服务端响应：地址+配置信息。
					>配置数据交付: DHCP协议的消息格式和状态机。
				>设计来源：Internet引导程序协议BOOTP。
				>租用：客户机使用一个商定的时间来配置信息。	
				>协议：UDP/IP
				>消息格式： 
					>操作：请求1，应答2
					>类型：基于ARP使用的值1
					>长度字段：MAC地址的长度；6
					>跳步：消息传输过程中的中继次数。0
					>事务ID：客户机选择的随机数；
					>秒数：第一次尝试申请经过的秒数
					>标识：广播标识；
					>客户机IP地址： 如果已知
					>你的IP地址：服务器填写提供给你的
					>下一服务器IP地址：下一个服务器的地址，用于客户机的引导过程。
					>网关/中继IP地址：DHCP/BOOTP中继器填写，转发DHCP消息时返回自己的地址；
					>客户机硬件地址：客户机的MAC地址；被用作标识符。
					>服务器名：
					>引导文件名：
					--DHCP选项：
						>填充0，子网掩码1，路由器地址3，域名服务器6，域名15，地址租用期51，租约更新时间58，DHCP消息类型53--一字节长度--一定会使用-可能值DHCPDISCOVER1,,,
				>协议操作：
					>先发现可用的DHCP服务器：以及它们能够提供的地址；然后决定使用哪台服务器和哪个地址；然后向该地址的服务器发送请求；
						>即：广播一个DHCPDISCOVER消息；
					>服务端确认该地址是否已经被分配出去：没有则确认分配给请求的客户机。
						>即：响应一个DHCPOFFER消息；你的IP地址：就被填写了提供的IP地址(可能是一个内网地址--且和客户机提供的要求的不同)；+租用时间+更新时间+重新绑定时间。
					>客户机再次广播：DHCPREQUEST消息；请求的IP地址=客户机选择的接受的那个OFFER提供的地址；
					>服务端：对应的那个服务端才同意将该地址进行绑定；其他服务器清除与该请求相关的状态；完成绑定，响应一个DHCPACK消息，通知客户端使用该地址；无法分配，则响应DHCPNAK消息；
					>客户机收到该DHCPACK消息，得到地址：开始探测，向该地址发送一个ARP请求以执行ACD；
					--释放使用DHCP获得的数据：ipconfig /release 获得数据：ipconfig /renew
					--查看使用DHCP获得的数据：ipconfig /all
				>DHCP状态机：
					>客户机状态：初始-->选择-->请求-->绑定-->更新-->重新绑定-->初始
				>DHCPv6消息格式：客户机546，服务端547；
				>DHCPv6协议操作：
				>DHCP中继：
					>客户机不直接连接服务端；而是连接到一个或者多个DHCP中继代理；
					>客户机与中继：
						>中继信息代理：标识发送请求的DHCP客户机；---本地解释的命名方法；
					>中继代理与服务端：认证子选项提供了确保消息交换完整性的方案；类似DHCP延期认证方法；有散列算法SHA-1
						>服务端响应中继查询：DHCPLEASEUNASSIGNED ，DHCPLEASEACTIVE,DHCPLEASEUNKNOWN
						>租约查询的扩展：BL 大批量租约查询--TCP/IP
					--第二层中继代理：针对 交换机+网桥	设计的轻量级 DHCP中继代理 LDRA
					--认证DHCP消息的方法：认证选项。来确定DHCP消息是否来自一个授权的发送方；
						>认证信息：消息认证码MAC，提供对发送方的认证和消息的完整性的检验；
						--使用很少：因为需要在客户端和服务器之间分发共享密钥。
			>无状态地址自动配置：SLAAC，用于链路本地地址(非全球性地址，无需被管理)自动配置的机制；
				>主机所在网络没有DHCP服务器和手工配置：可以自己按照某种方式生成IP地址：自动从链路本地范围169.254.1.1--169.254.254.254 使用16位子网掩码255.255.0.0 生成自己的IPv4地址； 即链路本地地址的自动配置；或者 自动专用IP寻址；APIPA; 即主机随机选择一个，然后检查该地址是否被子网其他主机使用；通过IPv4 ACD检查；
					>自己分配ip地址169.254/16 的结果是本地子网访问可能正常，但是Internet路由和名称服务DNS很可能不正常；当DNS不正常时，大部分常见Internet“体验”无法实现；
					--可以禁止使用APIPA,防止系统自己分配一个IP地址；windows中改注册表项；；linux中，/etc/sysconfig/network 可修改为 NOZEROCONF=yes
			>DHCP和DNS交互：当一台客户机获得一个IP地址，它同时获得的配置信息里还有：DNS服务器IP地址。
				>组合DHCP/DNS服务器：是一个服务器程序；在使用DHCPACK进行响应之前，通过“名称到地址”的绑定更新 内部DNS数据库；客户机名称-绑定地址。
			>以太网上的PPP：对于广域网连接，基于PPP的方法是更常见的客户机系统配置方法；	PPPoE
				>PPP作为某些ISP建立连接的首选：它可提供比配置选项DHCP更细致的配置控制和审计日志。
				>协议阶段：
					>发现阶段：交换几个PPPoE主动发现消息：PADI初始化，PADO提供，PADR请求，PADS会话确认..用于确定访问控制器的身份；
					>PPP会话阶段：ppp流量可以封装在以太网帧中；PPP协议 的配置功能 如 IPCP 最终负责为客户机分配IP地址；
			>与系统配置相关的攻击：伪造/未授权 客户机服务器引起的干扰；到耗尽资源的各种形式Dos		。。DHCP认证+SEND协议
		>防火墙和网络地址转化：控制互联网中网络流量的流向，限制所转发的流量类型。
			>防火墙：一种限制所转发的流量类型的路由器。
			>新问题：管理IP地址的分配和使用：网络地址转换NAT。从而可以在互联网的不同部分/地址范围 被重复使用；允许在多个范围中的同一地址重复使用---缓解地址耗尽的问题；
			--NAT+防火墙 的复合设备，是连接终端用户的最为常见的路由器类型；连接家庭网络，小型企业网络 到 互联网；
			>防火墙：确保终端系统免受攻击：利用防火墙来过滤部分流量以限制流量流向终端系统；
				>代理防火墙：多宿主的服务器主机。是TCP/UDP传输关联的终点，不会在IP层路由IP数据报；
					>是运行多个应用层网关ALG的主机，该主机拥有多个网络接口，能够在应用层中继 两个 连接/关联 之间的特定类型的流量；有内外两个IP
					>为每个传输层设置一个代理：客户端需要部署代理；
					>HTTP代理防火墙：web代理，；对内部来看，就像web服务器；外部网站来看，就是客户端；并提供web缓存；也往往加了内容过滤器：能够基于黑名单来阻止用户访问某些web网站；隧道代理服务器---CGIProxy---以避免用户被内容过滤器阻封；
					>SOCKS防火墙：
				>包过滤防火墙：互联网路由器。可以丢弃符合/不符合条件/规则的数据包；规则和标准称为：过滤器
					>简单过滤器：网络层+传输层报头中各个部分的范围比较；无状态的，单独处理每一个数据报。
						>IP地址过滤：
						>选项过滤：
						>ICMP报文的类型过滤：
					>复杂过滤器：有状态，关联已经到达的数据包，推断流或者数据报的信息，如构成同一个IP数据报的IP分片；	
					--规则安装：网络管理员安装 过滤器+访问控制列表ACL到防火墙中。限制外到内，也可能内到外
			>网络地址转换：NAT	
				>基本原理：重写通过路由器的数据包的识别信息；两个方向上，因此需要重写内部发往外部的包的源IP地址---变为NAT路由器面向Internet的网络接口地址，重写外部发往内部的包的目的IP地址---内部设备的内网地址；
				>NAT附加功能：
					>转换：
					>包过滤：
				>基本NAT：只执行IP地址的重写；将私有地址改写为一个公共地址；不流行；因为并没有减少使用IP地址数量；---即这种方式仅仅改变了内网ip地址为公网ip地址，端口号没有改变；每个内网地址都重写到了不同的ip公网地址；
				>网络地址端口转换NAPT：使用传输层标识符(TCP/UDP端口,ICMP查询标识符)来确定一个特定的数据报包到底和NAT内部的哪台私有主机关联；这使得大量的内部主机能够同时访问互联网，而使用的公有地址数量却很少；通常只需要一个；---即重写内网ip地址到同一个外网ip地址，同时重写了端口为不同的端口；这样区分了不同的数据包来源；
					>三个ipv4私有地址范围：10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 常常用来作为嵌入式DHCP服务器地址池的默认值；
					>NAT策略：允许所有的传出及其返回流量通过NAT，但几乎阻断所有传入的新连接请求。。。也利于内部拓扑的隐藏；。。。
					>TCP三次握手：A:发SYN包，B: 发SYN包+ACK确认， A:发ACK确认；。。。结束：发FIN包，强行结束：发RST包
					>内部主机发起一次TCP的过程：
						>内部主机构造SYN包：(10.0.0.16:9200,212.110.167.157:80)
						>NAT/防火墙作为客户端的默认路由器：接收这个数据包，查看TCP报头-SYN位为打开，于是判定为新的连接，于是修改源IP为NAT面向Internet的网络接口的IP地址，转发数据包：(63.204.134.177:9200,212.110.167.157:80)
							>同时：创建内部状态--NAT会话 来记录：当前正在处理的新连接；。。状态的内容：NAT映射：客户的源IP+端口--转换后的IP+端口；因为处理回复的数据包时需要；
							>同时：激活连接计数器，如果回复的ACK数据包在计数器过期前还没到，计数器将被清除，并创建超时较长的会话计数器，此时NAT会向内部端点发送额外的数据包 ---确认该会话是否已经终止--探测；；没有收到响应，或者收到RST数据包，则状态将被清除；
							--一个TCP连接被建立或清除时，最大的空闲时间是4分钟；所以NAT在判定打开或者关闭的连接是否已经断开前至少需要等待4min
						>服务器回复：(63.204.134.177:9200,212.110.167.157:80) 即NAT外部地址，称为端口保留；
						>NAT处理：比较收到的包的目的端口 和NAT映射条目，可以确定发起请求的客户端的内部IP地址，从而将回复的数据包改为：(10.0.0.16:9200,212.110.167.157:80) 然后进行转发。
						>客户端收到请求：一般表示已经连接到服务器；
					>内部主机发起一次UDP的过程：UDPm没有SYN，FIN，RST标记位，来表示会话的建立和清除；如果UDP数据包被分片，一般不能被NAT正确处理。	
					>ICMP的NAT行为要求：ICMP提供了关于IP数据报的状态信息，也能够用于测量和收集网络状态信息；
					>NAT和隧道数据包：NAT需要修改IP包头+封装在其中的其他数据包的包头和有效载荷；如点对点隧道协议PPTP的通用路由封装GRE包头；
					>NAT之后的服务器：
						>端口转发/端口映射：NAT外部地址被用于查找服务器，NAT则妥善重写和转发到服务器的适当流量；。此时，就可以让服务器给互联网提供服务；---即便它被分配了私有的不可路由的地址；
							>静态配置NAT：服务器的ip+端口；一个始终存在的NAT映射；如果服务器的IP地址被更改---NAT必须更新寻址信息；。。
							>局限性：如果NAT只有一个外部IP地址，最多将相同传输协议的一个端口转发到一个内部机器；。例如：TCP 80 端口访问内部的服务器；
					>NAT编辑器：IP层+传输层+有效载荷本身的改写；。PPTP进行透明操作时需要NAT编辑器；		
				>NAT穿越：
					>直接通信：
					>针孔：NAT的临时NAT映射；
					>打孔：采用针孔试图使位于NAT之后的两个或者两个以上的系统直接通信
						>客户机通过服务器连接到其他客户机：因为服务器保存有每个客户机的连接信息，直到它们的外部寻址信息；然后在客户机之间交换它们的外部寻址信息；。Skype便使用了这种方法；
							>一个客户端的外部寻址信息：就是这个客户机的最外层NAT的网络接口地址；
							>交换：即服务器发送其他客户机的外部寻址信息给这个客户机；
							--确定地址信息：应用程序使用一系列方法来定位其流量在通过NAT时所采用的地址；
								>直接：应用和NAT之间通过一个或者多个特殊协议来进行直接会话；
								>间接：VoIP应用
									>UNSAF方法：
							--NAT会话穿越工具：STUN 源自 UDP简单隧道穿越NAT---在VoIP/SIP应用中使用了一段时间。能够确定在NAT中使用的外部IP+端口；需要：公共STUN服务器+合作服务器
								>客户端：需要实现STUN请求协议，。STUN操作使用UDP、TCP或具备传输层安全性TLS的TCP；
									>STUN报文：头 20B   UDP/IP发出。
										>00开头：
										>报文类型14位：请求，响应，错误，成功
										>报文长度16位：
										>魔数：32位
										>事务ID：96位；请求响应；标志 事务；
										>多个属性：
							--利用NAT中继的穿越：TURN
								>公共互联网上的TURN服务器：中继就是客户机先和服务器通信，然后服务器将数据转发给其他客户机/对等客户端；因此，这并非直接的方法；
							--交互式连接建立：ICE 帮助NAT后的UDP应用主机建立连接；主要用于基于SIP/SDP的应用，将ICE定义为可扩展的报文和现场协议；	
			>配置包过滤防火墙和NAT：
				>防火墙规则：说明匹配条件的指令，来选择丢弃或者转发流量。
					>配置路由器；
						>配置一个或者多个ACL：每个ACL：规则列表---模式匹配条件+对应的动作
							>匹配条件：表达网络层/传输层中的包字段值+方向的说明--传入/传出的流量
							>对应的动作：阻止或者加速符合某个规则的流量；调整计数器或写一个日志条目。
							--例子：linux中的 iptables 根本基于一个NetFilter 的网络过滤功能来构建的；
								>表格：table 预定义表格：filter,nat,mangle
									>filter: 处理基本的包过滤；预先定义的INPUT,FORWARD,OUTPUT三条链； 分别对应的流量：到达的是路由器本身的应用程序、通过防火墙的流量、从防火墙主机发出的流量；
									>nat: PREROUTING,OUTPUT,POSTROUTING 三条链
									>mangle: 五条链，用于任意修改数据包
									--每条过滤脸：是一个规则列表；(匹配条件+对应的动作)
										>ACCEPT: 数据包将被转发
										>DROP: 数据包将被丢弃
										>QUEUE: 数据包将被提交给一个用户程序处理
										>RETURN: 处理将在之前触发的一条链中继续；
								>过滤链：chain
					>配置NAT: windows中ICS,linux中IP伪装；			
			>IPV4/IPV6共存和过渡中的NAT：双协议栈。
				>共存方法：
					>隧道：
						>Teredo,:
						>双协议栈精简版Ds-Lite:
							>在ipv6中的ipv4软电线隧道：只有ipv6的架构 也使服务提供者可以支持ipv4/ipv6客户网络
								>每个客户使用：B4 前网关；AFTR后设备 ---也执行NAT,。。这样，Ds-Lite通过一个服务提供者的IPv6网络 为客户提供了 到IPv4的访问；
							>SPNAT: 在服务提供者边缘使用。
						>IPv6快速部署6rd: 目标：通过一个服务提供者的ipv4网络为客户提供到IPv6的访问；
							>从IPv6地址映射到相应的IPv4隧道端点的计算：通过一个无状态 的 地址映射算法。框架：也使用了无状态地址转换；
					>转换：ipv4和ipv6之间转换的框架；使得一个ipv6主机可以访问一个ipv4网络上的服务；。转换，并添加 行为或者ALG的定义；
						>地址转换：To4(A6, P) P为前缀，A6为IPv6地址；To6(A4,P)前缀为P,A4为ipv4地址；
							>无状态转换：无需状态表格；进行ipv4/ipv6数据包的转换；
								>转换ipv4到ipv6报文：例如 版本、DS字段、流标志、负载长度、下一个头部、跳数限制、源IP地址、目的IP地址。
								>转换ipv6到ipv4报文：流入 版本、IHL、DS字段、总长度、标志、标识、分片偏移、TTL、协议、头部校验和、源IP地址、目的IP地址；
							>有状态转换：NAT64;;ipv6客户机---ipv4服务器，和NAT穿越技术兼容(ICE,STUN,TURN)	
			>防火墙和NAT相关的攻击：不正确的配置---没有能力处理IP分片；；受到外部劫持；				
		>ICMPv4,ICMPv6: Internet控制报文协议
			>背景：ip协议并没有提供 如何发现 发往目的地址 失败的 ip数据包。IP也没有提供直接的方式来获取诊断信息；
			>ICMP: 提供与IP协议层配置和IP数据包处置相关的诊断和控制信息；使用IP协议进行传输。负责传递：可能需要注意的差错和控制报文；但不提供可靠性；只是一种检测报告
				>报文的触发：IP层，传输层、应用层；丢包不会触发ICMP信息；由TCP来处理。防火墙一般封阻ICMP报文----也导致诊断程序如ping/traceroute 将无法正常工作；
				>ipv6中的作用：
					>一些简单的错误报告信令：
					>邻居发现：ND 与IPv4的ARP作用类似
					>配置主机和管理组播地址的路由器发现：RD
					>帮助管理移动Ipv6中的切换：
				>在ipv4中的封装：<576B			
					>ipv4头的协议字段：值为1， 表示该报文携带了ICMPv4.... ICMPv4报文可能被分片；
					>ipv4头之后就是ICMP头部：
						>类型：8位 42种类型；8个经常使用；
							>差错类报文：有关IP数据报传递。目的不可达3，重定向5,超时11，参数问题12
								>处理：应用层用户进程、传输层协议；。重定向报文---导致主机路由表的自动更新，目的不可达报文---路径MTU发现机制PMTUD--传输层协议实现；
							>信息类报文：有关信息采集和配置；。回显请求8，回显应答0，路由器通告9，路由器请求10
								>处理：将被操作系统自动处理；
						>代码：8位 进一步指定报文的含义；
						>校验和：16位 整个ICMP数据段的校验和。传输过程中不会被路由器修改---因为只改变了IPv4的头--如下一跳MAC地址；接收方如果发现校验和错误，则直接丢弃ICMP报文；
						>依赖类型+代码的内容：
					>ICMP数据：原始数据报的IP有效载荷区中的任何其他数据。
					>扩展数据结构：扩展头部+可变数量数据。如目的不可达、超时、参数问题报文。
				>在ipv6中的封装：
					>报文类型：
						>差错类+信息类：
						>IPv6路由器+主机的配置：
					>报文处理：未知的 差错报文 传递给上层产生差错的进程；未知的信息类报文直接丢弃；	
				>ICMP差错报文：
					>不会产生响应的差错报文的条件：避免广播风暴
						>ICMPv4差错报文：
						>目的地址是ipv4广播地址/组播地址
						>作为链路层广播的数据报：
						>不是第一个分片的其他分片：
						>源地址不是单个主机的数据报：
					>限制从单一发送者发出ICMP总体流量水平的规则：令牌桶限速发送；
					>目的不可达报文：传输过程出了问题，或者 接收者不感兴趣。
						>主机不可达：代码1  路由器或者主机产生的(如最后一跳的路由器发现主机不存在)
						>端口不可达：代码3 目的应用程序还没有准备好接受它；--常常和UDP一起使用时出现；--该端口号并未被服务器进程使用；可以TFTP+tcpdump 查看数据包交换的方法来说明。tcpdump -s 1500 -i eth1 -vv icmp or port tftp  每个数据包捕获1500字节，监视eth1以太网接口上的流量，-vv表示输出中将包含更多的描述性信息；。icmp or port tftp 表示输出中要包含匹配TFTP端口号69或者ICMPv4协议的流量；
						>需要分片：代码4 目的不可达，原因是中间某个路由器的传出网络接口的MTU<数据报的大小，而数据报里的IP头部设置了不分片字段，则这个数据报被丢弃，并产生ICMPv4 PTB报文，差错报文中有MTU值；。可以用来测定路径MTU,确定合适的包大小；
						>管理禁止通信：代码13 管理禁令正阻止 到目的地的成功通信；如防火墙故意丢弃流量导致；
					>数据包太大报文：
					>重定向报文：路由器确定自己不是主机将数据投递到目的地的下一跳，则发送重定向ICMP报文给主机--使主机更新路由表(同样目的地下一次就走其他路由器)，并将报文发送到正确的路由器；
						>报文内容：包括 目的地址--采取的下一跳路由器地址；
						>报文格式：类型5，代码1。。。测试：改变默认路由：netstat -rn ; 
							>route delete 0.0.0.0 删除默认路由器的配置
							>route add 0.0.0.0 mask 0.0.0.0 10.212.2.112 添加新的默认路由器的配置 
							>ping ds1.eecs.berkeley.edu  发送报文 先经过dns解析出ip 后会先到 10.212.2.112
							--同步运行：tcpdump host 10.212.2.88 来看 具体的活动，看得到重定向 行为
					>超时报文：类型11 ，代码0/1，因为IPv4报文头部有TTL生存周期字段--8位，当TTL=0时就会导致路由器丢弃报文，产生ICMP超时报文。此报文可以保证traceroute工具的正常运转；其他超时情景：分片有的没有到达，一段时间后就产生ICMPv4超时报文通知了。traceroute 使用来确定跳数：即从1开始，测试到没有收到ICMPv4超时报文为止的跳数；使用 wireshark可以查看到ICMPv4报文的具体各项内容；
					>参数问题报文：IP头部存在不可修复的问题。如某个字段超过了可接受范围；如总长度字段/IHL字段；
				>ICMP查询/信息类报文：	
					>回显请求/应答 报文；ping 类型8/0,
						>报文格式：包含 标识符+序列号。。标识符：值可能是进程ID, 序列号：每收到一个数据包，就+1；方便查看数据包是否丢失、重排、重复；RTT测量：都是当前主机的当前时间来协定的；
						>报文发送：通过ping程序；
							>发送到子网广播地址：ping -b 10.0.0.127 子网中所接收的节点都会响应；这样还学习到了子网其他主机的链路层地址；来更新自己的ARP表；
					>路由器发现报文：基本路由器及组播侦听发现的报文；
						>报文格式：路由器请求10/路由器通告9。。。
							>通告：路由器发送：定期对本地网络的所有主机组播地址224.0.0.1 进行组播，并提供给需要的主机；通常使用RS报文进行请求，发送到所有路由器组播地址224.0.0.2上；
							>发现：让一台主机学习到它所在的本地子网中的所有路由器；，以便从中选择一台作为默认路由器；
								>也被用来：移动IP的节点定位一个移动代理/(本地代理、外地代理)
					>组播路由器发现：MRD: IGMP类型48/49/50  主机和路由器以外的系统 也可以了解 网络层 组播路由器和感兴趣的主机的位置；TTL=1,设置路由器告警：通告151/请求152/终止153			
				>IPv6中的邻居发现：NDP/ND 将路由器发现+ARP提供的带地址映射功能的ICMPv4重定向机制结合；用来支持移动IPv6....。。ARP+ipv4广泛使用广播地址，而ipv6使用组播地址；	
					>ND: 邻居请求/通告 NS/NA 在网络层和链路层地址之间提供类似 ARP的映射功能；
						>主要目的：将ipv6地址转换为链路层地址；也用来检测附近节点是否可达；是否双向可达； ping6 -s ..
						>邻居不可达检测：
						>安全邻居发现：SEND    
							>密码生成地址：ipv6地址；基于节点的公钥信息，而将地址和节点证书关联起来；
					>路由器请求/通告：RS/RA 提供的功能包括：路由器发现/移动IP代理、重定向；以及对一些自动配置的支持；
						>表明附近路由器的存在和功能：它们定期被路由器发送；或者响应一个路由器请求RS报文；RS报文被发送到所有路由器组播地址ff02::2
				>ICMPv4和ICMPv6的转换：IP+ICMP头部都要转换；类型/代码 号的映射，分片、MTU大小和校验和的计算；		
					>类型值转换：
					>重新计算IPv6伪头部校验和：
					--信息类报文：回显请求+回显应答报文被转换；
					--差错类报文：目的不可达、超时、参数问题  三类差错报文被转换；
			>与ICMP相关的攻击：
				>泛洪：生成大量流量，导致针对一台或者多台计算机的有效DoS攻击；
				>炸弹：发送经过特殊构造的报文；能够导致IP/ICMP的处理崩溃或者终止；
				>信息泄露：帮助其他攻击；
				--例子：使用受害者地址为源地址的广播报文；重组时过大的IPv4数据报---Ping of Death攻击；改变ipv4头中的分片偏移字段---导致ipv4分片重组路由器---泪滴攻击；Land攻击；重定向攻击；流氓RA问题；
						Smack/Bloop攻击；
		>广播和本地组播:  链路层地址如何有效地用于从一台计算机向其他计算机发送组播或者广播流量？
			>互联网组管理协议IGMP:
			>IPv6组播侦听发现MLD: 企业和本地网络中使用；
			---一般提供了两种服务：
				>数据分组交付到多个目的地: 邮件发送/新闻分发；如果没有广播/组播，则服务的实现就是使用TCP--将一个单独的副本依次交付到每一个目的地--非常低效；
				>通过客户端请求/发现服务器；例如主机通过DHCP获取了初始IP地址后，获取最近的路由器的方式；
			---一般为使用UDP传输协议的用户应用程序利用广播和组播；：此时应用程序发送单个报文到多个收件方才是有意义的；
				>TCP不能使用广播/组播地址，但可以单播和任播地址(类似单播地址一样)
			---其他使用组播/广播的系统进程：路由协议、ARP、IPv6中的ND;..。IPv4中，组播是可选功能；ipv6中则是必须的了；	
			>广播：
				>路由器行为：将收到的报文转发到除了接收到的接口以外的每一个接口。
				--每个子网都有一个本地定向子网广播地址：即将主机号都设置为1。。。路由器的每个接口的定向子网广播地址：可以查看--ifconfig eth0 
					>如：ping一个广播地址：ping -b 10.0.0.127 可以收到比发送的请求数更多的响应；
						>过程：ipv4的实现通过咨询本地路由表中的信息和接口配置信息，确定这是定向子网广播地址，然后使用链路层广播地址ff:ff:ff:ff:ff:ff 发送该数据报；源地址自然是单播地址---只能是单播地址；而响应报文---自然是带上了它的ipv4地址的；
						>api过程：应用程序使用UDP协议，且API中特殊标志：SO_BROADCAST 以表示该应用程序确实 打算 发送广播数据报；
				--确定哪些接口用于广播：可以咨询ipv4转发表/路由表；	netstat -rn   展示接口列表；；展示 定向子网广播地址--接口地址	
			>组播： 
				>接收方：指明组播地址+可选源地址列表；主机和路由器中：软状态来维持；需要定期更新和超时删除；。。只看流量的组地址--不看源地址：称为任源组播ASM；看源地址则是特定源组播SSM；
				>IP组播流量如何使用MAC层组播地址：将ip组播地址转换为802 MAC/以太网地址。
					>MAC单播地址范围：00:00:5e:00:00:00 到 00:00:5e:ff:ff:ff 
					>MAC组播地址范围：01:00:5e:00:00:00 到 01:00:5e:ff:ff:ff  IANA 用来识别 IEEE 802 LAN 上的IPv4组播流量；
					>ipv4地址到IEEE 802 链路层地址/mac地址的映射：将ipv4地址的后23位取出来,前面补充一个0，直接放到 01:00:5e:... 后面。
						>ipv4组播地址：224.0.0.0-239.255.255.255 即 1110000.... 到 1110 1111.... 共有 2^(32-4) 个ipv4组播地址空间；
						>mac链路层组播地址空间：只接收2^23个ipv4组播地址；则有2^28/2^23 = 2^5=32个ipv4组播地址对应一个mac组播地址；
						--组播DNS地址224.0.0.251: ping 224.0.0.251 响应的主机，则是支持 mDNS 协议的主机。 类似：ping6 -I eth0 ff02::fb, mac地址：33:33:00:00:00:fb
						--ipv6每个接口有多个地址：正常。比如三个不同接口可以承载相同组播流量。
						--显示ip组成员：netstat -gn 
				>组播寻址过滤：在NIC中有过滤器，如果配置来被告知主机属于哪个组播组，那么只有IP层组播组关联的组播帧才被允许通过NIC的过滤器；从而使得主机开销更小；而使用广播，UDP数据报的丢弃需要到UDP层才会被丢弃---如端口不匹配而返回一个ICMPv4数据报端口不可达报文；
			>互联网组播管理协议+组播侦听发现协议：组播帧的路由相关
				>组播路由：组播路由器需要知道哪些主机对什么组播组感兴趣。
					>组播路由器：执行 反向路径转发 RPF 检查；即到达的数据报的源地址上?
						>了解附近的主机感兴趣的组：Ipv4使用 互联网组管理协议IGMP, ipv6使用 组播侦听发现MLD协议；支持组播的主机和路由器都使用；从而让LAN中的路由器知道哪些主机当前属于哪些组播组；---类似一个 “组播地址-主机列表” 的一个map.. 而每个主机和对应的路由器接口又有 转发表/路由表 来定义。从而从多个端口转发出组播帧；甚至直接建立起“接口-组播地址列表” 的map ,这样就可以直接的搜索而寻找到了，但不是"组播地址-接口" map--有遗漏;
							>IGMP: 即路由器定期 向 每个子网 发送IGMP 请求， 而接口对应的子网里的主机则响应它感兴趣的组播地址，这样路由器就建立了一个“接口-组播地址列表” entry;
								>主机也会主动发送IGMP报文给路由器，来告知它变动的感兴趣的组播地址；
								--路由器向主机发送IGMP请求：目的地址为：224.0.0.1, ff02::1
								--主机向路由器主动发送IMGP报告：目的地址为：224.0.0.22, ff02:16 
				>IGMP：
					>报文格式：ttl=1 仅仅限于本地子网；也使用路由器告警选项--DS:0x30代表网间控制；MLD是icmpv6一部分；
						>ipv4头部：24B, ttl=1,协议=2，DSField=0x30
							>查询：目的地址：224.0.0.1 ；组地址:	 类型：17,
								>查询报文：类型8位+最大响应代码8(接收方响应前的最大延迟时间量)+校验和16+QRV发送方最大重传次数3+QQIC定期查询间隔8+源个数16+若干个源地址
									>一般查询：组列表为空，用于更新任意组播组信息。全部感兴趣的组地址都返回。
									>特定组查询：对于识别的组是特定的。查询各个主机是否对提供的某些组地址感兴趣？
									>特定组和源查询：包含一组源的特定组查询；
							>报告：目的地址：224.0.0.22； 类型：34,18,22,  
								>成员资格报告：整体内容：类型8位+校验和16+组记录个数16+保留位24， 接着是组记录n个
									>组记录：类型8位+辅助数据长度8+组源个数16+ipv4组播地址32+ 源地址若干个
						>IGMP头部：8B报告，12B查询；
						>IGMP数据：组记录 或者 源列表；
						--链路层组播MAC地址：如 33:33:00:00:00:01
						--ipv6组播地址：如 ff02::c   ;可能报告的感兴趣的组播地址如：ff02::2:7408:ff56, 到了MAC层的帧组播地址则是：33:33:74:08:ff:56 按照映射规则则是如此；
						--IGMP报告：对哪个组感兴趣和希望加入哪个组，
						--源地址列表：就是屏蔽源用的；
				>查询器选举：多个组播路由器实现的协调。
					>一个组播路由器启动时：认为自己是查询器；在子网中发送一般查询；
						>一个路由器接收到另一个组播路由器的组播查询：比较它的源ip地址和自己的ip地址，如果它的源ip地址小，则自己进入备用模式---即最小的ip地址的路由器被认为是获胜者；并成为单一的查询器；负责向它连接的子网中发送查询；还存在计时器计时，在指定时间内没有按到更多的查询，则再次成为查询器；
				>IGMP和MLD探听：第二层交换机 通过查看第三层的信息了解它对特定的组播流量 是否有兴趣 ， 是可能的；就叫IGMP探听；
					>如果没有这种探听：snooping, 那么交换机就会沿着生成树的所有分支广播它 来发送链路层流量；而这就是浪费；假如感知了IGMP,再记录哪些端口 需要哪些组播流动，从而特定的转发，实现类似组播路由器的功能；
					>RGMP: 路由器端口组管理协议：不仅主机报告它们感兴趣的组播地址和源，而且组播路由器也报告；这样，以优化组播路由器之间组播流量在第2层的转发；
			>IGMP和MLD相关的攻击：是信令协议；控制组播流量的流动；
				>Dos攻击：通过发送IGMP、MLD来订阅大量的高宽带的组播组 而 发起；从而引起带宽耗尽，而拒绝服务；
				>资源使用攻击：使用相对较小的ip地址生成请求，从而被选举为链路的查询器；可以通知它自己的鲁棒性变量、查询时间间隔、将被其他组播路由器采用的最大响应时间，如果这个时间非常小---则被诱导迅速发送报告---消耗大量CPU资源；
				>协议的实现错误来禁用主机：或者导致他们执行攻击者提供的代码；分片的IGMP可能诱导os崩溃；
		>用户数据报协议和IP分片：
			>UDP: 传输层协议。保留消息边界、面向数据报而不是面向流，不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制；提供：差错检测：即提供端到端的校验和；
				>为保证数据被可靠投递：应用程序需要自己实现保护功能；
				>输出操作: 产生一个UDP数据报，发送一个IP数据报；
				>优点：无连接的特征，有开销更小的优点；
				>已有用途：广播和组播操作：更多直接使用UDP进行无连接传输；
				>ipv4中的UDP数据报格式：ipv4协议头中：协议字段=17；ipv6协议头中：则是：next header=17
					>UDP头部：8B
						>源端口号：2B, 可选，只要要求对方回复，才设置值，否则为0；
						>目的端口号：2B,帮助分离从IP层进入的数据，
						>长度：2B, 是UDP头部+UDP数据的总和
						>校验和：2B,包含IP头部的源ip地址+目的Ip地址+协议+UDP长度+ UDP头部+UDP数据 。传输中，除非经过NAT，否则传输到目的地址都不会被修改；。。校验和的计算：对于奇数长度的数据报则会补充0来计算；
							>接收者：重新计算校验和，如果不一致，则直接丢弃，不产生差错消息；如果端口没有应用程序在启动/进程，则会返回端口不可用/目标不可达的ICMP报文；
					>UDP数据：
					--测试：用sock程序生成udp数据报：sock -v -u -i 10.0.0.3 discard     发送方采用的端口号：从 49152-65535
			>UDP和IPv6: ipv6不存在ip层头部校验和；因此伪头部校验和是必须的；
				>伪头部：源ipv6地址16B+ 目的ipv6地址16B + 长度4B + 保留3B+ 下一个头部1B
				>teredo: 通过ipv4网络隧道传输ipv6。。。一种Ipv6过渡机制；
					>6to4的NAT穿越问题：ICE可以解决？Teredo 也能。
						>teredo的方法：ipv6数据报置于UDP/ipv4数据报的负载区里；
							>客户机：实现了Teredo隧道接口的ipv4/ipv6主机：
							>资格认证过程：客户机和服务器之间；ipv6直接或者UDP/ipv4间接；
							>Teredo地址：2001::/32为ipv6前缀；是一个ipv6地址；
								>组成：Teredo前缀+服务器的ipv4地址+16位标志字段+客户机映射的端口号+客户机映射的ipv4地址+服务器看到的客户机的地址信息
							>Teredo服务器：类似STUN服务器，用于帮助Teredo封装的ipv6分组建立直接通道以穿越NAT; 即客户端将数据专门封装，而发送给服务器端，服务器端知道如何解析，从而解封获取到正确的信息。。包含中继器的所有功能；
							>Teredo中继器：类似TURN服务器，中转连接双方的地址信息等；。。如果发现ipv6连接，则放弃使用Teredo隧道技术；
							>Teredo客户机和服务器通信过程：
								>客户机使用ipv4地址/主机名，服务器在UDP端口3544初始化配置：客户机封装ipv6消息在Ipv4数据报的负载区，来使得ipv6流量经过Ipv4网络基础设施；这个ipv6数据在UDP报头后；
								>服务器帮助客户机获得ipv6地址并决定它们之间的映射地址和端口号：
								>服务器回应：是一种ICMPv6 RA 消息；源地址=有效的本地链路ipv6地址，目的地址=客户机用作RS消息得到的ipv6地址
							>气泡：
			>UDP-Lite: 修改传统的UDP协议，提供部分校验和，避免以前的校验和需要覆盖整个负载；。。一种独立的传输协议；
				>自己的ipv4协议：
				>自己的ipv6下一个头部字段值：136  即ipv4协议号；
				>报文格式：源端口2B+目的端口2+校验和覆盖范围2(从UDP-lite头部开始的字节数)+校验和2 
			>IP分片：链路层中可传输的帧有最大长度限制。	因此ip引入了分片和重组；
				>ipv4中主机/路由器在转发数据报时：如果接口的链路的MTU小于 IP数据报的大小，则需要分片。
				>重组：到达目的地后才会。
				--UDP数据报的分片：
					>第一个分片有UDP头部：后面的分片没有；
					>分片信息的保存：IPV4头部：标志(每个分片同，从而目的端借助来重组) +分片偏移FO(负载的第一个字节在源数据报中的偏移量-8B为单位)+更多分片MF(最后一个分片为0,否则为1)；最后一个分片收到时，重组程序开始确定数据报的总长度，。
					>分片丢失问题：ip不差错纠正；超时重传是高层的事务；TCP重传整个IP报文；
					--sock来产生分片：因为链路层最多1500B的帧，20Bipv4报头,8BUDP报头，所以1472B负载，从而测试发送1473B的数据看分片：
						>sock -u -i -n1 -w1473 10.0.0.3 discard ..  。。。第二个分片从偏移量1480开始：
					>ip层受到一个分片：就开始启动一个计时器，超时了每收到全部分片，返回一个ICMPv4超时消息；30s/60s超时一般；	
			>采用UDP的路径MTU发现：
				>传统PMTUD使用ICMP PTB消息来完成：路径MTU发现；即最大的分组大小，使得不会被分片；
				>LAN支持1500B的MTU: 但是外网链路不一定；可能更小1492
			>IP分片和ARP/ND之间的交互：
			>最大UDP数据报的长度：65535-20-8=65507
				>实现限制：有的实现不支持。API套接字接口。。。对UDP数据报大小设置了限制的协议：DNS/DHCP
				>数据报截断：不能一次读出来；截断超额数据；要么后续读，要么丢弃？
			>UDP服务器的设计：对此有影响的UDP协议特征。
				>ip地址和端口号：如启动udp服务器：sock -u -s 7777
				>多地址：一个主机上，同一端口，多个本地ip地址,可以实现：SO_REUSEADDR 必须指定；
					>ip addr add 10.0.2.13 scope host dev eth0
					>ip addr add 10.0.2.14 scope host dev eth0
					>sock -u -s -A 10.0.2.13 8888
					>sock -u -s -A 10.0.2.14 8888
					>sock -u -s -A  8888
				>限制远端IP地址：默认：0.0.0.0:* 无限制。	
					>sock -u -s -f 10.0.0.14.4444 5555
				---拥塞：路由器中队列满；拥塞控制：通知客户端降低发送速率；	
				---分片流量少，且主要是UDP的。
			>相关攻击：
				>耗尽共享资源：缓存、链路容量；Dos攻击：因为UDP不控制发送速率；
				>协议漏洞：使得系统崩溃；泪滴攻击；分片、重组和重叠；
				>放大：类似ICMP的Smurf攻击；
		>名称解析和域名系统：主机名称标记客户机和服务器；
			>名称解析：主机名称 转换为 IP地址； 
			>DNS： 分布式数据库；有名称解析、电子邮件路由信息、服务命名等服务功能；
			>访问DNS: 应用程序通过 地址解析器 这个应用程序；
			>DNS名称空间：所有名称集合，按层次组织，形成一颗域名树；
				>域名树：树根=未命名。。。层级结构使得扩展性挺好；13台A-M的根服务器；
					>最高层：顶级域名TLD,通用顶级域名、国家代码顶级域名、国际化国家代码顶级域名、ARPA的基础设施顶级域名
						>通用顶级域名gTLD: edu 教育机构、int 国际组织
					>子域名：更多的后缀		
					>完全限定域名：FQDN.。每个部分63字节最多，最长255B
			>名称服务器：DNS服务器。存储名称空间-附加信息(ip地址)，至少2台---形成冗余--完全一样的内容		
				>名称到ip地址 这个信息的获取：从属服务器；
				>缓存：客户端可以保存。Linux：名称服务缓存进程NSCD 提供 客户端的缓存功能；/etc/nscd.conf 文件控制。
			>DNS协议：
				>执行对特定名称查询 的查询/响应协议：
				>名称服务器用于交换数据库记录的协议：区域传输；DNS通知；
				>递归DNS查询过程： 迭代查询 就是 返回联系人。
					>本地递归服务器：GW.HOME DNS服务器。互联网不知道这个DNS服务器存在；只存在本地用户的区域。
						>如果GW.HOME不知道 EXAMPLE.COM的IP地址， 也不知道EXAMPLE.COM 域 或者 COM TLD 的名称服务器，它就转发查询到另一个DNS服务器；即转发去查询 ISP提供的DNS服务器。
					>ISP提供的DNS服务器：如果也不知道， 则联系根名称服务器的一台。
					>根名称服务器：不是递归的，它们不进一步处理请求，而返回 需要联系的 COM TLD 的名称服务器 的信息。比如返回：A.GTLD-SERVERS.NET 以及一个或者多个它的ip地址；
					>ISP DNS根据获取的名称服务器信息联系gTLD服务器： 获得域名 EXAMPLE.COM 的名称服务器的名称和IP地址： 即 A.IANA-SERVERS.NET 服务器。	
					>ISP DNS联系 基于域名的正确的服务器：即 example.com 的授权 DNS服务器；上述A.IANA-SERVERS.NET服务器； 回复 EXAMPLE.COM的ip地址；
					>ISP DNS 回复 GW.HOME :
					>GW.HOME DNS 回复客户端：期望的ipv4/ipv6地址；
					---根-->域-->名称 三级 DNS服务器，是ISP DNS依次查找的DNS服务器。
				>DNS消息格式：12B，通常在UDP/IPv4数据报中运载。 所有DNS操作：查询、响应、区域传输、通知和动态更新
					>事务ID: 16位 
					>标志1：Q 查询0 R:响应1
					>操作码4：查询0 ，通知4 ，更新5 
					>其他标志7：授权回答/截断回答/期望递归/递归可用/真实数据/禁止校验/0。
					>响应码4：0-5: 无错误、格式错误、服务器错误、不存在域名、未实现、查询拒绝。
					>查询数16：
					>回答数16：
					>授权记录数：16
					>额外信息数：16
					>可变长度的区段：4个 ： 问题、回答、授权记录和额外记录。
						>查询： 1 0 0 0 
						>应答： 0 1 0 0
						--各个区段：
							>问题区段：名字、类型、类  
								>每个问题：以 域名开始：称为名称；每个名称 由一系列的标签组成：数据标签+压缩标签；
									>数据标签：若干个：字符串长度值 + 字符串； 0长度代表结束；这样来表达如：www.pearson.com  编码为：3www7pearson3com
									>压缩标签：编码多个域名时，为了简便，让一个14位指针指向前面的已经出现过的字符串的开始长度位置---字符偏移数来指向。
								>名称：要被查询的域名。使用上述 两种 标签 编码；
								>查询类型：16位 。最常见：A类型；ANY类型；返回和查询名称匹配的在同一类中任意类型的所有RR
								>查询类： 16位。1,254,255；互联网类、没有类、所有类；
							>其他字段：0个或者多个RR，RR包含名字、类型和类信息，也包含控制数据缓存时间的TTL值；
								>格式： 
									>名称：可以使用通配符；只包含星号字符的数据标签--首先出现。
									>类型：RR类型代码中的一个；。。和查询类型之相同；
									>类： 对互联网类型是1
									>TTL: 是RR可以被缓存的秒数；
									>RDLENGTH: 资源数据长度；指定了 资源数据RDATA 字段包含的字节数
									>RDATA: 数据取决于类型；类型1 对应这里是一个32位的ipv4地址；
									---资源记录集：为共享相同的名称、类和类型，但数据不相同的一组资源记录；
						--DNS编码名称、传输DNS消息选择传输协议： 
					---所以一个UDP协议的IPv4数据报：IP头20字节+8字节UDP头+12字节DNS头+四大区段--DNS消息(包括头部)最多512B;   如果没有传递完，则返回消息中的TC位字段=被截断；然后继续使用TCP来请求剩下的报文段---TCP将更大的消息分割为多个报文段；	
						>自己处理超时和重传：起始超时时间至少4s;
						>区域传输：通知消息引起；
							>完全区域传输：TCP
							>增量区域传输：UDP
				>端口号：53		
				>DNS其他功能：基于分布式数据库功能；它有不同类型的资源记录。记录既是请求的数据格式，也是响应的格式；	
					>单一的名称可能有多个匹配的RR: RR的类型：RR=ResourceRecord 资源记录类型；
						>RR具体类型: A---ipv4地址记录；NS--名称服务器--提供区域授权名称服务器的名称；IXFR--增量区域传输；AXFR--完全区域传输--通过TCP运载；CNAME--获得另一个域名的别名；SRV/NAPTR--帮助应用程序发现hi吃特定服务的服务器的位置
							>数据类型：传达在DNS中存储的信息。如IP地址、授权名称服务器的名称；
								>地址和名称服务器记录：授权服务器名称+其ip地址 是记录内容；使用dig 查看某个域名的任意类型的记录：dig +nostats -t ANT rfc-editor.org 输出的查询响应记录里：可以看到 ANSWER SECTION: 部分列出了 rfc-editor.org 和 名称服务器名称的映射 和 子域ip的映射 记录；ipv4/ipv6共4条；ADDTIONAL SECTION 字段 则是 名称服务器名称的ip映射；
							>查询类型： 问题字段中使用，增量区域传输+完全区域传输。
								>规范名称记录：CNAME  记录里有 名称的别名； 查看别名对应的真名，真名对应的Ip：host -t any www.whitehouse.com  一层层的命令执行就可以得到；形成CNAME链。。。。DNAME资源记录可以 映射  NAME.example.com 为 NAME.newexample.com 
								>逆向DNS查询：PTR(指针)记录；比如TCP连接请求的服务器知道访问的源ip,但是不知道这个源ip对应的名称；。新办法：利用Ipv4地址构造新名称：将Ipv4地址反转+in-addr.arpa 如：208.112.32.128.in-addr.arpa 后利用来进行PTR记录的查询；
									>逆向查询过程：首次：nslookup ; server f.in-addr-servers.arpa ; set type=ptr;...;; nslookup;  set type=ptr;  server adns1.berkeley.edu    ;   81.131.229.169.in-addr.arpa ;  可能返回多条结果；每条后半部分就是域名；但这个域名可能是真正的域名的别名；所以需要再次执行 server 域名别名 ; 81.131.229.169.in-addr.arpa ;直到只有一条结果为止，就得到了真正的域名；。。。实现机制：DNS树的单独分支；---即把ip地址反过来当作一个名称来处理---名称找ip的方式----直到找到匹配的ip。本地名称服务器也提供PTR映射；
										>可以加/号： 129.128/25.136.17.12.in-addr.arpa  来实现；对 12.17.136.128/25 这个ip地址的逆查询；因为前缀长度太长，超过了24位；
								>SOA RR: 查询的响应：1个问题一个答案 6个授权RR和10个附加RR;
								>MX 记录：邮件交换记录；提供了邮件交换器的名称；交付给中介，以便即便目的不在线--当它在线的时候也能看到---即像邮箱一样的；。。域名可能有多，按优先级排序；host查看：host -t MX cs.ucla.edu ns3.dns.ucla.edu	
								>TXT记录：
								>选项伪记录；OPT RR 记录；
								>服务记录：Serv RR 目的：查看某类服务的可用主机	。例如想查看 域example.com中 ladap服务的可用主机和端口：则构造 _ldap._tcp.example.com 执行 SRV记录 的查询；host -t srv_ldap._tcp.example.com 则返回ldap服务所在的完整域名和端口：如 389 www.example.com 
								>名称授权指针NAPTR RR 类型： 来支持动态委托发现系统DDDS;.。比如电话号码 转为 域名来查找 NAPTR 记录： 即先把号码点分，后反转+e164.arpa, 如 141 5555 1212 转换为 2.1.2.1.5.5.5.5.1.4.1.e164.arpa 用这个域名来查 NAPTR记录；返回一个绝对URI
									>例如利用 +420738511111 返回 “E2U+sip” "!^\\+(.*)$!sip:\\1@cesnet.cz!"  则使用第一个！和第二个！之间作为正则表达式，而输入为电话号码，而第二个！和第三个！之间为正则group结果依次填充到的字符串；1就代表第一个group()的结果，显然就是 这个电话号数字部分，所以替换填充之后第二部分就变成了：sip:420738511111@cesnet.cz  。联系一个sip服务器：host -t naptr cesnet.cz  从而可能返回 _sip._tcp.cesnet.cz 
							>元类型：与特定DNS消息相关联的临时数据---OPT RR元类型；
					>一个标准的名称查询过程：
						>内网内一个主机发出DNS请求(服务端53端口)：14B以太网帧头部+20Bipv4报头+8BUDP报头+12BDNS固定头部+DNS查询类型2类2数据标签(可变，比如9+4B)；
					>DNS更新：ipconfig 就能。发送一个DNS查询请求，flags=0x2800 (动态更新)， 区域字段：要被更新的区域 如 vista.dyn.home 	
					>区域传输和DNS通知：
						>区域传输： 复制一个域的RR 从一个服务器到另一个服务器；通常主从复制；
							>完整区域传输：从服务器联系主服务器；时间间隔后再次请求；全区域传送AXFR DNS消息：可以执行：host -l home. 则告诉dns服务器执行一个完整区域传输。
							>增量区域传输： IXFR消息；Flags=0x0000标准查询；授权区段：包含一个大多数字段都是空的SOA RR;
						>DNS notify: 观察者模式，主服务器推送给感兴趣的从服务器；flas=0x8480 标准查询响应；问题/回答/授权/附加四个段：1100 ,回答段：type:SOA类型，Time to Live: 0 time,Name:home,retry interval:15 seconds....。。。查询段：home:type SOA ;Type: SOA	
			>排序列表、循环和分离DNS：	
				>排序列表：对多宿主主机--有多个ip, dns返回关于这个主机的ip地址时，会根据请求方的ip而对目的主机的多个ip进行排序--最近的排在前面sortlist;
				>循环：一个域名下多台主机提供服务，则DNS返回这多台主机的ip地址，要实现负载均衡，则dns服务器配置为使用DNS循环；
				>返回数据支持隐私：分离DNS技术；split DNS 使得外面的服务只看得到主机AB,看不到DNS服务器？
			>开放DNS服务器和DynDNS: 用户可以利用DDNS服务器而更新ISP的DNS服务器中的账户条目？为了建立一个DNS条目，动态变化(内网ip可能会变)，而始终运行的服务对互联网是可见的；
				>客户端：运行DDNS客户端程序，为了实时保证ip地址和服务端沟通的一样；
			>透明度和扩展性：可以有新的RRl类型；
			>从Ipv4到ipv6转换DNS：是对记录格式的转换；+ipv4/ipv6转换器+DNS64
			>LLMNR和mDNS:
				>本地链路组播名称解析：LLMNR: 本地网络中使用以发现局域网上的设备；
				>组播DNS：mDNS: 是另一种形式的本地类DNS功能；使用通过本地组播地址来携带DNS信息；使用：UDP:5353 mDNSipv4地址：224.0.0.251 对于安全问题：使用DNSSEC来解决；
			>LDAP: 更普遍的目录服务。互联网应用层协议。提供：搜索、修改、添加、比较和删除基于用户选择模式的能力。
				>目录搜索工具：如ldapsearch 
			>与DNS相关的攻击：Dos攻击：大量对某个域名的某种记录的请求。
				>DNS服务器的缓存内容被修改---缓存中毒；解法：DNSSEC
		>传输控制协议：TCP		
			>差错纠正：差错检测后，纠正。差错纠正码：添加冗余的比特，使得某些比特被毁-真实的信息可以被恢复；是一种处理差错的方法。另一种：尝试重新发送---自动重复请求：ARQ。
			>编码理论：信息编码手段，使得信息能在信道里尽量避免出错。	
			>信息理论：丢失或者改变信息的通信媒介环境下的通信问题的理论：有损信道里可通过的信息量的根本限制；
			>其他差错类型：分组比特差错外：分组重新排序、分组复制、分组丢失。多跳通信信道上设计带纠错的协议需要考虑的问题。
				>分组丢失的处理：包括比特差错。办法：重发分组；直到正确接收----接收方 收到 且 确认一样 则发送 ACK.。。所以发送方有个问题：ACK等待时间，ACK丢失了怎么办？(很难区分是分组丢失还是真的ACK丢失，所以重发分组)接收方收到的分组有错怎么办？(不发送ACK)
					>发送方等待多久才判定丢失：而重传。
						>往返时间估计：RTT样本估计。
				>分组重复的处理：接收方收到发送方发来的。重复的判定：序列号一样。唯一的分组有新的序列号。重复的处理：丢弃。	
				--发送方：维持计时器+未确认分组的副本保持
					>分组窗口：未确认分组集合。分组数为窗口大小；
					>滑动窗口：收到了窗口前面的分组的ACK，则窗口向后移动一格，而发送新的加入窗口的分组。这种发送协议。
				--接收方：缓存到达次序杂乱的分组
					>流量控制：当接收方跟不上而强迫发送方慢下来的办法。
						>基于速率的流量控制：给发送方指定某个速率---数据永远不能超过这个速率发送；。适用：流应用程序，被应用于广播和组播发现；
						>基于窗口的流量控制：给发送方指定窗口大小--窗口通告/窗口更新---发送方则调整其窗口大小为这个值。ACK和窗口大小 在一个分组里返回。
						>拥塞控制的流量控制：中间路由器的限流考虑---即降低发送方的速率以便不压垮中间网络上的路由器。发送方根据某些信息猜测而主动减低自己的速率。
			>基本问题：TCP头部、连接建立和结束、估计RTT设置重传超时、数据传输-窗口管理-流量控制-紧急机制、拥塞控制算法、没有数据时的保活--保持连接的活动性。			
			>TCP服务模型：面向连接的、可靠的字节流服务。
				>面向连接：交换数据前，需要建立TCP连接。
				>字节流服务：没有消息边界。即一端先后写入10,20,50字节，另一端不知道每次写入的是多少；读和写的大小 每个端 独立选择；如固定20字节，读4次。TCP不解读字节流里的内容：不知道是二进制数据、ASCII字符、EBCDIC字符或者其他东西。
			>TCP中的可靠性：提供一个字节流接口：把发送应用程序的字节流转换为一组IP可以携带的分组---组包。
				>每个分组：有序列号--这个分组的第一个字节在整个字节流中的偏移量。它们的组合：重新组包。分组的大小：尽量不需要ip层分组进行分片。别名：报文段。
				>强制的校验和：IP头+TCP头+TCP应用程序数据
				>重传计数器：发送一个窗口的数据，只有一个重传计数器。ACK到达更新超时。有一个ACK没有及时收到，该报文段重传；
				>ACK的延迟发送：带上指示字节号N: 代表所有直到N字节的已经被成功接收了；对ACK丢失带来了鲁棒性；某个ACK丢失，但是后面的ACK足以确认前面的报文段。
				>一个TCP连接：双向、对称。
			>TCP头部和封装：
				>TCP头部：20B,带选项60B(最大段大小、时间戳、窗口缩放、选择性ACK)
					>源端口+目的端口：分别16位。唯一标识每个连接。和Ip一起称为：端点/套接字。
					>序列号：32位。该报文段的第一个字节在数据流中的偏移量。
						>SYN报文段：初始序列号ISN，为随机值。消耗序列号。
					>确认号：32位。确认号的发送方期望接收的下一个序列号。即发送成功的数据的最后一个字节的下一个字节的偏移量。
					>头部长度：4 
					>保留：4 
					>CWR:1  拥塞窗口减--发送方降低它的发送速率
					>ECE:1 ECN回显--发送方接收到了更早的拥塞通告
					>URG:1 紧急--很少使用
					>ACK:1 连接建立后都有效--启用状态---直到FIN?
					>PSH:1 推送--接收方应尽快给发送方传送整个数据--没被可靠实现
					>RST:1 重置连接-连接取消-因为错误。
					>SYN:1 用于初始化一个连接的同步序列号
					>FIN:1 报文段的发送方已经结束向对方发送数据。
					>窗口大小：16 从接收方想要接收的字节开始。
					>TCP校验和：16 伪头部计算。发送方计算和保存，接收方计算和验证。
					>紧急指针：16 需要URG 字段有效；
					>选项：
						>选择确认-选择重发-性能显著改善。
						>窗口缩放选项：
						>最大段大小：
				>TCP数据：TCP连接和终止时没有。
		>TCP连接管理：tcp：面向连接，单播协议。检测并解决IP层三大问题：丢包、重复、错误。		
			>何时建立连接、正常终止、无警告下重新启动：
			>TCP连接的建立和终止：TCP连接：一对套接字构成；一对端点；
				>启动：交换初始序列号(当前序列号)。
					>客户端：发送SYN报文段(syn位置位,目的端口号设置，初始序列号ISN(c))
					>服务端：收到后，发送SYN报文段(syn位置位，ack置位?,目的端口设置，初始序列号ISN(s),确认号ISN(c)+1)
					>客户端：收到后，发送SYN报文段(ack置位?,目的端口设置, 序列号ISN(c)+1,确认号ISN(s)+1)
				>数据传输：
				>关闭：让接收者看到自己当前的序列号。
					>客户端：发送FIN报文段(FIN+ACK置位,seq=K,ack=L)。。。ACK被设置的原因：确认最近一次收到的数据。
					>服务端：发送ACK报文段(ACK置位，seq=L,ack=K+1)
					>服务端：发送FIN报文段(FIN+ACK置位,seq=L,ack=k+1)
					>客户端：发送ACK报文段(ACK置位，seq=K,ack=L+1) 
				--半关闭：一方发送FIN并收到ACK，对方可以继续发送数据，完成后发FIN,后收到ACK，连接关闭。	
				--同时打开：即一方发送SYN后，收到的是对方的SYN,则返回ACK.。另一方也是；从而总共需要4个报文段。(即便另一方先收到ACK后收到SYN也可以正常建立连接)
				--包检测：telnet 10.0.0.2 80
				>连接建立超时：
					>服务器关闭：客户端 按 指数回退 方式确定的时间间隔 来发送SYN报文段。首次发送后，隔3s,6s,12s,24s,再发送；重试次数：5次，可设置。NAT中实现一部分TCP状态机。 
			>TCP选项：
				>最大段大小：可接收的 TCP数据的字节数 最大大小。默认536B (因为ipv4数据包574B能够被处理)。。典型值：1460B(40B的IP头+TCP头)
				>选择确认：接收方已经成功接收的数据块的序列号范围。每一个范围称为SACK块--一对32位序列号标识。一个SACK选项包含n个SACK块。n<=3
				>窗口缩放：范围扩展到30位；是窗口广告的比例因子；2^s倍，s就是因子。最大放大到1GB窗口大小.。。SYN报文段中双方都有。根据接收缓存的大小确定的。
				>时间戳：8B两个时间戳。发送方填充第一部分TSval，接收方原封不动复制填充到第二部分TSER。 从而可以估计TCP连接的时间，来估计重传超时。
					>防回绕序列号算法：报文段带上发送时间戳，从而即便旧的报文段重新出现在正在传输的报文段旁边，即便序列号一样，但是时间戳小，所以直接丢弃。
				>用户超时：发送方等待ACK的时间。USER_TIMEOUT.。3次或100s超时，有的。	
				>认证：加密散列算法+密钥值， 来认证每一个报文段；但是分发密钥是个问题。
			>TCP的路径最大传输单元发现：分组层 路径最大传输单元	发现 算法--无需ICMP。
			>TCP状态转换：有限状态机。触发事件：报文段传输/接收、计时器超时。客户端/服务器行为。
				>CLOSED: 未打开状态，关闭状态。
					>服务端：LAST_ACK 状态下收到ACK	后的状态--被动关闭；
					>服务端：SYN_RCVD 状态下收到RST 后的状态。
				>LISTEN: 服务端：被动打开后的状态。
				>SYN_SENT:  客户端发送SYN后的状态。
				>SYN_RCVD:  服务端：收到SYN后发送SYN+ACK后的状态。
				>ESTABLISHED: 连接建立。 
					>客户端：在SYN_SENT状态下，收到了SYN+ACK后发送ACK后的状态。
					>服务端： 在SYN_RCVD状态下，收到了ACK后的状态。
				>CLOSE_WAIT:  服务端：在 ESTABLISHED状态下 接收FIN后发送ACK后的状态；
				>LAST_ACK:	服务端： CLOSE_WAIT 状态下 发送FIN 后的状态；
				>FIN_WAIT_1: 客户端：ESTABLISHED状态下发送FIN后的状态。
				>FIN_WAIT_2: 客户端：FIN_WAIT_1状态下收到ACK后的状态。
				>CLOSING: 服务端：在 FIN_WAIT_1 状态下 收到FIN后的状态；
				>TIME_WAIT:2MSL 客户端： FIN_WAIT_2状态下接收FIN后发送ACK后的状态；
					>MSL: 最大段生存期。报文段被丢弃前在网络中被允许存在的最长时间。net.ipv4.tcp_fin_timeout 的数值 记录了2MSL状态需要等待的超时时间。
					>在发送最终的ACK之后：等待2MSL时长，因为可能发送的ACK丢失或者超时，导致服务端重发FIN,因此这个等待时间内如果再次收到了FIN--被丢弃，不会重发ACK(不占用序列号)?;
					>此状态下端口号是否可以被重新使用：伯克利套接字API：SO_REUSEADDR 支持可以被重新使用。
					>服务端主动关闭：也会进入这个状态，而在2MSL期间，如果重新启动服务端，会输出 端口已经占用 的 异常；使用 netstat -n -t 可以查看到处于 TIME_WAIT 状态。这个时间可能：1-4min
					>客户端主动关闭：同理。	
				----总结：
					>客户端： 建立阶段 CLOSED-->SYN_SENT--->ESTABLISHED   		 关闭阶段：ESTABLISHED-->FIN_WAIT_1-->FIN_WAIT_2--->TIME_WAIT(2MSL计时器)-->CLOSED   关闭阶段2：ESTABLISHED-->FIN_WAIT_1-->CLOSING(先收到FIN)-->TIME_WAIT(此时已经收到FIN+ACK)-->CLOSED
					>服务端： 建立阶段 CLOSED-->LISTEN-->SYN_RCVD-->ESTABLISHED  关闭阶段：		ESTABLISHED-->CLOSE_WAIT(收到FIN返回ACK)-->LAST_ACK(主发FIN)--->CLOSED 	
				----静默时间：TIME_WAIT状态的主机崩溃了，重启后等待MSL的时间。但实际上重启时间远远大于这个MSL。	
				----非半关闭而直接从 FIN_WAIT_2 到 CLOSED 状态：避免无限等待，设置计时器，超时后连接是空闲的-则直接进入CLOSED状态；。net.ipv4.tcp_fin_timeout 数值可以设置计时器的秒数。
				----同时打开：双方都发SYN, 收到之后都发新的SYN+ACK，然后就进入 ESTABLISHED 状态。 
				----同时关闭：双方都发FIN, 收到后都发ACK, 进入 CLOSING 状态，收到ACK后进入 TIME_WAIT 状态，初始化2MSL等待过程。
			>重置报文段：RST位 被设置置位。导致TCP连接的快速拆卸。
				>当目的端口没有进程在侦听：UDP返回一个ICMP 目的地不可达报文；而TCP协议返回重置报文段。例如telnet一个未使用的端口。telnet localhost 9999
					>重置报文段中：ACK位+ACK字段 都需要 设置。
				>当服务器重启后：收到了客户端发来的非SYN之类的请求---客户端还不知道服务器重启了---且服务器没有记忆之前的连接；从而服务器返回一条重置报文段。	
				>发送重置报文段终止连接：终止释放。SO_LINGER 逗留于关闭 设置为0.。。比如执行 ssh linux cat /usr/share/dict/words 输出大量单词，这个可能是误操作，然后用户ctrl+C, 进程被2号信号终止，SIGIHT.
					>报文内容：序列号+确认号。接收方：不会响应，只是终止连接并通知应用程序当前连接已被重置。
			>半开连接：一端直接关闭或终止连接，如客户端主机崩溃，电源被切断。例如 双方建立连接后，都是 ESTABLISHED 状态，没交换数据 然后 客户端 直接断电了---则服务端是无感知的---服务端该连接还处于 ESTABLISHED 状态。则客户端启动电脑带电后发起对服务器的连接---则是新的连接。从而服务器上就多出了一个半开的连接。
			>时间等待错误：TIME_WAIT 状态下收到重置报文段如果立刻结束TIME_WAIT。
				>当在TIME_WAIT时 收到了 数据传输时 老的ACK报文，则会响应 最新的 ACK报文段，而此时服务器已经 CLOSED, 所以响应 RST 报文段，客户端收到时应该忽略。
			>TCP服务器选项：客户端并发时 服务器如何使用客户端的。:::22 通配符地址--ipv6:全0.。。安全外壳协议 ，安全外壳服务器；netstat -a -n -t 查看。
				>新的客户端连接服务器时：服务器上可以看出：新增连接节点；本地地址都一样(ip+port)，而foreign address 则不一样；状态是 ESTABLISHED   安全外壳程序客户端使用的是临时的未使用的端口。LISTEN 状态的节点才能接收SYN报文段，ESTABLISHED 的节点则不能。当PPPoe链路连接服务器时，本地地址就变为了 互联网地址/PPPOE链路的接口地址。
				>限制本地ip地址：服务器不再是通配符地址，而是 10.0.0.1:8888  这样的地址。
				>限制外部节点：UDP可以指定外部地址+端口号；
				>进入连接队列：多个连接请求同时到达----
					>SYN_RCVD队列：net.ipv4.tcp_max_syn_backlog 最大的处于SYN_RCVD状态的连接的数目；超过了则直接拒绝。
					>ESTABLISHED队列：应用程序尚未接收。未完成连接，最多128个。
					>数据队列：
					---队列满：忽略新进入的SYN报文段；
			>与TCP连接管理相关的攻击：SYN 泛洪---TCP拒绝服务攻击---伪造SYN报文段--产生大量的半打开连接		
				>TCP劫持：序列号攻击。
		>TCP超时与重传：TCP执行效率。		
			>报文段丢失：启动重传。基于时间+基于确认信息。发送数据：设置计时器--超时则重传，重传超时RTO。。快速重传：没有延时情况下，SACK 表明出现了失序报文段。
			>根据连接的RTT设置RTO：每个连接独立采样计算RTT
				>指数加权移动平均：低通过滤器 估算方法：SRTT= 80-90%来自现存值，10%-20%来自新测定的RTT值。RTO=...倍数于SRTT
					>平均偏差：rttvar  . 3/4来自现存值，1/4来自 新测定RTT和SRTT的差。RTO=srtt + 4(rttvar) ...Jacobson 计算方法。时钟粒度的加入和优化。初始值：rtt/2
				>重传二义性：因超时而重传数据包后收到了确认包，该信息是对第一次还是第二次有二义性。所以这个数据不能当作RTT的测量数据。
				>karn算法：重传数据的确认信息不进行RTT测量，且之后采取退避策略，直到收到未经过重传的数据，才采用SRTT进行RTO计算。----TCP传输带了时间戳则不走karn算法。
				>带时间戳选项的TCP: 根据TCP累积确认机制，使用发送端发送时设置在时间戳选项的时间差 带上发送，后收到确认信息时候的时间 - 确认信息里的之前发送的时间戳的副本 来估算RTT.net.ipv4.tcp_timestamps 控制启用时间戳。
					>linux计算方法：mdev= 现存值*3/4 + (新测rtt-现存值)*1/4 = 新的偏差值 ， mde_max=max(mod_max, mdev)=最大偏差值  ， srtt= 现存值*7/8 + 新测rtt*1/8	, rttval=mde_max, RTO=srtt + 4*rttval 。。。所以入参 变量 只有 rtt测量值。mod_max 较大，所以丢包时 性能降低；
					>失序时测量RTT：偏大。
					>丢包和超时时测量RTT：因为有时间戳--所以可以利用返回的确认包数据中的时间戳来确定RTT。
			>基于计时器的重传：得到了RTO, 则用来设置重传计时器。新的待发送的数据包：记录：序列号--新的计时器。。RTO内没有收到ACK,触发超时重传。
				>超时重传事件触发的其他响应：降低当前数据发送率。
					>基于拥塞控制机制减小发送窗口大小：
					>重传时增大RTO退避因子：RTO=y*RTO y=1,2,4,8   < TCP_RTO_MAX  直到收到ACK,设置y=1
			>快速重传：更为高效；无需计时器超时。基于接收端的反馈信息来引发重传；		
				>触发的其他响应：拥塞控制机制。
				>重传时机：接收到 dupthresh 个 重复ACK后。重复ACK：接收到失序报文段时，显然接收端本地缓冲发现产生了空缺，则要把这个空缺报告给发送端；(SACK则可以返回多个空缺)----且指明哪个序列号的重复ACK.。
				>NewReno 算法 :
			>带选择确认的重传：SACK。一个RTT内可以获知多个空缺；SACK选项共4块，每个是一个序列号范围；一个ACK中。如果增加TSOPT--则最多3个ACK.,即在一个RTT内填补3个空缺。
				>发送端：利用返回的SACK块 进行丢失重传---选择性重传/选择性重发；先发送填补空缺的数据，后发送新数据---常见方法。
				>接收端：发送 缺失序列号范围的SACK的ACK.
				---RTT较大+丢包严重的情况下：采用SACK.---因为一个RTT内可以填补更多的空缺。
			>伪超时与重传：没有数据丢失而引发的重传。原因：伪超时---过早判定超时；包失序-包重复-ACK丢失 也可能；
				>伪超时处理方法：检测算法---， 响应算法----
				>重复SACK扩展：DSACK：告知何时的重传是不必要的；发送端可以推断：包失序、ACK丢失、包重复、伪重传；
				>Eifel 检测算法：利用tCP的TSOPT 来检测伪重传；发送一个重传，保存TSV值，接收到相应分组的ACK后，检测ACK的 TSER 部分，如果TSER<TSV,则该ACK是对应原始传输分组的ACK,因此本次重传是伪重传；。。结合DSACK 判断 整个窗口的ACK都丢失 ，但是原始传输和重传分组都成功到达接收端；---重传分组到达生成DSACK返回，发送端认为发送了伪重传。
				>前移RTO恢复算法：F-RTO 检测伪重传 的 标准算法。只检测 由 重传计时器超时引起的伪重传；	
				>Eifel 响应算法：针对超时重传的响应。
			>包失序和包重复：	链路层网络协议可能会重传--产生副本；
			>目的度量：ip route show cache 132.239.50.184 显示之前连接存储的信息。即TCP连接的状态变量值如srtt,rttval ，同一个接收端，如果关闭则需要从头开始学习，较新的TCP实现 则维护了这些度量值，即使连接断开，也能保存之前存在的路由或则转发表项，或其他一些数据结构；从而 创建新的连接时：会在这个数据结构中查看是否存在与该目的地端的先前通信信息---来读取利用。
			>重新组包：超时重传时 无需重传 相同的报文段， TCP允许执行 重新组包，发送一个更大的报文段 来提高性能。
				>tcpdump 信息解释：FP 29:36(7) ack 1 win 5480 为发送序列号 29到36的数据，窗口大小5480  假如 返回的 ack 14,  则下次发送： 14:36(22) ack 1 win 5480 的数据。可见 14 序列号的重传导致了一次重新组包；
			>与TCP重传有关的攻击：低速率Dos攻击---超时重传时发送大量数据---导致感受拥塞存在而减少发送速率并退避；随机选择RTO---重传时间则难以预知。。减慢受害tCP的发送。
		>TCP 数据流与窗口管理：TCP的动态数据传输；交互式连接、流量控制、窗口管理规程；	
			>交互式通信：90%TCP报文段包含大批量数据--1500B; 而交互式数据则小--几十B.。如ssh, 安全的远程登陆协议--取代了telnet
				>ssh对用户输入的回显过程：客户端键入一个字符-->服务端回显+确认--->客户端确认。。PSH置位--标识客户端缓存为空；。。数据部分：48B tinygram. 小包 在广域网 会加重拥塞；
			>延时确认：延迟ACK的目的--累计确认收到的数据包--减少ACK传输数目；--但是不能太久等待--否则发送方会重传；<200ms	
			>Nagle 算法：收集小数据，整合到一个报文段中；且 等到所有在传数据的ACK收到后才能 发送；。即遵循 停等 行为模式；自时钟控制--ACK返回的越快---数据传输越快；
				>测试：RTT较大的网络中：ssh 默认 Nagle算法实现：
				>要求时延尽量小而不是减少包数量：网络游戏，远程控制，需要禁用 Nagle 算法。TCP_NODELAY 
			>流量控制与窗口管理：每个ACK中都有窗口通告；
				>窗口大小：为到来的新数据预留的存储空间；。TCP头部有。
				>两端：
					>发送窗口结构：接收方发过来的提供窗口大小=已发送未确认的数据+即将发送的数据  形成的范围的大小；SND.UNA 左边界，SND.WND 提供窗口值；SND.NXT 记录下次发送的序列号---在之间。可用窗口值=SND.UNA+SND.WND-SND.NXT  
						>窗口左边界右移条件：收到确认ACK;
						>窗口有边界右移条件：确认的数据得到处理；。。窗口大小=0时，不能发送数据；TCP发送端开始探测对方窗口，伺机增大提供窗口；
					>接收窗口结构：左边界RCV.WND之前的是重复数据，有边界RCV.WND+RCV.NXT之后的是超出处理范围的数据；都被丢弃；接收到左边界的序列号的数据，窗口才会右移；
				>零窗口与TCP持续计时器：当接收端重新有可用空间，可以接收数据时，会给发送端发送一个  窗口更新 告知---纯ACK;----使用 持续计时器来防止死锁；指数退避 地 发送 窗口探测；
				>糊涂窗口综合征：窗口<MSS 则等待更大的窗口通知 直到超时 等。可以避免SWS
					>特征：窗口较小，发送端就立即发送数据去填满，导致一直发送小的数据包；。。所以：要避免小窗口通告，或者避免小窗口通告就发送数据；
				>大容量缓存与自动调优：自动调优：收到ACK，窗口增长2个MSS；。。TCP缓存更大、窗口更大 吞吐量则更大；自动配置，手动配置缓存大小，在高带宽传输路径上，网络吞吐性能更好；
			>紧急机制：收到UGR置位的报文段，TCP接收端进入紧急模式；带外数据OOB	
			>与窗口管理相关的攻击：资源耗尽---传输性能较差的网络攻击-蠕虫；。。针对持续计数器的攻击--
		>TCP 拥塞控制： 批量数据传输中最重要的；即当有理由相信网络已经或者即将进入拥塞状态时 减缓 TCP传输；何时减缓 和  何时恢复 。
			>拥塞：路由器无法处理高速率到达的流量，存储资源已经耗尽，被迫丢弃数据信息的现象 。
			>TCP拥塞检测：丢包 探测法(拥塞造成丢包)；时延测量和显式拥塞通知---使得TCP能在丢包发生前检测拥塞(拥塞造成时延，拥塞现场的路由器知道)；。。但无线网络中，传输和接收错误是丢包的重要因素；
				>拥塞窗口：cwnd 反映网络传输能力的变量；发送端实际可用窗口W=min(cwnd,awnd) awnd就是接收端通知窗口；。。W=带宽延迟积BDP 最好；RTT*链路中最小通行速率；
					>cwnd检测方法1：awnd假设足够大，则加快发送速率，直到出现丢包；
					>自同步：收到一个ACK发送一个新的数据包；。。RTO=重传超时
				>慢启动 算法： 因为初始阶段 未知 网络传输能力；
					>tcp执行时间: 新的TCP建立或者检测到 重传超时 或 发送端长时间空闲状态。
					>目的：使得TCP在用 拥塞避免 探寻更多的可用带宽 之前 得到cwnd值，以及帮助TCP建立ACK时钟；
					>开启：TCP在SYN后 发送 一定数目的数据段；个数=初始窗口IW; 一般为 SMSS(发送端最大段大小) 如 ：IW=2*SMSS 
						>cwnd 从1 开始，收到ACK后 递增到2；即 慢启动算法会以 min(N,SMSS) 来增大cwnd; N=好的ACK 确认的字节数； 好的ACK=ACK号大于之前收到的ACK;。。从而再收到一个ACK后序列号+2，则接着发送4个，然后收到+4，接着发送8个...。。一次发送一个RTT 往返时间 。。cwnd 随时间指数增长，达到慢启动阈值；
				>拥塞避免 算法： 
					>执行时机：确定了慢启动阈值后。
					>目的：为了得到更多的传输资源而不至于影响其他连接传输。
					>假定：由比特错误导致的丢包的概率很小。远<1%
					>cwnd更新：cwnd(t+1) = cwnd(t) + SMSS * SMSS/cwnd(t) 线性增长，累加增长；cwnd就是在外数据包的总个数---没有被确认的已经发送的包的个数
				--慢启动和拥塞避免 的选择：cwnd <ssthresh 慢启动阈值 ，使用慢启动；最大区别：在收到ACK时，cwnd怎样增长；	
				--发生超时重传或者快速重传时 cwnd的更新：ssthresh = max(在外数据值/2, 2*SMSS)
				>Tahoe\Reno\快速恢复算法：
					>Tahoe: 丢包时 cwnd=初始值1SMSS
					>Reno：快速恢复机制：恢复阶段，收到一个ACK，cwnd就增长1SMSS,
				>标准TCP：解决网络拥塞崩溃的问题；
					>慢启动阶段：cwnd=IW, ssthresh>=awnd 接收到好的ACK： cwnd+=SMSS  即 cwnd < ssthresh 时； cwnd+=SMSS*SMSS/cwnd 即当 cwnd>ssthresh 时；
					>收到三次重复ACK：即快速重传判定要执行了：
						>1.ssthresh 设置>=max(在外数据值/2, 2*SMSS)
						>2.启动快速重传算法，后 cwnd = ssthresh+3*SMSS  。。快速恢复1.
						>3.每接收到一个重复ACK：cwnd+=SMSS . 说明数据包已经成功传输；数据已经到达--拥塞缓解。快速恢复2.
						>4.当接收到一个好的ACK：cwnd = 在外数据值(ssthresh) 。。
					>拥塞避免阶段：收到一个好的ACK：增加1/cwnd; 出现一次丢包：cwnd减半； 。即 和式增加而积式减少AIMD拥塞控制;
						>一般的：cwnd = cwnd + a/cwnd  ;  cwnd=cwnd-b*cwnd; 为AIMD等式；。。可以利用FHPW00得出发送率：当a=1,b=1/2, 包个数/RTT  = 1.2/sqrt(p) p 为丢包率。发送率和丢包率有关，但不考虑重传超时；为简化的标准TCP响应函数。
				>对标准算法的改进：恢复阶段：NewReno ----收到序列号不小于恢复点的ACK才停止快速恢复阶段；		
					>在外数据的估计值：管道变量；	
					>转发确认FACK和速率减半算法：在丢包后的既不违背拥塞窗口减半 又避免出现等待空闲 的做法；。。但是实际效果<TCP Reno 
						>带界定参数的速率减半：RHBP 算法。net.ipv4.tcp_fack=1启用.在一个RTT时间内，每接收两个重复ACK,可发送1个新数据包。RTT=一个分组发送完成开始 到接收到分组的ACK为止的时间---Round-trip time 
				>限制传输：可用窗口较小的情况下，发送方每接收到2个连续的重复ACK,就能发送一个新数据包，来维持网络中数据包的个数，足以触发快速重传；
				>拥塞窗口校验：CWV算法。 TCP根据发送数据包接收ACK,而估计一个RTT内的 cwnd 和 ssthresh 的值。处理：在发送长时间暂停的情况下, cwnd 应该的衰减。
					>空闲发送端：没有数据需要发送 	而引起的空闲状态；。
					>应用受限发送端：需要传输数据，但因为处理器忙或者下层阻塞等 无法发送；
					>CWV算法：需要发送新数据时，查看距离上次发送是否超过一个RTO,超过了则：1.更新 ssthresh=max(ssthresh,3/4*cwnd) 2.每经过一个空闲RTT,cwnd 就减半 直到 SMSS 
						>应用受限阶段：1.已使用窗口大小记为 W_used , 2.更新 ssthresh=max(ssthresh, 3/4*cwnd); 3.cwnd=(cwnd+W_used)/2 ....所以长时间暂停后，进入慢启动阶段。
			>伪RTO处理-Eifel响应算法：恢复cwnd和ssthresh的值，转为正常状态，继续执行拥塞避免算法。
				>伪重传：如链路层的某些变化可能导致---如蜂窝转换；
				>算法过程：首次出现超时重传，Eifel开始执行，若认为出现伪重传，则撤销对ssthresh 的修改；ssthresh=N即就是一个往返链路容纳的分组总数的一半即N。拥塞说明这条链路已经满了，ssthresh达到了最大值---管道容量C。
					--初始阶段：ssthresh 指数增，超过容量C后减半，后线性增；C=2*N=r*RTT
					>1.收到包含ECN-Echo 标志位的好的ACK：停止操作；
					>2.cwnd=在外数据值+min(bytes_acked,IW)  未知链路是否拥塞--而发送IW的新数据也被认为是合理的；
					>3.ssthresh=min(在外数据值, ssthresh)
					--tcpdump记录数据包的传输轨迹；
					--tcptrace收集连接相关的统计信息：提供拥塞窗口的相关信息；如重传了多少个数据包--字节量多大；
					--wireshark可以查看tCP操作并分析干扰的原因；如时刻-发送的最大序列号
					>本地拥塞：tcp产生包的速率大于下层队列发送的速率；。拥塞窗口减半CWR：本地拥塞造成/或者收到ECN-Echo。
					--总结：cwnd值影响的是发送端实际可用窗口；ssthresh值影响的是发送端选择慢启动还是拥塞避免(来增长cwnd/调整cwnd),而超时重传快速重传影响ssthresh的值(减半)(减半后+3*SMSS赋值给cwnd因此发送端可用窗口也减少了)；(何时增大ssthresh?)。
					--总结2：在外数据包个数 <cwnd , 理论上可以再次发送包；但是如果因为一些原因如本地拥塞出现CWR事件，则不会发送；
					--总结3：在外数据值=首次发送而未收ACK的包数 + 重传而未收到ACK的包数 - 网络中已经不存在而没有收到ACK的包数。。。大致意思可以理解为 发送方已经发送的-接收端已经收到的；
					--总结4：RTO=y*RTT..。SACK返回的不是空缺而是已经收到的范围。。。参考：https://blog.csdn.net/Tencent_TEG/article/details/106416464
					--总结5：dupthresh为网络中乱序的包数；
					--总结6：恢复状态开始和结束：收到重复ACK-即含SACK则进入失序Disorder状态，再次收到2个重复ACK-则进入恢复状态Recovery(恢复阶段--可能出现快速重传;ssthresh/cwnd减少),直到收到ACK的序号大于当前已发送数据的最大序列号(重传结束)--恢复阶段结束；
					--总结7：CWR状态的开始和结束：出现本地拥塞事件-先ssthresh设置为当前cwnd/2后进入CWR状态，cwnd开始进入减值阶段-如果出现超时则中断减值过程；。。超时引发重传，重传后估计flight_size在外数据值--和cwnd比较后 可能发送数据也可能拥塞窗口调整(cwnd=在外数据值+最大突出值)
			>共享拥塞状态信息：新连接可能利用已关闭连接或者活动连接的信息。		
				>拥塞管理：本地os可以实现相关协议来了解链路状态信息，如丢包率、拥塞估计、RTT等；当一个TCP连接关闭前，需要保存：RTT测量值(rttval,srtt)、重排估计量和拥塞控制变量 cwnd-ssthresh
			>TCP友好性：TCP连接对传输资源的竞争问题：限制特定环境下TCP连接对带宽资源的使用；--TCP友好速率控制TFRC：基于连接参数和环境变量(RTT\丢包率)实现速率控制；
			>高速环境下的TCP: 此时TCP不能很好利用高速网路--因为窗口增加比较慢；。。但改进要保持与标准TCP的公平性；
				>二进制增长拥塞控制BIC-CUBIC
					>BIC-TCP算法：丢包(拥塞信号)时重新计算窗口的方法：[最近一次在完整RTT中没有丢包的窗口大小，最近丢包时的窗口大小] 在这个区间 二分查找--丢包则上界变化--没丢包则下界变化--不断压缩范围找到设定的最小间隔阈值--为最小增量--Smin.饱和点；.加法增大+二分搜索增大；
					>CUBIC算法：CUBIC窗口增长函数：W=关于t的三次函数；
			>基于延迟的拥塞控制算法：不断增长的RTT值可以作为拥塞形成的信号；。但和基于丢包的算法竞争时会失去优势。		
				>Vegas算法：和式增加和式减少的拥塞控制策略；吞吐量: 窗口大小/观测到的最小RTT;  这个次次计算； a,b 范围值维护。当 吞吐量 <a, 增大窗口，大于>b减小窗口；之间则不变；使用a,b窗口可以避免频繁的修改窗口大小---而减少震荡。
					>慢启动阶段：
					>不需要调整窗口的情况：因为返回ACK产生了延迟，而不是发送数据包在路径上延迟；这个是基于RTT进行拥塞控制判定的方法的潜在缺陷；。net.ipv4.tcp_vegas_config_void决定是否启用；
				>FAST算法：根据预期的吞吐量和实际的吞吐量的不同来调整窗口；根据速率起搏技术 每个一个RTT就更新发送率；	
				>TCP Westwood算法和Westwood+算法： 通过修改传统的TCP NewReno 发送端来实现 对大带宽延迟积 链路的处理； 。发送端的 合格速率估计ERE--对连接中可用带宽的估计；检测到丢包：则计算一个估计的BDP值--ERE*观测到的最小RTT
					>慢启动阶段：cwnd指数增长。
				>复合TCP：根据延迟+丢包来调整窗口；是标准TCP+Vegas算法的结合；	
					>新的窗口控制变量:dwnd 延迟窗口； 可用窗口大小 W = min(cwnd + dwnd, awnd);  拥塞避免阶段：ACK到达，则cwnd = cwnd + 1/(cwnd+dwnd)
					>缓冲区占用率：diff = W *(1-baseRTT/RTT) , 调整 dwnd :  当 diff < y 时，多项式增加dwnd; 当diff > y时，线性减少dwnd; 当丢包时：积式递减；
			>缓冲区膨胀：网络设备一般MB级别包缓冲区；会导致TCP性能下降；即缓冲区膨胀；家用网关上行端 接入点；在链路瓶颈处就会把缓冲区填满；。所以商用路由器缓存16KB-256KB足够；		
			>积极队列管理和ECN: 积极：应用FIFO和尾部丢弃 以外的 调度算法+缓存管理策略；
				>积极队列管理机制：AQM. 即将路由器和交换机的状态传输给端系统；
					>显式拥塞通知--ECN：对通过路由器的数据包进行标记---IP头中的两个ECN标识位；--来得到拥塞状况；
					>随机早期检测RED网关机制能够探测拥塞情况的发生：且控制数据包标记； 对包：计算 平均队列占用时间， 和[minthresh, maxthresh]比较， 在这个区间上，则被标记一个不断增长的概率值；如果大于maxthresh, 则将被标记一个可配置的最大的概率值MaxP; MaxP可以设置为1.0.  RED也可以丢弃数据包而不标记它们；。显然接收端才知道这个标记位，而发送端才需要--所以要发送给发送端；
						>路由器在ip头设置已经发生拥塞CE标识：将ECN设置为1，然后继续向下转发数据报；
						>接收端收到CE标识被置位的数据包：将每一个ACK数据包的“ECN回显”(ECN-Echo)位字段置位--直到收到一个从发送端发来的CWR位字段设置为1的数据包；因为CWR位字段置位说明拥塞窗口已经降低；
						>发送端接收到含ECN-Echo标识的ACK数据包：会调整cwnd值；同时还会设置后续数据包的CWR位字段；拥塞处理：调用快速重传+快速恢复算法；
						---优点：使得相同TCP吞吐量，而缓冲区的占用率下降甚至达到90%,背景流量也有10倍增长；。net.inet.tcp.ecn_initiate_out, net.inet.tcp.ecn_negotiate_in来控制向外传输和向内传输的ECN功能的开启；
			>与TCP拥塞控制相关的攻击：试图强迫TCP发送速率比一般情况更快或者更慢；			
				>基于接收端的不当行为：使发送端速率偏快；ACK分割攻击---ACK包更多而导致cwnd增长更快；重复ACK欺骗攻击；乐观响应攻击---对还没有到达的数据包产生ACK；
				--Linux的TCP/ipv4大约只有20000行c代码；
		>TCP保活机制：空闲的TCP不需要交换数据。只要两端主机不重启-改IP地址，那么它们将会保持连接状态；但是中间路由器不能保持连接的相关状态--如NAT配置信息；		
			>保活计时器：被激活时，连接一端将发送一个保活探测报文，另一端收到后返回一个ACK：。。如果中间路由器短暂重启---可能导致一端误认为对方主机已经崩溃。可选服务。
				>用处：服务端探测客户端是否在线，而检测到半开连接；
			>保活探测过程：在一段时间(保活时间)	内连接处于非活动状态，开启保活功能的一端向对方发送保活探测报文；如果没有收到响应，则 等待 保活时间间隔  时长后，继续发送保活探测报文，直到发送探测报文的次数达到 保活探测数，这时对方主机将被确认为不可达--连接被中断；
				>保活探测报文：序列号=对方主机发送的ACK报文的最大序列号-1；不会重传；
				>接收情况：k次探测都没有收到---崩溃--向对方发送一个重置报文；收到-正常工作--更新保活计时器；收到了重置报文---崩溃而重启--则断开连接；
				>三个配置变量：net.ipv4.tcp_keepalive_time, net.ipv4.tcp_keepalive_intvl, net.ipv4.tcp_keepalive_probes; 默认 7200s 75s 9次探测；
			>与TCP保活机制相关的攻击：容易受到欺骗攻击；。。而应用层保活机制如ssh较好；	
		>安全：安全威胁+安全机制 
			>蠕虫：利用缓冲区溢出 的问题 重写 服务器进程的内存；
			>信息安全基本原则：机密性---指定用户才知晓；完整性--传输完成之前不能被未授权的修改；可用性--需要的时候信息可用；可认证性---不能被假冒；不可抵赖性--个体行为可以得到证实；可审计性--可信的日志--能够描述信息使用的过程；
			>网络通信的威胁：
				>被动攻击：监听网络流量的内容(捕获/嗅探,流量分析)，破坏机密性；
				>主动攻击：篡改信息(存储修改和重放AB之间的通信流量)--破坏完整性；或使其拒绝服务--破坏可用性；
				--办法：加密：使得被动攻击无效，而主动攻击可以被检测出来；
			>基础的加密和安全机制：在不安全的信道上保护所传输的信息的机密性、完整性和可认证性；	
				>密码系统：加解密算法+支持的协议+操作方法(密钥)。。
					>对称密码算法：
						>分组密码类：每次只对固定位数的比特块操作，如64位/128位；如DES---操作64bit数据块，使用56位的密钥；。3DES,;AES--高级加密标准：密钥位数：128/192/256
						>流密码类：大量比特作为输入，且连续运行下去；
					>公开密码算法：一般用来交换对称加密密钥；会话密钥；
						>RSA 公钥密码算法：基于:1. pq=n ,   两个大素数之积=n,  p,q一般512b, n为1024b;  2.难题： c=m^e(mod n)  和 m = c^d(mod n) 如果把 e,d当作未知量,cmn当作系数，那么计算ed，是有难度的,知道其中一个e,也很难知道私有d；。。3.快速解法：但是如果知道n=pq, 则 可以立即得到一对ed, 即 e*d=1(mod (p-1)*(q-1)) 即生成密钥对。
							>基于发现：欧拉函数 Φ(n) 小于n的正整数且和n互质的个数。 推论：Φ(n)=Φ(p)*Φ(q),即p和q互质且pq=n；推论2：Φ(p)=p-1 即p是质数；从而如果n=pq,p和q都是质数，则Φ(n)=(p-1)*(q-1) 欧拉定理：m^Φ(n) mod n≡1
							>基于发现2：欧拉定理两边同时k次方，成立，同时再乘m，也成立，所以 m^(Φ(n)*k+1)≡m, 这样出现了还原m的特征；而指数的特征，显然是一个数对Φ(n)取模=1， 假设这个数=e*d, 那么e,d称为模反元素；即m^(e*d)≡m, e*d mod Φ(n)≡1; 
							>基于发现3：m^e mod x≡c, 则 m^(e*d) mod x ≡c^d  即指数次方后等式依然恒成立；用在加密中,e,d,n都是有关系的，即 e*d mod (p-1)*(q-1)≡1, n=pq 所以第一步就是得对n质数分解；e,d1,d2,d3....都有，e公开，而dk私有；
				>Diffie-Hellman-Merkle密钥协商协议：共同密钥的协商。
					>基于难题：g^k ≡ n (mod p) 已知 gnp,计算k;  但是 gkp已知，n就是很容易的；
					>得出协议：已知g,p, 一方：生成随机a, 则计算 A=g^a (mod p);   将A发送给对方； 另一方：生成随机b, 计算B=g^b(mod p) 发送给对方；
						>基于： B^a (mod p)=(g^b (mod p))^a (mod p) = g^ab (mod p) = K  这个数就是共享密钥；显然，双方都可以利用收到的A,B和自己的随机数来计算出来；。。。。但是需要认证---抵御中间人攻击；
				>签密与椭圆曲线密码：其他的公钥密码系统。
					>基于困难：寻找椭圆曲线离散对数元素。。椭圆曲线密码系统ECC,相同安全程度而密钥更短；
				>密钥派生与完全正向保密：
					>会话密钥的生成：由密钥派生函数KDF 根据一些输入而生成的随机数；。完全密钥正向保密：一个持续通信的会话期间---多次更改密钥；
				>伪随机数、生成器与函数族：
					>伪随机数：模拟随机的数字---计算机中。符合随机数的规律；。生成：通过伪随机数生成器+伪随机数发生器PRG 的设备生成。线性同余发生器LCG算法所生成的随机出现的数值是完全可预测的---没有达到密码系统的要求；
					>伪随机函数族：PRF是在算法上无法区别于真正随机函数的函数族。是加密性强的伪随机数生成器；CSPRNG.的基础；
					>随机数与混肴值：加密随机数--只使用一次的--临时密钥；用于认证协议；随机数---用于保障时新性；混肴值--用于加密文本的随机数，用来抵御对密文的蛮力攻击；
				>加密散列函数与消息摘要：加密散列函数---输入消息M输出摘要/指纹H，消息摘要可以看作是功能较强的帧校验序列；特性：不可恢复-充分散列抗碰撞；如生成128位摘要的MD5，生成160位的安全散列算法SHA-3， SHA-1/2都脆弱；
				>消息认证码：MAC/MIC---保障消息的完整性；基于有密钥的加密散列函数；H(M,K) 防止存在性伪造；不用于数字签名；
					>基于有密钥散列的消息认证码HMAC：形成t字节的HMAC：，抵御扩展攻击；。。其他的：CMAC,GMAC;AES-CMAC
				>加密套件与密码套件：
					>加密套件：实现三种性质的其他数学加密技术；cipher suite;cryptographic suite; =加密算法+消息认证码算法+伪随机函数族+密钥协商算法+数字签名算法(密钥长度/参数)；
					>加密算法的运行模式：密码块链接--CBC,计数器CTR, 级联不断加密；如明文块和密文块 异或操作；。。计数器模式更流行；CCM,GCM都是计数器模式，用于认证加密；
						>当加密算法被指定作为加密套件的一部分时：它的名字通常包括了它的模式、密钥长度；如ENCR_AES_CTR	
						>当伪随机函数族包含在加密套件的定义中时：会基于加密散列算法族/一个加密消息验证码。例如算法AES-CMAC-PRF-128 就是指一个基于AES-128的CMAC的伪随机函数族；PRF_HMAC_SHA1 是基于 HMAC_SHA1的伪随机函数族；
						>密钥协商算法在加密套件定义中：密钥协商参数与DH组定义有关：如模素数的椭圆曲线组ECP;
						>加密套件包含签名算法时：对数据、消息验证码、DH的值进行签名；数字签名标准DSA算法.
			>证书、证书颁发机构与公钥基础设施：怎样创建、交换和撤销密钥；--密钥管理。
				>信任网络：没有中心权威机构，背书者做背书的方式证明证书的可靠性；
				>中心化机构：对公钥基础设施的使用PKI---负责提供创建、吊销、分发以及更新密钥对与证书的服务；
					>证书颁发机构：用于管理和认证 一个实体 与它的公钥间的绑定关系；采用层次的签名框架；祖父密钥签名 父密钥，父密钥签名 公钥；。。从而一个证书颁发机构有一个多个根证书；
					>公钥证书：目的之一：识别网上四类实体--个人/服务器/软件开发商/证书颁发机构。绑定名称与公钥。查看预装CA的位置：openssl version -d | awk '{print $2}'
						>获取一个网站的证书并验证和查看：openssl s_client -CApath $CDIR -connect www.digicert.com:443 > digicert.out 2>1 其中 $CDIR 就是上述命令；然后grep "return code" digicert.out 来验证；有则对；转格式：openssl x509 -in digicert.out -out digicert.pem ; 后查看内容：openssl 509 -in digicert.pem -text 
						>组成： 数据部分：版本(X.509的)、序列号、有效期；签名部分：签名算法-散列/RSA 实际签名值
							>发行者Issuer: 发行证书的实体的不同名称；
							>主体Subject: 包含多个OID：国家名称域/州省名称域；
							>主体公钥信息: 主体 指定的实体 相关的算法和公钥；如指定RSA公钥：模(n):2048, 公钥指数65537---即e的值；从而可以用来对信息计算密文；私钥指数即d,
					>X.509标准：ITU-T X.509标准；能够以多种文件和编码格式 进行存储和交换的特殊证书；如DER\PEM(Base64编码版的DER)\PCKS#7\PCKS#12...PCKS#7 1.5版本最常见；
				>TCP/IP安全协议与分层：IPsec--VPN使用, TLS--HTTPS使用,DNSSEC---DNS的安全。。。Kerberos--Windows环境的第三方认证系统；SSH-利用安全壳进行远程登录和实现隧道功能的协议；		
				>网络访问控制：802.1X,802.1AE,EAP,PANA
					>802.1X: 局域网上的EAP协议EAPoL。。请求者--认证者--后端认证服务器
					>EAP:可扩展身份认证协议；实现身份认证、授权和收费，不执行加密；加密由WPA2等做；
						>包格式：代码字段--数据包类型；标志符--发送者选择的序号；长度--EAP消息的字节数；
						>交互过程：认证者发送请求给端点(申请者)，端点响应
				>第三层IP安全：IPSec提供数据源认证、完整性、机密性、访问控制；IKE/AH/ESP。同时提供交换密钥的方法、加密套件、标记使用压缩的方法；。适用于远程访问企业局域网；
					>安全网关：受保护与不受保护的网络区域间提供界限；
					>建立阶段：交换密钥材料、建立安全关联SA；SG检查IP头部特定字段--看是否使用IPSec和拥有预先存在的SA, 没有 则查询本地安全关联数据库SAD、安全策略数据库SPD,端点认证数据库PAD
						>Internet密钥交换协议IKEv2: 请求-响应对；IKE_SA_INIT, IKE_SA_AUTH 最基本交换；交换--加密算法、完整性保护算法、DH组、PRF会话密钥，消息封装在UDP:4500、500端口，基于窗口的协议；CREATE_CHILD_SA,INFORMATIONAL
							>IKE_SA_INIT: 协商选择 加密套件、交换随机数，执行DH密钥协商协议，；由发送方发出，响应者选择一个可接受的加密套件、
							>IKE_SA_AUTH: 上面阶段接收端选择某个证书名称返回；而此时发送端就要把证书发送过去；所以负载里有证书；
					>数据交换阶段：
					>IP认证头部: 在ip头之后，tcp头前；包括：安全参数索引SPI+序列号
						>ISP隧道模式：即在原始IPv6,TCP头+数据两端增加ESP头部+ESP尾部
					>L2TP/IPSec: 第二层隧道协议，支持第二层流量的隧道传输--通过IP/非IP网络的PPP流量，依赖一些在连接初始阶段提供认证的方法；，后续的数据包则没有提供机密和完整性保护；从而需要与IPSec结合使用，，选择IKE作为默认的方法；	
					>IPSec NAT穿越：
					--IKE建立并管理双方之间的安全关联；安全关联涉及认证AH或加密ESP;
				>传输层安全：TLS,DTLS
					>TLS: 可以应用层实现。前身为SSL--安全套接字层；TLS1.2运行在面向流的协议TCP之上；在多种加密套件基础上提供机密性和数据完整性。也能在两个匿名通信方之间建立安全连接；
						>记录层：记录协议：分片、压缩、加密与完整性保护。使用基于散列的消息认证码HMAC,生成密钥--基于HMAC(SHA-256)的伪随机函数族PRF
							>每个状态指定：压缩算法、加密算法、用于通信的HMAC算法；
							>处理流程：
								>明文记录：高层消息块划分后；类型+版本+长度+负载分片；
								>从状态中选择压缩算法：将明文记录压缩为TLS压缩结构；无损压缩，<1KB
								>应用加密与完整性保护算法：将TLS压缩结构转换为 能够在底层传输层连接上发送的TLS密文结构；。加密+MAC； 或者 随机数+加密----如AEAD算法如CCM/GCM---无需MAC提供完整性保护和加密功能；密钥来自--握手协议提供；
								>根据主密钥生成新密钥：=PRF(master_secret, "key expansion ", sever_random + client_random)  加密套件最常见材料=AES_256_CBC_SHA256
						>上层：信息交换协议：负责建立身份、认证、提示警报、为用于每一条连接的记录协议提供唯一的密钥材料；包含：握手协议、警告协议、密钥变更协议和应用数据协议；。
							>握手协议：协商加密算法，并交换 对称加密使用的 随机值；建立算法运行参数；交换证书并执行相互认证；生成特定会话密钥；为记录层提供安全参数；验证所有的操作都已经正确执行；
								>客户端发送hello消息开始：会话标志符+建议的加密套件编号+一套可接受的压缩算法+随机数
								>服务端收到hello消息：检查会话标志符是否在缓存中，在则简化握手过程 而使用之前的连接；。服务端hello消息返回：随机数+会话标志符；选择加密套件+证书；服务器密钥交换消息(证书没有包含足够信息；如密码套件以TLS_DHE_DSS,TLS_DHE_RSA开头等)+证书请求+ServerHelloDone；
								>客户端再次回复：证书+客户端密钥交换+证书验证+可能改变加密套件+完成；
								>服务端可能回复：改变加密套件+完成；
								---例子：服务器可以配置为只有一个密码套件：TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
							>警告协议：用于传递状态信息，如终止条件或者非致命的错误条件；
							>密码变更协议：指出通信一方希望将当前状态修改为挂起状态；
					>DTLS: 面向数据报的TLS---如VPN中也使用；
						>记录层：有明确的序列号；基于握手协议的序列号 而 制定 基于超时的重传方案；
				>DNS安全：域名系统安全扩展；解析器和服务器之间交换；	
				>域名密钥识别邮件：DKIM  帮助验证消息的签名者；