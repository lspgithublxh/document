1.问题：掌握已经有的，就是一件大事。就可以让自己值钱！
	>修炼哲学：用自己的语言说，用自己的双手做
		>不要装累装懒，而不务正业做浪费时间的事---而后面又羡慕别人和后悔自己，且还会真的累和懒，导致什么都没有掌握。！！
		  >自己本来就没有多少东西让人佩服尊敬的，如果还不持续努力，那么就太让人失望了！！与别人的差距就更大了，就会更加的不敢说话和脆弱和落后！！甚至连乡村的人都比不上！！！
		  >要集中注意力于一点，一个目标上---一个阶段一个时期，不分心的持续努力！！！
			>而为了这个目标这个大事而分多方面进行努力，多方面协调的努力；把这个大的工作、大的事情、大的职责分解为多个环节多件事情独立并行的做。来从多方面刺激发现体会到思想和技巧，并逻辑完备的前进。这样分离，既不单调也不分散精力，既有新鲜的乐趣也有攻克困难解决问题-探索发现功能|原理|机制|过程|职责-创造发明简化方法简便方法简便工具新技巧新工具新功能工具--升华打磨而做成服务产品的乐趣！！！！
			>提出问题-把不懂的想懂的不会的想会的描述清楚：把疑惑的问题、不懂的问题都表达出来，想弄懂的问题记录下来，记录下来，组织起来，并且不断的拓展；。
			>再分析问题-得出不得不做的最简最优做法办法方法策略路线方案：认识问题，分析情况、条件、联系、规律，抽象出概念，层层向上抽象出来，人工逻辑关系，人工逻辑推理连接关系，科研式的逻辑演进，用规律来压缩、简化、减少动作、减少对象、减少存储量-记忆量-动作量-能量消耗量，简化到极致-简化到理想状态，用规律统领，更重要的时用抽象概念来统领---统领整个认识全部的认识---统领全部的方案方法。就像压缩文件一样，压缩认识、简化认识，而同时又能解压缩解认识，而独立恢复出完整的一致的全部数据，独立恢复出完整的、一致的所有认识。
				>知识压缩法：！！规律、抽象、人工逻辑、抓头。
				    >抓头：就是梳理出本源、根本；导致一系列结果的根本事情；导致一系列衍生问题的根本问题、根本现象、根本矛盾、根本情况、根本事实。
			>再设计执行方案-独立做出来做样例做产品：自己讲自己做
		>先认识功能，弄懂了再看原理，简化了原理弄通了再自己做而模拟一个，最后利用来做成应用产品服务！！
			>功能描述清楚：清楚的标准和特征表现和根本认识根本变化：现在很多时候，对很多系统，很多工具，很多产品，是连功能都描述不清楚的不准确的不本质的不有效的。
				>不要不痛不痒，周围盘旋，绕来绕去，没有说到点上。
			>原理描述清楚：清楚了，简化了，极致简化了，掌握了。办法就是：自己来，用自己的语言，用自己的行动自己做。
			>来龙去脉：这个工具---所处的业务背景，业务发展中遇到的问题，所要解决的问题；明确后，再认识其功能。
		>大量阅读长篇分析型文章：取缔零散阅读，要阅读那种一篇能读一天以上的长文；并且自己来，对比作者，总结深究，得出结论方法工具，趁热强化训练。
			>对长文逐句逐字逐概念研究：彻底弄通、熟练运用、制作产品，三个阶段。。带着问题，疑惑的问题，先提出来、罗列分类出来，然后再自己来分析思考，然后再看长文，并边看边自己来。(p8长文，博士长文，专家长文)
			>彻底弄通的引导理解的提出的问题树：
			>技术阅读，头脑中一定要是模块语言，一定不是现实的图像，必须是代图框图调用图这样抽象的表达，通用的表达表示---才是最抽象而不失本质不失真的，而表达出来本质的最少元素而恰能表达本质的，就是重点就是关键核心。
				>一定不要先管具体图像是什么，具体长什么样，外观什么样，必须是抽象的框图描述！！框图形式，无需管具体什么样-------否则看不下去，没有逻辑，让思路断裂。比如云计算各种实体和操作；就像数理是看模型和代数几何。
		>牢固掌握一个概念：不能直接理解它的最底层的概念组织起来的描述形式，而是要环环相扣，层层分解，看下一层分解时候的概念组成图，连贯不断的分解，层层都认识到，是真正彻底弄通的标准--------属于让我来的具体做法指导。
			>让我来的指导：可以看到自己的真实水平、真实缺陷、真实不足，而有目的有问题地提高自己：让我来和让高手来，看分别会采取什么做法和分析，军事指挥(路线)和技术(策略)都可以。
			>理解也需要战略战术路线：不能生硬直接地去理解，
				>层层转化简化：
				>层层提问：理解路线，前进路线、推进路线，推进方向，树状路线;; 谋定后动。
				>层层承接：扼住、总揽、因果、；有A则B, 知A则知B,由A得B,由B得C,,,.....,越是后面越是复杂不直接和规模大必要描述越来越多的系统对象。
	>切换思维：没有思考时，就训练、使用、应用和记忆，后者是轻松的切换的不思考而没有害处的。。
		>思考问题时：语言时刻在线。
		>
	>java整体体系的知识：有事没事看看java相关的小知识技术博客-----网络的和计算机级别的也可以
	>问题1：cpu级别的CAS指令：计算之前读内存值A，计算之后读内存值B，当A==B时，将计算值回写到内存，否则返回失败状态。。。乐观锁---能冲突检测，认为冲突概率小且冲突了返回失败就可以而不用对内存加锁。。
	>问题2：classLoader: 限制启动类加载器Bootstrap ClassLoader才能加载某个类：比如限制sun.misc.Unsafe类(CAS操作)。。限制下的访问：
			>使用反射调用的方式来加载sun.misc.Unsafe类：使用它的cas方法：compareAndSwapInt()等
			>使用使用了Unsafe类的类比如AtomicInteger: 使用它的getAndIncrement()自增方法---这个方法转变为指令时就是CAS指令---和i++这种语句生成的指令不一样: 用多线程时有更高的并发性能。
			>数据版本号：AtomicStampedReference对象引用的原子性--解决ABA问题。
	
     >十大基本问题：(除了平时搞应用之外，也要关注这些基础) 每个都一张图简要描述---抽象描述
	>问题3：并发：
	>问题4：集合：
	>问题5：线程：
	>问题6：通信：
	>问题7：加载：
	>问题8：回收：
	>问题9：队列：
     >十大基本框架：(不知其过程设计的根据和原因，不会抽象描述，就不会有兴趣) 每个都一张图简要描述---抽象描述(就像苏东坡一段落一个字、两个字、三个字、一句话描述一样   向上抽象)
	>问题1：springmvc:
	>问题2：tomcat:
	>问题3：springcloud:
	>问题4：springboot:
	>问题5：spark:
	>问题6：kafka:
	>问题7：hadoop:
	>问题8：mysql:
	>问题9：redis:
	>问题10：docker:
     >常见基本应用问题：
	>top(n):1亿数据求最大的10个数，用堆法--树--一直排好序的10个数，来一个二分查找比较一次---自动保留10个--自动去掉最小的那个-----链表的方式：直接插入再去掉尾元素，。。（甚至所谓的双向链表）。
     >linux运维技术问题：
	>基础问题：	
		>用户和权限
		>进程、资源、文件、任务、软件包、磁盘等管理方法
		>企业级常用服务：DNS, FTP, Http, Mail
		>
	>安装Centos和配置环境：
	>Nginx反向代理和负载均衡：
	>Keepalived高可用服务器：
	>Memcache服务安装：
	>Nagios监控工具：
     >云计算问题：
	>业务背景：IT平均资源利用率低；痛点，事实。
	>引发需求：弹性的IT基础设施
	>需求分析和提出功能：高可用的、按需的、通过网络就可以快速即时获取到而便捷使用的、在线的远程的共享的弹性的多样的计算资源服务提供商。。从服务器、操作系统、应用软件到网络访问资源、各种具体的数据、服务。
	>功能的解决方案设计：谷歌“云计算”概念和架构体系---->亚马逊弹性计算云商业化运用---->ATT动态托管服务
	     >整体方案：底层分布式系统，中层虚拟化(以提供小块小块的资源，以充分饱和利用和共享利用)，上层资源调度编排管理并提供给客户方基本操作接口
	>问题：
	      >分布式系统一致性问题：
		>paxos算法：任何算法都有它的思想或者说观点、信念、原理、根据，可以用一句话、因果逻辑语句来概括描述。
		     >观点信念：对于一个集群，查看超过半数的机器才能从统计上看到集群的最新值，更新超过半数的机器才能认为从统计上更新了集群为最新值。(最新值即为：最新时间-值)
			>也为：用集群的方式存储一个值对有效读写的要求：读要读超过一半，写要写超过一半。并且读取的超一半的个数的值中最后采纳的值是从统计上认为的最新时间对应的值。写的目的是为了读，只有写的个数超过一半了，读的时候才能读到最新写的值。才能有效读写，才能成功读写。
			>附加效果：新的paxos过程只会让集群中的最新值机器数越来越多。
		     >并行地对集群执行paxos过程：读取最新值，提交最新值。应当有：在这个过程中，节点应该更新一次后就不再接受新的更新。
		     >集群节点的崩溃、恢复、增加、删除：
		     >阶段流程：流程概括：
		           >程序流程：详细的流程、算法过程。
		>
	      >分布锁问题：
	           >数据库锁： 第一种：记录方式：insert into .....同步代码.... delete  from .... ；；；第二种：数据库排他锁：select ... for update ....代码.... connection.commit()
		>单点与集群：
		>非阻塞锁：一旦获取锁失败，则报错而要重新执行获取锁操作。。第一种非阻塞，第二种阻塞。
		>非重入锁：获取锁之后不能再次获取，必须先释放。
		>释放锁：数据库宕机后，重启锁是否还在，或者取锁线程down了之后锁没释放。第一种不会释放，第二种会释放。
		>超时释放：第一种复杂实现。第二种，for update wait 5 就可以超时冲突返回。
		>基于数据库的悲观锁：独占数据，独占锁。性能影响大。主要是对并行的“读取-修改”这种业务场景。一端读了另一端则要等到修改完成后才能得到锁。
		>基于业务逻辑实现的乐观锁：不需要数据库锁，对于并行的“读取-(本地运算)-修改”、“读取”、“修改”三种业务场景；对于纯修改，则在修改数据时会更新记录的时间戳，不先读取；对于先读再算再修改，在修改时的语句中有when timestamp = 'timestamp_read' 这种的要求---如果不等，那么说明已经过时了被更新了，需要redo。---但如果更新的频率不高，那么这种redo是比较少的。
			>时间戳：就是数据版本。
	           >基于redis的分布式锁：缓存系统的锁
		>原理：client让redis上对一个key执行先判断 后赋值的操作，返回成功或失败；redis“判断-赋值”是一个原子操作(只有一个线程在判断)，成功表示赋值成功-获取到了锁，失败表示赋值失败--有client已经获取到了锁；可以设置等待时间，超时不再试图获取锁而返回。判断，从理论上看可以是判断该条记录的requestId是否为提交的值和value是否表明为无锁，来决定获取锁是否成功、释放锁成功，，，；实际上，redis的判断是set if not exists 即没有key则设置，有的话则直接返回。delete if same value
	           >基于zookeeper的分布式锁：自身集群、客户端监听而阻塞、zk客户端第三方库curator而可重入、得到锁的客户端挂掉自动删除该客户端创建的临时节点而释放锁、获取到锁的标记--client创建的临时节点序号值最小
		>client创建的临时有序节点所在位置：要同步的方法名确定的路径下。
		>zookeeper的原理：对zk的概括：用熟悉的简单系统来对比描述。
			>本质功能：一个有监听通知机制的文件系统。
			    >实现方法|设计路线|设计分析：树形的数据结构 、  读写的对外接口 、 主备的集群节点数据同步
				>对外接口：create, delete, exits, get data, set data, get children, sync(等待数据在集群中扩散完毕)
			>底层的根据、引用的服务：引用的基础功能、底层功能：操作系统的原语集；而一条原语是若干条指令组成的。
			>给客户端的会话id:sessionid
			>数据结构：树。保存在内存中。树的每个节点分为：临时节点---和client的生命周期绑定，持久节点--只能主动删除。
			     >一个节点的数据结构：
			     >一个节点的监听器：watcher
			     >一个节点的权限控制：ACL。五种权限：create, delete 对子节点操作；read,write 对节点本身的数据的操作权限(read也能读子节点列表); admin 设置节点ACL的权限。
			>系统保证的性质：
			     >顺序：所有client的更新请求事务都会顺序被集群执行(写请求)。
			     >原子：所有client的更新请求事务都会被集群原子的执行，所有的节点都应用了该事务，或者都没有应用该事务。
			     >统一：client无论连接集群的哪台机器，读取的数据结构是一样的，连树的每个节点都是一样的。
			     >持久：更新操作，持久化改变数据，直到下次更新。
			>集群中各个服务器之间的通信：
			     >zab协议：zookeeper atomic broadcast
				>目的：保证集群中各个副本的一致。
				>集群模式：主备。
				>两种集群过程：
				    >恢复模式：Leader服务器故障后启动，follower选举产生新的Leader服务器，并有过半follower机器和Leader状态同步|数据同步完成, 后退出此模式。(协议保证集群中有Leader，且只有一个Leader)
				    >消息广播模式：新的服务器加入集群时，启动，找到Leader服务器，完成数据同步，退出此模式。
			>client的一次更新请求：集群内部的同步，和外部client之间的同步。
			     >给该请求client分配一个全局唯一的递增编号：时间戳。分配一个会话ID.
			     >事务处理者：对于读取，直接该节点返回；对于写请求，如果follower收到了事务(路径-数据)，那么转发给leader服务器，leader向所有follower发送写请求，超过一半机器的响应是成功的则本次写入请求成功，则向follower提交事务，follower将数据更新到内存数据库。返回成功信息给客户端。
			     >特定间隔向连接的服务器发送心跳：保持会话有效。会话创建的临时节点和会话生命周期绑定。
			     >client向集群中一台机器发起会话连接：失败则会选择下一台。
			     >client读取服务器中一个znode时：可以设置watches，它会向注册的client发送它更改的通知。watches也是和会话绑定的，且一次更改只触发一次watches通知，会话关闭则watches被删除。
			>集群模式：主备模式
			     >角色：leader  -- follower -- observer
			     >Leader: 选举出来的，为客户端提供读写服务：。官方：7台机器200ms选举出Leader.。。两发两收。
				>选举过程：自己认为可以的：条件：每台机器有个leader变量，开始都赋值为自己id, 都会广播给其他机器，收到其他机器id,如果比leader变量的值大则更新(控制顺序更新)，则返回投它1票，否则返回自己的leader值，广播完毕，那么如果自己没有投票，那么设定自己为follower角色，leader值为更新的值，如果自己有投票且超过了半数则执行同步原子操作“设定自己为leader角色”，并广播消息，返回超半数确认，则选举结束，确认节点不接受任何重新选举请求；leader开始同步数据请求；未超半数，广播重新选举。
				    >启动时：第一轮状态都是looking, zxid都是0， 第一轮投票都是广播自己：(服务器标识ID sid, 事务idZXID zxid, 逻辑时钟-投票轮次)
				    >leader宕机时：每台follower更新自己的状态为looking, 开始投票：此时各自的zxid可能不同了，投票(myid, ZXID,logicLock)
				>选举过程概括：每台机器广播自己投票-------->接受投票比较自己的投票后更新投票而再次广播投票-------->接收投票，如果投票超半数相同，结束投票。开始取该投票的sid,如果是自己的，则更新状态为leading, 否则为following。
				    >在某一轮中，如果机器X收到了超半数相同的投票，那么它可以自行确定断定，投的这超半数的构成机器也一定收到了超半数的相同的这个投票(因为半数相同那么投的票肯定不是初始化的，肯定是选择对比之后再次投的)，从而可以安全地肯定地有理由地结束选举，更新自己的状态。对于更新为leading状态的机器，要开始和follower同步数据, 同步失败那么还会重新进行选举。
				>数据同步：
			     >follower:参与选举，为客户端提供读服务；参与写操作中“过半写成功则成功”策略。
				>follower互相之间不相互通信：follower和leader之间互相通信，follower也和client通信。
			     >observer:不参与选举，为客户端提供读服务；不参与写操作的所有过程。功能单一，而性能好。在选举过程中也提供读服务。
			>节点类型：
			     >持久类型：
			     >临时节点：选举过程中使用。
			     >顺序节点：锁定和同步中使用。
			>开销问题：写请求的开销大。
			>应用：zookeeper集群作为中间人身份
			    >分布式锁：
				>方法1：创建节点/(成功得锁，存在了等待)，.....code..... 删除节点
				>方法2：在一个节点A下创建临时顺序节点B(查A下所有临时节点的最小值是否是自己，是则得锁，不是则监控比自己的值小1的顺序临时节点---如果监听到这个节点的事件为删除事件即不存在了，那么可能可以获得锁了，开始查询比较....) ,,,,code,,,,,,删除临时节点。
			    >队列管理：
				>等待成员聚齐：创建一个节点，监听它的子节点数目即可。而成员到达一个则在下面创建一个临时节点。
				>FIFO:创建一个节点，进来一个数据则创建一个顺序临时节点，出去一个数据则删除最小的临时节点。
			    >Master选举：
				>方法1：创建节点，外部集群的node在该节点下创建临时顺序节点，将最小的节点作为master,同时监听该节点，使得当该节点下有数据变动---比如外部集群中某节点挂了，则开始重新确定新的master---还是按照最小值的顺序临时节点法则。
				
			>对外特性：
				>最终一致性：client读哪个server数据都一样。
			>三大组件：请求处理器、原子广播、复制数据库
	      >node集群的master选举问题：	   
1.https://www.cnblogs.com/felixzh/p/5869212.html(zookeeper较好的总结)