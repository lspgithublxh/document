---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。

>理论总结：
	>能否用动态规划的条件：规模为n的答案是否可能和规模为n-1时候的问题的答案相同？如果是，则是可以用动态规划的。只是新增的这个元素可能会影响最终的答案--或者构造最终的答案。
		>条件2：规模为n的答案是否可以拆解为规模为n-1,n-2,...1的问题的答案相关：组合/函数结果？
		>条件3：规模为n的结果的分类是否可以分类为 由规模n-1,n-2...1的问题的结果相关+规模为n的特有/新增元素的组合相关？(比如括号生成问题)
	>用动态规划的思路：结构的无重复拆解。关键在：规模为n的结构的无重复分类拆解。	
		>事情2：规模n的确定，什么的规模？哪个值当作规模？目标值是变量？而不是条件量？
	>解集必然性约束暴露处理、展示出来、巧妙独特形式描述展示出来、形式变换处理后展示出来、分析出来：大大缩小解的范围、大大降低找到解的难度。
		>
	>要利用指针移动的规律和特征：这样可以解决跟定位有关的问题。
		>双指针算法：对定位问题，有标记的作用。标记算法的大成。
	>复制问题的临摹算法：深度复制问题，临摹复制。
		>动手画图：画各种具体例子中找到新思路和灵感。往往就是一些特殊例子给了思路，而发展成为通用统一的方法。比如深度复制带随机指针的链表，就是要通过画图画例子，其中画出相同指向的特例的时候，就发现这种特例有特殊解法，而正好这种特殊解法还可以是通用的解法！！！
		>特殊例子的特殊解法：往往本身就是，或者可以发展改造为通用统一解法。
  
>中等题：
	>两数相加：
		>方案1：链表格式，利用一个循环即可，存储进位值。
	>无重复最长字串：
		>方案1：重复当作平原，不重复当作山峰；一次遍历，记录平原的起止和长度
	>最长回文子串：<问题描述>
		>方案1：利用回文的中心确定则可以确定整个回文；一次遍历，每个节点当作是回文的中心，来看以此为中心/左中心的最长回文长度。
	>z字形排列：
		>方案1：利用字符串索引和图像每个点的映射关系：最左边列，是1...line, 总共line行，那么第一列的第i个的右边的那个的索引index2= i + (line - i) * 2, index3=index2 + (i - 1) * 2, index4=index3+ (line - i) * 2, 这样关系就是：第k次的值：index(k)=index(k-1) + (k%2)*(line - i) * 2 + ((k-1)%2)*(i-1)*2;;k=1,....直到index(k)>n则停止。从i=1开始取,一直到line,或者i>n为值。
	>整数转罗马数字：
		>方案1：4,9,40,90,400,900专门直接返回处理。对于其他整数：就是从最大到最小单位依次尽可能使用：(n / 1000)个M即km个M + (n-n/1000*1000)/500个D即kd个D + (n-km*1000-kd*500)/100个C + (n-km*1000-kd*500-kc*100)/50+...
	>三数之和：
		>方案1：单个值放入map(值为下标), 两两组合，如果set中找到(或者是右边剩余元素中)互补(如果下标小于前两个元素，则忽略--已经找过)，则结果放入map1,否则放入map2
	>最接近三数之和：
		>方案1：先排序后双指针算法。
	>电话号码的字母组合：是一个9重循环的过程：
		>方案1：可以利用秒针-分针-时针的原理，构造一个List，元素为电话号码对应的字母list, 建立List长度个指针，最开始都指向0，然后在无限循环里，做三件事：List的0元素的list指针向前移动1位指向list下一个元素--可循环；第二件：进位：如果上一步操作后回到了0位，则List的1号指针的list指针开始移动到下一个元素---同理一直判断到最高位，实现全部进位；当最高位出现了循环，说明遍历已经完全了，可以结束了；第三件事：利用List的各个位置的指针而返回对应的字母组合；实现了n^k的自由组合个。
	>删除链表的倒数第n个节点：
		>方案1：n当作线段的长度，线段端点记录法：利用3个指针即可；首先从head开始，一个指针不断往下一个元素移动，移动1位，用一个变量统计移动次数，最开始为1，移动一位变为2，...当变为n时,则当前头指针元素就是倒数第n个元素，则用第二个指针标记这个头元素，每次右边指针继续移动时，这第二个指针跟着移动一位，再用另一个元素指向前一个元素，那么当第一个指针移动到末尾的时候，用第三个指针指向元素的next直接指向第二个指针元素的next即可。
	>括号生成：
		>方案1：关键不是思考新增一对括号之后如何拆解为更小规模已有规模的组合/，而是思考规模为n的结构如何由新增的元素+不变的固定的更小规模的若干个来构造出来---注意固定就是不破坏更小规模的结构。从而很自然想到新增的这对括号，可能包括的完整的更小规模+没有包括的更小规模，也即可以将规模为n的结构看作是由新增的这对括号包括了一个更小规模的括号集合+未包括的括号集合左右拼接而成；从而从总个数上看：dp[n]= ∑dp[i]*dp[n-1-i] , i=1,2,...n-1 且自然的，明显的，因为未包括的部分结构始终是不一样的，所以每个结果都没有重复。
	>下一个排列：
		>方案1：断定：下一个更大的数就是从最右到zui左，逐个比较右边是否比相邻左边那个数大，如果大，则交换；否则一直比较到最左元素，则原地反转数组即可：对称交换。
	>在排序数组中查找元素的第一个和最后一个位置:
		>方案1：区间确定方法：如果left,center,right中，发现center是目标,left,right不是，则从center到两端都要寻找;如果left是而center不是，则只寻找left,center,如果center,right是，而left不是，也左半寻找;这样一直直到相邻元素不是为止。
	>有效的数独：
		>方案1：题意看主要是看是否有重复，则用集合最佳。用3*9个set，遍历每个元素，根据行号,列号,行号-列号对3整除的余数 来分别放入对应的三个set中，只要有一个set放入之后set大小没有变化则说明 不有效；否则遍历每个元素完毕后，依然有效则说明有效。
	>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合:
		>方案1：先缩小解的范围：将candidates从小到大排序，找到target所在位置，截断，只在最左边到这个截断位置之间的元素组合即可。
			>单个元素构成：只需要每个元素看是否是target的倍数即可。
			>两个元素构成：找出所有的两两组合，对每个组合的两个数，定义一个函数f(a1,a2,now) 首先target-a1-a2，因为至少需要使用1次，得到的差，先分别看是否能用a1或者a2构成，然后差再-a1-a2，看是否能被a1,a2整除...，这样在一个函数里，就可以计算出结果。
			>三个元素构成：找出所有的三三组合---从最小到最大--达到target为止：对组合的3个数，先用target-a1-a2-a3,结果，看是否能用单个元素整除？两个元素整除？然后再-a1-a2-a3,结果还是看是否能用单个元素整除？两个元素整除？三个元素整除？
			>四个元素构成：...
		>方案2：就是普通的递归算法。把所有可能的组合都走一遍。target-a1/a2/a3/a4分支，结果继续减a1/a2/a3/a4....	
		>方案3：等效为背包问题：i个candidates构成的总和为target的所有情况 拆解/分类 为 按照第i个cancidate取0个、1个、2个、....target/ci个时对应所有情况的总和，那么可以发现：f(i,target)=∑f(i-1,target-k*ci), k=0,1,2,3,4...v/ci ，递归转换操作处理，即target的替换为target-ci, 得出 f(i,target)=f(i-1,target)+f(i,target-ci)用这个递推关系既可以得出所有的情况。因为f(0,target)=0，所以f(1,target)=f(1,target-c1)=...=f(1,target-k*c1)显然此时已经足够直观，只要target / c1整除，则可以构成，结果是：f(1,target)=1，即用第一个candicates可以构造到目标值。
	>背包问题：
		>方案1：背包递推关系式/状态转移方程：按照第i种面值取0个、1个、2个...k个而分类总共用i种硬币组合出目标值的所有可能情况；这种拆解 就 可以得出递归关系：f(i,v)=∑f(i-1,v-ci*k) k=0,1,2,3,...v/ci, 这个关系中有求和，所以不是最简单的递推关系，因此还需要简化，则令v=v-ci, 则可以整理出一个新的关系，两个关系相并，就可以得出f(i,v)=f(i-1,v)+f(i,v-ci)这样的关系！！显然这个只需要两个数组、甚至一个数组就可以完成了。
		>方案2：还是按照分别取a,b,c,个来最终拆解为转化为分解为 两个最小元素来进行的组合，,,,但有局限。
	>字母异位词分组:
		>方案1：核心是比较两个字符串是否是同一组字符的不同组合。办法是因为将一个字符串单词映射到统一的格式：如一个整数或者一个整数数组。这里正是用了整数数组。26长度，每位代表一个字符的个数。从而比较两个单词的整数数组是否相等即可。对于一个字符串数组，则每个都映射为这样的数组/规范字符串, 再put放到一个map里，就自然分组了。
	>螺旋矩阵：
		>方案1： 记录方向：上下左右，转向时记录已经走过的行号、列号；下次走到某个元素如果下一个元素的行号/列号已经被包括则不走了。如果都包含，则停止而结束了。
	>跳跃游戏：
		>方案1： 树形展示可达元素。每个节点可达的节点为其子节点，形成一棵树，起点为根节点，末尾节点为叶子节点。深度优先搜索。广度优先搜索。深度最长为n.。构造树的过程就解决了。
		>方案2(更优)： 反过来，从目标节点开始回溯，一个个节点看，看上一个节点是否可以到达目标节点--每个节点都看，直到首节点。需要记录可达节点集合--或者就是一个等长标记数组。
	>合并区间：
		>方案1：起点终点标记在线上，然后重新遍历。规律在于：遇到起点数+1，终点-1，则当值为0时，表示一个大区间已经形成。开始下一个大区间。
		>方案2： 类似，但无需标记，而是起点和终点都封装到一个Node里，标记值和起点还是终点，然后从小到大排序，然后遍历，操作就类似如上了。
	>第k个排列:
		>方案1： 先排序，然后在i-1的组合的插入上，规则为：从第一个开始，从右往左插入，但首元素不加。接着下一个老元素的插入；完成后，才开始加入最前面，从老元素第一个开始。
	>旋转链表：
		>方案1： n - k % n  就是断裂的位置，如果k%n==0则不用动，断裂的位置：指向null, 尾指针指向头即可。
	>不同路径：
		>方案1：必要分析，到达最后一个节点的可达节点2个，依次类推，构造出一棵树，叶子节点数就是路径数。
		>方案2：动态规划：f(i,j)=f(i-1,j) + f(i,j-1), f(0,0)=1, f(i,0)=1, f(0,j)=1
	>最小路径和:
		>方案1： dp: f(i,j)=min{f(i-1,j),f(i,j)}, 其中 f(0,0)="p0和", f(i,0)="直线路径和",f(0,j)="直线路径和"
	>规范unix路径：
		>方案1： 寻找下一个/ 分为两半，左边为内容，右边为子串，分别处理即可。
	>矩阵设置为0:	信息的原地标记和存储。
		>方案1：额外空间m+n, 存放有0的行号和列号，最后统一对这些行列进行置为0
		>方案2： 原地标记0所在的行和列的非0元素为极限值，最后再次遍历，将极限值全部设置为0。。优化算法为：不用每行每列都去标记，而只需要标记行号和列号--即第一行和第一列的元素是否为0，则标记的意思为这一行为0或者这一列为0，当然，四周的4条边需要专门首先查看---来确定是否需要置为0；即算法是：先用四个变量存：上下左右四条外围边是否需要置为0---查看四条边上的0位置即可确定--有则需要；没有则不需要；然后才开始对内部的元素进行判断：是否i,j行列需要置为0--需要则将对应的行首列首置为0；最后，再次遍历的时候，先内部，后外部四条边。
	>搜索二维矩阵：
		>方案1：比较普通，直接2次二分搜索即可。
	>颜色分类：
		>方案1： 计数排序
		>方案2：利用3种颜色的特定条件。用两个指针指向首尾，从0开始遍历，遇到0则和左指针的值交换，且左指针右移；遇到2则和右指针的值交换，且右指针左移，遇到1则不做什么，继续下一个元素。
	>组合：cnk
		>方案1：dp算法：f(n,k)=f(n-1,k) + f(n-1, k-1), 其中 n>=k, f(0,0) = 1, f(0,k) = 0,f(n,0)=1; f(1,1)=f(0,1) + f(0,0)=1, f(1,2)=f(0,2)+f(0,1)=0 注意运算。尤其组合生成时，ai 组合 f(n,0) 后者实际上是一个空串--即f(n,1)仅仅比f(n-1,1)多出一个元素而已。
	>单词搜搜：
		>方案1：构造搜索树，路径的节点上的字符连串就是 目标字符串--比较匹配则继续下一个字符的比较，而下一个字符来自所以可能的3个下一个节点--都符合则放在child里；不符合了则返回上一级查看下一个兄弟节点来看，没有下一个兄弟节点则再向上找。。。
		>方案2： 将child去除，而改用stack数据结构。将child入栈即可。弹出即可。栈就是深度优先。队列，就是广度优先。
	>删除排序数组中的重复项 II:
		>方案1： 记录当前字符、字符出现次数t；如果>=2, 则到下一个字符或者结束为止，向左移动/删除 t-2个位置。尾指针也同样移动确定。
	>搜索旋转排序数组 II:
		>方案1： 先进行二分混合搜索，如果可以确定下一步进行有序二分搜索即可，则直接转向有序二分搜索得到结果；否则继续混合二分搜索。
	>删除排序链表中的重复元素 II
		>方案1： 一般删除，两个指针，两个统计量-值和次数；然后每次删除之后，需要从头开始重新删除。
	>格雷编码：
		>方案1： dp算法。利用前n-1位的编码，直接复制一份出来-这一份的前面添加1，前一份则前面添加0，然后按照：old0->new0->new1->old1->old2->new2->new3->old4....依次输出即可；其中一格雷只有0,1
	>解码方法：
		>方案1： dp算法。 f(i) = f(i-1)独立单个i + f(i-2)并i-1并i----显然如果i-1和i可以并，那么：f(i)=f(i-1) + f(i-2); 如果不可以并，则：f(i)=f(i-1)。 而f(1)=1, f(2)=f(1)+f(0)||1||2 倒逼f(0)=1
	>反转链表 II:
		>方案1： 5个指针。一个指向开始分割的前一个，2个指向开始元素，剩下三个连续这指向，同步移动，来将中间的指向左边的元素，同步右移一位。
	>复原ip:
		>方案1： stack搜索方法：。
	>二叉树的中序遍历:
		>方案1： 递归方案是定义。迭代方案：用栈。当前节点，如果left不是null, 当前节点入栈，left变为当前节点，继续循环；否则打印当前节点值，看right,如果不是Null,则当前节点是right, 继续循环；否则是空，则弹出一个元素作为当前节点；
	>不同的二叉搜索树 II：
		>原理：一颗二叉树的一条完整的路径，可以用一个二进制数来表达，二进制数从0开始，根节点开始，左就添加0，右就添加1，到根节点就形成了一个二进制字符串，所以，一颗有n个叶子节点的二叉树可以直接简单的由n个整数来表示。
		>原理2：数组和二叉树的对应：一层挨着一层；每层按照左右先后加入数组，如果其中一个为null，则保留，但下一层则不再加它对应的null元素，只直接加有元素的下层元素。
		>原理3：一个整数就可以表示一颗二叉树。这个整数的每个数字表示一个节点，按照添加顺序由这个整数构造一颗树。而对于一棵树，按照一层一层的遍历的方式，得到的数字序列就是这个整数--当然必须有分割符：所以可以标准化长度。
		>原理4:双栈进行一层往下一层打印。
		>原理5：组合转为数组，长度不超过组合元素个数的2倍；数组转为结构，可以逐层打标记，从左到右的给每个元素打标记--如果没有子元素了--则结束--是一个结构。
		>方案1： 而组合，可以用dp算法产生。
	>不同的二叉搜索树 :
		>原理：数组格式的二叉树的特点：每层至少有一个元素，每层都可以划分为k个两个相邻元素构成的组，每个组内至少一个元素，如果一个元素也没有，那么这个组也要去掉。
		>原理2：h个元素分为k份，每份1-2个元素，有多少种分法；假设2个元素有x个，1个元素有y个，则求2x+y=h时，x,y的可能取值，且x+y=k这个约束要满足；从而得出x=h-k, y=2k-h, 所以共有C(k,2k-h)*2^(2k-h)种方案；；如果是多叉树，那么就不能直接得到个数的关系，而是得到个数之间的关系---就会需要用动态规划来计算得出----显然在这个二叉搜索树里不会有多叉树的定义！！但是，要考虑到容器可以一个元素也没有--因为父元素有值就要占子位置，而上层有use个元素，则下层有use个容器，则x+y+z=use, 其中z就是无元素的容器的个数，而有元素的是k份，所以零元素容器导致的排列有C(use,use-k)个，因此本层实际的方案数=C(k,2k-h)*2^(2k-h)*C(use,use-k)
		>原理3：可以省略的null: parent是null, 则本层对应的位置两个null都可以省略。parent不是null, 但是两个子都是Null, 如果这两个Null在数组的末尾则可以省略，否则在本层的末尾也不可以省略---因为会有歧义。。。
			>可以归结为：只要上层有b个元素，那么下一层就一定要占有2b个位置--且也只占2b个位置，就算末尾那个没有子，也要占，因为对下下层的影响；如果没有了下下层，那么加的这两个null也不影响 树的种数和树的结构---只是为了优化而把末尾的null去掉而已。
		>方案1：上一层的某种方案的所用节点数，决定了下一层的所有可能的用子数和对应的方案数：---当然下一层的元组容器数也是因素。n个元素k个容器的所有可能方案数f：n<=2k; n=1,f=2; n=2,k=1,f=1;n=2,k>1,f=4;n=3,k=2,f=C(4,3)
	>验证二叉搜索树:
		>方案1： 只需要对树采用中序遍历，比较当前元素和上一个元素，如果当前更大，则继续，直到最后的节点；否则不是二叉搜索树；
	>二叉树的层序遍历:
		>方案1： 就是数组的处理，每层的元组个数确定，“方案”确定，则下一层的个数确定，可以开始寻找下一层的所有元素；上一层的用子个数和本层的容器最多个数决定本层的结构。
	>二叉树的锯齿形层次遍历:
		>方案1：类似上，只是确定了本层边界后，从后往前进行遍历，下一次又从前往后...
	>从前序与中序遍历序列构造二叉树：
		>原理：中序遍历的顺序就是搜索二叉树的排序读法，先读取最左路径的最左元素，而前序遍历的顺序就是左分支下走节点顺序，所以中序遍历的结果可以指示一个路径的终点，而前序遍历则指示一个路径的起点；从而可以一条条路径确定下来。
		>方案：原理的实现。
	>从中序与后序遍历序列构造二叉树:
		>原理： 后序的最后一个是中点，然后从中序遍历中找到这个中点，就可以找到左右两半了，然后寻找后续的左右分割点，显然是右边的最左元素---这个元素正好就是中序遍历的中点的后一个元素，从而两个遍历都找到了左右两半的分割点，进行递归。
	>有序链表转换二叉搜索树:
		>原理1:按照滑链的方式，显然中点就是顶点，可以先根节点明确，然后左半边右半边再次明确各自的根节点，如此递归下去，就建立起来了。
		>方案1:遍历链表，得出n，新建arr, 再次遍历，放到arr里；然后开始找中点，放到arr,剩下的两半放到队列里；本轮结束，下一轮从队列里取出头元素，再次看中点...
	>路径总和 II：
		>方案1：用递归、栈实现。
	>二叉树展开为链表:
		>方案1：从最左节点开始，节点的左节点代表的长线的末尾连接到右节点，然后再从右节点的最左节点开始，这样一直往上，不断剪断左分支，再往右，再往上，...
	>填充每个节点的下一个右侧节点指针:
		>方案1： 使用三个指针：上一层的最左指针，上一层的游动指针，本层的游动指针。/进度指针。开始设置某一层时，从上一层的最左指针开始，左右节点指向，然后上层游动指针游动一位，而本次指针也游动到指向位；...一直到末尾，从而结束本层的指向；然后让上层最左指针指向它的左/右节点来指向下一层；而游动指针赋值同样的..本层指针则先赋值左节点....
	>单词接龙:
		>原理：两个单词之间变换一个字母可以相同，则可以逐个字母比较来实现；一个字典，可以建立起一个单词转换图，即一个单词通过转换一个字母就可以到达的词，则这两个词之间用一条边连起来，那么这个字典按照这种方式就可以构成一个无向图。则一个单词到另一个单词的最短路径就是这个单词到该单词的最短转换序列的长度；而最短路径可以用广度优先搜索统计d值而计算出G(V,E), delta(s,v)
		>方案：广度优先遍历的实现。
	>求根到叶子节点数字之和：
		>方案1： 搜索树-队列实现；累加可以*10的方式。
	>被围绕的区域:
		>方案1： 搜索树-队列实现： 可达节点更新为'T', 一直到没有未知。再把剩下的'O'更新为'X'
	>分割回文串:
		>方案1： dp算法。 字符串s的长度为n, 前i个字符串的所有回文分割数f(i) = ∑f(k),其中s(k+1...i)是一个回文字符串。
	>克隆图:
		>方案1：双map方案。广度优先遍历原图，放到Node-Number:map 看是否已经存放过是否需要生成新的number, 同时是否构造新节点：Number-Node_new 里记录，这样，广度优先遍历完成时就完成了复制。
	>加油站：
		>方案1： 一次遍历方案。先补充后消耗，看是否>0, 结果是大于0的，那么开始下一个加油站的补充,....如果返回到了起点，那么成功；否则如果突然断了，那么需要从断的那个位置作为可能的起点继续下去即可。
	>只出现一次的数字 II：
		>原理：如果用比较的方式，单独记忆的方式，是需要n相关的额外空间的如hashset,hashmap; 所以只能用统计的办法，混合在一起记忆-累在一起记忆。统计分，使用的运算？针对的对象？针对的对象的熟悉？能从统计结果上显示出特征？统计可以统计常数次。这里是统计整数，单纯求和不行--一个变量不行；所以 另一个办法：分类到常数个统计变量里，按取值区间是不行的，所以其他分类到常数个类型下的办法：得发现这些整数的特征、共同特征、统一特征、抽象共同特征、上层同属类型，显然就是32位整数，所以可以分为32个类型，各个数在各个类型上出现的次数--，显然如果重复，那么就倍增，3次则结果是3的倍数，其他出现3次的整数加进来，则也是3的倍数，所以遍历一遍，看各位的值，如果%3==1则一定是属于那个出现一次的数的其中一位的，所以全部找出并且恢复出整数即找到了！！
		>方案1：为上述原理的实现。
		>方案2： 最好的统计，显然不是对各个位出现1的个数进行直接的累加统计，因为最后还要对各个位分别的取余处理，所以如果是各个位直接的状态转换---：来1的个数分别为0,1,2,3次则分别是变为0,1,0,0,另一个状态整数相应位置为：0,0,1,0,即用两个整数的相应位置来纵向表示该位的状态--出现的1的次数对3的余数是多少，则所需要的空间就最低。状态位的所有取值00-10、来的位的所有取值0-1， 映射到的新状态位的取值，把这种映射转换为运算符号，转换为：状态整数=f(状态整数值,来的位的值) ， f确定了，那么运算之后，其中表示状态低位的整数值就是目标要寻找的只出现1次的数。
			>子问题：状态转换表、状态值映射表 得出 其中一个变量 映射出下一次的取值的逻辑运算方法：先用if-else层层结构来表示这个映射关系：最里层则是最简单的逻辑运算，然后层层消除---使用5种基本逻辑运算来消除一层一层的if-else: 转换为统一的运算表达式。。。中间画图：状态转换：00->01->10->00, 三对，当+0时，又是3对；然后逻辑分类映射。
	>复制带随机指针的链表:
		>方案1： 建立两个map的机制：新number-Node, 旧Node-number， 第一遍遍历，可以复制成功，且生成两个map, 然后第二次遍历的时候，旧里找出编号，而从新map找出Node来设置即可。
		>方案2：不需要额外的空间：随机这个的找到，用比照的方式，而利用原来的链表结构才能比照-临摹，所以新建的节点要放在原来的节点的后面，这样交替的出现新-旧节点，第一遍就是完成这个复制，然后第二遍就是random的旧的找到，而新的利用相似那么就在就的random的下一位。。。这样，random就赋值完成。然后第三编，next.next=next就可以拆分成两个链表了！！
	>单词拆分：
		>方案1： dp方式。f(i,j) = ∑f(i,k)*f(k+1,j), k=i,i+1,...j; f(j+1,j)=1 计算顺序：i,i; i,i+1;i,i+2;i,i+3;....这样，不断的从长度为1,逐渐计算长度+1，+2，，，，
	>环形链表 II:
		>方案1： 双指针法。类似跑道上两个速度不同的选手，必然会相遇的特点。利用两个指针，速度相差2倍比如，那么一直next下去，则最后会相遇：--，没有环那么null也可以判断。相遇，则证明了有环，此时保持不动。然后再从起点来指针，直到和这个不动的指针相遇，得出步数，然后不动的指针指向next，然后又从开始来一个指针，那么此时的步数可能增长1， 一直这么下去，就会突然步数降低了，此时则就是环的入口，这个入口找到了，且这个步数就是index!!!
		>方案2：利用双指针的速度特征。Floyd 算法。指针1：，指针2是指针1的2倍。则当1走到环的入口：F, 则2走了2F， 距离入口：F%C=h, 后1再走x后相遇：则x,2x+h=Nc+x,则x=Nc-h=c-h +(N-1)c, 显然，因为F=h+kc, 所以，第一次相遇在c-h, 那么环内相遇的指针再走h就到入口点，而从起点开始的指针则走F,而F=h+Nc，所以相遇后，一个指针从头走，另一个指针从相遇处同速走，下次相遇的节点就是入口节点。再次遍历就知道index了。
	>重排链表：
		>方案1：目标结果形式上，从n/2+1,到n节点顺序已经反过来，所以想到用栈可以反序；所以第二次遍历的时候，从n/2+1开始，向上取整的index开始，依次入栈，直到末尾，然后再从头遍历，从1开始，依次弹出元素，加到链表中。
		>方案2： 标记末尾指针法。一次遍历，先标记index=0元素，后到末尾p2时，直接指向index=0元素，然后将p2插入到p1下下个位置;然后将p1=下下个位置，从这里用新指针继续next,当道某个元素的next=p1时，则说明已经开始循环了，则将这个元素插入到p1的下下个位置，依次这样进行，直到出现p1.next.next===p1这样就表示已经成功了，将p1.next.next=null即可。
		>方案3：先反转n/2+1后开始的链表---通过三个连续指向三个节点的指针实现。或者通过递归实现。然后是：找到中间节点：用两个指针，2倍速比来找到。
	>二叉树的前序遍历:
		>方案1： 栈来实现。同样，中序、后序也可以。当前节点为根节点，先打印根节点，如果有左节点和右节点，则将右节点入栈，当前节点=左节点，...直到没有左节点，则弹出右节点作为当前节点。
		>方案2：莫里斯遍历。就是前驱节点指向当前节点，然后当前节点为下一个节点。这样下去，走到前驱节点时，则将前驱节点的指向删除。前驱节点：左孩子下的最右元素---一定是左分支下最后一个被遍历的。
			>参考：https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html
	>LRU缓存机制:
		>方案1： 两个Map：一个key-<v,timekey>, 一个timekey-<key>也可以。这样，从map里取值，后用值里的timekey删除map对应的kv值，然后更新timekey为新的时间戳+key，同时也插入第二个map。如果超过大小了，则从第二个移除首位的k-v对应找到第一个map的key来删除。
			>也可以实现：timekey变为numkey出现次数，按出现次数排序。也可以按照单位时间内的访问次数排序：numbytime_key, 这样需要在第一个map的值增加起止时间两个字段和次数字段。然后将比值+key作为排序的key在第二个map中。。每次访问的时候，都更新在第一map的值里的比值+key字段。自动调整，自己定时的检查和清理。
		>方案2： 使用队列。
		>方案3： 使用双向链表+hashMap.这样：从k-v可以找到Node,而此时不需要遍历链表，因为Node已经找到了，直接Node的前后相互指向就是删除，然后添加到头部位置即可；如果不存在,则新增，加到头部，如果size超过了，则删除尾部即可。时间复杂度O(1)
	>链表插入排序：
		>方案1： 记录一个排好序的尾指针，初值为head，对于下一个将排序的元素，先和尾指针比较，如果大于尾指针，则尾指针移动next, 开始下一个的插入；否则尾指针next指向next.next元素，而这个被删除的元素则开始从head开始逐个比较，找到处在cur.v<=Node.v<=cur.next.v的这个cur,然后插入到它后面即可。
	>排序链表：
		>方案1：最适合链表的就是归并排序：第一遍，先用3个指针两两排序，则链表中每两个是排好序的，第二遍，则连续2个和下2个归并排序，则也是n次遍历，共有连续4个是排好序的，从而logn次后都排好序了， 总共就是nlogn时间复杂度。
	>逆波兰表达式求值：
		>方案1： 使用栈的方式，逐个运算符轻松计算，一次遍历即可。
	>乘积最大子数组:
		>方案1： dp算法。 f(i) = max{f(i-1), ai, ai*a(ai-1)...,∏ak}
	>二叉搜索树迭代器:
		>方案1： 初始化则找到最左元素，下次就是取元素，然后寻找当前节点的后驱。记录根节点、当前元素即可。
		>方案2：使用栈。存所有左分支上的节点，后面就只需要一个个的弹出，如果有右节点，那么先将右节点及其左分支都入栈。。也是可以的。栈的最大深度就是树高。
	>第n高的薪水：
		>方案1： 基本思想：在连表够多，形成大表时候，利用列列之间比较筛选和统计，而往往可以得出想要的筛选结果。全表连接统计比较。所有的过滤都可以可视化为连接为最大表的对表的统计和筛选 出 那些行出来。
			>具体1：子查询。select distinct salary from employ e where (select count(salary) from employ where e.salary > salary) = n-1 
		>方案2： 连接条件：就是A表的一行是否和B表的一行连接的条件，可以列列相关，可以1=1,可以列=整数，等等各种丰富的关系。连接留下的，就是满足条件的行与行。
		>方案3： 函数:mysql8新增的：dense_rank()不跳号。select salary from ( select salary , dense_rank() over(order by salary asc) b from employ )a where a.b=n
		>使用建议：单表-连接-子查询/笛卡尔直积.。。自连接会产生精密的统计结果。
	>最大数:
		>方案1：两两比较，直接字符串化比较，从高位开始，直到某一位不一样而得出大小；否则一个数到末尾了，那么需要加长：AB,BA这样继续比较得出结果。
	>连续出现的数字：
		>方案1： 同一张表，行与行的连接，会产生精密的统计结果。
	>重复的DNA序列:
		>方案1： 动态规划算法: 前i个字符中目标字符串的个数f(i)：f(i) = f(i-1) + count{a(i-9)...ai 在a0-a(i-10)出现的次数} 
	>词频统计：
		>方案1：shell脚本中利用awk 语法命令。awk '{for(i=1;i<=NF;i++){a[$i]++}};end{for(w in a){print w, a[w];}}' word.txt
	>行列转换：
		>方案1： shell脚本： awk命令： awk '{for(i=1;i<NF;i++){if(i==1){a[i]=$i}else{a[i]=a[i]" "$i}}} end{for(w in a){print a[w]}}'
	>二叉树的右视图:	
		>方案1： 计算问题。前一行的start-end, 和最后一个非0的位置，决定了下一行的起点和终点---如果非0元素没有子也好处理。
	>岛屿数量:	
		>方案1：点属于同一个岛：将(i,j)放入一个set, 然后下一个点，如果四周在这个set,则都加入，否则新建set-加入四周，如果有一个点在两个set,或者它的四周分别在两个set,则两个set合并。这样，最终有多少个set就有多少个岛。
		>方案2： 岛的编号。相邻的陆地标记为同一个编号， 不相邻则编号+1， 如果发现一个陆地的相邻有2个编号，则这两个编号合并为一个编号，可以字符串拼接，或者加入一个set,那么，也是set的数量决定了岛的个数。
		