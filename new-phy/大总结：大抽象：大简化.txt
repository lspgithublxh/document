---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点
>介绍：概括
	>过程：十大过程；过程篇；
		>协议类：
			>RPC调用过程：
				>Dubbo调用过程：
					>服务端<->注册中心：注册、心跳
					>客户端<->注册中心：订阅、推送
					>客户端<->服务端：选调、限流+鉴权、降级+熔断
			>HTTPS一次过程：TLS一次过程：
			>TCP三次握手/四次挥手过程：
			>SQL解析处理过程：
		>算法类：各种系统使用；
			>垃圾回收算法：步骤；判断；动作；
				>G1算法：
				>CMS算法：
			>动态规划算法：确认有递推关系；建立递推关系；字符串相似度算法；
			>Diskt最短路径算法：KMP算法
			>缓存算法：
				>漏桶算法：
				>令牌桶算法：
				>滑动窗口算法：
			>一致性算法：
				>paxos算法：
				>zk选举算法：
				>raft算法：
			>加解密算法：
				>密钥交换算法：
				>用户认证算法：
				>对称加密算法：
				>信息摘要算法：
			>TCP初始化启动和拥塞控制算法：
		>方案类：
			>分布式事务：
				>二阶段提交方案：
				>事务消息方案：
			>分库分表：
			>数据同步：
			>缓存：
			>监控：
			>消息：
			>可靠性方案：所有意外情况/取值的事先考虑和处理;所有异常的兼容和都有处理分支；n个维度的意外特殊取值；n个条件的满足才能正常工作；m个条件满足则超长工作；
			>稳定性方案：单节点各项指标(使用率：cpu/mem/disk)随流量和各种故障因素的加入都变化很慢而不是变化幅度很大；
				>增加缓冲：避免超过处理极限；。小波动。
					>使用分布式缓存：
					>三级缓存：
				>增加检测和预备：大波动；
					>统计和扩容/缩容：统计单位时间内的变化量，估计变化时间；估计短时间内需要的总量，弥补差额；。
						>垂直扩容：
						>水平扩容：
					>检测故障和切换节点：心跳检测、指标检测；可用节点切换到对等服务/冗余节点、节点摘除；	
				>增加保护措施: 超大波动。在超过处理极限时；避免崩溃而完全丧失处理能力,舍弃无法顾及的；避免压力传递到后面的服务。
					>限流：
					>鉴权：
					>熔断和降级：
				---业务逻辑实现方面：代码方面：享元模式、消除冗余、消除重量级操作；
			>可用性方案：可用性是表象(已发生的统计；未发生的承诺：不可服务的时间的比例<)；稳定性是性质，可提高可用性；
			>高并发方案：高并发是表象(吞吐量)(网站/服务/单机吞吐量的提高的优化措施；瓶颈确定、替代方案)；高性能是性质，可提高并发度；
				>减少阻塞：
					>网络IO方面：异步非阻塞，主从多线程Reactor线程模型
					>磁盘IO方面：零拷贝、直接内存、页缓存
					>服务调用方面：超时断开；降级熔断；
				>减少同步：
					>CAS无锁操作：
				>减少串行：
					>异步：消息队列、事件监听+回调
					>多线程：线程池
				>减少临时才做：增加预备、减少性能损耗、代价耗费，增加使用效率
					>内存预分配：减少分配和回收的消耗；
				>减少专门去做：增加复用 
					>线程复用：
					>连接复用：tcp连接复用/jdbc连接复用/rpc调用复用(聚合服务)
					>数据复用：缓存；
				>减少流量压力：增加分流、增加冗余节点、无状态对等节点
					>集群部署：
			>高性能方案：
			>安全方案：加密套件
			>升级方案：流量切换(摘掉节点(配置))、流量排空、节点服务升级更换、节点重启、加入节点(配置)、服务检测、版本回滚
			>容量规划方案：
			>测试方案：
				>流量复制：
				>单机压测：
				>全链路压测：
		>选型类：各个选型判断逻辑流程；
			>数据存储方案选择：
			>数据索引方案选择：
			>数据缓存方案选择：
			>微服务RPC框架选择：
			>微服务治理方案选择：
			>微服务监控方案选择：
			>微服务管理方案选择：
	>组成：模型；架构；
		>领域模型：
		>概念结构模型：
		>JVM内存模型：
		>线程模型：
		>网络IO模型：
		>java并发模型：
	>模式：
		>23种设计模式：
		>8种架构模式：
	>策略：
		>缓存过期策略：redis
		>负载均衡策略：nginx
		>服务调用策略：client
		>jvm调优策略：
		>sql优化策略：
		>故障恢复策略：failover, failsafe,failback,failfast
	>系统：中间件
		>redis:
		>mysql:
		>dubbo: x个过程+y个策略+z个算法
	>源码：
		>java:
		>spring:
		>spring-boot:
		>dubbo:
		>netty:
		>sharding-jdbc:
		>mybatis:
		>jdbc:
		>tomcat:
		>rocketmq: