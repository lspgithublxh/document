---------读书战略：自顶向下，从应用层到底层细节。先熟悉的常用的，后底层的不常用的。精读好书---《深入理解系列》
--------es的处理思想都对应有 相应的“某种举动 及其导致 的问题”
>需求背景-痛点陈述：现实开发中遇到了什么痛点导致XXX的开发？  
>那么痛点的原因、产生的条件：分析是什么环境、什么动作 什么效果什么目的 等精准形容词的事实描述 导致了痛点的必然发生，难以避免？。条件-痛点。原因-结果。
>则可以消除痛点的最简单的精准事实陈述是什么：修改“条件-痛点”陈述的哪一部分就可以导致没有痛点产生。 要做的根本事情是什么：
>那么新陈述表明的解决动作是什么：
>新情况的新痛点是什么：新举动、新环境会产生的新痛点描述出来， 继续上述4条操作。
>学习要有战略和格局：过于零散、孤立、末支、叶子的知识点就没必要化太多时间，懂得放弃。聚焦在根节点、枢纽节点、产生分支的节点、主干知识点、枢纽知识点、关联到很多知识点的知识点上。
 >对于主干知识点：要有全新的认识视角和进行精细的描述，大量的提问和好奇和进行必要的实验以获取支撑观点/导出观点的数据。
 >规范是工程最独特的特征.
 >慢慢读：
>一种新技术的学习：
 >它面对的情况和问题、它的世界观、它的方案、它的方案验证/论证/能处理的解决的所有情况及能成功处理的理由/功能边界
  >所有的软件：都可以看作是向上封装一层接口，根据自己的世界观封装底层而向上/对外提供统一的(统一的更简单的更直观的更业务的更少底层信息的)接口，底层包含一系列的第三方的插件/构件/组件；内部则去做兼容和调用(对底层)(对上层则做逻辑分解和底层实现)。
>知识混乱就是因为没有组织：
	>组织就是关键字树：几个单词就是每层上的每个节点的内容；
	>组织也可以看作逻辑树：有逻辑关系，逻辑顺序，逻辑联系的关键字的层层集合。层层囊括更精细的范围，层层划分范围。
>推进理解的属性发展拓展、问题延展：重要方式；
>什么是架构：架构也是从抽象到具体的考虑和描述；树形延展开来，可以写满非常大的黑板和巨大的脑图！！sharding-jdbc,dubbo,spring都可以这样方式来展现它的架构！！它的抽象到具体的考虑---本身才是架构！！！而不是什么模块、模式之类！！
>抽象设计：则某一层就不管上一层的含义和下一层的含义，即更抽象的含义或者更具体的含义；而是实现本层的含义；完成本层的含义指定的功能；。如网络协议的架构设计；	
>面向设计来理解，面向架构设计来理解，面向架构问题一层一层来理解它：面向设计来理解，所以按照面向对象设计的方式，看其中的对象、行为属性、流程环节逻辑。	
>找不到知识/描述 所对应的问题 ， 那么看书将没有条理纲领，变得零散琐碎没有组织。	
>不是按概念方式组织，而是按架构、问题方式来组织 笔记，书本内容。架构顺序，问题层次顺序。	
>架构不是设计出来的，也不是演进出来的(甚至不是迭代出来的--尽可能避免迭代)：而是问出来的。	
>每个方法方案都从属于一颗树，所以找到一个方法巧妙方法仅仅是第一步--找到从属的层次树 有更大的价值；(无论是谁想到的方法/概念，都要这样更进一步)
>解决问题的办法就是提出问题：类似递归和动态规划；。。权衡就是线性规划；	优势劣势在一定场景下也是劣势优势；
>一个词，到一句话，两句话，一段话，一篇文章；这个就是抽象总结，层次总结；越简洁，站得越高
--在网络、搜索引擎、推荐系统 三方面的专家；作为系统方面的独特优势/拔高优势；(网络-查询-推荐)
	
----有且只有响应，通信端才知道连接是否成功；。浏览器自动扩展。
----维持连接，并发连接，都是软件的实现，物理上看都是一条出口；从响应就是维护连接的角度看，不存在需要维护什么连接，维护就是维护连接数据而已；只要发送响应，连接就活了；在网络端口出口，可以连续发送不同目的地的响应报文，这就是并行；所以完全可以用队列来接收请求数据包；而用队列缓存发送响应数据包；多核使用起来，来并行大批量的发送和接收；不存在要维护和持续占用“端口”网络出口这种概念---完全没必要，用完即走 就可；	
	>或者不存在连接这个概念：所有的事情就是接收数据包和发送数据包(接送/发送缓冲区)。(连接 是 软件臆造出来的概念，不要和物理对应；和物理对应就会束缚思想，就会很多事情理解不了不知道原因)
	>连接的状态转移图；
	>应用的固定端口：实际上是建立新TCP连接的请求的处理的端口，请求到达这个端口--后面建立一个独立的TCP连接---来负责和客户端通信-交互数据；
----UML：为什么类继承关系图---因为这就是具体到一般的概念对象抽象过程。自上而下是能力顺序，能力组合；	
----说话和介绍：语速不要快，快就是掩盖问题，掩盖过程步骤；直接导致别人认为思路不清晰，表达不清楚，东拉西扯；也不利于自己思路的成长和扩展和自己主动发现问题，且必然导致不简洁--废话很多；
	>介绍需要先纲目后具体：抽象到具体；而不是张口就是罗列枚举---内容没有结构--全是线性结构；
	>描述更精简：一个字一个词，一句话，两句话，一段话；
----大事和吏治：大事 就像西天取经；吏治就像管理四人；


--计划：nginx/tomcat-->计算机系统-->架构-->自己的系统架构方案:专题研究、大提问、大总结。大简化/模型图化；
>一个进程看作一个消息，代码计划/任务计划；；都是异步隔离；	
	>程序启动点/执行点：可以多个，看作是并行的；(一个机器上，多个程序文件里)；可以留下执行点/新增执行点；可以删除执行点/减少执行点；
	>函数式编程为什么好：因为每个精细环节清晰描述确定了下来；使得充分配置和指明动作；
	>如何看待对象的方法：所有的对象都是被动的；主动的只有cpu/并行点；
	>程序的执行要想象为人在执行；多线程则是交接执行权给其他人执行；
	
----未知和迷惑的地方：痛点	；
----关键和核心的地方：要点

--混乱的答案，宁可不说；只回答真正掌握的；。没有逻辑，因为没有进行抽象；没有找到所在的流程环节、模型中的位置

--大总结：含义包括：重新 深刻理解：
--通用的建模架构能力+Flink深度强化学习的推荐系统。。。。而不是做简单的业务逻辑开发；用深度强化学习来做应用/解决实际问题(用户的识别问题和抉择问题)；用抽象建模架构出逻辑完整的方案(工具方案/服务方案)；
--一体两翼的发展模型：底座：增强操作系统、网络、搜索、推荐能力； 两翼：普通项目：则架构建模；特殊项目：则深度强化学习；。。四大基础+两大实践(应用/使用)。。基础：是为了解决自己的问题；实践：为了解决别人的问题(用户的问题/大众)；

>介绍：概括
	>过程：十大过程；过程篇；
		>协议类：
			>RPC调用过程：
				>Dubbo调用过程：
					>服务端<->注册中心：注册、心跳
					>客户端<->注册中心：订阅、推送
					>客户端<->服务端：选调、限流+鉴权、降级+熔断
			>HTTPS一次过程：TLS一次过程：
			>TCP三次握手/四次挥手过程：
			>SQL解析处理过程：
			>DNS解析过程：用户程序-->本地域名服务器-->根服务器(回答.com找谁)-->顶级域名服务器(回答163.com找谁)-->权威域名服务器。共8个UDP报文。三类顶级域名(国家cn、通用com、基础结构arpa)。。逻辑根域名服务器13台：a.root-servers.net 实际中国17台，全球937台；副本；
		>算法类：各种系统使用；
			>负载均衡算法：静态、动态。实现：基于反向代理、NAT、DNS域名解析；
				>轮询：
				>最小连接：服务端实时当前连接数
				>源IPhash: 同一个ip的走同一个服务器
				>随机：
			>垃圾回收算法：步骤；判断；动作；。。复制；标记-整理；标记-清除；
				>G1算法：
				>CMS算法：
					>目标：降低每次垃圾回收的时间；最小影响可用性；
					>阶段：根标记-->并发标记-->并发预处理-->重新标记-->并发清除-->重置。
						>过程：确定gc root直接关联的对象(new/old)-->出发所有可达的对象-->(重新标记的预备工作)三大对象的标记(新晋升/新分配/新修改),并发进行一次MinorGC, 老年代分块(之前标记脏，现阶段扫描标记可达)-->并发清除-->重置，清除内部状态；
					>触发时机：老年代使用率：92%
					>备案：老年代设置太高，启动SerialOld
					>内存碎片整理：1.默认开启；FullGC前STW；2.配置k次不压缩的FullGC后执行1次压缩的FullGC(即FullGC后)
				>复制算法：存活对象不多，可以直接复制出, 自动压缩；
					>判断存活：可达性分析。(java没使用对象计数法)
			>动态规划算法：确认有递推关系；建立递推关系；字符串相似度算法；
			>Diskt最短路径算法：KMP算法
			>限流算法：
				>计数器算法：无需额外线程；一个请求累加1，达到N则限流；和上次更新时间的差达到了T,则清空计数器,从0开始。问题在：清空，意味不再计算刚才涌入的数据(导致最高短时间deltaT涌入2N而没被限住)；
				>漏桶算法：
					>不用额外线程：每个请求到，如果自旋等待线程数过限，则直接失败返回；否则计算上个请求通过的时间，没到deltaT则等待余时，到了则竞争取锁，成功则开始执行，失败则自旋，且自增等待线程数，等待时间超过限定则失败返回。从而几乎每个请求都会等，且等n个deltaT。
					>用额外线程：每个请求到，先入队等待,队列满则退出，等待时间超时也退出返回；独立线程请求队列首元素，唤醒它；唤醒之后，等待deltaT。。队列容量=容忍在队列中的等待时间*1/deltaT
				>令牌桶算法：无需额外线程：需一个令牌量计数器；每个请求到，令牌量为0则返回，否则令牌量减1；当前时间距离上个请求的时间的差*1/deltaT 为增量，加到令牌量计数器里；总量达到N则为上限；。令牌就是缓冲突发的大量请求而都能处理；
				>滑动窗口算法：无需额外线程；k个累加器,1个当前累加器指针,总量达到N则限流；和上次更新时间的差达到了T/k,则更新当前累加器指针为下一个累加器；要考虑刚才的计数，不是清空为0，而只清空最近T时间内的最早T/k内的统计量(从而被忽略的时间内的量对计算的时间内的量相比，因为忽略的比例很低，所以更准确)，则实际最大2N涌入而没有被统计出来，需要分布的时长>= T*(k-1)/k + deltaT ,如果时间更短，则会被统计出来；。。从而瞬间N的两个突发至少要间隔T, 才不会被发现；
			>一致性算法：
				>paxos算法：
				>zk选举算法：
				>raft算法：
			>加解密算法：
				>密钥交换算法：
				>用户认证算法：
				>对称加密算法：
				>信息摘要算法：
			>TCP初始化启动和拥塞控制算法：
		>方案类：
			>分布式事务：
				>二阶段提交方案：
				>事务消息方案：
			>分库分表：
			>数据同步：
			>缓存：
			>监控：
			>消息：
			>可靠性方案：所有意外情况/取值的事先考虑和处理;所有异常的兼容和都有处理分支；n个维度的意外特殊取值；n个条件的满足才能正常工作；m个条件满足则超长工作；
				>可靠性-数据方面：因缓存在内存未刷磁盘导致丢失的比例；
			>稳定性方案：单节点各项指标(使用率：cpu/mem/disk)随流量和各种故障因素的加入都变化很慢而不是变化幅度很大；
				>增加缓冲：避免超过处理极限；。小波动。
					>使用分布式缓存：
					>三级缓存：
				>增加检测和预备：大波动；
					>统计和扩容/缩容：统计单位时间内的变化量，估计变化时间；估计短时间内需要的总量，弥补差额；。
						>垂直扩容：
						>水平扩容：
					>检测故障和切换节点：心跳检测、指标检测；可用节点切换到对等服务/冗余节点、节点摘除；
						>消除单点故障：keepalived虚ip方案；冗余+心跳+切换 方案；
				>增加保护措施: 超大波动。在超过处理极限时；避免崩溃而完全丧失处理能力,舍弃无法顾及的；避免压力传递到后面的服务。
					>限流：
					>鉴权：
					>熔断和降级：
					>灾备：同城灾备/异地灾备。5种集群：主备/主从/多主/对等集群/非对等集群
						>多机热备：运行 keepalived 的节点 被 设置虚ip，有仅一个被设置，其他未设置；节点故障时立刻其他节点设置虚ip 实现故障转移。keepalived(心跳+选主策略)
						>一主多备：
						>冗余：双电源、双网卡、多机房；
						>隔离：物理隔离
				---业务逻辑实现方面：代码方面：享元模式、消除冗余、消除重量级操作；(通过codereview,单机压测，全链路压测发现问题: 内存泄露、死循环、死锁、线程文件使用)
			>可用性方案：可用性是表象(已发生的统计；未发生的承诺：不可服务的时间的比例<)；稳定性是性质，可提高可用性；
			>高并发方案：高并发是表象(吞吐量)(网站/服务/单机吞吐量的提高的优化措施；瓶颈确定、替代方案)；高性能是性质，可提高并发度；
				>减少阻塞：
					>网络IO方面：异步非阻塞，主从多线程Reactor线程模型
					>磁盘IO方面：零拷贝、直接内存、页缓存
					>服务调用方面：超时断开/重试-->熔断降级；(依次更重,熔断后返回降级结果)
				>减少同步：
					>CAS无锁操作：
				>减少串行：增加并行
					>异步：消息队列、事件监听+回调
					>多线程：线程池
					>请求级并行：多实例部署
				>减少临时才做：增加预备、减少性能损耗、代价耗费，增加使用效率
					>内存预分配：减少分配和回收的消耗；
				>减少专门去做：增加复用 
					>线程复用：
					>连接复用：tcp连接复用/jdbc连接复用/rpc调用复用(聚合服务)
					>数据复用：缓存；
				>减少流量压力：增加分流、增加冗余节点、无状态对等节点
					>集群部署：
			>高性能方案：
			>安全方案：加密套件
			>升级方案：流量切换(摘掉节点(配置))、流量排空、节点服务升级更换、节点重启、加入节点(配置)、服务检测、版本回滚；灰度升级；
			>容量规划方案：
			>测试方案：
				>流量复制：
				>单机压测：
				>全链路压测：
			>灾备方案：	
			>优化方案：因势利导；看情况而针对开药；望闻问切(而不是稀里糊涂不知病因而直接上猛药)；
				>jvm调优：
				>mysql优化：
					>痛点：瓶颈；
						>扫描行数太多：分库分表；索引没使用到/索引不好：索引优化(匹配查询)；
						>查询结果太多：利用覆盖索引；查询缓存开启；ICP/MRR优化；页缓冲池预热；业务方面：分页查询、先不排序、减少连表；
		>选型类：各个选型判断逻辑流程；
			>数据存储方案选择：
			>数据索引方案选择：
			>数据缓存方案选择：
			>微服务RPC框架选择：
			>微服务治理方案选择：
			>微服务监控方案选择：
			>微服务管理方案选择：
		>对象变化类：变化过程
			>锁膨胀过程：
				>偏向锁-->轻量级锁：
				>轻量级锁-->重量级锁：
			>锁粗化和锁消除过程：
			>申请锁和释放锁过程：	
		>周期阶段类：	
			>类的生命周期：7 加载、验证、准备、解析、初始化、使用、卸载
			>对象的生命周期：7 新建、使用、不可视、不可达、可收集、终结、释放
			>线程生命周期：6 new->running->blocked-->waiting-->time_waiting->terminated
	>组成：模型；架构；。基于模型谈过程，则过程显得清晰明白简洁；
		>领域模型：
		>概念结构模型：
		>JVM内存模型：
		>线程模型：
			>线程池：
				>数据结构：1 queue + n worker......status
				>状态：running->shutdown->stop->tinying->terminated
			>用户线程和内核线程的映射：一对一，多对一，多对多
			>调度方式：java线程：强占式调度---由系统分配执行时间	
		>网络IO模型：阻塞/非阻塞(手动api查结果)，同步/异步(回调通知结果)：
			
		>java并发模型：
		>锁：锁的代码。01->00->10。。线程锁：资源是代码；访问者是线程；访问者获取到锁才能访问对应的资源；
			>entryList: 阻塞队列
			>waitSet:等待队列
			>count: 重入次数
			>owner: 锁拥有者
			>是否可中断：
			>是否能超时：
			>并发场景：1.多个线程，取锁释放，交叉并行；2.多个线程，取锁释放，但先后串行，之间甚至有间隔deltaT;3.一个线程，先后k次取锁释放；
				>针对设计：场景1则重量级锁，处理竞争；场景2无需阻塞则轻量级锁避免上下文切换开销；场景3无需切换则初始化一次获取锁避免反复获取锁释放锁的CAS开销(判断owner是自己)；
				>竞争处理：场景1则到entrylist阻塞；场景2先立即失败重试即自旋k次后面失败则升级锁即修改锁状态+新建一个锁对象owner设置为占锁线程并将当前线程加入entrylist阻塞；场景3先立即升级锁更新锁状态创建锁记录放到占锁线程里,竞争线程开始自旋k次尝试；
			>锁的内存语义：锁的获取和释放；数据的加载和保存；
		>事务锁：资源是记录；访问者是事务；访问者获取锁的并发控制策略(只能串行：独占锁；可以并行：共享锁);	(当资源是一条记录时：行锁；一个范围但不包括里面已有记录时：间隙锁；一个范围且包括里面已有记录时：next-key锁)
			>资源：
			>访问者：
			>访问者获取锁的并发控制策略：
			--案例：select .. for update X锁；select ... lock in share mode; S锁
			>使用事务锁产生的问题：
				>死锁问题：解法：超时机制+等待图
		>事务：操作记录的过程：1.加锁；2.看隔离级别；0.备份到日志(undo)；3.操作记录/提交成功；4.防丢到日志(redo);5.逻辑备份(binlog)
			>基本属性：
				>原子性：1.事务的所有操作 要么都是成功的，要么都是失败的；(不能成功部分，而失败部分--尽管失败的这部分回滚且成功了)(保证整体一致，全局一致)
				>隔离性：1.事务A在操作资源R的时候B不能操作B必须阻塞等待
					>隔离级别：
				>一致性：1.做之前的数据 和 做了但失败而回滚后的数据 一致(单条记录的一致)；2.一致变化：原子式的 事务的每个操作 都是成功的或者都是失败的；(不能成功部分，而失败部分--尽管失败的这部分回滚且成功了)
				>永久性：1.t时刻成功的事务，所做的修改即便立即崩溃 服务器启动后还是事务成功后的数据(版本)；
			>使用事务也会产生的隔离性问题：
				>脏读：
				>不可重复读：
				>丢失更新：
				>幻读：
			>使用锁的画面：开启一个事务 到 提交/回滚一个事务 期间，可能使用了多个锁(每个锁什么类型跟语句有关)(加了独占锁可以再加共享锁，加了共享锁也可以再加共享锁)；
		>索引: B+树索引、全文索引、哈希索引
			>数据结构和算法： 
				>B+树： (二叉查找树：左子<中<右子)(平衡二叉树：子树高度差<=1; 从所有叶节点向上到根 得到n条路径，每条路径每个节点标记已走步数；所有路径相交处的已走步数差<=1)
					>叶子节点：主键+数据页；数据行所在的页-完整行记录；页读取到内存，再从内存页中查找；。互相指向，前后首尾；。。辅助索引节点：(key1,keys,若干个主键值(所以需要回表，但不用维护到数据页的偏移量))；(rows:预估行数)
					>构建过程：分裂/合并(多时少时都可能和兄弟节点合并,减少消耗大的拆分) 
					>索引页中有叶子数据：是(叶子节点中有索引数据) ；高扇出：是(且指针k,扇出k+1)
					>树高和耗时：16KB页，14Bbigint+pointer, 每页加载耗时10ms
			>建立时机：选择性>0.5；记录总数>2000；	
			>优化器选择哪个索引：
				>走联合索引：count(*)统计时；(a,b,c)用a,b列查询而c排序 且只查a,b,c,primarykey时(查全部列则不会--因为回聚集索引会导致离散读磁盘--代价大)；
		>mysql日志：
			>undo:
				>组织结构：格式
				>单条内容：含义。逻辑日志(但非SQL)，每行记录；
				>写入方式：随机写；数据库内，共享表空间中，非独立文件；
				>写入时机：事务执行中(因为insert/update的undo log行记录不同)；事务提交时将undo log行记录放入链表中(purge线程判断是否删除,删除后就减少了链表长度)
				>读取时机：使用场景/用途；mvcc;回滚/失败;
			>redo:
				>单条含义：每页的物理更改情况；
				>单条结构：(innodb)头部(redo log type + space + page no)12B + 主体(若干个事务的变更内容，字节长度为LSN) + 尾块()8B： 一个重做日志块(512B)大小同磁盘扇区大小，从而无需doublewrite
					>redo log file: 前2KB: log file header + cp1 + null + cp2; 后面则是 日志块log block1 ,lock block2.... 。两个cp 交替写入(提高可靠性)(用于恢复操作中)；
				>写入方式：顺序写。先写入重做日志缓冲buffer 后 调用fsync强刷到磁盘(事务提交时)；重做日志文件中。
				>写入时机： 事务进行中不断的写入(从而T1T2T1T3分块分布)(按事务开启顺序而非提交顺序)
				>读取时机： 数据库恢复(重启)时，读取redo各个事务块应用到对应的page上(比较了LSN,从checkpoint LSN开始应用日志块)；
			>binlog:
				>单条内容：逻辑日志；SQL
				>写入时机：事务提交后一次写入(按事务提交顺序而非开启顺序)
				>读取时机： 主从复制；POINT-IN-TIME恢复；
		>mysql页：内存中的页(存储到磁盘上也存有LSN)
			>首部：FIL_PAGE_LEN 值为所有事务在该页上引起的变更的内容描述的字节总长(对应redo中该页的事务日志块记录的LSN)
		>存储引擎：
			>是否支持事务：
			>锁粒度：
			>支持索引类型：
			>单表数据：
			>sql性能：
	>模式：
		>23种设计模式：
		>8种架构模式：
	>策略：
		>缓存过期策略：redis
			>LRU:
		>负载均衡策略：nginx
		>服务调用策略：client
		>jvm调优策略：
		>sql优化策略：
		>故障恢复策略：failover, failsafe,failback,failfast
		>MVCC: 是一种事务访问多个版本的记录的策略(访问哪一个)，入参一个：隔离级别；访问动作：读、写；
	>系统：中间件
		>redis: 数据怎么组织、存储、查询、变更；是否支持索引、是否支持事务；统一架构模型；
		>mysql:
		>dubbo: x个过程+y个策略+z个算法
	>应用问题处理：
		>缓存问题：4类
		>CMS GC问题：
	>源码：
		>java:
			>ConcurrentHashMap: 数据结构+算法 
			>ThreadPoolExecutor: 数据结构+算法 
			>AbstractQueueSynchronizer: 数据结构+算法 
			>ReentryLock:
			>ArrayBlockingQueue:
			>LinkedHashMap:
			>Selector:
		>spring: 各个过程
			>刷新的过程：
		>spring-boot:各个过程 
			>启动的过程：
		>dubbo: 各个过程 
			>发送的过程：
			>接收的过程：
		>netty:
			>发送的过程：
		>sharding-jdbc:
			>分库分表流程：sql重写+数据源的确定
			>主备切换流程：sql重写+数据源的确定
		>mybatis:
			>从DAO开始的执行过程：
		>jdbc:
		>tomcat:
		>rocketmq: