1.问题描述：
	>预知：
		>什么需要索引？一条记录？
			>对文档创建索引和更新索引
			>对JSON对象创建和更新索引
			
		>索引：
		      >基本观点：
			>索引是一个树形对象，索引是对一列数据的索引。。索引可以看作是对一列数据的分类--多层分类。
			>新增一个记录，可以根据索引树而分类到某层索引节点下，更新这个索引树（自动更新了这个索引树）
			>给定一个具体索引列的数据、或者模糊数据，可以从索引树下确定要查找的范围，将该范围下的记录返回给客户。
		      >多路索引：
		      >反向索引：

		>查询索引，查询记录
		>搜索：
			>查询DSL：表达查询和过滤器
			


	>基本概念：
		>搜索平台：
		>全文搜索服务器：索引、搜索、排序、过滤文档的引擎
			>对服务器的操作：
				>RESTFUL API：PUT\DELETE\GET\POST\HEAD（检查文档存在不存在）
			>优点：索引比数据库引擎对表的列索引简单
			>数据结构：
				>索引：像书的索引页，可以用此找到类型。像数据库
				>类型：像类，一个类，有许多具体的实例，每个实例就是一个文档。像表
				>文档：像对象，一个对象有许多属性，每个属性就是一个字段。像行
				>字段：像属性，属性值可以字符串数字数组对象。像列

			>文档搜索方式：
				>id方式：GET /索引/类型/文档ID
				>_search方式：
					>直接的：GET /索引/类型/_search
					>插叙字符串：GET /_index/_type/_search?q=key:word    其中_index和_type是可以多个的也可以是模糊的*,
					>领域特定语言DSL：
							GET /_index/_type/_search
							{"query":{"match":{field:word}}}
					>全文搜索：
						GET /_index/_type/_search
						{"query":{"match":{field:words}}}
						即有多个word，搜素引擎会按照相关性排序搜索到的结果，最相关的分值_score最高，排在最前面。相关性：就是匹配度。
						对于文段型很长内容的匹配效果必然更好----因为它自己就是索引引擎。而一般数据库是不会对一个超长文段进行建立索引（B-TREE多路索引）的----而如果用like或者正则将会非常慢。
					 段落搜索：match_phase
					 汇总统计：单词频率统计（似管道聚合）
			>数据存储：
				>分片：存储的是索引的部分类的文档（一个分片，是一个装着文档的数据容器|搜索引擎）
					一个节点上有多个分片，分片可以在节点之间迁移分配。
					>主分片：每个文档都属于某个主分片
					>从分片：是主分片的备份、冗余、副本，一个主分片可以有多个从分片
					>主节点挂了，新的主节点选出来之后其上的从分片会被提升为主分片。

			>文档更新：
				>文档本身不可变，更新就是替换。整个替换。重新索引，版本提升。
		>全文搜索引擎：基于分词、分段：同义词；
		>课题问题：
			>可以索引的对象：单个JSON对象
			>索引的内容：会是JSON对象的每个最终键值：即叶子键值。而完全不用指定对某个属性进行索引---像数据库的表的列一样。


	>实现功能：分词、同义词、词干查询
	>windows安装：对于Head,需要配置elasticsearch.yml文件，加配置行：
			>Head本质上还是一个nodejs工程
			  安装：npm install -g cnpm --registry=https://registry.npm.taobao.org
				npm install -g grunt-cli --registry=https://registry.npm.taobao.org
			>CURL:添加记录---给其中字段添加索引的办法：
			      >新增一个索引：名称和类型可以任意
				curl -XPUT http://localhost:9200/movies/movie/1  -d  '{"title":"The Godfather","director":"Francis Ford Coppola","year":1972}'

			>kibana:插入文档和更新文档和删除文档：
				PUT /movies/movie/1
				{
 				 "title":"The Godfather",
  				"director":"Francis Ford Coppola",
  				"year":1972,
  				"genres":["Crime","Drama"]
				}

				GET /movies/movie/1

			>DSL查询：POST _search
				>query JSON对象结构：
					{
 					 "query":{
 					   "query_string": {
   					  	 "query": "a",
   					   	 "fields": ["director"]
  					  	}
 					     }
					}
					其中query键里的query键是要从每条记录的每个键值中搜索的单词
							fields则指定了搜索的键的范围（相当于指定了数据库表的列）
				
					含有过滤器的查询结构：
					{
						"query":{
							"filtered":{
								"query":{
									"query_string":{
										"query":{
											}
										}
									}
								}
								"filter":{
									"term":{
									}
							}
							}
					}
					query_string里面相当于键的值里contain单词
					而filter里面的term里面相当于某个键的值必须is equal是的单词
					>分数查询：
						POST _search
						{
						  "query":{
						    "constant_score":{
						    "filter":{
						      "term":{"year":1962}
						    }
						    }
						  }
						}

					附加：
						>query里面的单词可以是多个，以空格分开，表示满足其中之一
	>java连接：端口：9300。其他是9200
	>与hadoop、spark:	

1.参考资料：
1.https://github.com/mobz/elasticsearch-head（head的安装）
2.http://www.cnblogs.com/ljhdo/p/4887557.html（windows下安装和运行，基本过程）
3.http://blog.csdn.net/mergerly/article/details/53412417（nodejs依赖的安装）
4.https://www.elastic.co/downloads/elasticsearch(elasticsearch官方网站)
5.http://www.elasticsearch.org/guide/reference/query-dsl/（查询定义语言）
6.http://www.yiibai.com/elasticsearch/elasticsearch-getting-start.html（简易教程--索引和搜索操作）
7.http://blog.csdn.net/jia18703423204/article/details/47040977（curl的安装和使用）
8.http://www.cnblogs.com/zlslch/p/6619089.html（性能比较）
9.http://blog.csdn.net/napoay/article/details/53581027（java api）
10.http://hao.jobbole.com/kibana/（kibana添加索引）
11.http://www.cnblogs.com/Wolfmanlq/p/5984494.html（非常完善的教程式资料）
12.https://elasticsearch.cn/article/102(聚合查询,group by多个)
13.https://elasticsearch.cn/explore/category-12（elasticsearch招聘信息）
14.https://www.elastic.co/products/elasticsearch（官网资料--java查询资料，其他语言如python查询资料也有）