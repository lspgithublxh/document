1.问题
	>服务端socket监听，到底做了什么？能够响应所有到它端口的连接？
	>客户端socket连接时，发送了什么？使得连接建立了，而在自己的专门端口监听唯一的另一ip:port的数据？
	>tcp层次及其以下的访问控制：到底包含哪些？控制了哪些？
	>客户端socket连接时，能不能直接连接到另一个socket？或者响应另一个socket发送来的连接？


	>网络通信基本问题：
		>a.网络应用程序的标记：网络层的ip标记主机，传输层的协议 + 端口标记应用程序。
			>ip确定主机，之后再用协议+ 端口可以确定主机上的应用程序。 而本地，直接用PID确定一个应用程序。
				>从观察者角度看，只要指一个网络应用程序，必须指它所在的ip 协议 端口
		>b.网络应用程序的编程接口：socket (即Unix BSD的套接字)
			>socket定义来源：unix：
				>unix观点哲学：计算机上的一切程序对象（数据和处理程序的整体，或者仅仅数据本身、仅仅程序本身当作文件来存储、访问、读写）的操作都可以用模式：打开-读写-关闭  来表示。即一切程序访问控制操作可以当作是对文件的访问控制操作。
						>程序对象、数据结构多种，就是文件的多种。
				>socket确定性描述：
					>协议域/协议族：domain如AF_INET  ，决定socket地址类型， AF_INET是 32ip + 16port
					>类型：如SOCK_STREAM描述包的特点。	
					>协议：IPPROTO_TCP:即TCP传输协议
				>使用socket来通信之前：
					>绑定地址域的ip + port。手动。服务端要手动，而客户端可以自动。
					>转换主机字节序为网络字节序：网络字节序：4字节数据从低到高位发送传输。主机字节序：可能4字节数据：高位反而放在低地址。
					>被动socket和主动socket:
						>被动socket：accept()之后可以返回一个新的socket---这个是内核创建的。
				>通信建立的三次握手的触发：connect()\accept()函数调用：
					>connect()被调用：则发送SYN J 并阻塞
					>accept()被调用：则在收到SYN J之后返回SYN K 和J+1 并继续阻塞
					>connect()调用端收到J+1退出阻塞，返回SYN K+1
					>accept()调用端收到K+1退出阻塞，返回内核创建的新socket,且该socket的localport都是服务端监听的端口本身：即与客户端无关。说明本地多个socket可以绑定同一个端口作为localport。
				>通信销毁的四次握手的触发：两端的close()函数调用：
					>一端close()调用：则发送FIN M ,另一端返回ACK M+1
					>另一端调用close():则发送FIN N, 一端返回ACK N+1
				
				>