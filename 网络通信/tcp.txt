1.问题：tcpdump wireshark
	>tcp连接的三次握手：
		>服务端启动：
		>a.客户端发起连接，包里带上传输数据时第一个数据的序号x，同步码SYN为1
		>b.服务端收到连接，解析包，返回包里带上客户端的首数据序号+1，和自己的首数据序号y,同步码SYN为1
		>c.客户端收到连接，返回包，包里带上服务端的首数据序号y+1,同步码SYN为1。并且向上确定已经建立连接。
		>服务端接收到连接，解析包，向上确定已经建立连接。
		
	>tcp链接：一次连接的建立，就是经过syn, ack 之后，服务器内存中建立了tcp_socket结构（ip,mac,缓冲区，各种控制参数）（也是一个tcp链接所产生的所有数据结构，几kb）。。而服务器发送完数据后，tcp_socket结构不销毁就是长链接，销毁了就是短链接。
		>tcp_socket结构的意义是：当每次有网络数据包到来，并且解析到tcp层次时，根据包中的port而定位到那个tcp_socket结构，从而找到服务端的对应socket而将包数据发送给对应的socket.
		>对应tcp_socket有tcb:专门描述当前socket的tcp状态信息等的。
	>tcp/ip协议设计目的：快传、有序、不丢失。（数据包）
		>快传：
		>有序：包有序号
		>不丢失：发送端发送一个数据后，会等待接收端返回的ack数据，没收到ack会重传（即数据还保留着）。

		>附加：
		  >流量控制：发送端的最大字节数和接收端的接收窗口匹配---发送端发送之前知道。这也是建立链接的必要性。
		  >阻塞控制：发送端调节发送速度，来避免网络阻塞。。根据返回ack的时间等判断阻塞程度。

	>从socket\tcp向下构造出数据包的过程：
		>
		>tcp层创建tcp段：
		>ip层在tcp段中增加ip段并且执行ip路由：ip路由即找到下一跳的ip地址。
		>链路层通过地址解析协议获取下一跳ip地址对应的mac地址并往包中加链路头：增加链路头的包可以被wireshark程序捕获。
		>驱动程序NIC复制数据包到自己的内存中并发送到网络上：由于遵守以太网标准，会在数据包中加帧间隙\同步码（分隔包）\crc校验和。


	>从网络端口接收数据包开始到tcp层的过程：
		>
		>NIC检验crc检验和看数据包是否有效：
		>NIC发送数据包到主机缓存区并产生中断：系统启动时已经注册了中断号和处理程序，cpu会调用相应的中断函数来处理。中断函数结束后，有软中断处理函数--即软件中断处理函数：把接收到的数据包一个一个地发送到上层。
		>链路层检测包是否有效并判断以太网类型再去掉数据包的链路头：向上输出
		>IP层检测包是否有效并ip路由判断是自己处理还是转发给其他系统：即下一跳系统，如果是本系统处理，那么判断ip header中的原型值来合适方式去掉数据包的ip头，再向上输出结果数据包
		>tcp层检测包是否有效并提取出tcb信息并从tcb中提出<sip,sport,tip,tport>信息：根据tcp链接查询hash table而查询出对应的tcp_socket，看匹配到哪个socket，从而把数据包发送到该socket的接收缓冲区中。接着，可能会构造新的tcp包并发送，如ack数据包。socket的接收缓冲区大小就是tcp接收窗口。数据会从socket接收缓冲区再到用户区。
		>
	
		---附加：驱动driver请求网卡nic发送数据,并且等待网卡事件的返回值----以事件方式接收数据。
			而nic和内存，cpu和nic设备之间之间可以直接作用：nic从内存中取数据是DMA，cpu发送数据到nic是程序化IO
			>tcp发送的包和驱动消费包之间有一个缓冲队列
			>驱动请求和NIC之间有一个环形队列：缓冲请求-响应。
			>NIC发送包前，是把包缓存在网卡的缓冲区中：
			
	>NIC是中断独立处理的，不是内核的一部分，不是内核程序。
	>数据结构 + 函数调用树（最底层是基本运算和读写存显传的操作动作）