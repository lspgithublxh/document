1.问题描述：
	>预知：
	   >客户端和服务端之间网络通信：看传输的字符流是什么？
					webservice最大特征是：http协议请求的内容格式返回的内容格式 ，内容体是有格式的。
	   >注解：
	   >构造某个接口的实现类的动态代理类：
		>只是构造动态代理类：那么只要构造实现某个接口的类：有一个注入类即源类，每个实现方法只是反射方式调用源类的同名方法，这样的字节码Class就可以了。
				     但是这样的代理类，没有更多于源类的功能，但是它可以有更多的功能。就是在调用源类方法前后调用另一个注入类的专门方法（而且这个功能因为重复，可以抽取出来为一个方法，被每个实现方法调用，从而每个实现方法只需要传递参数就可以了）---实现日志记录、运行时间统计等功能。
				     这个注入类就是日志切面类，调用它前后的方法就是该切面声称的（如@Before）前后的方法（初始化的方法也有）。
	   			>实现效果：不用实现接口，就让某个类成为其他类的切面类：（让自己的前后方法切于其他类的方法调用前后）
				>实现方法：注解声明。（或许可以程序声明或者配置声明）
		>构造静态代理类：
				>直接写好一个类，它实现了目标类的接口，引用了目标类，同时自己的前后方法加在调用目标类方法的前后。这样就完成了一个代理类，但是也要手动将这个代理类放到需要使用代理实现类的地方。
		
	   >服务与资源路径：
		>web服务也是一种资源，所以有资源路径。webservice是一种web服务，所以也有资源路径。
	   >SOA：面向服务架构:
		>是一种服务组织的架构。服务之间是通过网络通信，因为服务分布在不同的节点上、机器上。
		 是一种软件架构。是一种组件架构。软件的网络架构方式。通过网络架接起来。
		>用途：用于的场景：用于将网络服务集成。
 		------webservice就是一种SOA的远程调用技术（rpc----跨过网络调用另一台电脑上的程序里的对象的方法,另外的rpc有rmi,corba）
	   >SCA:服务组件架构：
	   >RESTful:代表性状态传输：representational state transfer
	   >JSON：javascript object notation
	   >CSV:comma separated value
	

	>技术体系：
		>soap:	一种以xml为形式的数据模型。一种用xml来表示交互信息的结构。一种xml结构。	
		>wsdl:一种以xml为形式的服务介绍模型（从而用户知道服务端提供了哪些服务--而不用直接去看源码）。一种用xml格式来表示提供的服务信息的结构。一种xml结构。
		      争辩：为什么要这么详细的结构？因为避免并发请求而返回的信息先后顺序不同，可能就混乱难分了---谁是谁的响应就不明确了。	
		>uddi:  一种xml形式的介绍行业企业提供的webservice的目录信息结构。		

		-------使用场景------------
		（用户或者先从UDDI获取到相应的行业企业它所提供的webservice服务整体路径：（可能若干个.wsdl），也是soap方式实现）
		用户通过webservice资源路径而发现提供的服务：(wsdl组织格式)
		用户编写http协议 + soap数据格式的报文 来访问服务端获取到soap数据格式的响应报文
		-------服务端使用场景---------------
		开发者以@Webservice方式声明类为webservice服务类
		开发者以Endpoint方式发布配置的：webservice资源请求路径---webservice服务类。或者以servlet调用的服务方式发布的：webservice资源请求子路径----webservice服务类。（这样的配置方式，同样使得客户端无soap请求则返回服务介绍，有soap请求则处理请求返回soap格式组织的数据）
		(开发者或者注册webservice路径到UDDI相应行业企业下----供大家搜索，注册过程也是http+soap方式实现)

	>实现方式：
	    >统一的：
	      #以endpoint方式发布：
				>发布资源路径作为运行参数传给EndPoint。Endpoint根据请求的资源路径（及报体）而调用相应的webservice实现类及其中方法
	      #在webapp中发布：
				>发布资源路径交给一个专门的servlet调用管理，而servlet可以等待转发到自己的请求。servlet根据转发到自己的请求而调用相应的webservice实现类（根据每个webservice实现类配置的接受路径而决定调用哪个webservice实现类来处理本次转发到自己的请求，因为每个webservice也有自己的处理路径，其他的处理路径则不处理，实际上也转发不到它。这个路径--实现类通过静态xml配置）及其中的方法。
				
		>java自带webservice功能实现：
			>声明：需要在接口上@Webservice声明，和在实现类上@Webservice声明。
			>测试：需要依赖@Webservice声明的那个接口。
			>好处：不需要依赖其他jar包。
		>JAX-WS:
			>声明：同上，且多。
			>
		>xfire：
		>apache cxf:用来在已有的web项目中加webservice服务
			>
		>axis2:用来主体就是webservice项目

		>纯粹http server/socket server实现方式：

	>不同于一般的web服务：
	    >一般的web请求，一般是要先登录----有session之后才能调用，否则会被拦截。而webservice配置到新的servlet，这个不接受拦截而直接可以被调用访问。
		>





*附加结论：
	>jdk中即javase中就有许多javax.*的开发包。


1.参考资料：
1.http://www.cnblogs.com/siqi/archive/2013/12/15/3475222.html（几种webservice开发方式）
2.http://www.cnblogs.com/holbrook/archive/2012/12/12/2814821.html（cxf发布方式）http://www.cnblogs.com/modou/p/6108712.html
3.http://www.cnblogs.com/Johness/archive/2013/04/19/3030392.html(jax-ws方式)