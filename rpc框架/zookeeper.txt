1.问题描述：	
	>预备：
	>概念：
		>设计目的：提供统一的视图服务：即无论客户端连接到哪个server，都返回同样的视图。
		>实质：分布式的小文件系统
			提供分布式锁、协调、消息队列服务。
		>提供的服务：开发分布式服务所需要
			>统一命名：
			>状态同步：
			>集群管理：本身可以是一个zookeeper集群，一个leader，其他是follower
			>分布式应用配置管理：
			
		>实现的方法：java编写
		  >结构：层次型目录树---保存在内存

		     >保存数据的目录：
		     >保存日志文件的目录：
		     >客户端连接zookeeper服务器：zookeeper会监听一个端口，接受客户端的访问。每次有访问，创建一个回话。
				
		     >心跳维持：zookeeper服务器之间或者zookeeper和客户端之间。
		     >存储数据结构：
		     >leader选举：在启动和leader崩溃的时候，
		     >follower和leader的状态同步：促使leader和foller有相同的系统状态。
		     >事务和提议：
		     >状态：looking ,leading ,following
		     >选举线程：启动、leader崩溃、leader失去大多数follower时候：
				>选举leader过程：询问每个节点 > 获取提议(id自己, zxid提议是事务有zxid)  >  判断最大zxid的server是否满足leader条件    >  判断结果为符合则设置server为下次推荐的leader    >  更新自身server的状态
					
					------询问列表：	
					------投票记录表：

				>选举过程中每个节点的行为：
					>内部：判断推荐者信息
						#判断是否要更新自己的投票情况：即更新自己的投票队列。（算法就是sid最大，zxid最大）
						#如果收集到了所有服务器的投票结果，则判断能不能确定leader：即看投票数是否>=n + 1,是则能更新自己状态为Following/leading,选举结束，退出；否则不能，继续保持Looking状态。
						#判断自己状态是否为Looking：不是则选举过程结束，直接返回对方leading是谁--和选举结束的信息。
					>对外：收发推荐者信息
						#广播：因为经过内部判断而改变了自己的投票。。每次广播之后收到所有的回复--包括延迟回复（即广播型回复、最新一轮回复）之后，会开始内部判断是否要结束选举。----即看投票列表中：投票结果是否半数以上server都投它；是则结束。开始询问预备leader，准备好没，leader等所有server都问了之后恢复准备好了，正式结束选举，当上leader.
						#单发：只回复对方一个自己的投票结果---即对方的投票肯定不行--比如轮数低了。

					-------内部数据结构：一个自己当前的投票、一个我广播后大家反馈回来的投票队列、一个自己的状态

				>Paxos算法：
				>当上leader之后：第一件事：同步逻辑时钟、来同步数据--使得最新和一致。

		     >状态同步：leader和follower之间：目的是使leader知道确定同步点。
		     >leader的2件事：
				>恢复数据：
				>处理来自follower的四种请求：
					#PING请求---为心跳请求，则看这小段时间内的PING请求的follower数是否超半数，否则发起选举过程。
					#REQUEST请求---为发起提议或同步请求（sync来强制更新server信息为最新），则加入到处理队列。
					#ACK请求---为对提议的反馈信息，过半则提交该提议。
					#REVALIDATE请求---为延长SESSION有效时间，一般通过并作延长处理。
		     >follower的3件事：
				>向leader发起四种请求：PING\REQUEST\ACK\REVALIDATE
				>接收leader的信息：PING\PROPOSAL（更改提案，提案带有一个zxid表明重要性和先后）\COMMIT(提案结果)\UPTODATE(变更同步完成)\SYNC（客户端强制同步完成）\REVALIDATE
				>接收client请求：读请求则返回，写请求交给leader,即以事务的方式。
		     >znode:实际上是文件目录（有文件和目录双重信息）
				>对znode可以增删改查
				>可以有子znode
				>一个znode数据大小1M最多。信息构成：stat(如版本号version、时间戳zxid，权限)、data（即关联的数据）、znode（子节点）
				>一个znode由一个路径标注。
				>更新znode信息需要带版本号，否则失败，更新后版本号增加。
				>可以对znode设置watch(它可以通知client一次 znode的数据变更)
				>节点类型：4种。临时节点（session断开则消失）和永久节点
				


		     >记录事务日志和定期快照：
		     >启动时恢复数据和会话信息：

		>启动、和查看：
			>服务端：zkServer.cmd
			>客户端：zkCli.cmd 127.0.0.1:2181
		>客户端对zookeeper集群的操作：
			>写请求：对其中节点（比如离自己进的，有空闲的）的写都会先发送到leader,leader再同步到全部的子节点即follower，来完成数据变更。
				  从而所有的节点都是一样的数据结构。
				>具体例子：客户端发送要发布的消息到zookeeper，zookeeper保存这个消息，且是有先后顺序的保存。
				>同步到各个子节点server使用的协议：zab
				>


			>读请求：连接到其中任何一个server，读到的内容都是一样的。
			>数据监视和子节点监视：
			>连接到server后有session会话保持。
			>视图更新：即客户端不会保持几十秒很久的和server的连接而会被强制关闭。

		>使用场景：
			>某集群节点要共享配置、配置变更通知每个节点：不是把zookeeper集群隔离开来专门使用，而是把zookeeper集群耦合在目标集群节点上。一台目标节点一个zookeeper节点。
					---------像分布式的冗余存储节点。
			>协调从大系统中划分出来的各个子系统的：协调物理分布的子进程：
				>需要协调的原因：网络故障，发起方根本不知道接收方收到没有----分不清楚是接受方挂了还是网络故障了(或许发起请求前就挂了)，所以一次次重新发送请求。而不是在接收方崩溃的那一刻就知道接收方已经崩溃了不用和它通信了。
					>所以大型集群，必须要有一个消息中心，维护各个节点信息的供各个节点查询和通知各个节点最新集群信息的，这样一个服务---一个中心共享服务通知服务。（消息共享和通知中心）
					>第二：出了局部故障（单点故障），需要安全处理（比如备份、通知）（故障恢复）。
						>单点故障：即master-slaves结构（主从模式）中,master挂了。
							>传统方式：加一个备份节点，但会因为网络故障出问题---两个master就出现了。
							>zookeeper方式：
					>
				>利用zookeeper本质是利用它：
					>client对zookeeper server创建znode节点是同步的,znode的编号是有序的，创建时可以加watch--常常watch父节点的子节点----从而在该节点消失或改变的时候，父节点会产生一个watch事件，而通知所有watch了这个父节点的client：即返回最新的子节点（它们的编号是有序的，默认以最小的为下一个活跃节点master）
					>client和zookeeper的连接正常情况下不会断掉。首次连接会返回一个id,后面会周期向server发送心跳来维持连接。而对client编程的时候，不用管心跳，只需要保证client一直在运行，比如进入System.in.read()阻塞就可以，会话会同样一直保持。
					>client一旦崩溃，zookeeper目录上的那个节点会消失，而父节点会生产一个watch事件，通知所有watch了这个节点的client，从而各个活着的节点收到最新的子节点列表，而取编号最小的对应的client为master。从而master产生，继续服务。
	
			

	------外：读写，内：心跳选举

*小知识：
	>查看windows上java进程信息：jps -l -v
	>伸缩性：


1.参考资料：
1.http://blog.csdn.net/tlk20071/article/details/52028945（安装启动zookeeper）
2.http://blog.csdn.net/tswisdom/article/details/41522069（对本质有讨论，深刻）
3.http://www.cnblogs.com/wuxl360/p/5817471.html（图例多）
4.http://cailin.iteye.com/blog/2014486/（真正说明了集群选master的应用过程）
5.http://blog.csdn.net/shenlan211314/article/details/6187037（客户端api编程）
6.http://www.cnblogs.com/ASPNET2008/p/6421571.html（选举过程，更合理的解释）http://blog.csdn.net/zhoulixin8/article/details/51751567
7.http://blog.csdn.net/yinwenjie/article/details/47613309（推荐过程，通俗易懂）
8.http://www.cnblogs.com/endsock/p/3480093.html（paxos算法）