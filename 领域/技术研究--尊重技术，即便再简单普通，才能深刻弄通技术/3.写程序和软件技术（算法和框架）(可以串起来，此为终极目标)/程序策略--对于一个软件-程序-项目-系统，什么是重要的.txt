1.对于程序（例子：汉诺塔）：
	>算法流程：
	>情况和问题的数据结构描述：
	>设计规则流程让情况的人为演化到目标情形（想象动画）---对应的数据结构的操作处理过程、变化过程演化过程：

2.对于机制（java内存机制垃圾回收机制）：
	>机制流程的结构图描述：从开始到结束的动态过程。（思考为什么这种机制可以？为什么要用这种机制？好处和坏处？）
	>机制要实现什么需求？（什么功能）：具体的说，用图来表达，从初始化到接着可能会做的一切动作、一切操作，分别都需要响应，分别都应该响应什么，如何响应如何呈现。
					   就是要充分描述、完全概括（周全描述,全面描述）所有从初始化开始的不同的需求，从而对应（有理有据根据规则根据人情事理）确定需要的响应（具体的怎样的响应，什么响应，这个响应也要精确描述）。
					（充分描述需求，精确描述响应）
					（不应当还客观存在却没有发现的需求---导致程序对该需求没有专门响应、或者错误的响应）（需求概括不全，是一种严重的问题）
				>预知：需求：就是需要响应的时候、需要响应的动作、需要响应的组合动作、需要响应的先铺垫若干可以改变后台（被操作的对象）且改变了后台数据结构和状态的若干个动作之后的某个动作--此时要新的专门的响应（而不是以前的单这个动作的响应了）。
				       响应：不是按照动作响应，而是按照时候、按照流程响应、按照后台当前数据结构（特征、类型）和状态响应，，，即不是机械的响应，而是运算后比较过分类过查看过后的旋转出来的设计出来的响应。
				       开发之前，需要明确想清楚：什么时地需要响应？进一步，需要响应，那么，需要响应什么？（严密开发，没有逻辑漏洞的开发）
					（开发，不能有逻辑漏洞，即需求响应漏洞）


3.对于项目（web系统数据查看和操作和提取获取感知生成）（顾及用户，顾忌用户，顾及整体）：
	>用户需求：
		>用户需要什么？最不可少的东西---突出和易操作，和附加的东西。
		 用户需要哪些响应？（数据响应，数据可视化后响应）（从响应角度看需求）
		>描述需求：按照时间地方（设计时间和地方）呈现可以响应用户需要的机关（即感受器，自己可知的事件-动作、数据感受器，命令输入、鼠标键盘输入、声音输入-人体特征输入）
			>需求的概括：描述需求需要概括--需要模型化、标准化（使用基本的图形作为建模语言）---------需求的建模语言来描述。：：从上分析得出，响应的机关需要用建模语言描述，操作流程需要建模语言描述。
			
	>业务规则：
		>活动规则：用户还需要遵守的规则，还需遵守的必要必不可少的流程，从而有条理，从而系统稳定健康，系统进化发展，从而活动可以持续美好的稳健的进行下去，要规范用户的行为限制用户的行为（因为用户可能不那么善良，可能会做坏事，满足自己的私欲，伤害到别人或者自己，或者破坏公共环境），大家是公平的平等的，没有歧视,大家都各得其所各得所需，玩得开心。
		
	>业务流程：

4.对于系统（linux操作系统）：
