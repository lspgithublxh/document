>任何事情都有层次体系：追求层次体系，找到层次体系明确表达 出来 是 当前 做事情的重点。
>等待开发的一些框架和工具。
>引用：每个引用都有一个值(要么是null/要么是指向对象的地址)
	>
	>引用类型：
		>弱引用：
			>将一个引用标记为弱引用：new WeakReference(T re)
			>GC时对一个弱引用标记的引用的处理：如果一个对象的所有引用都是弱引用，没有强引用，则直接将这个对象的空间回收了，而把弱引用标记的引用设置为null, 即re=null；而不是这个WeakReference对象为空。
			>运行中的问题：
				>内存泄露问题：无法回收的对象：为 当前没有结束的Thread的threadLocalMap里的Entry: key=null但是value还是有值的。这个value就不会被回收。原因：key指向的本来是一个ThreadLocal对象的引用，但是 引用key被标记为了弱引用，导致GC时如果 这个ThreadLocal对象只有这个key引用它 则就会直接回收它 而将key=null处理。
					>原因：没有其他强引用指针引用。
					>解法：key=null的entry需要被擦除。---threadLocal已经做了：但是不会自动做---有个触发条件--调用ThreadLocal的set/get方法：正是threadLocal在ThreadLocalMap之上封装的目的功能之一。
						>解法2：手动删除 不需要的 Entry对。remove()方法可以置null value引用 和 置空 entry引用。
						
>方法拦截器的使用：任何方法是否都可以拦截。
	>controller上的用户自定义方法拦截器的使用：而不是对controller的所有方法都应用--即专门对某个方法应用拦截器。
		>利用springmvc的controller拦截器 + 用户自定义的方法注解：检测到 方法上有这个注解，那么就 执行特定的逻辑。
>通信机制：
	>调用： 基本元素/角色/概念：主线程、工作线程；产生数据的方法、消费数据的方法；
		>同步异步：主线程上下文 和 获取处理 工作线程产生的结果 的方法 是否 是 同步进行的。 
			>理解2：触发生成数据的方法 和 消费处理产生的结果数据的方法 如果都是 主线程做，即先后做，则是 同步的-生产和消费是同步的。如果这两个方法第一个是主线程做，而第二个则是工作线程做/回调，则称 这两个方法 是 异步的。(生产和消费 是 异步的)
		>阻塞非阻塞：主线程调用某个方法，这个方法返回的结果 依赖其他线程跑的结果，则主线程 是 阻塞等待结果出来 还是 不等出来直接先返回。
			>阻塞：调用一个方法开始后一段时间到返回结果时：当前线程处于阻塞状态(需要阻塞等待 其他线程跑出结果)。(调用时纯主线程执行 和 调用中出现阻塞 有什么区别？表象上看 都返回了结果)
				>接着：1.使用结果进行处理，显然 是 和 上下文 是 同步进行的。2.如果调用方法时传递一个回调函数，让阻塞等待获取到结果后调回调函数处理结果，然后返回，显然 也是和主线程 上下文 同步的；或者 回调函数先交给工作线程，而阻塞等待工作线程得到结果并调回调函数处理结果之后，再返回主进程，那么本次调用还是和主线程上下文同步的。
			>非阻塞：同样的场景，调用一个方法开始后通知其他线程跑结果后，不阻塞等待这个工作线程跑出结果 而直接返回。
				>接着：1.如果用户定时去取，则是和上下文 同步 的 获取和处理结果；2.如果用户调方法时传递一个回调函数-让工作线程得到结果后直接回调这个函数来处理结果，则是和上下文 异步的 获取和处理结果(上下文调用后可以做其他事)。
			>理解2：主线程 等待结果 的 方式： 阻塞 地 等待 工作线程产生的结果， 或者 不断查询 来等待结果(不直接阻塞等待 工作线程如何一步步构造产生结果)(不望着一动不动)。
			>理解3：产生 数据的方法 需要主线程(调用线程) 阻塞等待后才得到 还是 需要主线程 不断查询后 得到。
			>理解4: 产生 事件的线程 和 消费事件的线程。调用 要求 数据源 产生事件的线程。
			>理解5：产生数据的方法 在工作线程1上运行，消费数据的方法在工作线程2上运行，要求 数据源 调用产生 数据的方法的方法 在 主线程 上运行。
				>把产生数据、消费数据 都 做成 和 主线程异步：