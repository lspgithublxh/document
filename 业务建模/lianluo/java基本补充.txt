>任何事情都有层次体系：追求层次体系，找到层次体系明确表达 出来 是 当前 做事情的重点。
>等待开发的一些框架和工具。
>进行面面俱到的描述。
>疑神疑鬼太累(已经发生的没做好的当吃亏,以后要注意)：减轻办法：不要装逼、不要装高尚、要重视信息安全(信息要加密要包装)(不要无所谓)、要确定性的办事(不要草率)。
>所有的愤怒都是别人的故意的计策和阴谋：别有用心、见不得别人好、见不得别人发展得更好 才会激怒和贬低和打击 来 摧毁对方/毁灭对方。不能让它得逞。(也谨慎打击别人:不是所有人都会越打击越强,但打击之后都会怀恨在心)
>规范的训练自己：所以要看技术书。
>连续关联、每个环节步骤都细化：可扩展可替换可新增可删除(方法和入参和局部变量和甚至属性)
>蔓延式关联。
>引用：每个引用都有一个值(要么是null/要么是指向对象的地址)
	>
	>引用类型：
		>弱引用：
			>将一个引用标记为弱引用：new WeakReference(T re)
			>GC时对一个弱引用标记的引用的处理：如果一个对象的所有引用都是弱引用，没有强引用，则直接将这个对象的空间回收了，而把弱引用标记的引用设置为null, 即re=null；而不是这个WeakReference对象为空。
			>运行中的问题：
				>内存泄露问题：无法回收的对象：为 当前没有结束的Thread的threadLocalMap里的Entry: key=null但是value还是有值的。这个value就不会被回收。原因：key指向的本来是一个ThreadLocal对象的引用，但是 引用key被标记为了弱引用，导致GC时如果 这个ThreadLocal对象只有这个key引用它 则就会直接回收它 而将key=null处理。
					>原因：没有其他强引用指针引用。
					>解法：key=null的entry需要被擦除。---threadLocal已经做了：但是不会自动做---有个触发条件--调用ThreadLocal的set/get方法：正是threadLocal在ThreadLocalMap之上封装的目的功能之一。
						>解法2：手动删除 不需要的 Entry对。remove()方法可以置null value引用 和 置空 entry引用。
						
>方法拦截器的使用：任何方法是否都可以拦截。
	>controller上的用户自定义方法拦截器的使用：而不是对controller的所有方法都应用--即专门对某个方法应用拦截器。
		>利用springmvc的controller拦截器 + 用户自定义的方法注解：检测到 方法上有这个注解，那么就 执行特定的逻辑。
>通信机制：
	>调用： 基本元素/角色/概念：主线程、工作线程；产生数据的方法、消费数据的方法；
		>同步异步：主线程上下文 和 获取处理 工作线程产生的结果 的方法 是否 是 同步进行的。 
			>理解2：触发生成数据的方法 和 消费处理产生的结果数据的方法 如果都是 主线程做，即先后做，则是 同步的-生产和消费是同步的。如果这两个方法第一个是主线程做，而第二个则是工作线程做/回调，则称 这两个方法 是 异步的。(生产和消费 是 异步的)
		>阻塞非阻塞：主线程调用某个方法，这个方法返回的结果 依赖其他线程跑的结果，则主线程 是 阻塞等待结果出来 还是 不等出来直接先返回。
			>阻塞：调用一个方法开始后一段时间到返回结果时：当前线程处于阻塞状态(需要阻塞等待 其他线程跑出结果)。(调用时纯主线程执行 和 调用中出现阻塞 有什么区别？表象上看 都返回了结果)
				>接着：1.使用结果进行处理，显然 是 和 上下文 是 同步进行的。2.如果调用方法时传递一个回调函数，让阻塞等待获取到结果后调回调函数处理结果，然后返回，显然 也是和主线程 上下文 同步的；或者 回调函数先交给工作线程，而阻塞等待工作线程得到结果并调回调函数处理结果之后，再返回主进程，那么本次调用还是和主线程上下文同步的。
			>非阻塞：同样的场景，调用一个方法开始后通知其他线程跑结果后，不阻塞等待这个工作线程跑出结果 而直接返回。
				>接着：1.如果用户定时去取，则是和上下文 同步 的 获取和处理结果；2.如果用户调方法时传递一个回调函数-让工作线程得到结果后直接回调这个函数来处理结果，则是和上下文 异步的 获取和处理结果(上下文调用后可以做其他事)。
			>理解2：主线程 等待结果 的 方式： 阻塞 地 等待 工作线程产生的结果， 或者 不断查询 来等待结果(不直接阻塞等待 工作线程如何一步步构造产生结果)(不望着一动不动)。
			>理解3：产生 数据的方法 需要主线程(调用线程) 阻塞等待后才得到 还是 需要主线程 不断查询后 得到。
			>理解4: 产生 事件的线程 和 消费事件的线程。调用 要求 数据源 产生事件的线程。
			>理解5：产生数据的方法 在工作线程1上运行，消费数据的方法在工作线程2上运行，要求 数据源 调用产生 数据的方法的方法 在 主线程 上运行。
				>把产生数据、消费数据 都 做成 和 主线程异步：
				
>java基本：new的时候初始化：可以使用构造方法级别的代码块 方式：{add(x);}  。 如 new A(){{xxx;}};
>线程池的使用：增加钩子函数 关闭。第二：应用里使用 需要在 runnable里手动记录开始的任务和判断当前是否已经被主线程结束了。。
>信息结构和信息关联：				
>Observable 实现异步的方式：
	>subscribleOn()则是异步向上订阅/请求:即准备向上订阅时，放在另一个线程里执行向上订阅/请求。
	>observeOn()则是异步的向订阅者onNext发送数据： 即收到数据时，先放到内部的一个队列里，然后异步的查询队列里的内容然后发送给下一个订阅者/child;
>结构化网络：
	>DHT算法：Kadmelia
>非结构化网络：网络节点为对等节点。
	>bitcoin 副本同步数据算法：gossip协议
		>gossip协议： 必须进行 面面俱到的描述。redis cluster , consul,apache cassandra 使用。
			>概念定义：抽象、封装。
				>被感染节点：
				>临近节点：
			>行为定义：抽象、封装。总结、概括。统一、通用、复用。
				>散播消息：
					>通信方式：异步发送，不等待响应(不关心是否收到/不处理响应?)
			>目标定义：	
				>目标效果：
					>扩展性：新增加的节点 要和 其他节点状态一致。
					>容错性：任何节点的宕机和重启 都不会影响 gossip 消息的传播。
					>去中心化：无需 一个中心节点 知道 和记录 整个网络的 状况。
				>必然效果：顶层思路。顶层想法。
					>任何节点可以把消息散播到全网：通过相邻传播。最终一致。
						>消息传播数量按级增长速率：2的级数 次方 。
						>对应的状态不一致收敛速率：开始很大，初期不一致减少也慢，但收敛速度越来越快。经过 logN步 就全部收敛了。
					>散播速率还是太慢：因为需要多步骤：最终一致的速率太慢；延迟太高。
					>消息冗余：重复的消息 会收到。
			>策略定义：
				>随机选择：
			>路径定义：
			>规则定义：对行为的限制、约束。对路径的约束。对目标的约束。
				>限制每次向后散播节点的数量：3
				>且这些散播节点尚未被自己发送过：
				>如果对方向自己发送过 则 自己不向它发送：即是无向边。
				>定时散播: 每隔1s
			>模型定义：整个协议过程的图像化展示元素。	
>codis: redis实例 的 前端代理 服务器。但是 官方有 自己支持的：redis-cluster。
	>目标：1.将 key分配到不同机器上。2.自身多实例部署 且进行slot数据同步来保证 实例接收的key都会被分派到正确的redis上。
	>思路：
		>对key的分配 环节：引进slot概念，共1024个，并且 一个redis绑定若干个 slot;
		>slot在dashboard上人工重新分配并同步给 codis实例 环节： dashbord发送给 zk, zk再同步给 订阅了 slot目录的codis;。且同步期间 codis进入 同步状态，不对外提供读写服务。
>redis集群方案：
	>客户端分片：key-->hash-->选择redis实例
		>优点：部署简单。只需要部署redis实例即可。
		>缺点：节点数量变更，导致 数据的迁入迁出。
	>服务段分片：	
		>痛点：开发人员只关注业务逻辑即可--只需要get/set即可，不用关心如何 hash 如何分片、新增节点、数据迁移 等等 统一的问题。
		>目标： 提供 给 开发人员 就像 操作一个无限大容量 redis节点一样 来操作的 API操作接口。
		>条件-思路: 像请求一个，则只能发送一个请求，而 数据必然存在 多个redis节点上，所以这个请求必须 能够 再次 分辨应该找哪个节点，则这个逻辑必须 要跑在另一个独立的机器上，这就是 服务端代理。
			>思路细化：代理层的具体功能、指标：1.实现具体的请求转发规则。2.数据的聚合和分解。3.redis server节点的在线扩展、扩容。4.redis server节点上的数据的异步迁移(对业务无损)。
				>缺点：增加了中间层 中心节点单点问题、流量瓶颈问题 、单次处理性能损耗问题。
			>集群化方案1：codis 具备丰富功能且完备的方案。
			>集群化方案2：twemproxy
				>主干功能：请求的路由转发。缺点：不能在线扩容缩容、没有友好的运维UI。
	>混合分片：请求转发逻辑一部分放在客户端，一部分放在服务端。			
		>集群化方案3：redis cluster 
			>请求转发逻辑：smart client 客户端自己完成。
				>数据迁移、扩缩容时的请求转发：
			>在线扩缩容：
			>在线数据迁移：迁移性能不高(所以二次开发)
			>故障自动恢复：哨兵
>架构设计：
	>mybatis 领域模型：
		>BoundSql: 封装了三个属性： sql:sql、sql列值占位符:parameterMappings、参数对象值:parameterObject。提供了几个服务：
			>数据结构：
			>算法：
		>TypeHandlerRegistry: 参数值的类类型处理器 仓库。	