>条件：利用变量/方法返回值 进行算术运算逻辑运算得到一个逻辑结果
	>动作：动作的内容：是 子条件-动作 列表。这个动作是一个封装型的动作(封装了子条件-子动作)，或者 是一个原子型的动作。
>条件发生：
	>执行动作：
		>同时情况的子情况为情况1：
			>执行动作1： 
		>同时情况的子情况为情况2：
			>执行动作2： 
>条件发生： 
	>执行动作: 
		>此时获取某种情况/量的取值为值1：
			>执行动作1： 
		>此时获取某种子情况/量的取值为值2： 
			>执行动作2： 
>事件发生：
	>执行动作： 
		>进一步出现情况1：
			>执行动作1： 
		>进一步出现情况2：
			>执行动作2： 
>事件出现： 
	>执行动作：
		>继续发生事件1：
			>执行动作1：
		>继续发生事件2：
			>执行动作2：
>情况出现：
	>执行动作： 
		>按业务规则将情况判定为分类1/情形1：
			>执行动作：
		>按业务规则将情况判定为分类2/情形2：
			>执行动作：
>情况出现： 
	>子情况1出现：
		>执行动作：
			>执行子动作1：
			>执行子动作2：
	>子情况2出现： 
		>执行动作：
----------------------------------------------
>事情的解决是一个 事情的推进的过程：
	>每一步推进的过程 就是 回答 递进的 问题的 过程：
		>明确事情的完成路径：各个节点。
	>业务 就是 设计环节的过程：	
		>没有业务：直接解决的做法。
			>设计业务：细问 直接做法 这个 描述 的 各个 词语 部分。
				>动作：执行一个动作不是无条件的，而是需要条件的。这就是业务规则。
				>动作：不是原子型的，最底层的最具体的，都是需要拆分的，拆分为一个流程，多个先后/并行的动作 形成 一个 从左到右 的 动作树。这就是业务流程。
				----动作都要问 什么条件下做，怎么具体做。
				>名词：是什么，是什么数据的集合，是什么数据结构，含义边界是什么。
				>名词：相关数据是什么，和其他数据 的关系 是什么。一对多，多对多。引用关系，包含关系。
				>名词：各项 数据的来源 是什么，数据存储在哪里。
	
---------------------使用例子----------------------
>收到车辆上报事件消息：Condition
	>对事件保存和同步：Action
		>无论什么事件都要求保存到数据库：C
			>保存到数据库：A
		>要求同步到APP: C
			>事件错误类型和车辆类型 取值为xx: C
				>事件消息同步到APP：A
		>要求同步到工单群：C 
			>事件错误码和车辆类型和状态 取值为xxx: C  
				>发送消息到工单群：A 
		>要求满足条件时创建工单群：C 
			>事件类型/错误码/升级触发类型/汽车状态和用途 取值为 XXX：C
				>调用服务创建工单：A 
		>要求有必要时进行任务补偿：C
			>事件错误码和车辆类型和状态 取值为XXX: C 
				>发消息到运营小助手：A
				>任务类型和任务状态 取值为 XXX：C 
					>标记任务为需要重发：A 
						>验证任务：A 
						>设置标记：A isResend=true
		>要求有必要时读取机车的日志：C 
			>事件升级状态/错误码和车辆类型和状态 取值为XXX：C 
				>发送日志请求命令：A  
				>异步处理回送的日志：A 
		>要求事件满足某种类型时记录 这个错误类型的事件：C 
			>事件错误码和车辆类型和状态 取值 XXX： C
				>保存到数据库：A
		>要求广播这个事件到消息中心某个主题：C 
			>事件错误码和车辆类型和状态 取值为XXX：C
				>发送给消息中心：A 
				
>制包请求：Condition
	>制包并保存包信息：A
		>
>车辆请求包信息：Condition
	>响应这个请求：A 
		>把包回送给请求者：A 
			>包 包括的所有数据项的数据的查询和填充：A 
				>策略部分：D
					>是否比较ECU版本：D 
					>ECU升级顺序：D 
					>预置条件：D 
				>文件部分：D 
					>文件key: D 
						>包路径：
					>密钥：D 
						>aes: D 
							>数据库存的aes_en用bks服务解码得到aes_key
						>aes_iv: 
					>签名部分：D
						>包的摘要：
						>包的签名：
						>公钥：
						>公钥的签名：
				>升级提示描述信息：
					>
				>ECU列表部分：
					>每个ECU：
						>基本信息：
							>升级类型：
							>升级顺序：
							>版本：
							>名称：
						>文件部分： 
							>文件key: D 
								>包路径：D
							>密钥：D 
								>aes: D 
									>数据库存的aes_en用bks服务解码得到aes_key
								>aes_iv: 
							>签名部分：D
								>包的摘要：
								>包的签名：
								>公钥：
								>公钥的签名：	
								
			>请求信息 满足 回送的条件：C
				>目标版本&当前版本&汽车VIN码 的取值 满足 对应的包存在：C 
				>汽车 满足 验证要求：C 
				>策略/配置字满足要求：C  
			>
>车辆内如何下载和解析这个包的：		
	>下载升级包：
		>请求包描述信息：IoTClient.invoke("ota.total-package-info.get",request, TotalPackageInfo.class)
			>转发invoke请求：com.chehejia.iot.sdk.a.b()方法来处理。
				>服务调用接口：转由com.chehejia.iot.sdk.http.HttpApiManager#invokeService()处理：如入参中服务名"ota.total-package-info.get"
					>转发给HttpApiImpl.invokeService():com.chehejia.iot.sdk.http.a类
						>将请求信息封装为json: {"service":"ota.total-package-info.get","payload":{...}}
					>接口信息iot-sdk.jar:com.chehejia.iot.sdk.http.api.ShadowServiceApi.invokeService(): 此方法配置的url路径"/iot-device-shadow/v1-0/service"
					>使用retrofit代理ShadowServiceApi接口： 在com.chehejia.iot.sdk.http.a类中实现。
						>内部构建的实际https客户端为 OkHttpClient 实例：
							>https使用TLSv1.2/X.509来生成sslscoket:
								>ssl证书来源为com.chehejia.iot.sdk.http.b.a.c()方法里的写死的字符串：只有一个，所以认为是单向认证--只认证服务器。
							>甚至有apn配置：
							>用户给okhttpclient配置了拦截器：1.打印url 拦截url,调用耗时统计,重试执行(再次调用proceed). 2. 补充报头："X-CHJ-Timestamp","X-CHJ-Token":"配置的","X-CHJ-Nonce","Content-MD5":"请求内容md5后base64编码","X-CHJ-Key":"android内存交换获得","X-CHJ-Sign":"带入参的内存交换"
						>最后用retrofit创建服务接口的动态代理Proxy.newProxyInstance：来自 retrofit2.Retrofit#create()
							>代理的Handler执行的事情: 1. 确定平台:android/java8  2.解析方法(适配器/返回数据转换器/方法上的retrofit注解解析/方法入参上的retrofit注解解析-以便格式化到http)封装解析结果到ServiceMethod对象。 3.封装方法+实际入参 到 OkHttpCall对象，并用方法的适配器适配一下。
								>okHttpCall的主要执行过程：
									>1.方法+参数生成请求Request: 方法的入参被参数处理器ParameterHandler逐一应用处理 后封装到RequestBuilder里，然后后者构建一个Request: 内部就是http请求信息的构造(url/header/body/method)
									>2.Request简单的转为okhttp3.Call对象：
									>3.构造一个Callback对象调用上述okhttp3.Call对象的入队方法：内部实现就是 调用 OkHttpClient.dispatcher().enqueue(new RealCall.AsyncCall(Call))来入队。入队就被提交执行：execute():
										>execute()的具体过程：RealCall.getResponseWithInterceptorChain() : 1.添加拦截器：用户的/重试的/BridgeInterceptor/CacheInterceptor/ConnectInterceptor/网络的/CallServerInterceptor 到新建的拦截器链RealInterceptorChain对象里。 2.执行拦截器链，并且执行的所有事情都是拦截器的拦截方法，没有专门的服务。
											>CallServerInterceptor的具体过程：1.请求Request写入http流HttpCodec 2.执行事件监听器 3.请求流写入@httpCodec.finishRequest()。4.等待返回takeResponseHeaders()->waitForIo()。 5.构建封装 Response:
												>核心为等待结果waitForIo(): 具体执行过程：对Object.wait()封装了一下---捕获了中断异常，返回了中断IO异常。
											>ConnectInterceptor的拦截执行过程：1.获取chain里的StreamAllocation：(从上面来则是空的)。2.用来构造HttpCodec对象：streamAllocation.newStream(OkHttpClient, Interceptor.Chain)	
												>构造流的过程：1.构造真正链接RealConnection。2.将3个超时信息配置到RealConnection的socket/source/sink的超时控制里。封装到new Http1Codec()/new Http2Codec()返回。
													>真正链接的构造过程：1.直接构造new RealConnection() 。 2.tcp+ssl阻塞式连接：RealConnection.connect() 3.
														>阻塞链接的过程：1.从route:Route属性获取 链接特征列表List<ConnectionSpec>。2.无限循环中，直至建立链接。如果是要求Tunnel隧道(http)则调@connectTunnel() 否则connectSocket() 3.链接建立后的处理establishProtocol(),监听器的链接结束事件通知。
															>connect过程：
																>Tunnel链接的过程：1.构造Request对象(url/header/)。2.至多21次重试connectSocket()，直到连接后调@createTunnel()返回的新Request非空。
																	>connectSocket()的过程： 
																		>1.创建原始Socket:
																			>HTTP代理类型：route.address().socketFactory().createSocket() 赋值给 rawSocket
																			>socks代理类型：1.如果是代理方式：则构造SocksSocketImpl实例，即要先连接 Socks server ,甚至以username/password方式连接。2.否则就是普通的PlainSocketImpl实例。
																		>2.执行socket连接：Platform.get().connectSocket() 内部实现即socket.connect(address, connectTimeout)
																		>3.socket的输入流的封装：	1.socket本身封装到一个超时对象AsyncTimeout，2.socket的输入流封装到一个Source对象里(它的read方法里-即就是请求方法里-这样读数据就实际去读socket输入流里的数据--还很自然的是个阻塞方法-并且读出到入参Buffer.Segment段里--从而自然而然传给了下级)，3.将前面的Source封装出的Source对象进一步封装/包装为可超时的Source对象：Timeout.source(Source),,显然包装的过程就是在真正的Source.read()的前后分别增加超时机制TimeOut的enter()和exit()方法---看门狗机制来控制超时。4.直接包装Source到RealBufferedSource：Okio.buffer(x)
																		>4.socket的输出流的封装：1.	socket本身封装到一个超时对象AsyncTimeout 2.socket的输出流封装到一个Sink对象里(它的write方法里-将入参的Buffer里的段的数据写到输出流里) 3.将sink封装为可超时的Sink:timeout.sink(sink) 即在前后增加enter()/exit() 4.进一步直接包装到RealBufferedSink对象里。
																>Socket连接过程：connectSocket() 和上述一样。
															>写协议数据的过程：establishProtocol()
																>route的地址里没有sslFactory: 则认为建立明文的http连接。如果是http2, 则需要更多的操作：先构建一个Http2Connection对象(将socket和上述的source/sink都封装进去,额外+listener+ping间隔时间+)，然后启动http2Connection.start()；如果是http1则设置 rawSocket 给socket属性，设置协议属性后直接返回。
																	>http2Connection构建过程：
																		>1.新建了一个调度线程池给writerExecutor属性，线程池以固定间隔调用PingRunnable任务，这个任务就是writePing(false,0,0)写,内部实质为调用属性writer.ping(false,0,0)这个writer在Http2Connection构造时new Http2Writer(sink,client)初始化了,显然 方法的实现 就是调sink来依次写了length-type-flags-streamId 即8-6-0-0 四个整数--最后就到了socket的OutputStream里；然后调了sink.flush()就是调输出流的flush();
																		>2.新建了一个core=0/max=1的无限队列线程池 给 pushExecutor,设置发送方接收窗口16kB和发送窗口64kB
																		>3.新建了一个ReaderRunnable任务，此任务封装了一个新建的Http2Reader对象，后者封装了source+client,内部还有new Hpack.Reader()来对http2头部压缩的解析读取。这个任务具体做的事情：1.reader读取服务器发送来的第一个http2帧--http2规定的"服务器连接序言"，这个帧9byte(length24+type8+flags8+streamIdentifier31+R1), 实际读取使用source.require(9)则就将从socket的inputStream里读取9byte到source的buffer里--也就存到了buffer的segment里了。然后解析出length/type/flags/streamId---实现只需要读取3个字节、1个字节(source.readByte())、1个字节、4个字节且和0x7fffffff相与。2.循环读取下一个帧，直到读干净为止。3.关闭连接(先 发送goaway给对端lastGoodstreamId,然后给每个流都发一个INTERNEL_ERROR的httpcode给对端:type=rst_stream，关闭writer.close()/sink.close()--内部会把剩下的没发送的也发送sink.write(buffer, buffer.size)再关闭，然后socket.close()最后线程池关闭writerExecutor.shutdown()/pushExecutor.shutdown())
																			>type的类型：10种：data/headers/priority/rst_stream/settings/push_promise/ping/goaway/window_update/continuation,其他则忽略丢弃。
																			>length就是指的是payload负载长度：
																			>flags的种类：8种：none/ack/end_stream/end_headers/end_push_promise/padded/priority/compressed 大多数是为ype=header/data类型的帧服务的--即先看type再看flags,相当于type下的flags。
																				>例如对data帧： 则有compressed/padding/end_steram三种可用的标记，如果有补白标记-则读取1byte表示的补白字节数量，后从length减去这个补白数，然后才开始读取实际的负载handler.data(inFinished, streamId, source, length)。读取完毕之后需要skip掉最后的补白：source.skip(padding)
																					>如果streamId是非0偶数则认为是推送流pushedStream，此时 先用source读取length个实际负载内容到buffer，后往pushExecutor线程池提交一个任务：此任务将buffer数据传送给用户-即pushObserver.onData(streamId,buffer),如果这个方法返回true，则表示cancel的意思，则需要向这个流发送取消意思的httpcode:writer.rstStream(streamId, ErrorCode.CANCEL)---这个方法：就是先sink发送(4,3,0,streamId)的header整数后发送CANCEL的整数httpcode:8 然后直接返回了。
																					>否则不是推送流：
																						>如果内存中还没保存这个StreamId对应的流：1.直接往writerExecutor里提交execute一个任务：任务执行writer.rstStream(streamId, ERROR.httpcode:1)。2.如果+length后的当前已读取字节长度超过了 initailWindowSize的一半，则 需要告知peer可以发送更大窗口的数据到这个streamId上：writer.windowUpdate(streamId, unacknowledgedBytesRead)， 内部实现就是sink发送(4,8,0,streamId)的整数序列+刚更新的已读数据的总长整数 后 flush。3.跳过这length个字节的头部，source.skip(length) 后直接返回。
																						>已经保存了-即不是第一次接收：则直接接收这length的数据：dataStream.receiveData(source, length)-->source.receive(in, length)：当前线程需要已经持有Http2Stream.this当前对象的锁-否则抛出异常；需要检查读取的长度+当前长度是否超过了总长度限制，是则需要skip长度后异步发送httpcode:FLOW_CONTROL_ERROR:3。也要判断是否finished是也要skip。然后才是真正的read:in.read(receiveBuffer, byteCount)即读取到当前流的receiveBuffer属性里，将 receiveBuffer里的内容写到readBuffer属性里，如果写之前 readBuffer是空的--则reader已经在等待数据了--所以需要Http2Stream.this.notifyAll()	
																				>例如对Ping帧： 则有ack标记，是ack标记则说明是收到的ping，则直接source.readInt()两个得到负载即0,0,然后直接唤醒阻塞在当前连接上的线程Http2Connection.this.notifyAll()--表示网络通了可以唤醒了--同理网络不通的时候就阻塞。
																				>例如对Settings帧：则收到的数据认为是 6byte的整数倍，每个6byte=2byte的id + 4byte的value, 每对id-value都设置到Settings对象里，id只有1,2,3,4,5,6取值。例如设置 MAX_CONCURRENT_STREAMS,INITIAL_WINDOW_SIZE,MAX_FRAME_SIZE； 封装到Settings对象后和peerSettings合并(Settgings:,set:int表示各个flags的合并，values则是一个数组id为index,value为元素)，	然后应用配置：writer.applyAndAckSettings(peerSettings) 主要是应用到hpackWriter.setHeaderTableSizeSetting()上，最后是响应一下发送方：发送(0,4,1,0)整数后flush
																	>http2Connection的启动过程：1.先写序言writer.connectionPreface();2.再写配置 writer.settings(okHttpSettings)3.再调整窗口writer.windowUpdate(0,..)最后启动上述建立的任务new Thread(readerRunnable).start();
																>route的地址里有sslFactory: 则需要先建立ssl:connectTls(connectionSpecSelector), 然后才启动startHttp2(pingIntervalMillis)
																	>tls连接的过程：1.先创建sslSocket对象：route.address().sslSocketFactory().createSocket() --> 2.sslSocket启动握手：ssl.startHandshake() ——>3.getSession()后进行验证verify(hostname,) 然后是证书pinner检查:域名下的Pin集合中某个Pin.hash是否和证书公钥hash 一致。address.certificatePinner().check()
																		>构建TLSv13:OpensslContextImpl实例：一个封装了 TLSv13={"TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"}协议的实例new OpenSSLContextImpl.TLSv13()。
																		>初始化这个实例：就是新建对象new SSLParametersImpl()赋值给sslParameters属性。1.寻找第一个x509KeyManager/pskKeyManager, 第一个X509TrustManager。2.匹配可用的密码套件(x509/psk两大类)
																		>将上述 sslParameters属性封装到new OpenSSLSocketFactoryImpl(this.sslParameters)返回：
																		>创建socket对象：1.引擎socket方式：new Java8EngineSocket(sslParameters)；2.文件方式：new Java8FileDescriptorSocket(sslParameters) 3.使用默认的
																		>开始握手：
																			>ConscryptEngineSocket的握手实现：要求此时state=0,然后更新=2 -->开始实际的握手doHandshake(): 根据此时的状态而执行@processDataFromSocket()  后面会转到native int ENGINE_SSL_do_handshake()这样的本地方法来具体实现握手。
																			>ConscryptFileDescriptorSocket的实现：转到NativeSsl.doHandshake()->NativeCrypto.SSL_do_handshake()依然是本地方法调用实现。
																			>sun.security.ssl.SSLSocketImpl#startHandshake()的实现：转到TransportContext.kickstart()  内设置 handshakeContext=new PostHandshakeContext()/ClientHandshakeContext/ServerHandshakeContext  , 后转到this.handshakeContext.kickstart() ->SSLHandshake.kickstart(this) ->看分支2：ClientHello.kickstartProducer.produce(HandshakeContext)
																				>produce()的过程：1.从上下文 取得 SSLSessionImpl 实例， 后从中得到对端peer的证书Certificate[]、密码套件CipherSuite、协议版本ProtocolVersion、id协议算法。2.可能创建sessionId:new SessionId() 3.找到可商定的 密码套件。4.构造客户端hello信息：new ClientHello.ClientHelloMessage(sessionId,cipherSuites,cipherSuiteIds,clientRandom,clientVersion). 并且写入扩展信息.extensions:sun.security.ssl.SSLExtension#produce(),然后才写到握手输出流里：.write(var2.handshakeOutput:HandshakeOutStream)并flush():handshakeOutput.flush() 具体的写入方法：先写类型再长度再内容，几乎都是整数级别的发送。
																					>握手输出流的构造：HandshakeContext()实例化时 new HandshakeOutStream(var2.outputRecord)  而前者关键 SSLSocketImpl()实例化时就 有new TransportContext() 注入new SSLSocketOutputRecord(var2)---最后这个类就有实际交付数据的方法deliver(byte[])--包含: 计算帧大小->加密->写入->flush刷写。SSLSocketInputRecord 则是读取。(pinning: 即将 域名-证书公钥hash 映射起来)
																						>HandshakeOutStream是一个内存流，但是 它complete()方法则会将 内存byte[]数据写入outputRecord:OutputRecord:SSLSocketOutputRecord, 后者也是一个内存流，但是很多方法都会写入deliverStream:OutputStream里，这个流的设置时机：new SSLSessionImpl()->connect()->doneConnect():有this.conContext.outputRecord.setDeliverStream(super.getOutputStream())/this.conContext.inputRecord.setDeliverStream(super.getOutputStream())/inputRecord.setReceiverStream(super.getInputStream()) 即设置的就是 socket的输入输出流。
																			>在上一步kickstart()而发送了ClientHello消息之后开始读取服务端的返回：readHandshakeRecord()->无限循环里：不断执行 SSLTransport.decode(this.conContext...)
																				>输入解码：TransportContext.inputRecord.decode()
																					>1.先读取header: @readHeader()
																					>2.再解码输入记录：@decodeInputRecord()
																				>分发输入：TransportContext.dispatch(Plaintext) 先看 Plaintext的类型：HANDSHAKE/ALERT/CHANGE_CIPHER_SPEC/INVALID/APPLICATION_DATA
																					>如果时 HANDSHAKE 类型： 继续分发handshakeContext.dispatch() -->即寻找SSLConsumer： handshakeConsumers：byte-SSLConsumer:此时恰好找到了一个name="server_hello"的 SSLConsuemr：然后开始消费：@SSLConsumer.consumer(),继续消费：this.handshakeHash.consume()
																						>第二轮decode-dispatch找到的 SSLHandShake: 依次名称为"certificate"/"server_key_exchange"/"certificate_request"/"server_hello_done"/"finished" ，其中  "certificate_request" 没有发现，直接到了 "server_hello_done"。
																							>其中"finished"名称的 SSLHandshake.consume(): ->转发给T12FinishedConsumer.consume()->onConsumeFinished(ClientHandshakeContext):  
																								>先构造一个结束消息：new Finished.FinishedMessage()
																									>先匹配一个Finished.VerifyDataScheme 实例： new Finished.T12VerifyDataGenerator()
																									>然后用来生成一个验证数据：T12VerifyDataGenerator.createVerifyData(HandshakeContext,ByteBuffer)
																										>先封装一个new TlsPrfParameterSpec()对象：封装了SecretKey + "client finished" + HashAlg.name + handshakeHash.digest()
																										>生成一个KeyGenerator：JsseJce.getKeyGenerator("SunTls12Prf") 并初始化 ：@init(TlsPrfParameterSpec), 然后生成一个密钥：@.generateKey():SecretKey  然后 @.getEncoded()获取编码成的byte[]返回(实际SecretKeySpec就是返回输入的byte[])。
																											>SecretKey生成的过程：AESKeyGenerator.engineGenerateKey()->实现为：SunJCE.getRandom().nextBytes(byte[]) 这样就生成了了一个随机数并放在数在byte[]里，返回new SecretKeySpec(byte[], "AES")
																									>对比 从入参HandshakeContext进一步生成的验证数据 和 从入参ByteBuffer里直接得到的验证数据：	MessageDigest.isEqual(byte[], ByteBuffer.get(this.verifyData))	不相等 就要报 解密错误："The Finished message cannot be verified." 。单位整流函数ReLu: (-i) >>> 31) * i
																								>结束握手：TransportContext.finishHandshake()
																									>先是handshakeHash结束：outputRecord.handshakeHash.finish()
																									>再启动独立线程 来 广播握手完成事件：调用 注入的 handshakeListeners 来广播：new HandshakeCompletedEvent()
																								>事件捕获：Finished.captureEvent() 记录 EventHelper.logTLSHandshakeEvent()事件："duration =  ... TLSHandshake:..."	
																								>特别的：HandshakeProducer.produce()
																								--协商完成：SSLSocketImpl.conContext.isNegotiated 成为了true
																					>第二大轮 为 CHANGE_CIPHER_SPEC 类型 的ChangeCipherSpec里的 T10ChangeCipherSpecConsumer:SSLConsumer： 消费做的事情：
																						>从握手上下文handshakeContext里取 密钥相关的封装SSLKeyDerivation: LegacyTrafficKeyDerivation：
																							>从中取 客户端写密钥clientWriteKey: algorithm="AES" 的 SecretKey:SecretKeySpec
																							>从中取 客户端写初始向量clientWriteIV: algorithm="Tlslv" 的 SecretKey:SecretKeySpec 并用这个实例来构造一个 初始向量 new IvParameterSpec(byte[])
																						>从握手上下文里取密码套件：CipherSuite:name="TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384": 再取TLS12的认证器Authenticator：
																							>从密码套件里获取读密码套件：SSLReaderCipher: 转到构造 new SSLCipher.T12GcmReadCipherGenerator.GcmReadCipher()
																								>cipher的配置Cipher: JsseJce.getCipher(var4)->Cipher.getInstance()
																									>先getTransforms("AES/GCM/NoPadding"): 得到 List<new Cipher.Transform(>
																									>构造CipherSpi 封装到new Cipher()返回。 
																				--startHandshake()过程总结： "server_hello" --> "certificate" -> "server_key_exchange" --> "server_hello_done" --> "finished"					
																		>注意SSLSocketImpl覆盖了@getInputStream()/getOutputStream()输入输出流方法：返回的是SSLSocketImpl.AppInputStream/SSLSocketImpl.AppOutputStream
																			>写入过程：write()->转到sun.security.ssl.SSLSocketImpl.AppOutputStream#write(byte[], int, int)
																				>同样的检查：同样的SSLSocketImpl.this.ensureNegotiated(true)
																				>开始交付数据：SSLSocketImpl.this.conContext.outputRecord.deliver(byte[])
																					>检查序列号是否溢出：this.writeCipher.authenticator.seqNumOverflow(),溢出则要报错。
																					>计算分段并检查是否需要split负载payload:this.writeCipher.calculateFragmentSize(): 即然后 needToSplitPayload()
																					>查询噪声大小：writeCipher.getExplicitNonceSize(); 8个字节。
																					>先写到自己类的内存：SSLSocketOutputRecord:OutputRecord:ByteArrayOutputStream.write(var1, var2, var6) 因为自己就是 内存流的继承类。
																					>然后开始加密：this.encrypt(this.writeCipher, ContentType.APPLICATION_DATA.id, 5) 这个 cipher:"AES/GCM/NoPadding"  ->实现为sun.security.ssl.OutputRecord#t10Encrypt(sun.security.ssl.SSLCipher.SSLWriteCipher, byte, int) 
																					>然后将加密结果写到交付流：this.deliverStream.write(this.buf, 0, this.count) 即写到了 socketInputStream里。
																					>刷走即可：this.deliverStream.flush()
																			>读取过程：read()->直接转到了InputStream的模板方法:内部调用了抽象方法InputStream.read()->实现就是 ConscryptFileDescriptorSocket$SSLInputStream.read()
																				>对ConscryptFileDescriptorSocket的实现：
																					>先检查socket开启状态：ConscryptFileDescriptorSocket.this.checkOpen()
																					>取文件描述符FileDescriptor：Platform.getFileDescriptor(ConscryptFileDescriptorSocket.this.socket)->内部实现就是Socket.getChannel():SocketChannel 的fd属性的值。
																					>开始实际读取：ConscryptFileDescriptorSocket.ssl:NativeSsl.read(FileDescriptor) -> 就自然而然转到了本地方法@NativeCrypto.SSL_read(FileDescriptor,byte[])
																				>对 SSLSocketImpl$AppInputStream 的实现:
																					>先检查：1.是否协商好SSLSocketImpl.this.conContext.isNegotiated; 2.连接是否broken:SSLSocketImpl.this.conContext.isBroken 。3.输入流是否关闭：conContext.isInboundClosed()/inputRecord.isClosed()。4.输出流是否关闭：conContext.isOutboundClosed()/outputRecord:OutputRecord.isClosed()
																						>如果都没有：需要考虑重新握手：@SSLSocketImpl.this.ensureNegotiated(true) ->即用一个双重检查锁定来同步唯一一次调用握手：this.startHandshake(true)
																					>先考虑从内部的ByteBuffer里读取：4096总大小。this.buffer.get()
																					>没有available()则开始实际的读取: SSLSocketImpl.this.readApplicationRecord(this.buffer)
																						>读取完整的输入包的大小：conContext.inputRecord.bytesInCompletePacket()->从SSLSocketInputRecord.is里读取。
																							>先读取到5byte到header：其中前2个byte构成了包的长度:header[0]header[1] + 额外的2/5byte, 总长 >33093则认为"Illegal packet size:"。
																						>然后读取并转为PlainText: this:SSLSocketImpl.decode(ByteBuffer.allocate(size))	->内部SSLTransport.decode()->
																							>自然的到TransportContext.inputRecord.decode()：得到PlainText[] 。实现为：转到->sun.security.ssl.SSLSocketInputRecord#decode()
																								>先读取5byte的头：readHeader() 第4、5个字节构成 可读长度：len
																								>开始真正的读取：decodeInputRecord()
																									>如果 SSLSocketInputRecord.recordBody:ByteBuffer 不够 len,且position=0 则需要重新赋值:ByteBuffer.allocate(len) 后将limit设置到这里this.recordBody.limit(len)
																									>从 SSLSocketInputRecord.is:InputStream 读取len 到 recordBody里。然后recordBody.flip()开始读取出来进行解码：@this.readCipher.decrypt(header[0],recordBody)
																										>对于GcmReadCipher的实现：则 sun.security.ssl.SSLCipher.T12GcmReadCipherGenerator.GcmReadCipher#decrypt()
																											>先从之前读取的buffer里读取fixedIv.length开始的recordIvSize长度的byte到byte[], 封装到 new GCMParameterSpec(byte[])
																											>然后初始化密码字：this:GcmReadCipher.cipher.init(2, this.key, var5, this.random)->内部是用spi:CipherSpi.engineInit() 这里的SPI如：AESCipher/org.bouncycastle.jcajce.provider.asymmetric.rsa.CipherSpi/PBEWithMD5AndDESCipher
																											>然后认证器开始获取认证字节：this.authenticator.acquireAuthenticationBytes() 内部就是从右往左依次自增了block:byte[]的前8个字节，某一位到0为止。
																											>密码字继续this.cipher.updateAAD(上一步byte[])： 转到com.sun.crypto.provider.AESCipher#engineUpdateAAD(byte[], int, int)->直到com.sun.crypto.provider.GaloisCounterMode#updateAAD()写到内存流中。
																											>开始真正的对输入解码：this.cipher.doFinal(ByteBuffer, ByteBuffer);->this.spi.engineDoFinal()-->com.sun.crypto.provider.CipherCore#update(byte[], int, int, byte[], int)-->this.cipher.decrypt(this.buffer)开始了真正的解码。 com.sun.crypto.provider.PCBC#decrypt()->this.embeddedCipher:SymmetricCipher.decryptBlock()->com.sun.crypto.provider.AESCrypt#decryptBlock()最后这方法里就是纯粹的解码了，只有数组操作和位运算。
																											>封装结果到new Plaintext()里：返回。
																									>解码完成 合并到 handshakeBuffer里：
																									>添加数据到 handshakeHash 里： 	
																									--输入解码完成。	
																							>再将PlainText分发：TransportContext.dispatch(PlainText) 分发就分PlainText.contentType:ContentType 类型 专门处理：
																								>HANDSHAKE 类型：则 handshakeContext.dispatch()
																									>再读取PlainText的第一个int数映射的HandshakeContext.getHandshakeType()类型 而 分 SSLHandshake 类型 专门处理：
																										>SSLHandshake.HELLO_REQUEST:SSLConsumer 类型： 开始消费.consume()
																											>DHClientKeyExchangeConsumer的实现：
																											>ServerHelloDoneConsumer 的实现： 
																												>生产者生产：HandshakeProducer.produce()
																													>ServerHelloDoneProducer.produce() 实现：1.先构造消息new ServerHelloDone.ServerHelloDoneMessage() 2.写到输出流里：ServerHelloDoneMessage.write(ServerHandshakeContext.handshakeOutput) 3.输出流刷写outputRecord:HandshakeOutStream.flush() .4. 新增 消费者到handshakeConsumers：SSLHandshake.CLIENT_KEY_EXCHANGE/SLHandshake.FINISHED, ChangeCipherSpec.t10Consumer
																														>flush()最终：
																															>@先加密this.encrypt(this.writeCipher:SSLWriteCipher, ContentType.HANDSHAKE.id, 5)-->加密过程类似：最终@sun.security.ssl.SSLCipher.T12GcmWriteCipherGenerator.GcmWriteCipher#encrypt()
																															>再将加密内容写到交付流里：SSLSocketOutputRecord.deliverStream.write(this.buf, 0, this.count) ->flush()也即socket输出流的flush()
																							>再将PlainText转移到入参的ByteBuffer[]里: PlainText.fragment:ByteBuffer
																					>读取到buffer之后则类似上述：先是赋值给了内部SSLSocketImpl.buffer, 读取buffer里的内容到byte[]返回。只读取一个byte。	
																		>仍然封装socket的输入输出流到一个Sourc/Sink		
																		--注：sslSocketFactory的来源：OkHttpClient.sslSocketFactory()/newSslSocketFactory()-->来自Platform.get().getSSLContext().getSocketFactory(): sslContext来源SSLContext.getInstance("TLS"),且需要初始化init()	,实际返回的就是new SSLSocketFactoryImpl()-->createSocket()返回的就是 sun.security.ssl.SSLSocketImpl	
																			>如果来源于conscrypt: 则 OpenSSLSocketFactoryImpl为工厂，则创建 Java8FileDescriptorSocket/ConscryptFileDescriptorSocket, 最后都是 交给了 NativeCrypto.SSL_do_handshake() 这样的native方法。
											>RetryAndFollowUpInterceptor的拦截的执行过程：真正的构造了StreamAllocation对象--并调OkHttpClient.connectionPool()来获取了连接池---而连接池来自new Builder()构造方法里new ConnectionPool()。		
					>调用代理接口的方法：执行https请求，得到的对象是json对象，反序列化为对象后传递给请求方:onNext()	
				>发布mqtt事件/信息：实际转给了com.chehejia.iot.sdk.mqtt.a#a()方法处理。
					>准备阶段：新建了HandlerThread对象并跑起来；这个HandlerThread的Handler 就是 com.chehejia.iot.sdk.mqtt.a.a 实例；
						>这个线程运行执行的内容：取mq队列里的Msg,来执行msg.Handler:target.dispatchMessage()发送；
							>如果msg.callback非空：则message.callback.run()调用。
							>否则调Handler.handleMessage(Msg): 都是利用Binder内存消息通信。
						>IIoTService实例的创建：Stub.asInterface(var2) 内部：new IIoTService.Stub.Proxy(IBinder) 这个IBinder是ServiceConnection回调创建的。	
					>封装消息发送阶段：调com.chehejia.iot.sdk.mqtt.a#a()实际用MessageReceiver:f.messageArrived()发送。
						>该方法内部则调Message.sendToTarget()发送: 然后 调 Handler.sendMessage(Msg) 这个就是消息入队。
					>再转给com.chehejia.iot.service.IoTApp: 依次调用@getServiceHost(@getInstance())处理得到结果作为ServiceInterface实例-否则取ServiceManagerImpl
						>再转给com.chehejia.iot.sdk.service.IIoTService.Stub.Proxy#publishMessage(): 内部最可能交给了android然后以 shell方式发送了消息。
		>根据包描述信息里的文件路径下载包：IoTClient.getOicManager().downloadFile()开始 。 来自com.chehejia.ota.OtaClientImpl#startDownload()方法。
			>转到com.chehejia.iot.sdk.oic.OicImpl#downloadFile()处理：
				>先下载证书：OicApiRequest.getDownloadCredentialV2()
					>转到实际下载接口：使用HttpApiManager代理com.chehejia.iot.sdk.oic.api.OisApi接口调用它的@getReadSts(identify, fileKey, stsType, durationSeconds)方法：此方法的注解@GET("/chehejia-service-ois-app/ois/v1/sts/read")
				>得到证书之后：开始实际的下载：分BOSService或者OSService: com.chehejia.iot.sdk.oic.service.BOSService#download()
					>启动独立线程异步执行：先构建http客户端AndroidBOSClient -->计算下载calculateDownload()分割出一个个检查点 -->断点下载/分段下载downloadWithCheckpoint()，每个点封装出一个下载任务DownloadTask提交到线程池 --> 无限等待任务完成，结果PartResult排序--->外部有序打印所有失败部分part的失败信息，最后调异常处理回调。
						>构建客户端：AndroidBOSClient根本为了封装凭证credential[accesskeyId/accessKeySecret/securityToken]。内部bosClient=BceHttpClient/BosClient 都是采用http方式。
						>计算下载点：1.先获取元数据：bosClient.getObjectMetadata(bucketName, objectKey) --> 元数据包括内容长度，用来划分为若干个指定大小的段。
						>分段下载：每段下载为独立的任务，每段明确了长度，每段有序号，所以可以将每段写入文件指定偏移量--使用RandomAccessFile实现写入request的指定的文件，baidubce的oss读取客户端实现获取。
							>指定桶名-对象key-分段起止位置：然后使用bosClient.getObject(objectRequest)执行获取指定的内容：
								>实际构造http请求时：对Authorization 部分 很多sha256的结果的拼接, 对x-bce-security-token报头部分则是 凭证bceCredentials的securityToken部分。
								>实际执行http请求的客户端：OkHttpClient
								
				--完成之后request指定的filePath就创建了一个下载的文件：开始下面的 解密和验证：decryptVerifyPackFile()				
	>解密升级包：			
		>获取包描述信息：
		>对称密钥解码：
			>aeskey:
			>aes_iv: 
				>功能：防止子序列修改。iv=initial vector初始向量。
		>文件包分段解密：
			>每个1Mbyte为一段进行AES解密：
			>解密结果append到目的地文件：
	>验证解密后的升级包：
		>摘要验证|完整性：
			>计算新文件的SHA256的摘要并BASE64编码：D
			>得到的摘要和获取的包描述信息里的包摘要比较 ：A
				>结果满足 相等：C 
					>正确：A 
				>不相等：C 
					>文件已不一致：A /D (D是一种认识)
		>签名验证|发送方正确：
			>公钥的签名 的验证：
				>公钥解码：
				>公钥的签名解码：
				>根公钥解码：
				>用根公钥+公钥签名来解密出结果 和 公钥比较：A 
					>相等： C  
						>正确： 
					>不相等： C 
						>公钥签名不是根私钥加密结果|公钥签名和公钥有一个被破坏了|根私钥不对：D 
			>文件摘要 的 验证： 
				>公钥的解码: 
				>文件签名的解码：
				>上一步生成的文件摘要的解码：
				>用 公钥 + 文件签名 来解密出结果 和 文件摘要 比较： A 
					>相等：C 
						>验证升级包签名成功：
					>不相等： C 
						>抛出异常：
		>包描述信息保存：A 
			>保存在本地的 meta.json 文件中：
		>包文件和包描述文件 压缩为一个文件放在本地：A 
			>后删除包文件和 包描述文件。
	>验证成功后执行回调函数：		
>补偿任务的定时执行：
	>无论条件都要扫需要重发的任务：C
		>扫需要重发的任务：A 
			>扫任务对应的要推送的车：A
			>验证任务：A 
			>发送任务: A 
				>更新重发次数：A 
				>发送给影子服务：A
			>去除重发标记：A	
	

	
	
>java加密api简介介绍：https://www.jianshu.com/p/a3af4049c8ca	
	