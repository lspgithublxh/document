>pull-stream的架构设计：
	>三个过程：
		>封装过程：从最原始的Readable对象/函数开始，作为输入 调第一个 Through函数 而生成第一个包装了 原始Readable对象/函数的 新的Readable记作 W1, 然后将W1 作为输入 调用第二个 Through函数 而生成了W2, 如此直到Wn， 然后将Wn作为 可读对象 输入 调用 sink的 启动方法 开始 这个拉取的过程。
			>封装过程的本质目的：将 上一个readable的引用 封装到 当前 readable对象的环境引用里，使得执行当前这个readable函数 可以找到 上一个readable，从而调用它而转发继续执行下去。
		>请求过程：从 sink 开始，先生产一个自己的cb, 然后调 入参Readable 的方法，方法的入参就是 这个cb 和 一个 end参数， 而这个Readable是 Wn, 因此就到了Wn 的实现方法：它最后会调封装过程中传递到自己局部环境中的上一个Readable对象的函数引用：将end信息传递，而构造一个封装了 入参中的cb即调用者传递进来的cb 的 一个自己的新的cb 作为 另一个入参，于是 开始Wn-1这个Readable函数方法的执行： 直到 最原始 的Readable, 会直接生产 数据，而调 传过来的W1的 cb的方法，入参就是end+data。
		>响应过程：从w1的cb的执行开始，最后会调 它封装的上一个readable的 cb，继续传递下去，如此，直到 Sink的cb，从而sink就获取到了数据。
		
	>方法栈角度：看依次入栈了哪些方法，弹出了哪些方法。	
	
>	