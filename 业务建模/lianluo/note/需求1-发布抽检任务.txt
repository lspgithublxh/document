>任务创建：没有涉及到 配置升级策略。具体和VIN有关。
------------具体需要的做的事情：
	>创建任务：
		>如何给汽车VIN配置 升级策略？：车型车系使用的。所以考虑给单独某辆车配置 默认策略？---还是动态修改。--还是强制不用其他策略，直接代码中的策略？--只要判定这个任务是 抽检任务即可。
			>汽车是如何使用策略的？：何时 什么业务中。
			>任务触发方式 可以调整。
	>查询汽车当前是否已有升级任务? 有则取消。---查看汽车升级状态表ota_vehicle_upgrade_status该汽车的最新的升级状态：
		>如何判定：
			>1.下发消息已发送的证据：验证通过后，会下发(ota_vehicle_download_notice保存:任务id+车vin+包id+版本+下发成功代表的messageid)；任务isExecuted会更新为已经执行。下发服务(iot-device-shadow)下发内容(taskid/version/vin/packagefullid/upgradetype)
				>包id来自：
					>目标版本为ota1支持的时:ota_package_total_full (通过 车型车系版本 三个参数 查询) 取id 。 ota1版本：版本号中间段=1
						>验证：对正式任务有 包状态 限制。
					>目标版本为ota2支持的时：通过ota-service 间接 从 ota_package 取(通过 车型车系版本 三个参数 查询)id
						>验证：对所有任务有 基线包描述信息存在：通过 baseline_id 查 ota_baseline_description 里的 description存在。
				>升级策略验证：一句话描述。
					>该车系车型默认策略存在：  即 车型车系id 在 ota_upgrade_strategy_veh_relation 中 。
					>该车系车型所有策略id中：所有策略id保存在 ota_upgrade_strategy_veh_relation 中 。
						>每个策略id:  关联到的ecu 列表 中 不能存在 没有配置 升级顺序的ecu。
				>车辆校验：一句话描述。
					>vin列表不能重复和为空：
					>对每辆车vin:
						>车型车系和平台一致：ssp-vcs-service
						>对工厂任务要求车的状态必须是总装下线/ok下线/打印合格证 之一：其他类型任务 无限制。车的状态来自 ssp-vcs-service
						>黑白名单要求和车辆与任务匹配要求和车辆当前升级状态要求：
							>1.非诊断仪来源的：需要黑名单校验(ota_vehicle_blacklist);不是强制升级白名单上的汽车需要(ota_vehicle_whitelist):车辆用途和任务类型匹配，车辆状态和任务类型匹配,固件版本不能为0，最新的车辆升级状态表明车辆的 升级触发类型 如果是普通任务触发的 则表明的车辆升级状态 不能还在 升级中/等待升级中/回滚中(相当于上一个任务触发的升级如果还在执行，那么本次的任务就不再下发)。
						>目标版本的要求：1.和当前版本相同的且不是诊断仪来源则 必须 在同版本白名单中；2.低于当前版本的 必须 在 降版本白名单中。
						>支持配置字的变量车型的汽车的配置字必须存在：汽车的配置字来自 ssp-vcs-service, 是否支持来自mongodb
		>如何取消：汽车升级状态 查看 ，如果正在 升级 如何取消？未开始的任务如何取消？
			>汽车正在执行升级任务能不能被终止的方法？
	>是否下发抽检任务？：任务验证：
		>基线包校验 阶段：版本不比较。 全量包
		>升级策略校验 阶段：默认升级策略存在，且为：版本不比较。 全量包。
		>车辆信息校验 阶段： 当前版本 等于 目标版本时 无 限制 。。其他同之前。
	>汽车主动下载升级包描述信息和升级包文件？：收到下发命令后。同时还下载其他信息。
		>如何给汽车返回完整正确的升级包描述信息？：汽车请求中带有 当前版本和目标版本
			>统一要求：对车辆和任务的要求
				>黑白名单限制要求和车辆与任务匹配要求和车辆当前升级状态范围要求：
				>包id和基线描述存在要求：通过 车型车系版本 就要匹配到。
				>默认升级策略存在要求 和 车型车系的每个策略的每个ecu都要配置升级顺序 要求：
				>支持配置字的变量车型的汽车的配置字必须存在的要求：
			>查找汽车的升级策略：来源要求：先精确匹配后 粗略匹配：即先从汽车-策略 关联表里找：ota_upgrade_strategy_vin_relation	，没有才从 车系车型-策略 关联表里找。ota_upgrade_strategy_veh_relation
			>查找汽车的升级包：
				>目标版本为ota1版本：要求：1.主体信息 来源为ota_package_total_full，且是通过 车型车系版本 得到的 -且有 包状态要求；如果升级策略的包类型不是全量包 且存在 增量包，则主体信息采用增量包。2. 是否版本比较 则看 升级策略中说明的如果不是要比较而是自动 且此时 上一步采用的不是增量包 且 当前版本和目标版本不同 则也是要比较；3. 加密大包的对称密钥的解密 调chehejia-service-bks-app服务实现；4.升级提示信息 从ota_package_total_full获取。5.升级结果 信息 也是从 ota_package_total_full 获取。	5.ecu包信息列表 来自包关联的ecu列表 经过 策略关联的ecu列表的过滤 之后的 ecu列表：策略关联的ecu列表信息 从ota_upgrade_strategy_ecu_relation可以ecu列表然后需要经过排除汽车的配置字设定的需要忽略的ecu集合，包关联的ecu列表信息 从 ota_package_total_full_ecu/ota_package_total_delta_ecu 获取，过滤方式为：包关联的ecu需要在策略关联的ecu列表里 且 策略关联项表明该ecu配置了升级顺序，则这个ecu id符合要求，接着获取它的全包信息ota_package_ecu_full/ota_package_ecu_delta(含fileName/fileSize) 和 基本信息 ota_base_ecu，ecu包类型(组件包/ECU包)
				>目标版本为ota2版本：要求：1.直接从ota-service查询出包实体(含ecu包信息列表)：使用 vin+当前版本/目标版本+包类型。2.需要补充的信息：是否版本比较-仍然是要求 全量包+目标/当前版本不同。3.需要对 ecu包信息列表进行过滤：要求ecu包信息，必须在策略ecu列表中，且策略ecu项必须配置了isUpgrade=1要升级。
			>升级包序列化后持久化：存到mongdodb.
			>升级包描述信息就是这个“升级包”信息：返回它。
		>如何给汽车返回完整的包？：汽车自己如何解密这个包？(跑在汽车上的软件执行的事情)
	>汽车主动上传进度信息？：
		>如何接收处理汽车上报的进度信息？：汽车上报请求中带有 vin +事件信息列表。
			>要求按事件类型处理：
				>下载包的进度报告：事件信息转为进度实体 存储到 ota_vehicle_download_progress
				>升级进度报告：事件信息转为进度实体 存储到 ota_vehicle_upgrade_progress
				>升级状态报告：事件实体转为状态实体 存储到 ota_vehicle_upgrade_status 。 然后 要求： 1.查看报告信息 是否是 升级失败信息(条件：报告中的错误类型被包含 | 错误类型=下载失败/准备升级失败/回滚成功-失败/升级失败/外设升级失败)： 判定为是 升级失败信息 报告  且 触发类型 不是 ADI(售后诊断仪注入)， 则要发送消息：接收方=ota运营小助手标识。2.判定汽车为销售车 且 已激活 且 触发类型=强制升级类型/普通升级类型 且 报告的错误类型=升级失败/回滚失败/回滚成功/外设升级失败/内包含, 则要创建工单并发送：升级失败工单群组。3. 根据指定错误类型list 查看汽车升级状态表  是否有错误记录，如果有 则 要 机车日志回放(回读车机上某一时间段内的日志ssp-vds-service)。 。 4.ota任务补偿：(条件：已激活的乘用车 & 错误类型=下载失败/准备升级失败 & 内异常不包含)补偿动作： 通过messageid查ota_vehicle_download_notice得到taskid (或者通过vin查任务-vin表得到匹配的taskid), 得到taskid查taskvin表得到补偿次数，不可以补偿 则调 mms-api 来发出不可以补偿的信息；可以补偿则验证后 更新taskvin isResend=true。 5. 错误类型的保存(条件：任务类型=强制升级类型/普通升级类型，错误类型=升级失败/回滚成功/回滚失败/外设升级失败) 6.手机消息推送：新版本推送/不满足预判条件-升级模式进入失败/通知VCS更新车辆固件版本& 推送升级失败通知z推送升级成功通知/推送升级失败通知..。。7.升级状态 以 mq消息形式 发送 到一个主题(ota-batch服务、圈子服务订阅了)
				>升级命令报告：触发定时升级、立即升级、取消定时升级时会上报此事件。事件实体转为命令实体 存储到 ota_vehicle_upgrade_command
				>清E方结果报告：完整性检查  后 事件实体转为 清E方实体 存储到 ota_vehicle_eeprom_clear。
	>升级失败信息：前2个要做。
		>汽车如何开始下载：


>问题：
	a.抽检任务的策略的实现：
	-----如果新增一批策略，则需要 在 汽车上传进度消息 完成的时候 要 找到taskid ---并判定为 抽检任务的升级完成消息/异常消息 ，然后将升级策略假删除。。。劣势：可能会影响其他任务的策略。
			>抽检策略和汽车关联的创建时间：抽检任务创建时候太早？ 任务下发消息时候 ？ 车辆获取 升级包描述信息的时候？---此时肯定可以的。
	-----如果不新增策略，而是直接在获取包描述信息时 直接 设置 包类型、是否比较版本 等实质的策略内容。。劣势： 没有策略记录。
	b.抽检任务的验证：
	----专门验证时，对同版本白名单 不做限制。
	---其他不变。
	c.创建任务的取消：必须 在 创建 任务-汽车vin 关联的时候，因为这个时候才体现了 任务 的时间关系，这个时候取消 掉 同一辆车的 尚未开始的任务(包括其他抽检任务)都取消--假删除状态即可。

	OTA专项群：工单群消息发送：https://open.feishu.cn/open-apis/bot/v2/hook/3d1b0c33-a7f6-4ce5-a808-a644c1646656
	>修改：
		>不当作策略：仅仅存储这个信息到这个抽检任务里。


>需求涉及变动：从影响到的 流程到环节：
	0.验证任务时：抽检任务无白名单要求。
	a.创建任务时：增加了保存 该任务的 抽检任务特征(但不保存状态信息)，扩展信息形式保存。
	b.定时推送任务时：增加了 判断抽检任务然后 让该汽车的 其他任务都暂时取消--即只取消对它的任务--因此只能task_vin删除--从而后面不会推送。
	c.汽车查询 包描述信息时：在策略部分 使用 定制策略。
	d.查询任务时  增加 了 对任务的排序。
	e.补偿推送任务时，由于是通知vin +taskId + version + packageId + upgradetype  所以 不用做处理。
	f.汽车上报进度信息时：增加同步到“工厂OTA专项群”。
	----
	a.抽检任务校验时：无白名单校验
	b.抽检任务创建时：保存任务的升级策略。
	c.查询任务时  增加 了 对任务的排序。
	d.定时推送任务时：增加了 判断抽检任务然后 让该汽车的 其他任务都暂时取消--即只取消对它的任务--因此只能task_vin删除--从而后面不会推送。
	e.汽车查询 包描述信息时：策略获取部分应用策略覆盖：任务策略>默认策略。
	f.汽车上报进度信息时：增加同步到“工厂OTA专项群”。

>测试进展：
	>jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder] 
		>HEAP="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m"
	>jmeter -n -t testplan/RedisLock.jmx -l testplan/result/result.txt -e -o testplan/webreport
	>jmeter -n -t Tree.jmx -l result.txt -e -o webreport
	>验证任务 接口： 
		>jemeter吞吐量：Throught 176 即 每秒完成的请求数。
		>jconsole jvm活动线程：284， 守护程序线程：276, 则认为 真正直接处理用户请求的线程数=8个。 qps=176, 则每个线程每秒平均处理 22个请求，则50ms每次请求的耗时。当并行请求结束后，活动线程直线下降到90。

	

>已知条件：
	1. 任务发布（web）：
	  参考formal_task.html、formal_task.js
	  关键点：任务校验（taskVerification）、任务创建（submitPublishTaskForm）
	2. 任务推送（app）
	  参考 OtaTaskInfoJob
	  关键点：任务业务校验（taskValidation）、执行推送（executeSendTask）
	3. 车辆收到升级通知
	4. 获取升级包描述信息（app）
	  参考OtaPackageController
	  关键点：获取固件升级包描述信息（queryPackageTotalInfo）
	5. 车辆下载升级包文件
	6. 解密验签，开始升级
	7. 车辆上报升级数据（app）
	  参考 OtaReportService
	  关键点：事件上报（reportEvent）



------------------------------------------------------------------------FIX bug------------------------
>性能优化：
	>任务校验：
		>升级策略校验 阶段: 
		>车型关联的策略：
			>性能优化：
				>措施1: 策略关联的ECU查询： 给频繁的查询 添加索引 ALTER TABLE ota_upgrade_strategy_ecu_relation ADD INDEX idx_strategy_ecu(`upgrade_strategy_id`,upgrade_order)
				>措施2：车系车型的默认策略查询：ALTER TABLE  ota_upgrade_strategy_veh_relation  ADD INDEX idx_strategy_veh(`vehicle_series_model_id`, `is_default`)
				>措施3：查询车系的每个策略对应配置的 ECU升级列表 是否使用缓存？ 甚至有漏洞？
					>缓存的使用方法：查询时、变更时数据时。变更数据时连带失效掉redis中的数据。所以对本地查询的数据，一定要使用变更(监听数据库binlog变更可能是最好的-canel)(或者统一数据库拦截器--检测到变更sql--则将对应的reids缓存删除掉, 同理对应的查询语句也可以这样处理-查询的时候直接先查数据库---但是要求这种拦截能够不访问数据库；mybatis拦截器/druid拦截器都进行尝试)(甚至在变更的时候发送一条消息-让监听者可以收到消息)。
						>缓存实现：方法拦截器，直接从查询层/保存更新层开始。
						>缓存实现2：spring-cache 
					>微服务调用：则一般不使用缓存：或者缓存较短的时间。比如 车系车型信息。但是能够监听 汽车变更的消息，即 如果 变更的时候 发一个消息，那么收到之后再更新也是可以的。缓存失效时间策略+变更消息监听。
				>措施4: 业务流程优化：减少无端的逻辑、重复冗余的逻辑，不精简的逻辑，扩展性有问题的逻辑。业务流程扩展性。各个环节 更加 接口化、异步化、并行化。
				>措施5：异步、并行的使用(可以并行的串行都并行起来)，可以并行完成的事情并行调用。如用 jdk.parallelMap。如多线程。//注意线程局部变量的 改变，统一的异步接口，这样可以在异步的时候将线程局部变量都发送给目标线程---即提交任务的时候 将 获取 当前线程局部变量里的数据取出 然后在调用任务的时候再把数据捆绑进去(因为原线程可能已经被销毁了)(光通过方法参数是不通用的,)。
				>措施6：部署更多的实例，并行分割处理各个请求。
		>车辆校验： 
			>性能优化：
				>车辆信息获取：使用了缓存但没有批量接口，单个获取，且没并行获取。/ssp-vcs-service/ 这个服务。
				>*车辆是否在黑名单中：应该批量/缓存/并行/索引，ALTER TABLE `ota_vehicle_blacklist` ADD INDEX idx_vin_blacklist(`vin`,`is_delete`)
				>*车辆是否在白名单中：应该批量/缓存/并行/索引/offset分页，ALTER TABLE `ota_vehicle_whitelist` ADD INDEX idx_vin_whitelist(`vin`,`type`,`is_delete`)
				>*车辆升级状态：还是建议批量/并行。索引已经有了。
			>性能优化2：
				>验证并行：1.单个并行(可能导致某次队列满而变为主线程执行--此时不能再加入队列--如果改成abort则直接返回了---所以最好还是抛出异常--然后再尝试丢入线程池--尤其单个任务执行的时间非常长的场景)、2.块并行，给多个id 让一个worker一次串行执行。
				>验证并行2：1.分布式计算，将id分块 并行发送给 计算节点，然后等待验证的结果，直到全部id块 都验证成功了 然后 返回验证 成功， 如果计算节点都不行 则退化为 本地计算。
	>任务保存：
		>当前保存的方式：设置id的方式并发的情况下是错的。所以应该改为用户手动设置值/或者使用拦截器设置。
	>任务推送：
		>取消任务时：不要直接更新，要先取出list, 后再更新。否则失去了更新的id list, 无法记录下来。
		>并行执行任务：可能不可以并行的执行。
		>并行下发一个任务的汽车：
		>重复推送一个消息会怎样？：
		>定期查询已经完成的任务 但是 还有车辆 没有推送 完成？：补偿推送。
	>后台获取VIN列表：当文件上传时：应该保存到一个地方oss, 然后从这里下载下来处理。
>数据关联：什么的 什么信息。什么概念的什么概念。什么和什么是有关联的 并记录了这种关联。什么和什么的关系。当前已经关联起来的数据。(关联可以存在关联者表里，但更应该或者客观上在独立专门的关联表里)
	>车型车系：
		>关联：
			>包信息：
			>升级策略：1.表示该车型车系的所有升级策略，其中有一个策略标记为默认策略。
	>车：vin
		>关联：对应 
			>升级策略：1.表示该车 的所有升级策略(无默认策略,也没有这些策略的优先级指定)。
			>黑名单：1.表示该车的 拓展描述信息。
	>ota包： 
		>关联： 
			>基线版本：
			>包文件：
	>升级策略：定义：指示汽车对各个部件的软件进行升级(调度/指挥/能对升级过程操作过程说明)
		>关联： 
			>ecu: 1.表示 该策略要求 对该ecu 升级时 要在什么条件下才进行(即指示这个ECU的升级顺序、升级方式、是否升级)
	>基线版本： 
		>关联： 
			>汽车： 
			>基线包描述信息：1.表示 每个基线版本 的扩展描述信息：如升级成功的描述。
	>包文件： 本身独立无依赖的(完全是关于文件本身的信息)		
	
-------------------------------车型分组
-------------------------------OTA后台增加交付任务类型	
>任务类型增加交付任务。
>创建任务：复用 ota/open/api/task/publish 接口。
	>增加特殊验证：限制推送基线为正式基线
	>验证任务：统一的，车辆校验时 限制车辆状态为打印合格证及之前状态。
>补偿任务job: OtaTaskCompensationJob 未作改动,会下载失败补偿重发。仍然每天7、16点执行。
	>查询OtaTaskVin里要求重发的所有任务：isResend=true 的所有任务。按任务id分组。
	>任务校验：统一的。taskGeneralValidation():包、策、车
	>校验成功的任务：发送，重发次数+1，状态修改为不重发/结束。
	>校验失败的任务：不发送。状态修改为不重发/结束。
	
-------------------------------性能优化： 
>定期推送任务时：也需要优化，补偿任务job也需要优化？？
>测试：跑出70个可行的：
	>32155个VIN: 正常验证11m, 全部不通过。而通过线程池，则2min,但是遗漏了50个左右---因为线程一直抛异常？--否：是list添加异常。
>总结：1.并行验证。2.并行下发升级通知。3.黑白名单缓存。4.数据库新增索引若干。5.并行补偿。
	>并行下发测试：
	>
------------------------------待解决问题：
>升级任务下发：多实例部署下，会重复查询 重复发送？	
	>解法1：使用redis缓存正在处理的任务 但是会导致 每次还是重复查数据库。都会查，只是这种方式有数据返回。
	>解法2：先更新处理时间和更新id: 成功了则查询这个id对应的任务，所有相当于行锁定，且设置锁定时间。
>插入数据的主键id是直接查询的：多实例下和并行线程下可能都有问题？  所以 不要使用 刚刚插入的数据的主键。。。得在表中增加其他唯一键？
	>问题特征：
		>创建任务的时候：
		>事件上报的时候：未发现。
		>自增主键：且不适合 分库分表---因为数据id会重复---所以数据不能重新分布。tk-mybatis的做法：SELECT LAST_INSERT_ID() 来填充。。所以批量插入就是有问题的？
		----使用mybatis-plus？？  先查询SELECT LAST_INSERT_ID() 后插入的做法。这个sql且不指定表，
		>更大的问题：不适合做事务。如果在一个事务里，那么前后是不知道id的，这样完全无法实现。
	>问题方案：
		>方案1：-- 先查 后更 :更新成功 则再用：本地存储着。 效率不高，可能反复更好几次。
			>自动化方案：避免使用 select LAST_INSERT_ID() 。提供一个id生成方案。
		>方案2：使用 MysqlIntercepter, 不行。除非使用MybatisIntercepter----第一层的拦截器--直接拦截mapper来设置id。	
>分页问题：查全部数据，如车辆库管理--白名单列表。查全部数据，然后取部分？
	>解决方案：
		>数据批量缓存？:缓存id?
		>利用数据库limit语法+id < ...
		>使用：PageHelper.startPage(pageNum, pageSize) ：PageParams<OtaPackageTotalFullEcu> params = new PageParams<>();
															params.setPageIndex(pageNo);
															params.setPageSize(pageSize);

															// 按页查询
															PageResults pageResults = queryPageResults(params, example);
			也很麻烦。
>增删改查基本功能都太麻烦：！！！写一堆接口。			
	>方案1: 写一个共同的服务，实现统一的基本功能。
	
>事务和异常没有引入：服务的一致性如何保证？	



---------------------------------------------TBP实践

1.OTA升级任务下发性能优化方案
>明确问题：
	>真正目的：避免OTA任务无法下发,影响包的升级。
	>理想状态：云端支撑单次推送百万车辆级别，校验时间分钟级。
	>现状： 数千车辆名单，等待校验20分钟，无校验结果返回。
	>问题：云端在分钟级内单次不能推送给车辆的任务有接近百万级别个。	
>分解问题：
	>when: 查询任务时、任务校验时、分发任务时、任务状态更新时
		>what: 分发任务时：任务的车辆信息查询、任务的车辆升级策略校验、任务的车辆状态校验、任务发送给车辆。
			
	>优先解决的问题：任务发送给车辆时。
	>流程： 任务封装为目标接口要求的形式、调用影子服务发送任务、判断返回结果看是否发送成功、失败后的记录和补偿。	
	>问题点：调用影子服务发送任务。 
	>设定目标：相同时间内 单实例发送任务数 达到原来的 10倍。
	>把握真因：影子服务本身耗时、因没有数据依赖所以可以并行发送但没有使用并行发送、影子服务的错误率高可靠性低 。
	>对策：主线程单独发送、多线程并行发送、多节点分布式发送。
	>具体实施内容：采取线程池的方式 将任务并行发送给汽车，当线程池中工作线程数达到设定的最大值时 由主线程执行任务发送。
	>评价结果和过程：
		>评价结果：并行改造后 任务单位时间内的发送量 达到了原来的10倍左右。
		>评价过程：改造过程中发现统计的实际执行的任务数少于提供的任务数，调查后发现是 一个非并行安全的数据结构导致，替换为并行安全的数据结构后问题解决。
	>巩固成果：在开发过程中新编写的线程池和线程池使用工具 发挥了较大作用，所以提取为一般工具，当其他业务有任务需要在内存中并行执行时，可以直接方便的使用。
		>下一步改善：车辆校验的并行化。
		
>基本概念文档：https://li.feishu.cn/file/boxcnucoe7rgbvF3exfoQaOnWjc
>OTA业务文档：https://li.feishu.cn/docs/doccnZFiPBRwkhpQvxvWd9Fwqgh#

	
		
--------------------------X01任务管理
		
		
		
----------------线上问题：
  ---首次升级
  
  1.服务或者客户端ssl 证书过期或port重置
	>3到8个taskNum,所以线程池大小为3-8; 采用 最大=最小线程大小，阻塞队列存任务；
		>每part下载100ms,则 10s差不多下载完成。
		>每1s,则 100s 即一分多钟。而请求的凭证1800s, 且开始下载 时刻接近于得到凭证时刻。。
		
		
	>是否百度云有并行限制？
	>建立ssl的过程 不对 导致？   重复建立？ 或者 端口重置？？底层了解是必须的了。		
	
	
--------------任务查询性能问题：
>优化办法：1.查询 结果 需要 去重 。 2. 查询需要分页。 3. 去除 在 循环里查询的逻辑。	
            //需要去重
            Set<Integer> dinstinctTaskIds = Sets.newHashSet();
            taskIds = taskIds.stream().filter(dinstinctTaskIds::add).collect(Collectors.toList());
			

