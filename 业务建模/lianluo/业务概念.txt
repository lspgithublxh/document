>基本领域概念：建立领域模型，业务模型。
	>汽车：
		>属性：
			>车系：维护 车系、车型、车系变量。
			>车辆用途：在车的基本信息里。所以要用 vcsService:ssp-vcs-service 服务。 
	>ECU: 版本
		>属性：
			>名称：
			>硬件零件号：
			>软件分支：
			>供应商id: 
			>是否支持OTA差分：
				>差分算法：
			>转换器：
			>默认升级方式：
			>默认升级顺序：
	>升级包文件：package
		>属性： 
			>文件名：
			>文件大小：
			>文件存放路径：
			>文件加密：
				>加密算法：
				>密钥：
					>公钥：
				>摘要：
	>OTA：
		>基线id: ota_baseline_id
			>基线版本：
			>基线阶段：
			>创建来源类型：SCM/TEST
		>版本号：version 
		>升级包唯一标识：unique_desc
		>类型：全量ecu升级包、部分Ecu升级包。
		>状态：已制包、测试通过、已发布、已删除、审核通过
		>打包人：
		>审核人：
		>测试人：
			
>扩展领域概念：
	>任务：
		>属性： 
			>任务名称：
			>任务类型：
			>任务状态：
			>发布策略：
			>升级类型：
			>该任务的要升级的全量包id: 
	>升级策略： 
		>属性： 
			>升级条件：
			>升级包类型：
			>是否比较ECU版本：
			>策略创建人：
>活动的关键交互过程：OTA活动的交互过程。
	>角色：
		>汽车： 职责汇总：接收升级通知、从云端下载升级包、验证包、开始升级、上传进度报告。
		>云端：职责汇总：负责管理任务、下发通知、接收报告、接收和下载任务
		>运维人员：职责汇总：负责创建任务
	>交互过程：按时序表述。
		>云端：创建任务-->下发升级通知 ----------->接收下载请求并返回数据----接收下载进度报告并保存--->接收升级进度报告 并保存。
		>汽车：-------------------收到升级通知--->下载升级包、上传下载进度-------------------->验证包、开始升级、上传进度报告、升级完成-->
	---系统任务：车辆软件包升级 控制管理 系统。	
>事情推进图： 从推进过程 看 设计的业务动作/考虑的业务情景/创造的业务价值；
	>创建任务的推进过程：从校验到创建。
	>任务推送的 推进过程：就是事情的明确过程，从头到尾的明确过程，自顶向下的明确过程，明确过程就是提问过程，就是明确一系列问题的答案的过程。 
		>什么时候推送？
		>推送什么任务？：哪些任务才是需要推送的。
			>是否推送一个任务 需要做哪些验证？：精确匹配条件(对任务本身的各个参数限制约束)：任务的各个参数都要和要求的值匹配。这里就会过滤掉一批 不合规的任务/不符合推送条件的任务。
				>具体验证条件：
					>任务普通验证：任务类型？执行类型(执行时间)?
					>任务内容验证：
						>1.基线包校验。:
							>可行路径1：a.目标版本号 符合规范。&-->b.全量包存在(该车系下所有车型的该目标版本号对应的全量包) 且 已经测试审核通过。
							>可行路径2：a.目标版本号 不符合规范。&-->b.基线包存在(该车系车型目标版本下应该唯一)(从ota-service获取到基线包)、且该基线包的基线版本描述信息存在(从ota-service获取)。
						>2.升级策略校验。：
							>可行路径1：a.该车系下每个车型的车系车型信息存在(从ota-service获取)。-->b.该车型车系信息的确定的默认OTA升级策略存在(从ota-service获取)(可能有多个策略)。--->c.该升级策略规定的ECU列表中不存在没有配置(没有配置升级顺序)的ECU， 除非这个策略的实体不存在(策略不存在为什么是合理的？)。
						>3.车辆信息校验。
							>可行路径1：
								>a.该任务的VIN列表不存在重复的VIN.。&---->
								>b.对每组汽车信息:
									>VIN\车系\变量车型信息，要和平台的匹配(平台的通过ssp-vcs-service获取);
									>& 如果当前任务为工厂任务:则该汽车的状态必须是三种状态之一(总装下线/OK下线/打印合格证); 
									>& OTA源非诊断仪时: 
										>该车不能在黑名单中(用VIN+黑名单确定) 
										>& 如果该车不在强制升级白名单中, 则要求：本任务为测试任务则车不能是销售用途车,
										>&, 车的状态只能是总装下线|OK下线|打印合格证|已交付|待激活|已激活,&, 车的当前版本(即固件版本)不能是00.000.000 ,
										>&,该车的升级状态如果存在且升级触发方式为普通升级 则 升级状态事件类型不能是 等待升级/升级中/回滚中。
									>& 当前版本 等于 目标版本时： 要求：如果OTA源类型不是诊断仪 则 要求 该车必须在 同版本刷写白名单中。
									>& 当前版本 小于 目标版本时： 要求：该车必须在降版本刷写 白名单 中。
									>& 如果当前汽车支持配置字(从mongdb获取该变量车型的配置字map--有则支持)： 则要求 该汽车基本信息(从ssp-vcs-service获取)中的配置字不能是空的。
								--通过上述验证的汽车vin就是最后可以推送的目标汽车。	
			>验证结果怎么处理？是否需要发送验证结果通知？
				>处理1： 将没通过验证的汽车信息 发送 给用户：
					>用户如何获取？：通过task任务的发布人id 而调 aisp-amp-service 获取完整的用户信息--包含手机信息。
					>信息什么格式？什么内容：VIN + 任务ID + 版本号 + 任务类型 +  失败原因
					>怎么发送、发送到哪里？：短信方式发送，转发给专门做这件事情的服务 mms-api。
					>发送失败怎么处理？直接报错即可。
				>处理2： 对 通过验证的汽车信息 ，则这些汽车就是 升级包 推送目标。
					>具体推送动作：对每辆通过验证的车：VIN
						>推送可以升级的消息：
							>消息内容：VIN + 版本号 + 升级类型 
							>消息发送方式：调 另一个微服务 iot-device-shadow  来完成。
							>发送成功：则返回一个消息ID。
							>发送失败：抛出异常。
						>& 将任务对应的全量包信息等入库：
							>入库内容: VIN + 任务ID + 版本号 + 全量包ID + 升级类型 + 发送时间(当前时间) + 消息ID(上一步成功时的得到的消息ID)
		>任务在哪里？：这些任务怎么获取。
			>查找哪些特征的任务出来：所有 未执行、已发布、开始时间小于现在的任务。
		>推送给谁？
		>怎么推送？
		>怎么验证推送成功了？
		>推送失败怎么处理？是否要重试？是否要记录？
		>推送成功之后要做哪些事？比如记录成功、发成功消息。
			>对任务的处理：更新为已经执行。
	>车辆下载升级包文件 的 推进过程： 一切为目标服务，描述 应该 不偏离目标。自顶向下描述，不要从一层直接下到最底层(即便非常长的回路)，即要广度优先描述，而不是深度优先描述。
		>何时开始下载？
		>下载之前需要做什么准备？
			>事情1：根据VIN获取固件升级包的描述信息。(调app 服务来实现)(固件：就是 设备驱动软件)
				>验证汽车是否满足条件：1.该汽车 要通过 黑白名单校验。&--> 2.通过 基线包 校验。&-->3.通过 升级策略校验。&-->4.通过 配置字校验。
				>准备信息：获取汽车基本信息、车型车系信息：升级策略、(用vin从ssp-vcs-service获取)、获取配置字规则(从mongodb)、配置字信息、找到需要排除的ECU ids列表(借助ssp-vcs-service服务)。
				>升级包描述信息？：
					>目标版本支持OTA1:
						>验证车型车系目标版本确定的大包(ota_package_total_full) 是否符合规范：存在 且 状态正常(不能是删除/未制包).
						>确定要推增量包还是要推全量包？：如果存在该全量包的该版本的增量包 则 推增量包(用全量包id+ 固件版本来 从ota_package_total_delta查找增量包)
						>确定是否要比较ECU版本？：升级策略里的是否比较ECU版本配置 为是 则比较，为自动 则：当前版本和目标版本不同 且 非增量包 时 要比较。
						>大包是对称加密过的，它的密钥如何获取？：在大包数据模型(ota_package_total_full/ota_package_total_delta)里有 该对称密钥 加密后的字符串，用这个字符串调chehejia-service-bks-app服务来解密 就得到 对称密钥了。
							>aes密钥还需要的iv从哪里获取？： 在大包数据模型里有。
						>大包的摘要/用私钥做的签名/和私钥配对的公钥/及其公钥签名：都在大包数据模型里。
						>大包的升级提示信息？：包括 升级提示描述文本/升级提示H5页面地址/注意事项 都在大包 里。(##增量包有吗？)	
						>大包的升级结果信息？：包括 升级结果描述文本/升级结果Html页面地址 都在 大包里。
						>固件包的ECU列表信息？：该升级策略 下的ECU列表 中 不在 上述需要排除的ECU ids列表中的 那些 ECU ids ,这个是必要条件。
							>如果是全量包：先获取 对 该全量包 配置的 ECU列表(ota_package_total_full_ecu): 对每一个ECU id， 
								>需要满足条件：ECU实体存在 & 策略关联的ECU列表包含该ECU id  且 升级策略为要升级该ECU
								>ecu的包类型如何确定？：组件类型：该ECU支持OTA差分 且 差分算法为 安卓算法。
								>ecu包的摘要/签名/公钥/公钥签名信息？：也在 全量包-ecu 关联项 里。
								>ecu包的文件key?: 也在 全量包-ecu 关联项 里。
								>ecu包供应商个数？：该车系车型 ecu名称 下 决定的 ecu基本信息 条目数。
							>如果是增量包：先获取 对 该增量包 配置的 ECU列表(ota_package_total_delta_ecu)：对每一个ECU id,	
								>需要满足条件：ECU实体存在 & 策略关联的ECU列表包含该ECU id  且 升级策略为要升级该ECU
								>升级类型和升级顺序：都在策略-ECU 关联项 里： 
								>ECU 增量包实体如果存在 则要设置ecu包信息为增量包信息：ECU增量包(ota_package_ecu_delta)中查找得到。此时，增量包基于的全量包(base/target)(ota_package_ecu_full)都要存在。 
								>ECU增量包不存在：ECU包id对应的全量包 就要存在。
								...其他设置要求同上。
					>目标版本不支持OTA1： 
						>升级包来源?: 扩展包信息：扩展包来自ota-service，所以要求扩展包一定存在。
						>升级包是否要进行ECU版本比较：同上逻辑。由策略配置决定 +  非增量包&目标版本和当前版本不同决定。
						>升级包的ECU文件信息列表来源？：扩展包里的Ecu包信息扩展 列表 经过 过滤 后得到： 过滤条件：ECU id 在 策略-ecu关联项里 且 配置为升级，从而封装升级类型+升级顺序 放到该列表里。
				>升级包描述信息构成成功后 需要的处理？：序列化为jsonstring再转为Document后保存到mongdo。		
		>什么下载方式？
			>给定下载条件：包文件id(package_file_id)、包类型 
			>给定条件决定要不要下载？：包文件id对应的实体存在(调ota-service查找)
			>下载文件的本地临时存放路径？：是。(/chj/data/ota/temp/download) 文件名： timestamp+filename;
			>从oss下载文件并保存到临时路径的过程？：
				>原始文件存放地址-nas地址确定: /data/otaupload ..从 NAS获取备份升级包;
				>尝试从nas地址获取:
					>直接将nas地址对应的File以文件输入流的方式 加载到 临时文件地址:  其中 需要解密: 每1M byte 数据 进行一次 aes解密(密钥已经通过前述方式获取,iv本身有).
					>验证解密后的文件是对的?: 对 该临时文件进行sha256计算得到 摘要,和 已有的摘要比较,相等才对.
				>失败则从oss地址获取: 从oss下载放到nas地址.
					>oss key是多少?: 包文件实体里有.
					>用ois获取?: 内部先获取用户鉴定信息(chehejia-service-ois-app) -- > 后报告连接成功 ,拿到许可证-->  使用 这个filekey + Credential 许可证 后 用 OSSClient 这个阿里的客户端 来下载,  下载结果 是 一个输入流.---->内部还是httpclient来实现的.
					>解密:
					>验证解密后的文件是对的?: 对 该临时文件进行sha256计算得到 摘要,和 已有的摘要比较,相等才对.
			>文件写出给请求者：直接将临时文件内容复制到输出流。
			>临时文件的后续处理？：删除这个临时目录即可.
		>从何处下载？
		>下载进度如何上报？
		>下载成功后做什么处理？如发消息。
		>下载失败后做什么处理？如发消息、重新下载？
		>上报升级数据?: 
			>数据内容? : VIN+ 服务类型(事件类型) + 事件信息列表 
			>上报方式?:上报过程: 分服务类型不同上报不同. 对事件信息列表 里的 每个事件信息:
				>服务类型为 车机 上报 下载进度: 进度信息在哪里?在 事件信息的entity属性里,此属性还包括的信息: 当前版本\目标版本\时间\进度值\消息id . 然后直接 入库:ota_vehicle_download_progress
					>上报间隔:10s
				>服务类型为 车机 上报 升级进度: 信息包括:整体升级进度\正在升级的ECU名\正在升级的ECU的升级进度\消息ID 等. 直接入库: ota_vehicle_upgrade_progress
					>上报间隔: 5s
				>服务类型为 车机 上报 升级状态: 信息包括: 事件类型\触发类型\失败ECU名称\错误类型\源(车机/诊断仪)\消息ID . 直接入库: ota_vehicle_upgrade_status
					>上报间隔: 每次ota-app的升级状态发生跃迁
					>入库之后的事务:
						>发送升级失败信息到OTA运营小助手: 将事件信息+车辆基本信息+车辆位置信息(ssp-vds-service获取)  封装起来, 调 封装的http客户端PushClient发送出去.
						>异步创建OTA升级失败工单群组: 也是 将 类似信息 调 封装的http客户端发送出去.
						>异步车机日志回读: 先获取车机日志灰度配置列表,对 每个, 根据 VIN+错误类型 获取 汽车升级状态列表, 调回读接口(ssp-vds-service) 发送 状态信息.
						>异步出发OTA任务补偿机制: 查询该机车最近的任务-->该任务对应的OtaTaskVin表记录的推送次数 超过阈值 -->则调发布者的电话 而短信发送给他;...如果没有超过阈值-->再次验证通过之后, 更新OtaTaskVin 为需要重新发送.
						>异步保存升级失败记录: 直接封装 而 入库:ota_upgrade_fail_record
						>推送手机通知: 1. 获取机车人账户(aisp-account-service) 调 pushClient发送出去. 并保存到数据库里:ota_vehicle_upgrade_app_push.
						>同步车辆OTA升级状态到ota-batch服务:   将 该事件 序列化 后 当作一条消息 发送 到消息中心: rocketmq, 主题为 rocketmq.ota.status.sync.topic
				>服务类型为 车机 上报 执行升级命令: 信息封装 后 直接 入库: ota_vehicle_upgrade_command
				>服务类型为 车机 上报 清E方结果: 信息直接转换 后入库: ota_vehicle_eeprom_clear
			>上报给谁?:
	>车辆 升级 软件包 的 推进过程：
>基本服务目标：思路 和 方案。
	>同步基线：
	>同步ECU：
		>根本步骤：从pdm下载ecu包、制包 并 上传到 bos。
			>ecu包：包括 全量包、差分包、中间包。
	>同步状态：记录升级 开始 到 升级成功/失败 的 进度、结果。
	>制包：
		>根本步骤：用ECU升级包+... 制作OTA增量包、全量包；
			>制作过程：压缩、加密、上传：
	>升级状态机制：
		>根本步骤： 下载、升级、重启。
	>同步ECU流程：
		>根本步骤：上传ECU全量包 到 云存储：
		
>其他服务接口：
	>1.按照分类获取车辆信息：v2-0/vehicles/get/{vin}  获取的是车辆的完整的信息：如 基础信息、设备信息、电机、摄像头、ECU\电池、车型、物料、消息、配置字信息。
	>
	
>数据表的设计：
	>ota_vehicle_download_notice: 汽车的一个任务的 最新的 进度消息 推送记录：
	>ota_vehicle_upgrade_status: 汽车的一个任务的 一条消息 表达的 升级状态记录：
	>ota_upgrade_strategy_veh_relation: 一个确定的车系车型 对应的 升级策略 记录 ，
	
---总结：基本概念(领域模型)、基本服务(交互图)、事情推进过程(完整详细的步骤和服务粘合的细小逻辑)