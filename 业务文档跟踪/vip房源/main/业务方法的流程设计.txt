1.问题：
	>原则：职责单一、暴露最终、接口编程   。。（这是对于抽象设计业务，而对于具体调用的实现业务型实现式编程--可加“匿名内部类编程”；要么用bean，要么用匿名内部类）
	>根据-哲学-观点：代码之间是有关系的，前后是有关系的，层次上是有关系的。是自然而然向下走的，应该做什么事是必然的可以推理出的而不是随机的可以选择的或者随机选择的，而不是突然突兀的。
		>变量定义，则要立即使用，而不是分隔很远。
		>纵向必须分块抽出来，不能影响方法整体的功能，局部功能、中间功能必须抽出来写成方法---而不是占用主程序的空间。
			如果某一块含有许多个变量，那么这些变量可以放在放在一个容器里返回。
		>局部功能之间，是并列关系没有先后关系，那么顺序可调，如果有受到前后局部功能的影响（需要前面的预备，还影响到后面的局部功能），那么它所在的位置就不可以调整，需要固定。
		>要能分辨-指出-感受到：局部功能和整体结构（判断和处理）
			>是局部功能，那么这块可以提出方法，形成局部方法。
				>分辨方法1：某一块最终的作用是生产一个中间数据结构，供后面调用使用。
			>是整体结构，那么保持这种结构-不再抽出方法
				>分辨方法1：逻辑分支讨论结构，最多3层，最好1层，不能更少---才能体现是这个方法的逻辑--而不是只有一行调用方法而已：体现出它自己的逻辑讨论-分类讨论。
				>分辨方法2：本功能的固定模板、固定流程。而不是子功能或者局部功能的固定流程。最简单的，就是聚合一个个顺序调用的结果，上一个是下一个需要的数据结构。
				>分辨方法3：最外层的直接对情况分类的if-else等分支判断结构，而里面的更详细的对另一种情况（另一种数据结构）的分类的if-else就不是主程序应该讨论的情况了（是不同类情况的划分）。
						且最外层的if-else讨论，还可以分类划分而组织起来，这是子类，来避免主程序过于庞大（这是同类情况不同种情况的划分）。
				>分辨方法4：按处理的数据结构和处理的阶段分类。
					    >一块还在处理A数据结构，紧接着下一处已经在处理B数据结构了。（即不按判断分，而按处理的数据结构分，增删改查的数据结构分）
				>分辨方法5：大板块大板块的分：这一块计算这--这一块的计算目标，下一块计算那--那一块的计算目标。对于并列的数据准备式程序，这样划分。
					    >一个计算目标：得出的结果直接存储，不再作为中间数据参与转换和计算，且一定要存储。
					    >要：是设计规则。会：是熟悉规则，使用规则。
		>主程序中不应该看到子功能的实现。--主程序中不应包含子功能的实现代码--而只是包含对子功能的调用。
			>则应当明确主程序的功能，主程序应当讨论的情况。主程序层次应当讨论的情况（抽象层次，大类情况）（从而讨论应该设计怎样的方案，怎样的实现结构），而不是更细的情况--子程序层次应当讨论的情况。
		>以判断和处理描述：（制造判断，制造处理，制造数据结构）
			>判断：对数据结构值的计算比较
			>处理：java里和数据库里都是（对数据结构）：增删改查，的组合的顺序连接拼接，顺序执行，流水执行，先后执行，承接执行。
		>形象化方法：想象一个输入数据结构，整个方法对它的各种处理都图像化来表达。
			>这个输入的数据结构：可以直接是一个数据项，一个具体实际的存在也可以---而不一定要是内存中的数据结构。
		>参数方法：方法里的判断根据是否是用了方法的参数。而不是方法里生成的中间数据。对方法里生成的中间数据---对它的进一步判断的逻辑都应该是放到一个专门的方法中进行的。
			>一个严密完整的逻辑应该对参数和生产出的数据进行验证。----因为程序不总是可靠的---情况不总是正常的发展而出特殊情况
			>每个方法里面都是一个参数线。参数处理线。
	>所以一个方法里，一块大的功能，也可以按调用层次或者变量使用的纵向切块而抽出方法。


	>具体实现：
		>包装类的使用：一个数据的衍生数据的缓存容器类，方便进一步从被包装的数据中提取出新的数据。
		>匿名内部类的使用：利用程序上下文数据来构造新类的方法，避免大量的属性注入。（bean是另一种处理思路，没有bean灵活，因为匿名类的方法结构是不变的，尽管运行时参数不同）
		>抽象类的使用：模板方法模式，既可以固定一个流程，先抽象设计、固定流程、调用没实现的方法，局部方法不实现--子类继承实现。本身还不会被实例化来误用。
		>接口中的静态内部类的使用：相当于静态属性(类型为class)，但是类型(的实现)可以利用接口中上下文进行构造（包括方法的实现代码），比如用来实现一个接口，从而属性名就是类名--用接口的这个属性就获取到了一个类，是类的聚合体。

	>应用和好处：
		>可以解决：如何看一个方法的实现?
			   如何重构一个方法的实现？
			   如何实现一个方法？




