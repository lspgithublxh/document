1.问题：请求路径：/fangyuantongjiapi/count
	>基本数据结构：
		>RefreshedCount：是用户已经刷新的实体（infoid和count）
		>ReservationRefresh:是用户预约刷新的实体（infoid和reserveCount）
		>CnsmRet:(totalValue,curValue)
		>RscParam:参数对象
		>ShowBlocks:

	>业务流程：(用数据结构、增删改查、判断和处理来描述，情况类别来描述--分类处理)（条件-任务，情况-任务）
		>1.参数验证：是否存在三个必须参数：userid, dispcateid,productid
		>2.数据准备：当前用户的网灵通列表（工具型数据）
		>3.查询结构准备：根据产品。同时生成时先过滤网灵通列表。PromotionCommonQuery（工具型数据）
		>4.数据的生成：构建List<ShowBlocks>,根据不同的产品id:就是网灵通、诚信、免税三类进行分类统计(房产网灵通类别，共有：网灵通、诚信、免税、网灵通2四种类型100301-100304),根据上述查询结构等（）
				>1.数据准备：再次过滤后的网灵通列表
				>2.情况分类--数据生成：利用网灵通列表、产品id、包装后的统计类。。分房产网灵通、诚信房源、免税房源三类产品类别统计。。下面是房产网灵通
						>1.参数准备：推送限制参数PromotionLimitParam的生成
						>2.数据生成：根据限制参数和网灵通，用户id和query内容
								>1.数据封装和生成：直接属性设置
										>优先推送的资源数量
										>--几乎每个属性的获取都是调用wraper的远程请求处理来完成的。

						>3.数据存储：放到View的Model里。键名为：promotionStatVO

						---免税房源：
						>1.参数准备：推送限制参数、再次过滤后的网灵通、免费房源信息（推广表Promotion就是房源信息表）
						>2.数据获取：Map1(总刷新和等待刷新数,且会封装):（数据传递、查询）手动和预约刷新的次数和（到现在已经完成刷新）、正常状态预约和已经完成状态预约的总次数（其中有的预约已经在当前时间之前完成刷新，有的当前时间之前已经开始刷新但没有完成的）
								   >1.数据计算：用已完成预约（含有已完成刷新和未完成刷新类型） - 已完成刷新（预约类型）  =  未完成刷新但已完成预约的次数：等待次数
						>3.数据计算：剩余刷新数：= 一天最大刷新数（推送限制参数里有） - 已完成刷新数 - 等待刷新数
						>4.数据计算：截至日期为今天endDay的推广数（先找出）HeaderStatistic.getPromotionDeadlineCount
						>5.数据获取：免税房源的资源详情（免税房源的接口IRscConsumable的静态内部类getdetail中方法来实现，本接口的实现也是通过代理ProxyFactory.create()来获取，本接口的定义要求使用@ServiceContract、@OperationContract等注解╀）
								>1.数据计算：用户-城市-产品-类别下的免税数量、免税剩余数量(从上述资源详情中提取)
						>6.数据存储：放到View的Model里，键名为：freeTaxStatVO。值即为一路封装过来的视图实体FreeTaxStatVO
							
						---诚信房源：
						>1.参数准备：再次过滤后的用户网灵通列表、推广限制参数、含查询体的包装类
						>2.数据获取：（会设置到结果数据结构中）用户推广总数(已经推送的信息条数，仅套餐内-不含在线购买的，也不是一天可以推广的总数):服务调用获取
						>3.数据计算：剩余推广信息条数（可以设置的数量）（一周推几次信息、一次推多少个信息、一条信息在哪个位置-排序位置）：为一天最多可以推广的数量 - 已经推广的数目（上述已经求出）(已经选择的数量)
						>4.数据计算：截至日期为今天的所有推广数量
						>5.数据计算：总共刷新次数：（就是已经完成的全部刷新数）下架前预约刷新（取消前刷新）的信息条数 + 预约而已经完成刷新的信息条数 + 已经完成的手动立即刷新次数。。。。。。。计算方法2：不是之前的分算，而是总算。
							     等待刷新次数：今天会执行的预约刷新次数总和 - 今天已经执行完成的预约刷新次数
							     剩余刷新数：（还可以刷新的次数：可以用作手工立即刷、预约刷、预约取消刷）一天最大刷新数 - 今天已经完成的全部刷新数 - 今天等待刷新数
				>3.showblock map的初始化：从xml结构中提取showblock标签数据--及其外层的urlflag属性值。值为showblock,这个对象从xml中提取出来，showblock中的id就是类别id：如二手房-出租房等：DispCateIds.ErshouFang  DispCateIds.ZuFang,,,而这个可以从参数中获取。
							   >1.数据获取：根据类别而从前map中得出List<ShowBlock>
							   >2.数据替换：遍历上述ShowBlock,将前面得出的三个VO里的数据适时放到ShowBlock的content字段里。
							   
				>4.数据封装：遍历整个ShowBlocks List，提取name-content到json中返回


2.请求路径：/fangyuantongjiapi/count
	>1.参数验证
	>2.数据获取：用户当前三种状态的网灵通，并且过滤掉不适合的网灵通
	>3.数据获取：降价信息used：直接用接口IDepreciationService.countDepreciationsByUserId(userid,...)来获取。构造json而返回。
	



						