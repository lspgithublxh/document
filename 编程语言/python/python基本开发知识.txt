1.问题：实际开发中常用的实用的模式、常遵守的规则。。分主题描述：。。。目的:减少大家弯路，有个大致轮廓的认识。	
	>python是什么？ --- 解释型编程语言，可以解决什么问题？---IO问题、计算问题（给出许多代码、实际生活工作科研中使用的带来方便的案例）。python是怎么解决这些问题的？（python解释器的原因部分和语言设计的原因部分）。为什么要用python来解决这些问题？（语言特点和解释器特点）。python不能解决什么问题？(不建议用来解决什么问题，相对的，特性决定的)
	理论和实例-编程实例。第一个：hello world  第二个：pai的计算    第三个: 排序算法（如冒泡排序）
		>主要用途：a.计算处理数据、数据可视化：（如matplot, numpy, tensorflow）(excel简单处理)
			   b.网络编程：抓取数据、简单的网站
	>python编程哲学：问题事情转换为编程模型、函数模型、调用模型、对象模型、对象行为过程模型。
		（主讲设计思想，不能用主力来搞语法）(回归基础，重视原理，多理论探讨--课后自己实操编程，使得基础牢固，最多到设计模式-设计原则，只介绍一些小工具，不太多的第三方运用)
	>设计思想、语言特性、
		>高效的高级数据结构：使你可以在一条语句中表达复杂的操作
		>简单高效进行面向对象编程
		>简洁语法：语句缩进来代替大括号--来组织语句组
			   变量或参数无需声明
		>脚本语言特性：闭包、map、函数指针、字符串动态定义函数（key-value方式，value为函数）、log函数切面编程--方便构造代理、字符串直接当脚本执行
		>解释型语言：无需编译链接，直接运行，不用编译，即改即运行，测试方便。（放在jvm上的是class文件，放在解释器上的脚本源代码）
	>解释器：
		>运行原理：如何执行整个python文件的、加载整个文件的，解释器，数据区
			>从最顶层模块开始，__buidin__到__main__模块--
		>内存管理：
		>执行python abc.py <arguments>时做了什么？
			>代码一行行被执行：遇到表达式和函数分别：
			>__name__将被赋值为__main__
			>参数输入到了sys.argv里，可以import sys来获取到输入参数
		>扩展新函数和数据类型：用c/c++
			>
		>解释器集成到某个C应用程序：
		>运行并和解释器交互：cmd中输入python，则进入和解释器交互的模式：命令行模式：（缺点是不能保存）（一个解释器的交互式实例）
			>如果需要换行：会自动根据语句是否结束而...展示从属提示符
		>最近表达式的值：_下划线来表示。
	>虚拟环境：virtualenv
		>
	>模块：可以（.py）
		>可以：独立的脚本来执行
		>可以：导入的模块来使用
		>构建、发布、安装：
			>打包上传到PyPI,从而开源自己的包：https://pypi.python.org/pypi
		>模块名和文件名：__name__获取模块名   主模块的这个值：__main__
		>内容：可执行语句  + 函数定义  + 类定义
			>可执行语句:在模块导入的时候执行一次
			>函数定义:
			>类定义:
		>重新加载：reload()
		>模块的搜索路径：当前目录    sys.path（PYTHONPATH）
		>import:后面模块或者包
		>from a import b:b可以是函数或者变量。 首先看包下有无b--来看b是否是模块，不是则认为a是模块	
		>导入时会怎么找：sys.path路径下找
			>首先是当前工程
			>即sys.path所列出的顺序	
		>内置模块：如sys, os 需要import
		>内建名称空间：python解释器启动的时候首先加载内建的名称空间(名字到对象的映射)：即__builtin__模块中的名称空间
			>名字-对象：这些对象有类、函数
	>包：一个含有__init__.py文件的目录。这个文件可以是空的，可以有包的初始化代码。__all__变量是一个数组，定义导入时将导入的本包下的哪些模块
		>且一个包的外层到工程下的文件夹为止--都必须同样是包，否则在一个纯文件夹下定义一个包是不会被引用的。
		>
	>程序文件类型：
		>.py
		>.pyc
		  >一个.py模块被导入，那么执行这个导入的模块，被导入的模块就会被编译生成.pyc的字节码文件---以方便下次加速加载。
			而执行的导入模块的模块只需要装载一次，所以就不会生成.pyc文件。	
			加载-链接-编译-加入内存-执行-写到.pyc
		  >
		>.pyo:更小更优的编译文件
		>.pyd:python的动态链接库
	>位：32位的python安装包：不能超过2G内存。
	>开发环境：Pycharm,IDLE（右键py文件可以打开）,eclipse
	>下载：官网上(2.7.14  python-2.7.14.amd64.msi就自带pip,其他版本可能包不全)。https://www.python.org/downloads/windows/
	>语法：语义
		>数据类型：
			>int:
			>float:
			>分数：Fraction     Fraction(4, 5)
			>小数：Decimal  且可以识别多种小数的写法（如科学技术法）以及对应的特殊处理方法
			>复数：1 + 2j表示和计算
			>字符串： 'abc', "abc"  字符串中标识引号： '"ab", dd' 或者转义符\'
				  >原始字符串：r'abdf'同一当作字符串\没有转义功能	
				  >三引号表示多行字符串，否则每行字符串都用'' '' ''
				  >字符串运算： * 重复 +连接
				  >没有字符类型：单字符串表示
				  >直接正负整数来索引：截取。截取时对起止整数没要求
				  >字符串不可变：不可赋值。
				  >unicode字符串：表示方式：u'adb\u0020'  原始模式ur'\u0020abd'
				  >编码解码转换：unicode ascll utf-8 latin-1可以相互转换:编码-解码-再编码...。。。显然的是：一个unicode的中文是无法转换为ascll码的。
					>告知解释器该字符串是用什么来编码的、要编码为什么目标码
					>不同编码类型：对同一个中文进行编码，结果的十六进制数是不同的：
							>‘眉’字：utf-8:\xc3\xbc    
				  				   unicode:\xfc
							>dict打印中文来看，utf-8会是：\x..\x..格式，unicode会是\u1234形式。
					>编码的：字符串表示--肉眼看到的、内存数据形态、软件标记读取认为的，软件展现出来的
				  >格式化：.format包括数字都可以。。不用%这种旧的方式	
				  >函数、类里的首行文档字符串的作用：可以通过 函数名|类名.__doc__访问到这个文档字符串
			>列表：[a,b]可以被索引和切片:切片是一个副本
				>运算：拼接式合并： +
				>元素修改： a[2] = '3'  a[3:4] = [3,4]   索引式修改和切片式修改
				>嵌套其他列表：a[1] = [3,4,5,6]
				>众多方法：append()  pop()  popleft() 从而可以当作栈和队列
				>初始化赋值：
					>列表推导式：表达式  for in  <1,n>  if 表达式	返回一个单元素list
					>嵌套列表推导式：[表达式 for in ] for in  返回list元素的list
				>删除元素：按索引或者切片：del a[0] del a[0:2]
			>元组：(a,b)第三种序列类型
				>不可变（值或者引用）、可以索引访问：
				>空元组和单元素元组：()  'aa',   ('1',)
				>元组拆分：t,b,c = (1,2,3)
			>集合：set()
				>空集合：set()
				>推导式：a_set = {i for i in 'asssss' if i not in 'abc'}
				>函数：union 等集合运算
			>字典：{key:value}
				>访问(key或遍历)、增删：不能用.来访问某个键的值。只能[不变量]来访问
				>遍历：iteritems()来逐一获取
				>key-value:实际上是一个元组
				>字典推导式：{x:x**2 for x in range(1,10,1)}
		     >工具：
			>类型判断： isinstance(object, type)  type(a) == type(b)
				
			>序列化和反序列化：json模块处理
				>序列化：将一个python数据结构对象转换为json格式字符串  ： json.dumps(data, ensure_ascii=False)
				>反序列化：json.loads(datastr)之后是一个dict,而且中文是unicode编码。如果直接print看不出来，如果访问键，则没问题。
		>运算符：
			>基本： + - * /(全是整数则整除) //(小数整除)  **幂乘方  round(a,2)刚好5舍大于5入
			>赋值：=
			>多重赋值： , =     先计算赋值者再赋值给被赋值者，计算从左到右
			>in 元素在集合中是否存在：
		>流程控制：
			>if -elif -else
			>for:只能是对序列进行： for item in ['b', 'a',2]: 
				>for - else :当for执行完毕了也没有执行过break命令那么就会执行else里的内容。
				>for的底层调用：迭代器函数：iter(类实例：有__next__, __iter__方法)
			>range(起，止，步长)：生成一个整数list
		>变量作用域：
			>变量：使用前必须定义（赋值） 。。
			>全局变量：
			>__all__变量：
		>包管理：
			>安装到哪里：
				>单文件模块：直接放到$python_dir/Lib下
				>多文件模块(是一个包结构，有setup.py)：安装方法:解压：python setup.py install
					>会被安装在Lib\site-packages下：
					>有的包依赖VC++9.0 
				>自定义setup.py文件来安装模块：使用setuptools 中的setup函数和find_packages函数
				
				>pip方式：在Lib\site-packages下有
					>且包是.exe格式，比如wheel的安装，后为wheel.exe
					>pip search $module_name
					>pip install $module_name
						>本质：是先从PyPI上找，然后下载到本地仓库。所以可以离线下载包。离线安装：pip install abc.zip
					>pip list（查看已经安装的包）
					>pip递归安装：pip install -r requirements.txt   //多个模块
				
				>whl文件：
					>pip install .whl
				>.exe自定义安装：numpy-1.9.2-win32-superpack-python2.7.exe
					>
			>仓库：
			>pycharm包管理:Project Interpreter下
			>不用import的包、模块：在什么路径下：系统包、系统模块
				>查找顺序：.zip ----  DLLs  ---- Lib  --- site-packages
		>文件目录：
			>一个文件一个模块
				>一个文件中：一个类，几个类，或者若干个函数
			>一个带__init__.py的目录算一个包
				>__init__.py里的内容：all=['module1', 'subpackage1']
			>
		>异常处理：try/except/else/finally (else在没有发生异常时执行) (finally最后执行，且推出try一定会执行，无论走excpet,else或者都没走，最后都会执行finally)
			>两种错误：语法错误和异常：syntax errors 和 exceptions
				>语法错误：报错信息里有尖括号：指明是哪个地方出了语法错误
				>异常：运行期间产生的错误：没有尖括号，只有异常堆栈。
			>具体异常：
				>control-c会引发KeyboardInterrupt异常
			>try-except语句：raise 继续向上抛出异常
				>正常不执行exept,发生异常了转向执行except子句匹配异常：匹配到了执行异常处理语句，没有则向上级try-except抛出,最终都没有则终止程序运行，显示错误信息。
				> except ValueError:
				  except (RuntimeError, TypeError, NameError):   必须要有括号
				  except:
				> else: 并列于except:表示抛出异常则不执行，没抛出异常则执行的代码块。（关键就是保证了抛出异常就不执行） ：虽然有等效实现，但这个关键字简化了实现
			>作用之外：可以从程序底层转到上层。
		>函数定义：和使用、调用。定义关键字def，先执行定义，后才能调用
			>传参：传的是引用。。（常量自然就是值了）
			>参数初始化：数值可以来自函数外部。。。函数调用时就可以参数个数不定。
			>函数定义：带*参数和带**参数：
				>带*的形参：是一个元组，接收调用时的额外元素到元组里
				>带**的形参：是一个字典,接收调用时的额外键值对到字典里
				>函数名可以先定义为一个局部变量的名称（不是它的值），并且初始化为任意一个值。
			>调用一个函数：
				>会生成一个局部符号表： 变量引用首先在这个符号表里查找，然后在包含函数的局部符号表，然后是全局符号表，最后是内置名字表
					>因为全局符号表是众多函数都要找的区域，所以其中的全局变量不能在函数中被赋值，只能取值（除非用global语句命名）
					>
				>调用时传递的参数中带*或**：
					>带*：首先实参是list,会拆分为各个参数来有序赋值给形参
					>带**：首先实参是dict,会拆分为各个key-value来对应赋值给形参。
			>重命名机制：一个函数定义之后，它的函数名会该函数所在空间的符号表中：这个名称指向该函数的函数体。所以这个名称是可以被使用的---而不是只能用来被调用()。
			>常用函数：len()  sorted()  join()//调用者可以是字符串，形参可以是一个元组
				  >enumerate(a)可以获取index, value的遍历
				  >zip(a,b)可以同时对多个list进行遍历--一一对应
				  >遍历修改的list，可以 遍历a[:]而在for里进行操作
			>匿名函数：定义，则像js里一样可以用字符串来给它命名。用运行结果来作为函数名。反复执行一个函数定义而给赋值给不同的变量。
				  >lambda可以创建简单的匿名函数
				  >因为函数名是一个指针型变量，所以可以获取值，所以可以被其他指针引用。从而间接得可以赋值给“属性”--比如map的一个key（可变）,实例的一个属性（约束死已经不可变了）
			>函数式编程：lambda表达式：可以用来创建短小匿名函数
				>lambda定义函数的格式和被调用：lambda 形参表:函数体       被调用依然和普通函数方式一样()
					------在python解释器交互环境是有效的，但在IDE中还没有效果
				>函数式编程工具：filter(functon, list)可以返回list中符合function要求的元素list
						  map(function, list)可以返回对list每个元素都function处理后的结果list	
						 reduce(function, list, initialval-iflistnull) 第一次用function处理list前两个元素，将结果和list第3个元素用function处理，直至处理完list返回最终结果。
					应用：map(lambda a:a*a, [1,2,3,4])
				>
			>预扫描过程：函数有预扫描过程，只要函数里有yield关键字，那么就会将这个函数当作是一个生成器函数，直接调用该函数，则直接返回一个生成器对象。可以调用很多次，每次返回的是不同的生成器对象。
				>
		>局部符号表：一个变量：开头几行可以被定义为变量，后面可以被定义为函数。这是不定的。		
			>dir()查看当前定义的命名列表：变量、函数、模块			
					
		>面向对象思想的实现：类的定义、继承、覆盖、封装、多态.
			>定义关键字class,先执行定义，后才能调用
				>属性定义：直接定义即可， 只要是在类里的名称都是有效属性名，都可以.来访问。。。类的局部变量就是类的属性。
					>局部方法内引用类的属性---self.abc   从而可以识别是来自外层命名空间，作用于所有内层域。
					>
				>函数定义：直接def定义即可 ，属于类的名称空间。
				>文档定义："""abc"""是三引号，通过__doc__来访问。
				>方法定义：普通的def定义的函数，且参数至少有self
					 >方法调用其它方法：需用self.method()的方式
					 >方法私有化：__开头的方法都是私有化的。只能类里的方法之间调用。
				>编码规则设计初衷：尽可能的避免冲突。
			>类的实例化：调用的方法：__init__():
				>实例化：每个实例各自保存的是类的每个局部变量的值的引用，所以初始化的引用一般都是一样的。。。并列于方法的属性就是这种。
				>只属于实例的属性的定义：self.attribute, 
					>a.定义在方法里:类的名称空间的函数里
					>b.实例引用来定义：  比如： a = AA()  a.newAttri = 'abc'   那么a实例就能增加一个属性。
				>tostring:定义__repr__()方法
			>预备：
				>命名空间：三大类：内置命名空间、模块命名空间、函数命名空间（对象的属性集也可以属于）
					>空间区分了引用路径。
					>空间中属性的访问.,属性可读
					>命名空间的生存周期：
						>每次函数调用生成一个局部命名空间：
						>每次递归调用也生成要给局部命名空间：
				>作用域：程序可以直接访问的命名空间的区域。
				>全局变量：全局可以访问：但是在另一个命名空间访问时，需要加global

			>继承：需要显式从object继承：class A(object):pass
				>可以用self.来访问到基类定义在类空间的所有名称:即全局的和实例的。
				>	
			>多继承：
					
			>覆盖：如果需要访问父类同名方法：只需要BaseClassName.methodName()			
			>封装：
				>_单下划线开头实例变量protected不能import到,双下划线__开头变量类里private	
			>相关函数：
				>isinstance()
				>issubclass()	
			>空类的作用：class A():pass 可以绑定数据结构：。比如 a = A() a.data = 'abc'  ,  a.name = 'lishaoping'...	
		>特殊语法：简化语法：
			>生成器型列表：并不是直接将列表的值都生成放在内存中。而是实时使用时计算出来。。也只能迭代一次。也用于只迭代一次的场景。
					gen = (i * i for i in range(1,100,1))
				>生成器是一个不存数据的迭代器。调用时以计算的方式获得数据而不是读取的方式取得数据的迭代器，所以也可以.next()来获取下一个生成器计算出的值。
				>重要应用：生成器中定义生成器，子生成器中再定义/调用生成器，一直定义/调用，一直到多层，可以实现组合结果。
			>yeild:返回一个生成器对象---该对象记住了计算获取迭代值的代码起止位置和当前位置，且记住 计算迭代值的表达式（yield位置后）。
				>生成器运行取值程序，取到一个值就保存当前指针位置而退出生成器，而调用生成器的for继续执行--里面的内容，下一次取值调用生成器则生成器继续上一次位置执行
				>用next或用for in 才能让迭代器对象运行-取值退出-再运行
			>for快速赋值给数组	
				:如果后面是生成器，可以出现空循环----只要生成器没有返回值：或者只有当生成器返回了值--才会执行for里面的代码，而生成器本身的取值程序在一直执行。
			>print输出不换行： print 'sss',即加一个逗号结尾
			>阻塞等待获取控制台输入：raw_input('please input a line')
			>pass:什么也不做
		>脚本语言特性：
			>eval('表达式|源码')、exec()：动态表达式、源码解释函数。
		>闭包和切面编程：
			>关于闭包：
			    ----正确：
				>闭包是一个运行时生成的概念：(内存中的概念，方法栈帧概念)是运行时产生的一个变量-函数的空间。{}。（借鉴大数据里的发送闭包）。。一个闭包，两个闭包。
				>
			    ----闭包新解：闭包是一个内存空间概念。（闭包是一种存在，一种结构，内存结构，引用结构，独立空间的引用结构）
				>一个闭包是有独立空间的，闭包里的变量和函数都有独立的专门的新的内存空间的，只要闭包里的函数或者变量还被引用--被外部变量引用，被引用的这些变量或函数就不会被回收。退出闭包也不会被回收。
				>只有在执行一个函数调用的时候，会新建一个这个函数的闭包。函数执行调用完毕时，闭包里被外面的变量引用的变量或函数，以及被引用的函数里依赖的闭包里的变量，都不会被删除（其他可能被回收），且将只被外部引用的变量访问到，从而创建外部变量（对象）的私有变量。
				>因为词法性质的作用域（类似js），函数运行在定义它的直接作用域中，而不是调用它的作用域。
				>解释器在哪里找名称空间？向外找，所在空间和全局空间，而不是向并列函数里找。
			    ----错误：
				>闭包是一种特殊函数：里面调用了函数外的变量。即便是该函数在for循环里，for循环的局部变量也是外部变量。
				>闭包在定义的时候：无论匿名函数或者有名函数，函数里的代码是没有执行的--赋值也是代码也没有执行。
				>闭包在调用的时候：外部变量可能在闭包定义到调用之间值已经被改变了，那么闭包在调用的时候因为找该外部名称所在外部空间--而就会返回该变量的当前值。
						>更重要的是：调用一个闭包的时候，会生成一个闭包空间，里面有变量，如果这个闭包空间里还有定义另一个闭包，且外部闭包执行外后这个闭包没有删除--比如作为返回，那么这个闭包所在的外部闭包空间中的变量也不会删除--也会保存。函数运行栈栈帧。一个闭包空间就是一个栈帧。而for循环不会形成栈帧，所以不会形成闭包空间。
				>闭包如何能使用到不断变化的变量在某个时刻的值：或者说闭包如何暂时保存外部变量的值：可以把外部变量的每个变化值分别放到一个闭包中，而每个闭包中都有。
		>注解：带参注解有三级参数：注解本身的----被注解函数名称----被注解函数的实参
			>注解本身是一个函数：这个函数的输入就是被注解的函数
				>注解是用一个函数来注解另一个函数。。是函数替换-输出，是将被注解函数输入主注解函数而输出结果函数。注解的目的，注解的结果，就是输出结果函数。
			>函数被注解后，函数名指针已经不在指向原函数，而是注解本身返回的函数或者说输出的函数。
			>解释器在执行被注解的函数的定义的时候，即还不是调用的时候，注解函数开始执行---从下到上---并最终把注解函数输出的函数指针给被注解函数名
		>python3:
			>nonlocal
		>资源回收：
			>引用计数，为0则会被回收机制定期自动回收
		>交互模式特殊标记符：
			>_  :表示表达式最近一次的计算结果
	>常见功能：(常使用模块、包)（基本功能）
		>文件操作：
			>打开-读写：f = open(file, mode)返回文件对象.. w、a都可以没文件自动创建
				>f.read(size)  f.readline() 返回第一行：换行符会自动加上--即保留了。
			>文件指针移动：seek()  tell()
			>用完文件自动关闭：with  open() as f:   并且不会抛出异常  ..支持上下文管理协议的对象，就可以用--open函数实现了，所以可以，管理协议包括enter和exit两个方法。
		>系统操作：
			>许多linux命令操作实现。
			>第三方模块实现：win32service来控制对windows服务的启动、停止、服务状态查看。
		>多线程|进程操作：
			>进程操作：
		>网络操作：socket编程和http编程
			>socket:向网络发出请求和应答网络请求
			>套接字socket类型：服务器之间通信AF_UNIX、进程之间通信AF_INET
					>普通的TCP类型SOCK_STREAM、UDP类型SOCK_DGRAM
			>法1：创建socket并初始化--》绑定端口ip--->收发数据
			>法2：raw socket通信 AF_PACKET    linux上搞
		>GUI用户图形操作：
			>简单的demo。Tkinter  wxPython QT
		>matplot数学运算：
		>.py打包为exe: pip install pyinstaller   
			>pyinstaller 
		>远程调用：xmlpclib  SimpleXMLRPCServer
	>常见场景：
		>web网站开发：常用框架
			>bean管理：
			>数据库连接：访问
			>页面的开发：页面工具
			>优势在于：
				>建立简单的web服务器：非常方便：python -m SimpleHTTPServer 8999即可将当前目录当作项目根目录而建立一个web服务器。
		>爬虫：常用框架
			>requests + 
			>spacy
		>大数据操作：hadoop集群、spark集群的访问：常用框架
			>spark:
				>安装：pip install py4j \ pyspark (有211M)
		>机器学习算法的实现和访问：常用框架
		>微信公众号开发：
		>微信小程序开发：
		>微信小程序利用：
	>常见问题：
		>版本问题：python 32 /64位
		>编码问题：程序中
			>查看系统编码(ascii)：sys.getdefaultencoding()
			>设置系统编码reload(sys) sys.setdefaultencoding('utf8')
			>永久设置系统编码：方便pip安装包的时候不报编码错：UnicodeEncodeError: 'ascii' codec can't encode
					>新建文件：Lib/site-packages/sitecustomize.py  内容为上述三句。
			>源文件编码：文件内容编码-首行标记：#coding=utf-8 #coding:utf-8 #-*- coding:utf-8 -*-
		>包找不到：尤其当某个模块是拷贝过来的时候，需要拷完---不仅是文件夹--可能还有单个文件。



	>附加：
		>python　IDE:开发环境
			>PythonWin  pycharm
		>python 
			>编码规范：
				>代码块的开始和结尾：（强制，否则报错）
					>开始：按代码的层级关系缩进,每一行都是同样多的缩进（一个代码块，一级代码块）
					>结尾：不用分号。
				>代码块：包围不用大括号（包括流程控制if-else,for-while，函数定义方法定义），只用缩进和冒号。大括号是定义字典的。
					>顶级定义：函数-类之间空2行，方法之间空一行（非强制，会告警）
				>文件和socket:
					>关闭：减小消耗文件描述符、减少处理它们的资源
					>使用with管理文件
				>import导入：
					>自上而下：最通用到最不通用
				>命名规范：
					>module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name, function_parameter_name, local_var_name.
				>导入文件时文件主功能不能执行：所以主功能放在main函数中，且要有 if __name__ == '__main__'检查
			>注释：
				>函数：三引号：''' 里面'''
				>类、方法：三引号：'''
				>块注释：#
				>
			>程序：
			>


	>20个demo
	>说的这些，只能给大家一个片面的认识，希望大家亲自了解和操作以便有全面的认识。
	>缺点：太格式化，匿名函数定义不方便。
参考文档：
1.http://www.runoob.com/w3cnote/google-python-styleguide.html（编码规范）
2.https://pypi.python.org/pypi（包网址）
3.http://blog.csdn.net/qy924565830/article/details/53992708(各种模块的安装)
4.https://www.lfd.uci.edu/~gohlke/pythonlibs/（64位模块的安装）
5.https://www.cnblogs.com/wumingxiaoyao/p/7047658.html(socket编程详细)
6.http://www.runoob.com/manual/pythontutorial/docs/html/errors.html（参考资料2）
7.http://blog.csdn.net/qq_31776303/article/details/78994763（微信小程序跳一跳）

			
	

