1.$类方法（静态方法）的扩展：$.extend({add:function(){}});

2.$对象的方法扩展：$.fn.extend({add:function(){}});//在原型prototype上扩展方法
   另一种写法：$.fn.add = function(){};


3.$("#d").data("key", {});//为对象绑定数据，可以访问到。

4.$("#i").bind("click", function(){});//可以给对象绑定事件。。与on的区别在只能对已经创建的dom进行绑定，不能对将来创建的元素绑定，而on可以。

5.函数、方法的调用方式：
  直接的：()括号调用方式。那么该函数、方法使用的this里面存储的数据是该函数|方法默认定义的。
  间接的：.call(obj) / .apply(obj,[]) 调用方式。那么该函数、方法使用的this里存的数据就是obj里面this里存的数据了，而不是该函数默认的数据。
  ------表明一个功能：只要有相同的this数据结构,方法定义在哪个函数/类里都一样，没定义的其他类同样可以调用这个方法|使用这个方法，只是用间接的.call | .apply方式。而自己也没必要再次重复定义一个方法。起到不继承也“拥有”“可以享受”相同的服务，，相当于租用，免费使用的服务，无代价的服务。
  -----任何一个对象都可以使用该函数，都可以作为该函数的作用域..所以回调函数的作用域可以不断改变，在一个jquery对象数组被遍历时，可以以当前的jquery对象为作用域的方式调用回调函数，则每次回调函数都会有不同表现---完全不用传递参数！！！，并且，从而回调函数或者说函数中this就是指遍历数组时的当前元素。。
      （上述是this和call方法最佳的协同方式，jquery的map()函数就是使用了这种协同方式的函数---参数函数必然是以call方式调用的）

6.dom相邻元素选择：
  siblings()同辈元素（不含自己）， parent()上一级元素（parents()则是祖先元素）， children()下一级子元素
  next()  prev()相邻元素。
 
7.this的可能值（不同作用域）：
   7.1 任何函数的执行都有调用对象，而这个调用对象在函数内用this可以访问到。
   7.2 游离的this对象是window对象。
   7.3 以new的方式调用函数时，函数内部的this发生改变，变为它自己。以.call(obj, "")方式调用时，函数作用域this变成obj。
       即是说，一个函数内部要把方法绑定到自己对象上，而不是绑定到window对象上，就要以new的方式调用这个函数，而不是直接()调用。
   7.4 举例：jquery对象，也是new出来的，封装了dom对象的相关信息。jquery对象的方法也是绑定到jquey本身函数的，而不是绑定到window对象----从而不污染window对象属性和方法。所以，按此方法，本人也可以写一个类似jquery的js框架出来。
   7.5 直接定义对象{}。其中的函数型值，函数里面的this是这个对象，因为{}本质是是new 了一个对象，而键就是属性，值就是属性值。
   7.6 游离变量或者函数会被绑定到window。非游离，就是该函数或者变量放到了某个属性下。遍历函数中的回调函数，这个回调函数就是遍历函数遍历每个元素时绑定该函数到该元素中的。
   7.7 new时，做了什么？和直接调用的区别，认为就是：new时，将 this重新赋值为{}。即首行加入this = {};并且末行加了一个return this。还有详细的差别，比如__proto__是不一样的：
       用户定义的类的对象即this的__proto__里面有constructor方法不一样。
   

8.map()函数（jquery对象使用时）
  //形成一个map对象。键为回调函数的返回值。值为数组中的当前元素。
  数组而已。
9.事件冒泡
  》根据页面和js建立了“对象-各事件的响应组” 
  》实时的，监听线程（可以多个）监听外部输入或者js调用，有事件发生，则封装事件并入栈。
  》实时的，处理线程（可以多个）弹出事件栈中的事件，分析该事件影响到的对象（这个是从dom树的最底层最细小的元素往上，到最顶级容器的查找过程。又叫冒泡过程），匹配到一个对象立即执行对应事件函数---没有该事件的函数则继续往上：从最相关的对象到次相关的对象，整个过程中共享的对象是e,一个事件对象。所以如果在某一个事件函数里设置了e的禁止冒泡属性值，那么主程序不会再往上找。
   根据e.target还可以直接设置在body上而统一在一个地方定义click...等事件。（事件委托）


10. 闭包
  》当有必要在函数内定义局部变量（而不是属性变量，因为那个量不是它属性），
  》又有必要在外部访问函数内的这个局部变量（且为直接调用，而不是构造对象来调用）
  ---则定义这个函数，就会在内部定义成闭包形式。

   》或者说有必要隔离出几个变量出来专门对它们操作。就会自然而然定义出一个闭包函数。
   》或者说有必要定义几个隔离开来的变量并定义一个专门对这些变量操作的工具类，就会自然定义一个函数，隔离变量作为局部变量，工具类作为函数的返回值。

  ---每次调用这个函数，都会形成一次上下文。（闭包关联到一个执行上下文：包括局部变量和操作方法）
11.函数与执行上下文（活动上下文）
  函数执行一次，就会创建一个新的活动上下文，所以说每次调用的值是互相不影响的。
  函数第一次访问函数外部的变量时，该变量的值是该变量所处活动上下文的当前阶段（结束或者执行过程中）的值。
  一段代码的执行，都会先形成一个新的上下文，每次调用一个函数执行其中内容时，会形成一个新的活动上下文，如果其中有定义一个函数，那么执行这个定义时，这个定义的函数会绑定到所处的活动上下文（当然不会执行，只是定义它），同时扫描其中局部变量和引用变量，创建函数作用域链。。所以调用函数n次，形成了n个活动上下文，分别都绑定了一个定义函数。每个活动上下文之间没有任何关系。
   （函数指针》函数作用域链》活动上下文）
12.脚本语言（函数和类定义是一样的，都支持的）最重要的：就是活动上下文。
   ---函数最重要的就是活动上下文。
 
13.js函数执行顺序
   》立即执行函数  。此时，dom还没有建立，前面部分的js已经加载完成，所以访问dom将什么也得不到。
   》document.ready函数。。此时，已经建立dom，可以访问到dom里面的元素。
   》jquery对象函数  。。和docoment.ready函数执行等级一样，谁先谁先执行。
   》window.onload函数。。最后，所有资源加载完毕，开始执行。