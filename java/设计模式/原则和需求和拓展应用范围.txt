1.问题描述：
   预备：
   事先明确：
   整体原则：不修改代码而调整功能。最高原则。
		（抽象的东西，形式不变，而功能可以改变。具体的东西，形式改变，功能才改变）
		 （所以用抽象的东西，搭建起来的结构比用具体搭建起来的结构稳定、牢固）
		   （搭建系统，就是搭建规范和契约，和结构，是最顶层的设计，适用范围和功能范围最广包容最广的设计，而不设计具体的操作、实现）（抽象和具体都要依赖抽象）（只有main函数才能构造具体、依赖具体，其他都必须要依赖抽象）
			(方便以后扩展和升级，降低依赖，降低耦合，接口编程，依赖抽象)
	     不做多余的实现，抽象的东西内容要少。（抽象接口可以多，但内容需要少）（先定义许多抽象，再定义若干具体）
	     		（低耦合、高内聚。）（能不公开的方法属性都私有化，不泄露给任何其他类，不给任何其他类看到或者使用）

	>三方：已方、依赖方、调用方
	>目的：#简化编程、清晰条理化编程---组织代码、责任分解--动作分解--每个动作具体明确都有对象负责（而动作本身类型上不同，导致了分工不同，责任不同，事务不同）、
		对象分类与关联：既能统一确定处理又能专门独立处理、功能单一功能明确
	       #缩短运行时间、加载时间、搜索时间，避免、减少反复的重复的动作--或者得到重复的结果--删了又建
		梳理流程、用更简单的流程达到同一效果
	       #无障碍扩展、不修改扩展(继承和实现的重要作用和意义)（功能扩展、功能覆盖、功能关闭）
		 
	       #权限控制（不能拥有某方法、不能调用某方法）
	>原则：
	>需求：
	>规律：有需求，就有实现，最佳实现就是使用了规律，按照这种规律设计的流程就是一种设计模式。

	>推演，应用范围，扩展开来可以达到的应用范围：

2.具体的设计模式：
	>创建型设计模式：已有类构造它的对象---具体方法、形式
	    >创建需求：
		     >可以的实现、常见的实现和最佳的实现：
		     >遵循的原则：
		     >使用的规律：
		     >设计的具体流程--及其达到的目的：
	>构造型设计模式：已有类，利用它依赖它构造新的类、目的在于扩展已有类的方法--具备更多动作：
		     >

	>行为型模式（管理型模式）：已有类，构造新的类，含有已有类的容器--或者应用变量（但没有具体的对象，这个需要外部输入），新的类本身也有简单的高层次的独立的不同的功能，输入已有类具体的对象（若干个），
					目的在于控制它们、组织它们、管理它们、服务它们，从而作为一个整体具有整体功能----即在调用方看来：已有类和新类作为整体实现的体现的功能。


3.需求演练---拓展展开理解：
    预备：先有原则、需求，后有java语言设计（后有面向对象的语言）
	3.1比如一个具体的方法，其中的代码，有调用其他类的对象的方法。但现在希望不用那个类，而是用其他的类的对象的方法来替换，但是要求不能改这个具体的方法。
	       做法：做法就是：引用该类的对象的变量，应该可以同样引用新的类的对象，所以这个变量应该是旧类和新类的共同父类或者接口；其中条件：在方法里不能有具体new出旧类对象，而是调用方输入设置进去的。
	       结论：所以：原则之一：编写方法之内的内容时，尽量不要使用new出对象的方式，能则必须要用接口或者抽象类类引用对象。不用new的方式，可以用工厂类方法的方式获得或者是调用方注入。
	       推论：这样就不用修改方法体内容了。
	       推因：因为需求的变化，而反复修改同一个方法体内容，是不科学的。只有因为这个方法体的内容逻辑-流程有问题需要修改、内容实现不够好需要修改、内容不能满足新的需求。
	       推论2：不能因为配置、业务需求而修改可以用配置实现更改功能的代码块--方法。
			即：能够通过配置和外部注入的方式，使同一个方法达到新的功能，就不要用直接改方法体内容的方式。。。而要达到不要改的效果，还要求在最开始写代码的时候就要，对象尽量用注入、引用尽量用接口，来让以后尽量只用配置和注入的方式就能实现功能的转换、调整。
	       推论3：为以后着想，为以后尽量只需要外部注入和配置的改变就实现一方法功能的转变和调整，在编写方法实现的时候，就要尽量使用接口，不new来得到对象。
	       另论：方法都注入和配置，那么必然有最上层最终调用方使用的注入和配置，--往往从文件中提取出配置出来，注入第一层，层层传递，最终工作类和每一层的类都有具体的对象，来完成相应的功能。而整体结构没有变。
	       推论4：方法功能的转换，应该尽量考注入和配置，而不是直接改变程序方法的结构和具体流程代码。（方法的多态？）
		（开闭原则）（对方法体的要求及其考虑原因）（不变代码而调整功能）
	
	3.2对于上述编程要求，需要编译器来具体配合、解释。
		编译器：必须要允许和识别抽象类和接口引用，能够根据引用变量类型和对象的引用类型中的方法（也能判断对象的该方法是否来自该引用类型类），和对象的实际地址，来实际执行对象的该方法的具体实现代码。
			这就要求引用类型类和具体实现类之间要有指定指明的继承关系或者实现关系（没有，那么编译器无法识别是否实现类对象的方法来自引用类型类），而这种指定关系在定义具体类时候就要指定。这就是extends 或者 implements
		>推论：为实现上述不变代码而调整功能，要指定指明关系，即在定义具体实现类时候指定exdends 引用类型类（接口）。
		（里氏代换原则）（定义类，定义具体类功能类）（指定引用类型）

	3.3比如一个具体的属性（set方法），方法的形式参数（构造方法在内），它有时是本类依赖的类（依赖关系，关联关系。同属性之间可能组合关系），是一个工具类，具体类，但是以后可能是有新的具体类效果更好或者符合需求，而要替换，此时就要修改这个具体类，。。而只要修改来调整功能就不好，而要不修改就调整功能，可以将这个属性设计为一个抽象类、接口，一个各个具体工具类都实现的接口都引用的接口，是这些具体实现工具类的引用类型。
		所以，就是依赖抽象、接口，而不是依赖具体，依赖高层而不是依赖低层。只能依赖更抽象，不能依赖更具体。抽象和具体都要依赖抽象，只有最终调用方---main函数---而不是某个类才构造具体，即才依赖具体。。
		（依赖反转原则）（依赖型属性，要抽象而不要具体）（和常规的依赖具体不同，依赖抽象）
		
	3.4比如一个抽象的接口，方法太多那么其实它就变得具体了，是一个精确的接口，实际上各个使用场景继承实现类只需要其中少数方法而已，其他的是多余的。所以为了各个场景各取所需，自然想到接口分离出新的接口。每个接口专门收纳几个接口方法。
		（接口隔离原则）（实现类不应当做多余的实现，不需要的实现）（抽象类接口的内容能少则少，不能给实现类多余的负担）

	3.5比如一个实现类的方法或者属性，如果仅仅是内部使用，那么外部调用方就不应该能访问到。所以要private私有化，对于私有属性就不能有get方法。
		 依赖方公开的方法应该尽量完成功能，而不是未彻底完成而暴露一些类出来，给本方，导致本方依赖了依赖方所依赖的类。自己的依赖尽量不能传递给调用方。
		（迪米特法则）（最少知道法则，尽量不要让调用方依赖本方的依赖方，即不要让调用方知道本方的依赖方）
	3.6比如一个具体类，让它继承一个类，不如让它依赖一个类。减少耦合。否则父类改变，子类就要改变。比如父类增加了抽象方法或者具体方法，修改了抽象方法或者具体方法。而合成复用，就完全不关心不受父类内部的各种变化。
		 （合成复用原则）（依赖对于继承来说，改动要小）

    一个类的定义可以体现6个原则：
	public class C extends A implements B,G,I{//2个原则,extends和implements
	   private M m;
	   private void hello(D d){//2个原则，private 和D
	    	d.hello();
		E e = Factory.getInstance();
		e.work();
	   }//内容一个原则
      }
4.问题解答：
	>为什么要减少修改？尤其是属性的类型的修改,因为使用它的方法很多，一改全都改，而且对于调用方来说，还要跟着修改，非常麻烦。
			所以开发设计类时，必须考虑到让以后尽量不用修改类的代码就能实现功能转换的效果、作用。

