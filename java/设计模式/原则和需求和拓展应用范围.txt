1.问题描述：
   预备：
	>三方：已方、依赖方、调用方
	>目的：#简化编程、清晰条理化编程---组织代码、责任分解--动作分解--每个动作具体明确都有对象负责（而动作本身类型上不同，导致了分工不同，责任不同，事务不同）、
		对象分类与关联：既能统一确定处理又能专门独立处理、功能单一功能明确
	       #缩短运行时间、加载时间、搜索时间，避免、减少反复的重复的动作--或者得到重复的结果--删了又建
		梳理流程、用更简单的流程达到同一效果
	       #无障碍扩展、不修改扩展(继承和实现的重要作用和意义)（功能扩展、功能覆盖、功能关闭）
	       #权限控制（不能拥有某方法、不能调用某方法）
	>原则：
	>需求：
	>规律：有需求，就有实现，最佳实现就是使用了规律，按照这种规律设计的流程就是一种设计模式。

	>推演，应用范围，扩展开来可以达到的应用范围：

2.具体的设计模式：
	>创建型设计模式：已有类构造它的对象---具体方法、形式
	    >创建需求：
		     >可以的实现、常见的实现和最佳的实现：
		     >遵循的原则：
		     >使用的规律：
		     >设计的具体流程--及其达到的目的：
	>构造型设计模式：已有类，利用它依赖它构造新的类、目的在于扩展已有类的方法--具备更多动作：
		     >

	>行为型模式（管理型模式）：已有类，构造新的类，含有已有类的容器--或者应用变量（但没有具体的对象，这个需要外部输入），新的类本身也有简单的高层次的独立的不同的功能，输入已有类具体的对象（若干个），
					目的在于控制它们、组织它们、管理它们、服务它们，从而作为一个整体具有整体功能----即在调用方看来：已有类和新类作为整体实现的体现的功能。


3.需求演练：
	3.1比如一个具体的方法，其中的代码，有调用其他类的对象的方法。但现在希望不用那个类，而是用其他的类的对象的方法来替换，但是要求不能改这个具体的方法。
	       做法：做法就是：引用该类的对象的变量，应该可以同样引用新的类的对象，所以这个变量应该是旧类和新类的共同父类或者接口；其中条件：在方法里不能有具体new出旧类对象，而是调用方输入设置进去的。
	       结论：所以：原则之一：编写方法之内的内容时，尽量不要使用new出对象的方式，能则必须要用接口或者抽象类类引用对象。不用new的方式，可以用工厂类方法的方式获得或者是调用方注入。
	       推论：这样就不用修改方法体内容了。
	       推因：因为需求的变化，而反复修改同一个方法体内容，是不科学的。只有因为这个方法体的内容逻辑-流程有问题需要修改、内容实现不够好需要修改、内容不能满足新的需求。
	       推论2：不能因为配置、业务需求而修改可以用配置实现更改功能的代码块--方法。
			即：能够通过配置和外部注入的方式，使同一个方法达到新的功能，就不要用直接改方法体内容的方式。。。而要达到不要改的效果，还要求在最开始写代码的时候就要，对象尽量用注入、引用尽量用接口，来让以后尽量只用配置和注入的方式就能实现功能的转换、调整。
	       推论3：为以后着想，为以后尽量只需要外部注入和配置的改变就实现一方法功能的转变和调整，在编写方法实现的时候，就要尽量使用接口，不new来得到对象。
	       另论：方法都注入和配置，那么必然有最上层最终调用方使用的注入和配置，--往往从文件中提取出配置出来，注入第一层，层层传递，最终工作类和每一层的类都有具体的对象，来完成相应的功能。而整体结构没有变。
	       推论4：功能的转换，应该尽量考注入和配置，而不是直接改变程序方法的结构和具体流程代码。



