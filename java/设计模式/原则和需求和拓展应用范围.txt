1.问题描述：
   预备：
   事先明确：
   整体原则：不修改调用方代码而调整功能，而让调用方利用到新的服务新的实现。（改变的是main运行参数）最高原则。
		（不能修改类中的代码来调整功能，而只能修改main函数中的代码来调整功能，即修改运行参数、初始化参数。而类还是好好的，没动。main函数不属于任何类，是运行启动函数，可以改，每次运行前都可以改。）
		 （main中的代码每次运行时都可以改，而写好的类，那么每次运行前，都不应该再改）（main中的运行参数可以提出来到文件中，从而每次运行前自由调整，而类编译好之后，已经无法改了，得改源代码再编译再部署替换软件包，从而不能利用到上次运行所加载的类，，这个必须关停系统才行。。而改变main参数，重启---可以通过重新执行main函数来完成，而且不用再重新加载依赖的那些类，因为已经在内存中jvm数据区中，非常快）
		（抽象的东西，形式不变，而功能可以改变。具体的东西，形式改变，功能才改变）
		 （所以用抽象的东西，搭建起来的结构比用具体搭建起来的结构稳定、牢固）
		   （搭建系统，就是搭建规范和契约，和结构，是最顶层的设计，适用范围和功能范围最广包容最广的设计，而不设计具体的操作、实现）（抽象和具体都要依赖抽象）（只有main函数才能构造具体、依赖具体，其他都必须要依赖抽象）
			(方便以后扩展和升级，降低依赖，降低耦合，接口编程，依赖抽象)
			（软件不是独立的软件，总有调用方，总给调用方一些接口。而调用方总会改变需求，或者软件总有升级，而有了新的实现，不应该要求调用方改变代码来运行到升级后的新的实现，而是改变调用方的最终调用者main的运行参数就可以。）
	     不做多余的实现，抽象的东西内容要少。（抽象接口可以多，但内容需要少）（先定义许多抽象，再定义若干具体）
	     		（低耦合、高内聚。）（能不公开的方法属性都私有化，不泄露给任何其他类，不给任何其他类看到或者使用）(尽量不要写死，只在最终调用方写死)
	     				（设计师，定义接口，和编写main函数而已）
				（避免反复操作，避免多处重复的同样流程----要提取出来）
				（不能职责过多，过多就不能共享，过多就会重复实现。。。划分职责到不同方法，不同类，自然分层自然功能共享）
				(最少依赖)
	     不暴露需要隐藏的逻辑。（比如创建逻辑，或者因为创建需要大量配置，或者往往不希望调用方直接new，而是要访问控制，只能通过专门工厂类获取，直接提取就可以了）

	     不使用模式和使用模式效果一样，则不使用模式。

	     ----接口编程、功能单一（平行切分--分段分步骤，或者包围切分--整体与内部与内部的内部）、暴露最终（隐藏细节，调用方使用简单，基本不用额外的操作，直接使用，从而调用方专注于自己的业务代码。同时，避免了调用方随便使用而破坏了内部的数据和和数据结构使功能异常）
		形式上--接口编程
		功能上--职责单一
		服务上--隐藏细节
   模式本质：去掉模式二字，即是本质--即产品，功能产品
	    是24种模型产品、标准模型、编程模型、程序模型、流程模型、编程结构、流程模板、设计模板、功能类别、功能模型、功能单元、基本功能单位、场景类别、常见场景类型（编程编了20年，总结出的世界上的场景类别---实际上就那么24种）。
	    ---24种模板长什么样？就像古代一共有24种兵器。设计原则就是兵器的使用原则。


	>三方：已方、依赖方、调用方
	>目的：#简化编程、清晰条理化编程---组织代码、责任分解--动作分解--每个动作具体明确都有对象负责（而动作本身类型上不同，导致了分工不同，责任不同，事务不同）、
		对象分类与关联：既能统一确定处理又能专门独立处理、功能单一功能明确
	       #缩短运行时间、加载时间、搜索时间，避免、减少反复的重复的动作--或者得到重复的结果--删了又建
		梳理流程、用更简单的流程达到同一效果
	       #无障碍扩展、不修改扩展(继承和实现的重要作用和意义)（功能扩展、功能覆盖、功能关闭）
		 
	       #权限控制（不能拥有某方法、不能调用某方法）（调用方不能知道创建逻辑，不能直接new，访问限制）
	>原则：
	>需求：
	>规律：有需求，就有实现，最佳实现就是使用了规律，按照这种规律设计的流程就是一种设计模式。

	>推演，应用范围，扩展开来可以达到的应用范围：

2.具体的设计模式：
	>总论：
		模式的本质是：服务的模式。给调用方怎样的接口和怎样的运行参数。
		来源：调用方需求接口和运行参数，己方提供实现、提供接口和运行参数。
			调用方对接口的使用：或合成复用、或继承实现、或依赖关联。
			#策略模式---以接口组织内部具体实现对外提供多样化选择服务：调用方直接调用，而改变main运行参数可以改变调用方实际享受到的服务（实际调用到了提供方不同的实现）。
								       不变调用方代码而让调用方运行提供方新的实现。调用方在内部或者外部，只是一个类。
									在运行参数中提供具体的算法选择。
			#代理模式---没有改变调用方代码而让调用方运行了提供的代理实现，而不是原来的实现。			

	>创建型设计模式：已有类构造它的对象---具体方法、形式（最佳的方式，是不直接new的方式）
	    >创建需求：
		     >可以的实现、常见的实现和最佳的实现：
		     >遵循的原则：
		     >使用的规律：
		     >设计的具体流程--及其达到的目的：
	>构造型设计模式：已有类，利用它依赖它构造新的类、目的在于扩展已有类的方法--具备更多动作：
		     >

	>行为型模式（管理型模式）：已有类，构造新的类，含有已有类的容器--或者应用变量（但没有具体的对象，这个需要外部输入），新的类本身也有简单的高层次的独立的不同的功能，输入已有类具体的对象（若干个），
					目的在于控制它们、组织它们、管理它们、服务它们，从而作为一个整体具有整体功能----即在调用方看来：已有类和新类作为整体实现的体现的功能。
					(调用其他对象，对象之间的通信，一个对象知道另一个对象的信息)
				
			>策略模式：
				>处理的问题、情况：
					>己方：写10个算法方法，每个算法是实现同一个功能的不同方式。
					>调用方如何调用：是高内聚低耦合的，即调用方法里调用算法的时候，情形是：输入算法，内部执行这个算法。
							如何可以实现不改变调用方代码而调整算法改变算法。。。当然，最终调用方，即main函数里可以改变且必须在这里改变算法。两次运行，两种效果。main里是初始化。
					>如何设计依赖方出现的位置和引用类型：
	
				>分析情况并自然导出最佳方案，且就是本模式做法：
					>将10个算法方法写在同一个类当中，那么调用方就会写死算法，以后要调整算法，就不能再main里调整，而只能在调用方中改变代码。。这违背了开闭原则。
					 显然，反过来看，调用方不调整代码，而是在main里调整，那么调用方调用的方法必然是一个接口方法。而一个算法就是一个接口方法的实现方法，所以一个算法方法得放到一个类当中。每个算法类实现同一个接口，这个接口就是调用方调用时使用的方法。
				>现实情况和现实需求：
					>现实情况就是：调用方，经常需要被调用方（己方）调整功能、调整具体的实现。但不希望改变调用方的代码。
						调用方也是类，也是不能改的。软件升级，为兼容，即旧版本能放在的地方---周围有很多调用方在调用--在依赖，新版本放上去不会出现兼容问题。
					---加密算法、软件升级同一方法新的实现	
			>代理模式：
				>处理的情况：
					>本来某种服务已经有了一个接口（及其实现类）来提供了，并且有许多调用方已经在使用这个接口（即写到了调用方的代码里），但现在的需求最新的需求是，具体的实现类功能上无可挑剔且要保留，但是要在某方法运行前后执行一些代码，那么可以构造实现类的一个代理类，代理类实现同样的接口，并调用该实现类的方法作为同样方法的实现体，只是在调用前后分别执行一些方法。
					  而运行参数上即main函数上则就改成了给调用方注入代理类。
					----切面AOP	
			>单例模式：
				>需求：一个类，对外只能提供一个实例。调用方永远也只能获取到同一个实例。
				>实现：私有化构造方法，保证new对象方法只会执行一次---比如加载类的时候，比如用同步锁。对外提供一个方法，返回这个单例对象的引用。
				---SpringContext\ ControlEngine
			>普通工厂模式：
			>静态工厂模式：
				>获取一个类的实例，但是每次创建实例都需要专门被处理，创建太麻烦，需要大量配置（且配置最佳又不在程序里而在配置文件里），且不希望调用方知道创建逻辑，所以调用方不能直接new，而是需要用专门工厂类提供的方法。
						再，可能会调整具体的实例类型，或者调整实例的各个配置参数，而可以直接修改main启动参数实现，工厂方法不变。（日志实例对象，这个配置就复杂，所以用工厂模式，从配置文件里提取配置信息构造一个对象返回）
						------复杂实例的构建，往往都需要用工厂模式。---其他情况下，没必要使用工厂模式。	
					LogFactory
			>抽象工厂模式：
				>需求方需要：提供一个创建具体工厂的工厂。显然具体工厂就要继承这个工厂，这个工厂像一个接口，不应该可以实例化或者负责实现生产，所以是一个抽象类。
					     这样，调用方不用修改代码就能将一种工厂切换为另一种工厂，从而调用方可以用切换为的新产品工厂生产出不同类的工厂。而改变main运行参数---非new的方式也可以就能获取到新的工厂。
				>使用：调用方使用抽象工厂进行编写类，而用工厂生成器来生成一个具体工厂。（抽象工厂本身不负责生产工厂，而只是引用具体工厂）
				>对外暴露为：抽象工厂和工厂生成器。
					AbstractFactory
			>建造者模式：
				>市场需求：（编程需求）
				>对外提供什么服务：（这种模式编写的程序对外提供什么服务，或者这种模式编程实现了什么功能）
						  对外提供一个建造者类，调用方提供（输入）一系列的项目，建造者类实例按照一定算法组合而返回一个组合后的整体。
				>调用方怎么使用：（对外暴露的接口）
						实例化建造者，增加项目。获取组合结果。
					StringBuilder
			>原型模式：
				>需求市场：需要一个实例的拷贝（而不是引用）
				>提供方：使用原型方法生成一个实例---浅拷贝，认为低层是通过反射机制来实现的---也比较容易和熟悉。用非new方式（new方式是一种自动的反射，而非new方式就是手动反射）创建了一个类。
				>调用方：只需要实现Cloneable接口，调用其中clone()方法即可。
					Cloneable
			>适配器模式：
				>需求市场：做一个已有软件的适配器来扩展未做可改调用方的功能。。调用一个已有软件太复杂的问题，所以产生了适配器，改成调用这个适配器。
				>调用方：还没有开始写，或者可以修改代码。但是不希望包含调用已有软件的逻辑（因为调用这个软件的逻辑也复杂，可能有多个分支，或者需要输入多个参数，来调用已有软件的不同部分）-----所以希望有个类去专门调用，而我调用方去调用这个类就可以，这个类就是适配器。
					 先写了适配器，再写调用方。
					（何时需要一个适配器，再写一个适配器。或者调用一个适配器）
					（包装好已有方，因为已有方有复杂的调用逻辑）
			>桥接模式：
				>何时需要桥接：更像是一个创建型模式。需要一个多维度描述的类的实例。
				>实现方：与其通过层层继承的方式，来最终形成一个多维度的具体类的定义。不如，每个维度分别是一个类，最后上层的类的实例挂接到下一层类的实例上，形成最终的低层的类的实例就是一个精确的类的实例。而，每层的实例可以不同，因为下层引用的上层是一个接口型。	
					  层层引用上层接口的方式来构造具体精细实例。最上层是一个接口，下层每层都是一个抽象类，若干个它的实现类，其中抽喜类引用上层的抽喜类或者接口。
				>调用方：可以自定义进行各层new和挂接，来最终形成一个精细的实例。
					（包装好已有方，因为已有方需要专门创建对象）
			>门面模式：
				>需求：何时需要一个门面？
					本方：提供了大量的子系统--并列的。
					调用方：如果直接调用子系统会很麻烦。而对子系统的操作往往是类似的，所以可以提出一个门面，对各个子系统统一操作。
					       从而调用方只需要依赖这个门面就可以控制整个若干个子系统的系统了。
					（包装好已有方，因为已有方许多。。调用方每次使用都要大量写，不如直接写一次--写在门面里，以后的地方就调用这个门面就可）
			>享元模式：
				>需求：获取某个类的实例，希望有就返回引用，没有空余的才创建实例。来节省开销。
				>满足需求：管理池，初始化创建一批，且保留，用完继续保留，不删除。
				>调用方编程:只需要调用获取实例方法即可，不必关心是已有的还是新建的。

					String 线程池中的线程、数据库连接池中的连接
			>责任链模式：
				>需求：何时需要构造一个责任链？一个需求处理链---层层处理链（往往一个系统的过滤器、拦截器，是一个链）。
					即是需任一个实例能调用下一个实例（且不知道下一个实例是什么怎么执行的），依次调用直到最终实例。
				>满足需求的设计：可以自然反推到，最简设计时，所有实例的类实现同样的接口，而在同样的方法中，要执行下一个实例，那么必然要取到下一个实例，但是又不能直接取，所以要设计一个共同类，让它去取，它知道下一个是什么实例，它内部有标记--计数器。同时让它去调用下一个实例的同样的属于接口的方法。
						  这个辅助类先假定为Chain类。
						 （此外，用桥接模式同样可以实现---但是只适合少量过滤，因为要手动指定每一个元素的下一个元素）
				>调用方使用：只需要调用Chain类来有序输入若干个实现了上述接口的任何类的实例，执行Chain类启动方法就可以了。
						（即先编写实现接口的类）
						（同时最终类可以是另一种类，不需实现上述接口，而用反射的方式调用它的方法来执行）
						 （而每个过滤器可以选择处理或者不处理，交给下一个处理器或者停止交给下一个处理器直接返回）
					
					Spring-security过滤器链，web过滤器链，监听器链。
			>命令模式：
				>需求场景：命令调用类、具体命令类，所有命令的解析执行类。。定义命令调用命令实际执行事务。
				>设计满足：依次依赖，不跨层依赖，且向右依赖。使得职责单一，命令的调用和命令的实际解析分开了。
				>调用方：依赖命令，调用命令即可。
						
			>解释器模式：
				>功能：描述分解语言并运算语言,划分出表达式，再进一步划分分解，单位不断变小，产生有序的有结构的一系列命令-=单元。
				>所以构成：表达式对象，和表达式对象之间的运算方法对象。
				>调用方：输入一个描述语言---即一句话。则解释器负责分解而理解这句话的含义，分解为一个一个的命令，则交由具体的命令执行者去执行。
				 	面向对象语言解释器编译器。
			>迭代器模式：
				>迭代器是集合的迭代器，是集合的遍历工具。
				>调用方不必直接去看集合有多少元素，一个一个的去访问，因为不同的集合类型，访问方法不同。
						访问集合的元素交给迭代器。调用方只需要关心还有没有元素，有则返回这个元素。
						同时即便以后具体集合变了，也不用修改源代码，因为同样有迭代器。
				
			>中介者模式：
				>将类之间的网状耦合关系，梳理为星形耦合关系，屏蔽类的改变对其他类的影响，从而只会影响到中介者本身，而其他不用改代码。
				    相互关系--相互通信变为中心通信。降低节点负担---减少节点代码。或者每个节点没必要知道其他所有节点的联系，或者根本不知道其他节点，很难知道其他节点。
					server端、controller就是**的中介者。
					群聊--聊天室，就是一个中介者。每个调用方只需要都调用它--即比如静态方法就可以消息汇总了，而且可以发给每一方调用方。
			>备忘录模式：
				   >需求：何时需要一个备忘录：，存什么信息？
				   >满足方设计：一是存储备份--或者操作历史操作状态，而是返回备份---操作历史--操作状态。
				   		备忘，存储的实际上是一个系统某个时刻的状态--即各方面的度量，而这些度量需要备忘录自己找。
					      -----更正确的是，每个调用方都有一个自己的备忘录，当调用方想备忘的时候，直接调用自己的一个备忘方法，状态信息存到备忘录里，而恢复到备忘之前的状态，则调一个方法直接重新设置了自己的状态值到备忘时的各方面状态值了。
				   备忘录让调用方一键备忘和一键恢复。
			>观察者模式：
				   >何时需要一个或多个观察者？被观察者是谁？（通知者模式）
				   >需求：调用方是明星、机构、卖方，观察者是粉丝、欣赏者、买方。
				   >


3.需求演练---拓展展开理解：
    预备：先有原则、需求，后有java语言设计（后有面向对象的语言）
	3.1比如一个具体的方法，其中的代码，有调用其他类的对象的方法。但现在希望不用那个类，而是用其他的类的对象的方法来替换，但是要求不能改这个具体的方法。
	       做法：做法就是：引用该类的对象的变量，应该可以同样引用新的类的对象，所以这个变量应该是旧类和新类的共同父类或者接口；其中条件：在方法里不能有具体new出旧类对象，而是调用方输入设置进去的。
	       结论：所以：原则之一：编写方法之内的内容时，尽量不要使用new出对象的方式，能则必须要用接口或者抽象类类引用对象。不用new的方式，可以用工厂类方法的方式获得或者是调用方注入。
	       推论：这样就不用修改方法体内容了。
	       推因：因为需求的变化，而反复修改同一个方法体内容，是不科学的。只有因为这个方法体的内容逻辑-流程有问题需要修改、内容实现不够好需要修改、内容不能满足新的需求。
	       推论2：不能因为配置、业务需求而修改可以用配置实现更改功能的代码块--方法。
			即：能够通过配置和外部注入的方式，使同一个方法达到新的功能，就不要用直接改方法体内容的方式。。。而要达到不要改的效果，还要求在最开始写代码的时候就要，对象尽量用注入、引用尽量用接口，来让以后尽量只用配置和注入的方式就能实现功能的转换、调整。
	       推论3：为以后着想，为以后尽量只需要外部注入和配置的改变就实现一方法功能的转变和调整，在编写方法实现的时候，就要尽量使用接口，不new来得到对象。
	       另论：方法都注入和配置，那么必然有最上层最终调用方使用的注入和配置，--往往从文件中提取出配置出来，注入第一层，层层传递，最终工作类和每一层的类都有具体的对象，来完成相应的功能。而整体结构没有变。
	       推论4：方法功能的转换，应该尽量考注入和配置，而不是直接改变程序方法的结构和具体流程代码。（方法的多态？）
		（开闭原则）（对方法体的要求及其考虑原因）（不变代码而调整功能）
	
	3.2对于上述编程要求，需要编译器来具体配合、解释。
		编译器：必须要允许和识别抽象类和接口引用，能够根据引用变量类型和对象的引用类型中的方法（也能判断对象的该方法是否来自该引用类型类），和对象的实际地址，来实际执行对象的该方法的具体实现代码。
			这就要求引用类型类和具体实现类之间要有指定指明的继承关系或者实现关系（没有，那么编译器无法识别是否实现类对象的方法来自引用类型类），而这种指定关系在定义具体类时候就要指定。这就是extends 或者 implements
		>推论：为实现上述不变代码而调整功能，要指定指明关系，即在定义具体实现类时候指定exdends 引用类型类（接口）。
		（里氏代换原则）（定义类，定义具体类功能类）（指定引用类型）

	3.3比如一个具体的属性（set方法），方法的形式参数（构造方法在内），它有时是本类依赖的类（依赖关系，关联关系。同属性之间可能组合关系），是一个工具类，具体类，但是以后可能是有新的具体类效果更好或者符合需求，而要替换，此时就要修改这个具体类，。。而只要修改来调整功能就不好，而要不修改就调整功能，可以将这个属性设计为一个抽象类、接口，一个各个具体工具类都实现的接口都引用的接口，是这些具体实现工具类的引用类型。
		所以，就是依赖抽象、接口，而不是依赖具体，依赖高层而不是依赖低层。只能依赖更抽象，不能依赖更具体。抽象和具体都要依赖抽象，只有最终调用方---main函数---而不是某个类才构造具体，即才依赖具体。。
		（依赖反转原则）（依赖型属性，要抽象而不要具体）（和常规的依赖具体不同，依赖抽象）
		
	3.4比如一个抽象的接口，方法太多那么其实它就变得具体了，是一个精确的接口，实际上各个使用场景继承实现类只需要其中少数方法而已，其他的是多余的。所以为了各个场景各取所需，自然想到接口分离出新的接口。每个接口专门收纳几个接口方法。
		（接口隔离原则）（实现类不应当做多余的实现，不需要的实现）（抽象类接口的内容能少则少，不能给实现类多余的负担）

	3.5比如一个实现类的方法或者属性，如果仅仅是内部使用，那么外部调用方就不应该能访问到。所以要private私有化，对于私有属性就不能有get方法。
		 依赖方公开的方法应该尽量完成功能，而不是未彻底完成而暴露一些类出来，给本方，导致本方依赖了依赖方所依赖的类。自己的依赖尽量不能传递给调用方。
		（迪米特法则）（最少知道法则，尽量不要让调用方依赖本方的依赖方，即不要让调用方知道本方的依赖方）
	3.6比如一个具体类，让它继承一个类，不如让它依赖一个类。减少耦合。否则父类改变，子类就要改变。比如父类增加了抽象方法或者具体方法，修改了抽象方法或者具体方法。而合成复用，就完全不关心不受父类内部的各种变化。
		 （合成复用原则）（依赖对于继承来说，改动要小）

    一个类的定义可以体现6个原则：
	public class C extends A implements B,G,I{//2个原则,extends和implements
	   private M m;
	   private void hello(D d){//2个原则，private 和D
	    	d.hello();
		E e = Factory.getInstance();
		e.work();
	   }//内容一个原则
      }
4.问题解答：
	>为什么要减少修改？尤其是属性的类型的修改,因为使用它的方法很多，一改全都改，而且对于调用方来说，还要跟着修改，非常麻烦。
			所以开发设计类时，必须考虑到让以后尽量不用修改类的代码就能实现功能转换的效果、作用。
	-------减少修改主要是减少调用方的修改，修改只修改main里的代码，即初始化启动的代码，这里的代码就不是任何一个类的代码。

5.模式的应用：
	>切面切点：
	>

6.额外知识：
	>java new创建对象的时候，分配空间和初始化它的顺序是随机的。
	>同步代码块，可以提出来为一个同步方法，是等价的。
	>接口中不能有static方法。只能public abstract最多两个。
	>静态方法不能被复写。因为静态方法是由类调用的。
	>枚举enum定义的实际上是一个类，每个枚举元素可以看作是类的一个实例。但是枚举类默认已经继承了Enum，所以不能再继承其他类。
	>时序调用图非常有用：等待调用完、等待执行完，从左到右，是从main到深层调用，从上到下，是一个方法内，一行代码一行代码的执行，空隙是--等待调用完执行完，第一行上方是依次深入的：类-方法。
	>面向对象思想：具体编程中，A类某个方法中new一个B类的对象，相当于买了或者安装了或者拥有了一个B的实例（看作是工具，比如笔，电脑，手机），持有引用相当于借别人的工具，静态类方法相当于公用工具，然后调用执行B，而B类的实例方法开始执行，相当于A类暂停，B类开始表演---进入B类的方法。或者把A看作是一个有序的命令集合，B也看作是一个有序的命令集合。
	>面向对象编程：用效果省略动作，直接设置效果来模拟遭到了某种动作----因为结果效果是一样的--结果效果的描述是一样的，方法名代表动作----描述动作，方法内容设置属性新的值代表效果变化。这样，方法就对动作和效果进行了完全的描述。从而方法可以描述现实。从分描述事情事件。


参考资料：
1.http://blog.csdn.net/sinat_29581293/article/details/52188926（整体描述，有代码）
2.http://www.runoob.com/design-pattern/abstract-factory-pattern.html（官方规范文档）