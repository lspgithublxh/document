1.问题描述：
   预备：
   事先明确：
   整体原则：不修改代码而调整功能。最高原则。

	>三方：已方、依赖方、调用方
	>目的：#简化编程、清晰条理化编程---组织代码、责任分解--动作分解--每个动作具体明确都有对象负责（而动作本身类型上不同，导致了分工不同，责任不同，事务不同）、
		对象分类与关联：既能统一确定处理又能专门独立处理、功能单一功能明确
	       #缩短运行时间、加载时间、搜索时间，避免、减少反复的重复的动作--或者得到重复的结果--删了又建
		梳理流程、用更简单的流程达到同一效果
	       #无障碍扩展、不修改扩展(继承和实现的重要作用和意义)（功能扩展、功能覆盖、功能关闭）
		 
	       #权限控制（不能拥有某方法、不能调用某方法）
	>原则：
	>需求：
	>规律：有需求，就有实现，最佳实现就是使用了规律，按照这种规律设计的流程就是一种设计模式。

	>推演，应用范围，扩展开来可以达到的应用范围：

2.具体的设计模式：
	>创建型设计模式：已有类构造它的对象---具体方法、形式
	    >创建需求：
		     >可以的实现、常见的实现和最佳的实现：
		     >遵循的原则：
		     >使用的规律：
		     >设计的具体流程--及其达到的目的：
	>构造型设计模式：已有类，利用它依赖它构造新的类、目的在于扩展已有类的方法--具备更多动作：
		     >

	>行为型模式（管理型模式）：已有类，构造新的类，含有已有类的容器--或者应用变量（但没有具体的对象，这个需要外部输入），新的类本身也有简单的高层次的独立的不同的功能，输入已有类具体的对象（若干个），
					目的在于控制它们、组织它们、管理它们、服务它们，从而作为一个整体具有整体功能----即在调用方看来：已有类和新类作为整体实现的体现的功能。


3.需求演练---拓展展开理解：
    预备：先有原则、需求，后有java语言设计（后有面向对象的语言）
	3.1比如一个具体的方法，其中的代码，有调用其他类的对象的方法。但现在希望不用那个类，而是用其他的类的对象的方法来替换，但是要求不能改这个具体的方法。
	       做法：做法就是：引用该类的对象的变量，应该可以同样引用新的类的对象，所以这个变量应该是旧类和新类的共同父类或者接口；其中条件：在方法里不能有具体new出旧类对象，而是调用方输入设置进去的。
	       结论：所以：原则之一：编写方法之内的内容时，尽量不要使用new出对象的方式，能则必须要用接口或者抽象类类引用对象。不用new的方式，可以用工厂类方法的方式获得或者是调用方注入。
	       推论：这样就不用修改方法体内容了。
	       推因：因为需求的变化，而反复修改同一个方法体内容，是不科学的。只有因为这个方法体的内容逻辑-流程有问题需要修改、内容实现不够好需要修改、内容不能满足新的需求。
	       推论2：不能因为配置、业务需求而修改可以用配置实现更改功能的代码块--方法。
			即：能够通过配置和外部注入的方式，使同一个方法达到新的功能，就不要用直接改方法体内容的方式。。。而要达到不要改的效果，还要求在最开始写代码的时候就要，对象尽量用注入、引用尽量用接口，来让以后尽量只用配置和注入的方式就能实现功能的转换、调整。
	       推论3：为以后着想，为以后尽量只需要外部注入和配置的改变就实现一方法功能的转变和调整，在编写方法实现的时候，就要尽量使用接口，不new来得到对象。
	       另论：方法都注入和配置，那么必然有最上层最终调用方使用的注入和配置，--往往从文件中提取出配置出来，注入第一层，层层传递，最终工作类和每一层的类都有具体的对象，来完成相应的功能。而整体结构没有变。
	       推论4：方法功能的转换，应该尽量考注入和配置，而不是直接改变程序方法的结构和具体流程代码。（方法的多态？）
		（开闭原则）（对方法体的要求及其考虑原因）（不变代码而调整功能）
	
	3.2对于上述编程要求，需要编译器来具体配合、解释。
		编译器：必须要允许和识别抽象类和接口引用，能够根据引用变量类型和对象的引用类型中的方法（也能判断对象的该方法是否来自该引用类型类），和对象的实际地址，来实际执行对象的该方法的具体实现代码。
			这就要求引用类型类和具体实现类之间要有指定指明的继承关系或者实现关系（没有，那么编译器无法识别是否实现类对象的方法来自引用类型类），而这种指定关系在定义具体类时候就要指定。这就是extends 或者 implements
		>推论：为实现上述不变代码而调整功能，要指定指明关系，即在定义具体实现类时候指定exdends 引用类型类（接口）。
		（里氏代换原则）（定义类，定义具体类功能类）（指定引用类型）

	3.3比如一个具体的属性，它有时是本类依赖的类（依赖关系，关联关系。同属性之间可能组合关系），是一个工具类，具体类，但是以后可能是有新的具体类效果更好或者符合需求，而要替换，此时就要修改这个具体类，。。而只要修改来调整功能就不好，而要不修改就调整功能，可以将这个属性设计为一个抽象类、接口，一个各个具体工具类都实现的接口都引用的接口，是这些具体实现工具类的引用类型。
		所以，就是依赖抽象、接口，而不是依赖具体，依赖高层而不是依赖低层。只能依赖更抽象，不能依赖更具体。
		（依赖反转原则）（依赖型属性，要抽象而不要具体）（和常规的依赖具体不同，依赖抽象）
		
		

4.问题解答：
	>为什么要减少修改？尤其是属性的类型的修改,因为使用它的方法很多，一改全都改，而且对于调用方来说，还要跟着修改，非常麻烦。
			所以开发设计类时，必须考虑到让以后尽量不用修改类的代码就能实现功能转换的效果、作用。

