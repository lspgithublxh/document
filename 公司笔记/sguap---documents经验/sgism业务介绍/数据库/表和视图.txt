1.核心实体：
  personal_info:仅仅一个人的基本信息。没有卡、没有用工信息（没有标段、公司、人员类型、入场时间退场时间、考试时间考试成绩）。
  v_personal_info:一个人的基本信息 + 最新用工的公司-人员类型-标段-出入卡号
  employment_info:一个人的全部用工信息。用工关系到出入卡，所以有卡的外键。
  v_employment_info:一个人的最新用工信息。不含人员基本信息，含卡id。

  ls_personal_info：仅仅一个临时人员的基本信息。类似上。
  ls_employment_info：仅仅一个临时人的用工信息。同样有上述信息。
  v_max_ls_peolpe_emp_info：一个人的最新用工信息。类上。
  
  

 实体扩展信息：
  certificate_info:仅仅一个人（常驻）的证书信息。与用工无关。可以多个证书。
  attence_finger：仅仅一个人（常驻）的指纹信息。和用工无关。多个指纹信息。
  card:仅仅一个人或者一辆车的出入卡信息。和用工无关。一人或一车只有一张出入卡（因为对一个人办卡时只能办一张卡，卡的状态可以变而已）。

  personal_inout:一个人的一次刷卡记录，相信记录。
  

2.实体的场景1：（演化字段）常驻人员管理
 0）增删改：
    >记录上：是modify_status的区别。1,2,3
    >增加时：
	    # 身份证读取：直接调用在安装ActiveX控件时已经绑定在window对象下的IDCardReader对象的读取方法（和驱动交道获取到身份证的信息），可以返回一个身份证的信息（三种信息，图（base64str）号国），再将这些信息显示到input和img上。
	    # 照片上传：选择上传图片文件，而选中后通过onchange事件执行方法，该方法到后台，验证文件类型和大小，确为图片，则压缩为一个base64加密的字符串返回在前端img标签上显示。（验证和返回路径如：~/rest/personalinfo/upload/personalpic?id=）
			拍摄：启动一个新窗口，执行三个流程可以拍照：
				#打开摄像头：Camera打开方法
				#拍照：Camera拍照方法并将返回的图str放到img png类型中显示，这个是个预览，不会到后台验证等--也不行了。
				#确定：将上述图str放到绑定了onchange事件的img上，这个自然引发事件。同时，还回调方法，将图str放到form的专门entitycontainer里。
	    # 资格证书上传：开一个新form页面：	编辑后将保存到certificate_info里，有personal_id关联。
	      ----其中资格证书的显示：是一个DataGrid，在form加载成功后开始load，并将$e对象放到了form对应的html里的一个标签中。	
   >删除：
   	  # 先验证：一是否进场？二该人是否有且最新用工-基本-出入卡信息中看是否出入卡有效？三看该人是关联了常驻车且常驻车没有删除？四看该人是机具负责人且机具未删除？  满足前述条件，则不能删除。	（问题在于常驻人用临时车，常驻人可以删除。）					

 1）批量进场（重新进场）
   >实现流程（交互流程）：
            >显示已经退场的（有进退场的日期，且已经过期）
	    >用户选中若干后，提交（到后台）
 	    >后台批量更新用工记录表employment_info的相应记录的in_date字段。
 2）批量退场：
   类似上面。

 3）常驻人员出入卡状态有条件切换：在未办理、无效、有效、注销中切换（对应使用各种动作）。
    >实现流程（交互流程）：
        >除生效需要配置页面，无效、注销只更新state值。退场后不能进行一系列切换动作。
        >新办（动作）：会写该人该次用工的card数据到设备：activex控件调用硬件接口。
			整个form：~/rest/personalinfo/card/{personal_info的id}，因为从一行取出来的。返回的对象：MergePersonalInfo，它的id是personal_info的id拼上employment_info的id。它的其他属性是人员、用工、card三表的信息。如果传过来的personal_id为空，会返回一个随机的id和随机的emp_id构成的MergePersonalInfo对象。
										#如果那个人没卡没办卡（不是重办什么的）即id_card为空，那么新存一条记录到auto_number里--仅仅作为标记（标段和时间、人和部门类型），而它的卡、部门、人的类型的拼和其他固定字符的拼就是作为待刷入的卡的新卡号，即存入id_card属性中。卡号不为空但是卡状态为：需要重办新办（即状态不是失效也不是有效，即卡处于注销和未办理状态），那么也同样生成插入一条到auto_number，也将前述信息存入Id_card属性中。
										#同时直接设置二维码：查出人员基本信息（联合用工和部门），构成键值对字符串，此字符串放到Qrcode对象里，Qrcode对象将数据生成boolean[][]对象，此对象为真部分时，对应位置画小方格到一个BufferedImage对象里，通过ImageIO.write写到一个字节数组流里，流取出字节数组加密为Base64字符串，即为二维码--前端可以解开。
			>制证：取form里的值（常驻人基本信息），打印到卡表面：PrintPersonCard(),成功了失败了只有提示。没有其他数据变化。
			>写卡：
				a读卡:从卡片中读出card_no
				b读数据库：看上述card_no即id_card字段是否存在card中（该标段该卡类型卡号）：~/rest/card/queryCardByCardNo。从三表联合中。
				c写卡：从form读出id_card字段写入卡芯。
				d写数据库：前端会检查验证用户输入的几个属性如：grant_time，再保存form
					   后端看id_card是否存在card中，没有则是新生成的卡号，则联合有效期等信息封装到card对象存到card表中，同时更新employment_info中的id_card_id字段。
									有则是旧卡号，那么更新该卡的有效期到card中即可，同理无聊的再更新一下employment_info的id_card_id。
	>无效（动作）：设置对应卡的state为"0"
	>注销（动作）：设置对应卡的state为"2"
	>生效（动作）：设置对应卡的state为"1" ~/rest/lspersonalinfo/cardValid 
				（注意，此时的form不是上述form，而是~/rest/personalinfo/{人员id}的form，但是后台仍然执行类似上述的查询--装到MergePersonalInfo对象，但是id_card不再有上述讨论。且如果personal_id为空，会返回一个随机的id和随机的emp_id构成的MergePersonalInfo对象）
				如果单单生效：成功后前端执行：me.view.getForm().entityContainer.trigger("saved");应该是刷新前端而已，没有后台动作。
				如果生效并写卡：那么后端返回后进一步执行写卡的前三大方法即abc三步骤。因为假定form里的id_card肯定存在，所以直接刷入卡片---相当于卡消磁了变化了需要再次刷入同一个卡号，所以不用保存到数据库。	
	>重办（动作）：同新办（动作）。
   >状态转移图：
	>有效状态：无效（动作）、注销（动作）
	>无效状态：生效（动作）、注销（动作）
	>注销状态：重办（动作）
	>未办理状态：新办（动作）
	
			
3.实体场景2：常驻人员管理
  
4.实体的场景3:临时人员管理
     1）临时人员的出入卡的状态有条件切换：类上。
        #临时人员删除：验证：一看出入卡是否有效？ 二看该人有临时车辆且该车辆未删除？三看该人是机具负责人且机具未删除？  都不满足条件，则删除。（删除可能有问题：在于--无法进入删除条件--报错，因为返回是null）（所以临时人和常驻人删除不了是前端问题）---事实没问题。
                         

5.实体的场景4:指纹管理  略。人员出入卡管理--略。（仅仅查看）
     	

6.实体的场景5：人员实时进出场：
 	>常驻人员实时进出场数据： 是查看当天刷过卡的人的最新的刷卡记录，如果是进场，那么就是进场时间到查看时为止的时间，出场只显示出场时间。
	>临时人员实时进出场数据：也是如此。				
	>刷卡记录：本标段下临时常驻人的全部刷卡记录（当然有连用工和基本信息表）。。没有天约束（昨天的也有）。---可以查询，这个是独立的功能。

7.实体场景6：人员动态统计：~/rest/personalinout/countPersonIn
   1）历史在场人数：当天从早上第一次统计开始，到当前最近一次统计为止，5个部门的高峰人数。（每天都这么统计）
      历史在场总计：上述5种人数的分类相加。
	但是：总进人次：却是当天到点击这个时刻为止（认为数据正常，其实就是当天，如果已经过去的一天，就是全天数据了，如果是今天，那么就是到现在为止刷入了的）所有进场刷卡记录的个数（即只对天和标段和入场类型做限制）。
	      总出人次：同上理。所以会出现的问题是：（上次高峰统计到现在）已经有新人刷卡进了，但是没有统计在高峰记录表内（毕竟这个一个小时统计一次，即便缩短时间，经常高峰统计，也是对所在小时的更新，毕竟有间隔，就有误差（只是更新时间快慢而已，统计逻辑不变）---不是直接统计源数据personal_inout之类的）。

   2）下图：按照上述的数据进行绘制。	


----------从数据角度看业务。


  
   	
