1.核心实体：
  personal_info:仅仅一个人的基本信息。没有卡、没有用工信息（没有标段、公司、人员类型、入场时间退场时间、考试时间考试成绩）。
  v_personal_info:一个人的基本信息 + 最新用工的公司-人员类型-标段-出入卡号
  employment_info:一个人的全部用工信息。用工关系到出入卡，所以有卡的外键。
  v_employment_info:一个人的最新用工信息。不含人员基本信息，含卡id。

  ls_personal_info：仅仅一个临时人员的基本信息。类似上。
  ls_employment_info：仅仅一个临时人的用工信息。同样有上述信息。
  v_max_ls_peolpe_emp_info：一个人的最新用工信息。类上。
  
  

 实体扩展信息：
  certificate_info:仅仅一个人（常驻）的证书信息。与用工无关。可以多个证书。
  attence_finger：仅仅一个人（常驻）的指纹信息。和用工无关。多个指纹信息。
  card:仅仅一个人或者一辆车的出入卡信息。和用工无关。一人或一车只有一张出入卡（因为对一个人办卡时只能办一张卡，卡的状态可以变而已）。



2.实体的场景1：（演化字段）常驻人员管理
 0）增删改：
    >记录上：是modify_status的区别。1,2,3

 1）批量进场（重新进场）
   >实现流程（交互流程）：
            >显示已经退场的（有进退场的日期，且已经过期）
	    >用户选中若干后，提交（到后台）
 	    >后台批量更新用工记录表employment_info的相应记录的in_date字段。
 2）批量退场：
   类似上面。

 3）常驻人员出入卡状态有条件切换：在未办理、无效、有效、注销中切换（对应使用各种动作）。
    >实现流程（交互流程）：
        >除生效需要配置页面，无效、注销只更新state值。退场后不能进行一系列切换动作。
        >新办（动作）：会写该人该次用工的card数据到设备：activex控件调用硬件接口。
			整个form：~/rest/personalinfo/card/{personal_info的id}，因为从一行取出来的。返回的对象：MergePersonalInfo，它的id是personal_info的id拼上employment_info的id。它的其他属性是人员、用工、card三表的信息。如果传过来的personal_id为空，会返回一个随机的id和随机的emp_id构成的MergePersonalInfo对象。
										#如果那个人没卡没办卡（不是重办什么的）即id_card为空，那么新存一条记录到auto_number里--仅仅作为标记（标段和时间、人和部门类型），而它的卡、部门、人的类型的拼和其他固定字符的拼就是作为待刷入的卡的新卡号，即存入id_card属性中。卡号不为空但是卡状态为：需要重办新办（即状态不是失效也不是有效，即卡处于注销和未办理状态），那么也同样生成插入一条到auto_number，也将前述信息存入Id_card属性中。
										#同时直接设置二维码：查出人员基本信息（联合用工和部门），构成键值对字符串，此字符串放到Qrcode对象里，Qrcode对象将数据生成boolean[][]对象，此对象为真部分时，对应位置画小方格到一个BufferedImage对象里，通过ImageIO.write写到一个字节数组流里，流取出字节数组加密为Base64字符串，即为二维码--前端可以解开。
			>制证：取form里的值（常驻人基本信息），打印到卡表面：PrintPersonCard(),成功了失败了只有提示。没有其他数据变化。
			>写卡：
				a读卡:从卡片中读出card_no
				b读数据库：看上述card_no即id_card字段是否存在card中（该标段该卡类型卡号）：~/rest/card/queryCardByCardNo。从三表联合中。
				c写卡：从form读出id_card字段写入卡芯。
				d写数据库：前端会检查验证用户输入的几个属性如：grant_time，再保存form
					   后端看id_card是否存在card中，没有则是新生成的卡号，则联合有效期等信息封装到card对象存到card表中，同时更新employment_info中的id_card_id字段。
									有则是旧卡号，那么更新该卡的有效期到card中即可，同理无聊的再更新一下employment_info的id_card_id。
	>无效（动作）：设置对应卡的state为"0"
	>注销（动作）：设置对应卡的state为"2"
	>生效（动作）：设置对应卡的state为"1" ~/rest/lspersonalinfo/cardValid 
				（注意，此时的form不是上述form，而是~/rest/personalinfo/{人员id}的form，但是后台仍然执行类似上述的查询--装到MergePersonalInfo对象，但是id_card不再有上述讨论。且如果personal_id为空，会返回一个随机的id和随机的emp_id构成的MergePersonalInfo对象）
				如果单单生效：成功后前端执行：me.view.getForm().entityContainer.trigger("saved");应该是刷新前端而已，没有后台动作。
				如果生效并写卡：那么后端返回后进一步执行写卡的前三大方法即abc三步骤。因为假定form里的id_card肯定存在，所以直接刷入卡片---相当于卡消磁了变化了需要再次刷入同一个卡号，所以不用保存到数据库。	
	>重办（动作）：同新办（动作）。
   >状态转移图：
	>有效状态：无效（动作）、注销（动作）
	>无效状态：生效（动作）、注销（动作）
	>注销状态：重办（动作）
	>未办理状态：新办（动作）
	
			
3.实体场景2：常驻人员管理
  
4.实体的场景3:临时人员管理
     1）临时人员的出入卡的状态有条件切换：类上。

5.实体的场景4:指纹管理  略。人员出入卡管理--略。（仅仅查看）


6.实体的场景5：人员实时进出场：
 

7.实体场景6：人员动态统计：~/rest/personalinout/countPersonIn
   1）当天从早上第一次统计开始，到当前最近一次统计为止，5个部门的高峰人数。
	但是：总进人次：却是当天到点击这个时刻为止所有进场刷卡记录的个数（即只对天和标段和入场类型做限制）。
	      总出人次：同上理。所以会出现的问题是：已经有新人刷卡进了，但是没有统计在高峰记录表内（毕竟这个一个小时统计一次）。
----------从数据角度看业务。


  
   	
