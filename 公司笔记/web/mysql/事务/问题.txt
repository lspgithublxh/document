1.事务本质上要解决的问题:并发读写数据库最终导致数据不一致和不正常的问题。
  本质： 是为防止上述问题发生，而对并发中的操作，本身在被执行时要求具有的表现出来的特性，（ACID）,它认为如果具有，就不会发生上述问题。
  每组操作都视作“事务”  
  要求每个事务操作的都是隔离性的、备份性的数据库数据，且这一组操作（事务）像原子一样要么成功（则提交）、要么失败(则回滚)，成功（即提交后）后则操作的备份数据会覆盖掉数据库的原始数据从而数据库数据发生持久性的（不可回复）改变，同时通知其他事务数据库的这个数据已经发生了持久性改变而必须要一致地以当前的数据为准进行操作。


2.数据库在实现并发中的操作具有上述四种特性时，做了两件事：
（1）操作内要有指定的标记：事务开始、提交、回滚（对并发的操作本身的特殊描述、特殊指定、特殊要求、特殊标记。）
	>所以在程序中，用户可以自己制作一个事务。
（2）对数据库选择性施加两类锁：独占锁、共享锁。具体的锁也只有这两大类。具体到行级锁和表级锁。（读锁、写锁、乐观锁、悲观锁分别只是具体读或写的时候怎么加、加什么具体锁的一种模式、模型）
	>加锁是用户的行为。

3.事务隔离级别：
	>起因：一般的数据库都是允许读的时候和其他读更增事务同时操作一个数据的，或者叫允许并发的。而这会产生问题。
	>问题：
		>读另一个事务修改未提交：脏读
		>一个事务两次读之间已被另一个事务修改：不可重复读
		>一个事务在读和打印之间，有新的事务增加记录：幻读（即两次统计不对，对每条记录是对的）
	
	>事务隔离级别： 读未提交--产生问题1
			读已经提交--产生问题2
			可重复读--产生问题3
			序列化--没问题：因为事务都顺序执行，效率但是也最低
		读已经提交级别：oracle一般不会产生大问题
		可重复读：mysql问题更小