1.问题描述：
	>HashMap的底层数据结构：数组 ， 数组的元素是Entry , 而Entry是一个动态链表的节点，即它可以指向下一个Entry元素
		>key映射到数组下标的方式：对它的hashCode求hash而得到。----hash算法就是&运算，本质是一个取hashCode在数组length-1代表的数上的与结果。
		>数组长度：为了用最高效的计算：&来作为计算hash的运算方法，而让hash值在length之内（从而作为索引位置），而与输入数直接相关，那么因子（length相关）最好就是11111这种类型，所以length最好就是2的整数次方。
	>HashMap的扩容：
		>默认数组16,负载因子0.75
		>扩容时机：实际存量达到长度*负载因子时
		>扩容算法：（扩容逻辑）新建2倍数组---重算hash---复制过去

	>并发读写HashMap:
		>只报错不控制：
			>报错条件：一旦满足：
				>迭代器抛出并发错误：迭代器会查看hashMap的modCount是否和自己的modCount值一样，不一样就报错。即认为被修改了。



	>知道数据结构后的运用：
		>a.初始化HashMap时候，size和refactor要一起。避免resize
		>b.遍历HashMap时候，用Entry方式，因为最直接可以获得--最快构造出迭代器，而keyset要先获取到再能迭代。