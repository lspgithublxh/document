1.传统BIO模型：
	>读：TCP RecBuffer里没有数据，则一直等待，阻塞，直到有数据--程序也阻塞在这里。
	>

2.NIO模型：---根本目的和意义：少开线程
	>读：TCP RecBuffer里没有数据，则返回0。不会阻塞。有，则从网卡读数据到内存中。----这个读网卡中的数据是同步的而不是异步的。
		？如何知道有数据？---就绪事件通知。
	>模型：
		>Select:网卡事件的接收器和对应处理转发器。
			Channel-关心事件-处理器的注册目的地。
		  本身在事件到来前是阻塞的，到来事件后开始路由转发调用。阻塞的具体实现：可以是轮询，或者是操作系统事件通知。
		  select本身负责等待，负责全部连接的等待（从而减少线程切换开销和cpu开销）。而在事件到了，比如读，那么在读网卡过程中是不能进行处理其他事件的-----即实际进行读写和连接时是阻塞的。
	  开多个select可以并发的处理更多的网络网卡事件。
	>Reactor模型，是上述的模型。
	>Preactor模型。用户不是从网卡中读数据，而是从自定义自己知道的缓冲区读数据。即操作系统自己代劳把网卡数据读到用户指定的缓冲区域。
			而select这个时候就是等待操作系统自己听到事件并读网卡数据到用户自定义缓冲区完成为止时发给转发器即select的事件。此时select才开始通知转发到channel的处理器，而处理器从缓冲区读到数据之后，新开线程异步的处理，而把控制权交给事件分发器select本身---好监听其他的完成请求事件。

	>实际模型：事件被Selector听到，而Channel从网卡读到数据，且先放到Buffer里

3.AIO模型：
	>读：TCP RecBuffer里没有数据，不阻塞。在有数据准备好时的读也是异步的。






