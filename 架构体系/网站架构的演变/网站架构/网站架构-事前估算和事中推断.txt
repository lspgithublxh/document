1.问题描述：
	>架构本质：
	>预备：
		>大型网站特征：海量数据存储、高并发访问（本质上是访问数据、所以数据可以分类存到不同服务器上）、内部大量服务层层互相调用（异步或同步，所以服务分布式部署、消息队列联系）、各种客户端（包括web网站，这个也是相当于客户端，而app调用数据库-像网站，展示数据的方式不同而已）和第三方应用
			---总结：三大分布式：数据分布式、服务分布式、客户端分布式（调用分布式）：且每块数据或服务的分布式都是独立的服务器集群，而不是多块数据共享一个服务器集群，同理每块服务。
			    >补充特征1：多个数据中心（用户就近访问，冗余复制的备灾中心）（远程消息系统能将所有用户的微博数据在不同数据中心之间同步）
		>网站加速反应-减少到网站应用服务器的请求：CDN（缓存服务器放在ISP的机房里，用户请求必经的网络）、反向代理（缓存服务器放在网站的中央机房里）
		>用户请求的负载均衡：应用服务器集群、微服务+消息队列+服务注册中心
				     >业务拆分：各功能模块分别部署、互相不影响-独立演化发展、还可统一管理-互相通信互相接口调用。比如用户登录模块、首页模块、数据库访问模块（尤其数据库集群系统）、业务A模块、业务B模块、服务C模块、服务D模块
		>减少对数据库的请求：本地缓存和分布式缓存服务器集群
				     >本地缓存：把部分常访问的数据缓存在内存中

		>对数据库请求的分流：读写分离--而做主从复制
				     >主从复制：写到主服务器时，主复制到从服务器。从服务器和主服务器都可以被读。
		>数据库表数据过多而拆分存储：分表--分布式数据库
		>文件数据的过多而拆分存储：分块--分布式文件系统
		>结构化数据结构及其搜索：NoSQL和搜索引擎
					 >原始数据往往可以存，离线分析数据往往也可以存在这里。

	>架构问题、技术方案、使用原因--分析证明的若干个观点和判断和性质（场景和系统）：
		>数据库的伸缩性架构：（数据库服务器的负载压力）
		>系统在高并发场景下的性能评估和性能测试：
		>系统瓶颈：（网站架构的本质）
		>4+1视图模型-多角度描述软件系统设计
		>性能、可用性、伸缩性、扩展性、安全：
		>负载均衡、异步处理、分布式缓存：
		>数据库的写入性能：
		>最终是解决业务问题：而业务问题可以业务手段也可以技术手段解决。
		>技术选型和架构决策时的调查的对象及其描述、分析的对象及其结论、判断的对象及其结论，，，等等考虑作为根据：
				

	>模式和套路：（即极多的网站都这么架构且效果好）
		>预备：常见三大问题：高并发、海量数据、高可靠运行
			>架构目标：高性能、高可用、易伸缩、可扩展、安全
		>方法1-也是首先：逻辑分层：外层调用里层，高层调用/依赖底层（底层实现高层的接口，再底层实现上层的接口。最底层无需调用其他接口）。MVC模式、网络通信协议7层架构模式、
				 >不只是方便开发维护，而分层每层如果独立部署独立演化，那么在不同的机器上的缘故就支持了高并发发展为分布式服务。高并发最终向分布式发展，分布式本身也是支持高并发的。
				（把视图、服务、数据库访问接口分开）
		>方法2-第二步：并列功能分割：视图拆分为多块而独立部署演化，服务拆分为多块而独立部署演化、数据库访问接口也是。纵向的分割，为多个模块，每个模块之间互不影响高内聚低耦合而独立开发维护部署，从而系统更健壮、稳定可用（而不是一下子互相牵连全部倒塌）。
				（可以独立出去的业务都独立出去，分离分割出去）
		>方法3-第三步：分布式化（服务、静态资源、数据库存储、计算、配置、锁、文件系统）
			  >解决分布式的问题：特征-问题：通过网络--性能低，服务器多了宕机概率大--影响其他调用服务而使得网站可用性降低，分布式环境--数据分散而数据一致性问题存在（分布式事务），对于开发而维护困难
			  >分布了--并发性好   独立了--开发效率高迭代快  专门了---复用性高数据库连接少
			  >
			

	>什么是价值：
		--被使用就是价值。被使用得多，价值就大。被用来解决的问题越多，价值就越高。
		>为什么会被使用：新客户：功能新奇有趣、好玩（人们都图新鲜）、有用、解决了需求、产品简单好用有品位、体验过程中被尊重被帮助有地位、性能出乎意料没人抱怨
				 老客户：解决了需求、养成了习惯、经常有变化新意、越来越强与多（对新客户又呈现简单基本不复杂，而需要长时间探索新功能）

		>
	>什么是懈怠--草率--不上心：
		>不知道危害、不知道恶果、不知道损失、不知道代价、不知道事故、不知道官司。。。不在乎尊严、不上进


	>架构系统的性质描述（除了结构描述---上述已有）：
		>性能：响应快慢的度量--响应时间、TPS。（可以预测网站容量，分析系统瓶颈，异常指标报警）
			>浏览器端：页面压缩、浏览器缓存、页面合理布局
			>网络上：多数据中心、CDN静态资源就近部署、中央机房反向代理
			>网站服务器：应用服务器集群-负载均衡
			>应用：本地缓存和分布式缓存系统、发给消息中心而直接返回、多线程和内存管理优化
			>数据库：索引、缓存、SQL优化、分表分库读写分离、数据库集群、NoSQL利用
			-----超出负载设计能力的情况下的处理
		>可用性：可以使用可以服务的时间长短的度量：7 *24小时减去网站宕机、服务不可用时间。。一般是百分数：99.99%
			>有宕机就要考虑可用性，必然会宕机所以必然要考虑可用性--考虑的目标就是提高可用性，就是服务器宕机而服务依然可用。
			>手段：冗余。应用服务器集群---负载均衡：且回话保存在均衡器上---及其备份上。
					数据库：读写分离，数据实时备份。宕机后请求转移和数据恢复。
			>开发过程中：预发布验证、自动化测试、灰度发布
		>伸缩性：是否可以将系统构建为集群、是否可以或容易向集群中增加服务器、增加后是否提供和原来服务器无差别的服务
			>应用服务器集群：
			>分布式缓存服务器集群：缓存路由算法
			>数据库集群：关系型：路由分区；非关系型：先天可以集群规模的线性伸缩；；
		>扩展性：新增需求或产品是否对已有业务无耦合、代码无改动、发布无等待（独立发布）
			>事件驱动架构：通过消息队列来实现无耦合调用。从而调用者完全不知道处理者，处理者完全不知道调用者。从而调用者可以新增，处理者可以新增可以改变。---程序都不变---不影响旧的以前的。因为新的调用者和新的处理者可以加进来。
			>分布式服务：通过网络调用服务实现调用者之间无耦合不互相影响，调用者和被调用者不必在一台服务器上争用资源。调用和被调用者独立发展，独立迭代，从而实现系统局部的独立发展----有的迭代快有的慢---不用互相等待。
			
		>安全性：恶意访问和攻击获取数据的行为，是否可以得逞：
			>攻击的应对方案：

	>开发者对网站系统的处理动作：
		>升级优化：


	>性能测试：准确度量网站实际性能，以及为了开发实时监控网站的程序---阈值报警---在灾难发生前一定时间通知开发者。
		>响应时间：不同的系统，响应时间差别大。
				内存读取:100G/s  >  局域网络：2G/s  >  机械磁盘：500M/s   > 网站响应时间/速度：页面/s
		>并发数：网站用户数 > 在线用户数 > 并发用户数（一次处理时间内的请求数，每秒的访问量 * 一次处理的时间 = 并发用户数）
		>吞吐量：一次处理的时间的倒数。TPS（每秒事务数），QPS(每秒查询数)
		>程序计数器：资源使用情况：内存-CPU-磁盘使用情况：System Load系统负载：正在被CPU执行和等待CPU执行的进程数目总和。
		>测试方法：
			>性能测试：增加并发请求数，直到达到设计目标且系统处理能力未饱和--还有增加的空间---即增长率即将下降之前或之时。
			>负载测试：增加并发请求数,直到系统处理能力饱和--性能达到顶峰不能再提高且开始减小。从而获得一个临界请求数--最大负载（形象化看作是增加担子），增加系统压力。
			>压力测试：增加并发请求数，直到系统崩溃而不能再处理任何请求（是瞬间的是资源消耗满了，而不是逐渐减少到0）。也获得一个临界请求数---最大压力
			>稳定性测试：长期运行，看是否稳定。直到不稳定，看经历了多久。获得一个最小值---稳定运行时间。
			
	>性能优化：
		>web前端优化：文件就近获取。
			>减少http请求、使用CDN、反向代理。http请求：无状态-每次请求都是独立的建立通信链路和服务器独立的线程来处理--开销大。
			>浏览器缓存js，css,图片。更新则可以换名--r随机数-使缓存失效
			>服务器文件Gzip压缩--减少文本文件的量（压缩文本文件80%以上效率：压缩基本原理：相似替换-简化表示，相似抽取-简化替换）
			>文件顺序：CSS在上，js在下。
			>cookie减少。
			>CDN和反向代理服务器：代理浏览器保护旗下浏览器，代理服务器保护旗下服务器。
			
		>应用服务器优化：缓存、集群、异步
			>优先考虑：缓存：因为减少访问时间和计算时间。
				>缓存：内存中。分布式缓存系统。磁盘中。但是问题：数据可能不可靠，数据更新时间需要考虑，重建缓存开销大（缓存预热可以缓解）。缓存热备甚至都不合理。缓存服务崩溃--缓存雪崩的问题。缓存穿透--访问不存在的数据来迫使访问数据库。
				>Jboss:缓存：缓存集群服务器之间需要互相通信，扩展不易。
				>Memcached:通信协议tcp，序列化协议get key自定义，监听服务libevent,内存管理多维数组trunk为单位进行垃圾回收，服务器互不通信，只是存储（客户端hash算法获取存储的地方----一个服务器相当于hashMap的动态链表数组的一个动态链表）。
			>异步：消息队列的使用。发完消息就返回，而消费者进程从消息队列里取出来异步的存到数据库。--或者订阅了而收到消息而处理。消息队列服务器。
			>集群：负载均衡，使得每台应用服务器的访问压力降低--cput和mem消耗都更小，所以响应会更快。。

		>存储性能优化：
			>排序后存储：B+树：
				     LSM树：
			>RAID:磁盘并发读写，冗余备份。
			>HDFS:各阶段策略：
				>文件分块---每块冗余3份。

	>可用性优化：失效转移（缓存数据和数据库数据的高可用，服务的高可用）
		>session管理：session绑定和session服务器
		>无状态服务：(服务无状态化)服务不存储请求的状态（当然也不存储请求状态的变更，这个请求信息是在session管理里的）
		>分级管理：服务重要性不同，给的资源优劣不同（服务器资源）
		>超时设置：请求超时，则断掉链接--抛出异常。---重试或者转移请求到其他服务器。
		>异步调用：不等下一步且受到邮件为准（大量的权限申请类型服务），先返回成功，后台消费者再存储数据库、发邮件、调修改服务。
		>服务降级：拒绝服务、关闭服务。让服务对新增访问用户不可用或者某些服务暂时不可用。
		>幂等性设计：服务被调用一次或者重复调用多次效果一样----服务有效性校验（比如用订单号来表示一次调用：来实现1h内可以重复调用，但是效果是一样的--因为订单号已经生成并且成功处理了）
	    >高可用的数据保证策略：
		>备份：保证不丢失。多个副本。
		>失效转移：保证一个副本不可访问一台访问宕机可以切换到其他机器来访问到。
	    >高可用数据的特点：
		>数据持久性：磁盘中且多个副本。
		>数据可访问性：多个副本切换访问。
		>数据一致性：副本数据一致相同---修改也同步变化。
		----数据用户一致：副本可能不一致，但是一次访问后经过校验可以确定正确的那个副本数据----比如用数据的版本。

	    >数据备份：
		>冷备：定期数据备份。相当于数据版本。
		>热备：异步和同步方式。就像调用服务一样。
			>异步：写数据一份成功就返回。后台复制多个备份。
			>同步：写数据到多台数据服务器，每台独立返回。
			----实现者：数据库服务器。比如master-slave的读写分离机制。各种关系型非关系型数据库都有这种性质。
			>
	    >失效转移：请求的重新路由
		>重新路由到对等服务器上。或者不对等的存储服务器上。宕机确定---重新路由---数据恢复
	    >软件保证：
		>自动化测试：用selenium来编写脚本进行自动化测试。
		>网站发布：预发布验证（预发布服务器）和灰度发布（正式线上服务器）。
		>
		>数据采集：日志记录。storm进行日志的统计和分析。
		>服务器性能监控：Ganglia：图形化方式在浏览器中展示实时性能曲线。服务器集群监控。

		>
	>可伸缩性优化：主要是伸，而不是缩。。对于脉冲式访问，那么需要缩的。
		>服务的物理分离：部署在不同的服务器上。
			>纵向：数据---基本技术服务----可复用基本业务服务----网站具体服务产品
			>横向：不同业务的分离。

		>相同服务的集群化部署：同一个服务用一个集群来部署。增加服务器比换服务器容易。

		>应用服务器伸缩：
			>实现效果：集群服务器数量的配置、集群中新上线/下线服务器的发现、请求分发到新上线服务器（停止到下线服务器）
					（比高可用的策略，负载均衡增加的事或者说强调的事是：上下线服务器的发现等）
			>第一级负载均衡：DNS域名解析负载均衡。
				>由DNS域名服务器解析得到将访问的ip服务器--往往是网站的负载均衡服务器。
				>负载均衡：仅仅是计算ip分解请求流向，对请求分流---就是负载均衡，对同一个网站的请求。不要求知道ip，不要求直到目标服务器，和目标服务器没有管理关系或者代理关系。----通过其他机器也可以到达这些目标服务器。。正如DNS负载均衡一样，一个DNS可以，其他DNS服务器也同样可以，而且DNS服务器和目标服务器也不是一个公司的，各自的，且没有什么合作关系。
				>反向代理：强调代理，一组服务器的代理服务器--就是反向代理服务器，一组用户浏览器的代理服务器叫代理服务器---比如网吧里的电脑访问外部的网络--正是通过代理服务器。而这组服务器就是通过反向代理代理服务器来处理客户端请求的。
					   ---因为反向代理服务器也能计算ip目标服务器（就是被代理的服务器），所以常用可用反向代理服务器来做负载均衡。
					   ---然而反向代理服务器不一定是为了负载均衡，因为可能内部服务器上的应用都不一样，用户访问的入口也不一样，app都不一样，网站都不一样，只是都使用一个反向代理服务器而已。	（带负载均衡的反向代理服务器像是一个带负载均衡的DNS服务器）
			>第二级负载均衡：http协议层次的负载均衡：如上的反向代理方式。
			>第三级负载均衡：ip目标地址修改和源地址修改方式：
				>可以深入操作系统内核进程获取到ip数据包----从而改变ip数据包的目标地址，从而转发到内部的服务器。而又可以改变源地址为自身的地址，所以请求又会返回到自己上来，再将目的地地址改变为用户的请求地址即可。3次ip地址变化。
				>内网局域网的请求都从网关服务器进而处理结果返回网关服务器：所以网关服务器又天然是一个负载均衡服务器。
			>第四级负载均衡：数据链路层负载均衡：修改目的mac地址方式
				>内网服务器配置为和网关服务器一样的ip---虚拟Ip方式，那么网关服务器直接修改请求的通信数据链路层的mac地址为目标内网的机器的mac地址，那么目标内网机器处理完成后可以直接返回数据给（到网关后在发给）客户端了（网关服务器和负载均衡服务器不同时）。----直接路由方式DR。。。实际上是操作系统负载均衡。操作系统实现。典型产品：LVS（Linux Vitural Server）
			>负载均衡算法：
				>轮询-随机法：
				>hash散列法：像hashmap的query一样，从而同一个ip访问总到一个服务器上，实现session绑定。（不采用session分离的方式---有状态服务器模式）
		>缓存服务器伸缩：新上线缓存服务器和已经缓存了数据的服务器，都能被访问到。
			>Memecached分布式缓存集群： 客户端key ---> 路由路由算法得ip:port ----- > 通信得到value
				>hash算法：一致性hash算法：使用虚拟节点的方式虚拟增大了节点数（即使只有3台服务器，也能虚拟为1000台服务器，1000个节点，从而降低hash环上的影响范围----但是新增进来的机器同样要分散为1000个小范围，所以均匀地影响了每个机器而已）。。。。虚拟化的方法。
				
		>数据库服务器伸缩：（新增服务器进来，做两件事）	数据迁移和路由配置	
			>关系型数据库：
				>主从（每个mysql实例，都部署为主从结构）数据库服务器集群：分库（业务切分）分表（纵向切分）分片（一个表横向切分）
				>访问代理：Cobar（可以集群方式部署），这样可以访问Cobar而访问分库分表分片的Mysql实例。
				>mysql主从集群的伸缩：关键是确定数据单位：每个服务器负责的数据单位是什么，有多少单位数据。从而新加入的服务器确定它负责哪些和多少的单位数据？
					>迁移单位：Schema
					>迁移方式和过程：mysql数据同步功能 --- > 同步完成，删除旧机器上的Schema。在Cobar中修改该Schema的路由配置，使得为新机器的ip。
					>GreenPlum:复杂sql的查询的非实时业务中--比如数据仓库。

			>非关系型数据库：
				>放弃：结构化查询语言。ACID数据一致性（原子性，隔离性，持久性，一致性）(使用zookeeper来实现)
				>天然：高可用性和伸缩性
				>Hbase:
					>以HDFS为数据实际存储方案。
					>HRegion：为每台机器上的数据管理模块（程序）：而每台机器上是有文件数据的---文件块的。
						  >一个HRegion上管理一段key-及其对应的各列数据。
						  >数据迁移时：比如新增了HRegionServer,那么就以HRegion为单位迁移到新的HRegionServer上，并在HMaster上记录新的HRegionServer等信息。
						  >数据存储单位为HFile，而HFile是以HDFS为存储实际结构的。（即HFile文件格式文件目录只是看到的目录形式，实际是HDFS方式存储的）
						  >分裂：当数据量太大时，就分裂为两个HRegion，然后迁移---根据集群中实际负载情况。
					>HRegionServer:启动HRegion实例。可以启动多个。一台物理机部署一个HRegionServer
					
					>HMaster:作为实例，Hbase会启动多个HMaster实例,其中一个是主（通过zookeeper选举出主HMaster出来）。一个HMaster上存储了所有的HRegionServer所在的ip:port和上面的HRegion的key范围。
					>应用程序访问调用时序图：先从zookeeper找到HMaster,再从HMaster找到HRegionServer，HRegionServer会找到对应的HRegion来访问：HRegion则读取数据或者写入数据。然后返回。

			>非关系型数据库：
			-----摇一摇功能：两个实习生一个星期开发出来的。
	>网站的可扩展架构：降低软件耦合性、减少依赖
		>系统功能的不断扩展：新业务新功能的不断加入。。可扩展结构的强大。
		>模块化、固定结构化、固定流程化：固定一个过程或者框架。
			>内存依赖转换为网络依赖（局域网，内网访问）。
			>直接依赖转换为间接依赖。直接调用不如触发调用、非耦合调用、异步调用，交给第三方，让第三方帮我完成----关键在第三方是两个（至少)独立的工作者，分别独立和两方打交道，而第三方的两方之间仍然是触发关系---一方触发另一方---程序中的新开线程-进程关系-或者利用到os的进程间通信---激发一个异步运行的进程。就像变压器：不是直接在一个回路中，而是在两个回路中，各自通过电磁场触发联系。
			>事件驱动架构：EDA。比如进程之间的通信，可以用事件驱动架构，操作系统实现的生产者消费者模式。
		>分布式消息队列：消费者-生产者模式。流程上，纵向分解，且调用分解。
		>分布式服务模式：SOA架构，从而不用知道具体的服务实现，哪个实现，而知道服务名就从调度中心知道了服务的地址ip:port或者详细的http请求路径，从而进行直接调用。虽然是耦合调用，同步调用，但是不同服务模块就可以独立开发-迭代-测试-部署和维护。新增服务也是对已有系统服务毫无影响的了可以的了。
			>websevice：注册中心用uddi描述服务
				    服务提供者用wsdl描述接口
				    服务调用者用soap和服务提供者通信
			>服务的负载均衡:性能
			>服务的失效转移：高可用
			>服务的迁移：容易伸缩
			>高效的远程通信：
			>整合异构系统：使用了不同语言开发的在不同平台上跑的系统
			>版本管理：接口的升级
			>监控实时：服务提供者和调用者都要各项指标的监控。
		>可扩展的数据结构：ColumnFamily
			>


	>网站的安全架构：
		>XSS攻击：跨站脚本攻击：是输入中的带有<Script>之类的内容，从而会在访问该页面时在浏览器中被执行。产生相应的问题。
			>解法：消毒
		>SQL注入：参数中输入可能被当作sql执行的sql语句。如 delete  -- //这样的。而使得最终生成的sql是一个含义变化了的sql。
		>单向散列加密：加密而不能破解---除非彩虹表方式。MD5   SHA..
			>用户密码存储
		>对称加密：可以加密和解密，同一密钥。DES,RC
			>cookie加密
		>非对称加密：公钥和私钥来进行加密和解密。或者解密和加密。
			>数字签名：私钥加密传输一个信息，公钥解密。。那么该信息有签名的性质，因为只有发送者才有私钥。
			>一般加密：公钥加密，私钥解密。RSA,HTTPS---就是用公钥来加密进行传输
	
		>密钥的存储：数据库中，且加密存储。加解密算法则在程序中实现--应用中实现。
		>贝叶斯算法垃圾邮件识别：TAN算法--ARCS算法识别。
		>布隆过滤器：不准确的小失真的过滤算法---判断在、出现过的算法。
		>统计模型：风控模型
		>规则引擎：
		