1.问题表述：
   
   >条件：
   >根据--依据--规则：
	如果一个样本和其他k个样本相似，而这k个样本中绝大多数属于的那个类别，被认为是这个样本的类别。
        ---用显微镜下细菌集合康托尔图来理解非常合适。
	>具体的临近计算：欧式空间距离--常见（向量差的2阶范数也可以）。
	>海明距离：两个二进制数之间不同的位的个数。即异或运算后1的个数，如果将n位二进制数当作n维向量，那么两个这样的向量之间的距离显然可以看作是向量作为点时，全部n维向量其实就是超立方体的每个顶点，所以海明距离就是顶点之间的边数。
		   而具体中，如果每个n维二进制向量当作一个编码，那么全部的编码就是超立方体的全部顶点。---显然这个超立方体其实不会很大：因为64维的二进制向量空间已经极其大了（顶点极其多了）。
		   >推论1：四维空间中，一个超立方体有16个顶点，且任意其中一个点，距离它为1的点有4个，为2的有6个，为3的有4个，为4的有1个。这正是组合规律。
		   >推论2：1) 从1维到3维超立方体，都可以看作是k维的超立方体按照垂直于自己的方向（法线方向）延展单位长度而来。4维同样可以这样看作。
		           2) 也可以看作是维数个垂直方向的点张成的空间的各个顶点。对于四维空间，第四维的点可以看作是未来的点。每一个点都有未来的点，但是一个点只能直接到未来的它对应的那个点，而到不了未来的其他点，也不能先到现在的其他点之后从其他点到其他点对应的未来的点，另外，未来的点可以到未来的临近点,同时未来的点也不能回到现在的点（所以这种路径其实也是有方向的）。
				因此，比如原点，对应着未来的一个点，原点到这个未来的点的距离是1，而未来的点到临近的未来的点之间距离为1的有3个，为2的有3个，为3的有1个，加上原点到这个未来的点之间的距离1，那么原点到未来的点的距离--个数就分别是1 # 1,2 # 3, 3# 3, 4 # 1,而原点到现在的各个顶点距离--个数，1 # 3, 2 # 3, 3 # 1, 统计起来，原点的临近点的距离-个数：1 # 4， 2 # 6， 3 # 4， 4 # 1 。也符合实际数学计算结果。
		   >编码错误：原来的编码是A,在传输到接收端过程中发生了n位错误变成另一个编码B,同时传输过来验证1-n位错误的编码共n个，根据这个验证编码就知道发生了几位错误。比如发生了一位错误，那么将传过来的1位错误验证码 和传过来的全部一位错误编码求海明距离应该有为0的。
		   >编码纠正错误：
				比如m个n维的向量集合A，假如全部编码（映射到了）另一个空间，其维度是k, 而且如果要纠正d个错误--或者允许最多出d个（位）错误，那么映射到的空间中，每个向量之间的距离（超几何距离）应当是（大于或者等于）2 * d + 1,那么即便发生了d个错误变成另一个向量，通过寻找这个向量的d个距离以内的向量，必然能且只能找到一个向量--且就是原来的向量，，从而找到了真正的编码向量。
				（所谓海明距离为d的编码方案就是：其中每个向量对应的编码向量之间的海明距离至少都是d）
		   >编码检测：比如m个n维的向量，假如最多出d个错误，那么如果将向量映射到d + 1维的空间中--即每个向量之间的距离是d + 1（至少），那么如果出错了--个数少于等于d个，那么肯定这个出错的向量是不在编码方案中的，或者说即便发生了d个错误（d个以内的任意个），一个原来的向量的编码向量也不会变成另一个编码向量，，从而只要不在编码方案中，那么这个传过来的编码就是出错了的。
				
   >预知：
       >样本与样本之间的相似度：
       